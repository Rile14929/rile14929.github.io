<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="react源码分析（三）render-render阶段 如果以下代码没有特殊标记，路径都是 src&#x2F;react&#x2F;packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js  这个 performConcurrentWorkOnRoot 函数中包含两个重要的阶段，render 和 commit 阶段。这是每个并发任务的入口点。 12345678910111">
<meta property="og:type" content="article">
<meta property="og:title" content="react18.2源码分析（三）render-render阶段">
<meta property="og:url" content="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="react源码分析（三）render-render阶段 如果以下代码没有特殊标记，路径都是 src&#x2F;react&#x2F;packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js  这个 performConcurrentWorkOnRoot 函数中包含两个重要的阶段，render 和 commit 阶段。这是每个并发任务的入口点。 12345678910111">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-4.png">
<meta property="og:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-2.png">
<meta property="og:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-3.png">
<meta property="og:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image.png">
<meta property="og:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-1.png">
<meta property="article:published_time" content="2024-07-02T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-02T16:00:00.000Z">
<meta property="article:author" content="rile">
<meta property="article:tag" content="react18.2">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rile14929.github.io/images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-4.png">

<link rel="canonical" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>react18.2源码分析（三）render-render阶段 | 右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          react18.2源码分析（三）render-render阶段
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-03T00:00:00+08:00">2024-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="react源码分析（三）render-render阶段"><a href="#react源码分析（三）render-render阶段" class="headerlink" title="react源码分析（三）render-render阶段"></a>react源码分析（三）render-render阶段</h1><blockquote>
<p>如果以下代码没有特殊标记，路径都是 <font color=gray><em>src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js</em></font></p>
</blockquote>
<p>这个 <code>performConcurrentWorkOnRoot</code> 函数中包含两个重要的阶段，<code>render</code> 和 <code>commit</code> 阶段。这是每个并发任务的入口点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the entry point for every concurrent task, i.e. anything that goes through Scheduler.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ??</span></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// Something in the passive effect phase may have canceled the current task.</span></span><br><span class="line">    <span class="comment">// Check if the task node for this root was changed.</span></span><br><span class="line">    <span class="keyword">if</span> (root.callbackNode !== originalCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The current task was canceled. Exit. We don't need to call</span></span><br><span class="line">      <span class="comment">// `ensureRootIsScheduled` because the check above implies either that</span></span><br><span class="line">      <span class="comment">// there's a new task, or that there's no remaining work on this root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current task was not canceled. Continue.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, using the fields stored</span></span><br><span class="line">  <span class="comment">// on the root.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This was already computed in the caller. Pass it as an argument.</span></span><br><span class="line">  <span class="keyword">let</span> lanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// Defensive coding. This is never expected to happen.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We disable time-slicing in some cases: if the work has been CPU-bound</span></span><br><span class="line">  <span class="comment">// for too long ("expired" work, to prevent starvation), or we're in</span></span><br><span class="line">  <span class="comment">// sync-updates-by-default mode.</span></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We only check `didTimeout` defensively, to account for a Scheduler</span></span><br><span class="line">  <span class="comment">// bug we're still investigating. Once the bug in Scheduler is fixed,</span></span><br><span class="line">  <span class="comment">// we can remove this, since we track expiration ourselves.</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line">        <span class="comment">// The render completed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this render may have yielded to a concurrent event, and if so,</span></span><br><span class="line">        <span class="comment">// confirm that any newly rendered stores are consistent.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It's possible that even a concurrent render may never have yielded</span></span><br><span class="line">        <span class="comment">// to the main thread, if it was fast enough, or if it expired. We could</span></span><br><span class="line">        <span class="comment">// skip the consistency check in that case, too.</span></span><br><span class="line">        <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          renderWasConcurrent &amp;&amp;</span><br><span class="line">          !isRenderConsistentWithExternalStores(finishedWork)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// A store was mutated in an interleaved event. Render again,</span></span><br><span class="line">          <span class="comment">// synchronously, to block further mutations.</span></span><br><span class="line">          exitStatus = renderRootSync(root, lanes);</span><br><span class="line">          <span class="comment">// We assume the tree is now consistent because we didn't yield to any</span></span><br><span class="line">          <span class="comment">// concurrent events.</span></span><br><span class="line">          renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// Need to check the exit status again.</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if something threw</span></span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">          <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">            root,</span><br><span class="line">            originallyAttemptedLanes,</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">            lanes = errorRetryLanes;</span><br><span class="line">            exitStatus = recoverFromConcurrentError(</span><br><span class="line">              root,</span><br><span class="line">              originallyAttemptedLanes,</span><br><span class="line">              errorRetryLanes,</span><br><span class="line">            );</span><br><span class="line">            renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">          prepareFreshStack(root, NoLanes);</span><br><span class="line">          markRootSuspended(root, lanes, NoLane);</span><br><span class="line">          ensureRootIsScheduled(root);</span><br><span class="line">          <span class="keyword">throw</span> fatalError;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是 commit，要么是，如果有什么被暂停了，就等待一段时间后再 commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-render阶段-renderRootSync"><a href="#1-render阶段-renderRootSync" class="headerlink" title="1. render阶段 - renderRootSync"></a>1. render阶段 - renderRootSync</h2><p>进入 <code>render</code> 阶段的，同步渲染模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 1. 记录 render阶段 开始</span></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= RenderContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevDispatcher = pushDispatcher(root.containerInfo);</span><br><span class="line">  <span class="keyword">const</span> prevCacheDispatcher = pushCacheDispatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the root or lanes have changed, throw out the existing stack</span></span><br><span class="line">  <span class="comment">// and prepare a fresh one. Otherwise we'll continue where we left off.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableUpdaterTracking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDevToolsPresent) &#123;</span><br><span class="line">        <span class="keyword">const</span> memoizedUpdaters = root.memoizedUpdaters;</span><br><span class="line">        <span class="keyword">if</span> (memoizedUpdaters.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          restorePendingUpdaters(root, workInProgressRootRenderLanes);</span><br><span class="line">          memoizedUpdaters.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span></span><br><span class="line">        <span class="comment">// If we bailout on this work, we'll move them back (like above).</span></span><br><span class="line">        <span class="comment">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span></span><br><span class="line">        <span class="comment">// That way we can keep the current update and future updates separate.</span></span><br><span class="line">        movePendingFibersToMemoized(root, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. workInProgressTransitions赋值（用于dev环境）</span></span><br><span class="line">    workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br><span class="line">    <span class="comment">// ! 3. 初始化</span></span><br><span class="line">    prepareFreshStack(root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStarted(lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didSuspendInShell = <span class="literal">false</span>;</span><br><span class="line">  outer: <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        workInProgressSuspendedReason !== NotSuspended &amp;&amp;</span><br><span class="line">        workInProgress !== <span class="literal">null</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// The work loop is suspended. During a synchronous render, we don't</span></span><br><span class="line">        <span class="comment">// yield to the main thread. Immediately unwind the stack. This will</span></span><br><span class="line">        <span class="comment">// trigger either a fallback or an error boundary.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> For discrete and "default" updates (anything that's not</span></span><br><span class="line">        <span class="comment">// flushSync), we want to wait for the microtasks the flush before</span></span><br><span class="line">        <span class="comment">// unwinding. Will probably implement this using renderRootConcurrent,</span></span><br><span class="line">        <span class="comment">// or merge renderRootSync and renderRootConcurrent into the same</span></span><br><span class="line">        <span class="comment">// function and fork the behavior some other way.</span></span><br><span class="line">        <span class="keyword">const</span> unitOfWork = workInProgress;</span><br><span class="line">        <span class="keyword">const</span> thrownValue = workInProgressThrownValue;</span><br><span class="line">        <span class="keyword">switch</span> (workInProgressSuspendedReason) &#123;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnHydration: &#123;</span><br><span class="line">            <span class="comment">// Selective hydration. An update flowed into a dehydrated tree.</span></span><br><span class="line">            <span class="comment">// Interrupt the current render so the work loop can switch to the</span></span><br><span class="line">            <span class="comment">// hydration lane.</span></span><br><span class="line">            resetWorkInProgressStack();</span><br><span class="line">            workInProgressRootExitStatus = RootDidNotComplete;</span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnImmediate:</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnData: &#123;</span><br><span class="line">            <span class="keyword">if</span> (!didSuspendInShell &amp;&amp; getSuspenseHandler() === <span class="literal">null</span>) &#123;</span><br><span class="line">              didSuspendInShell = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intentional fallthrough</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="comment">// Unwind then continue with the normal work loop.</span></span><br><span class="line">            workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">            workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ! 4. workLoopSync</span></span><br><span class="line">      workLoopSync();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleThrow(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Check if something suspended in the shell. We use this to detect an</span></span><br><span class="line">  <span class="comment">// infinite ping loop caused by an uncached promise.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Only increment this counter once per synchronous render attempt across the</span></span><br><span class="line">  <span class="comment">// whole tree. Even if there are many sibling components that suspend, this</span></span><br><span class="line">  <span class="comment">// counter only gets incremented once.</span></span><br><span class="line">  <span class="keyword">if</span> (didSuspendInShell) &#123;</span><br><span class="line">    root.shellSuspendCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  popDispatcher(prevDispatcher);</span><br><span class="line">  popCacheDispatcher(prevCacheDispatcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is a sync render, so we should have finished the whole tree.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Cannot commit an incomplete root. This error is likely caused by a '</span> +</span><br><span class="line">        <span class="string">'bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStopped();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 6. 再遍历一遍更新队列</span></span><br><span class="line">  <span class="comment">// It's safe to process the queue now that the render phase is complete.</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressRootExitStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-记录-render-阶段-开始"><a href="#1-1-记录-render-阶段-开始" class="headerlink" title="1.1 记录 render 阶段 开始"></a>1.1 记录 render 阶段 开始</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">executionContext |= RenderContext;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-workInProgressTransitions赋值"><a href="#1-2-workInProgressTransitions赋值" class="headerlink" title="1.2 workInProgressTransitions赋值"></a>1.2 workInProgressTransitions赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-prepareFreshStack-初始化"><a href="#1-3-prepareFreshStack-初始化" class="headerlink" title="1.3 prepareFreshStack 初始化"></a>1.3 prepareFreshStack 初始化</h3><p>初始化 <code>workInProgressRoot</code>、<code>workInProgress</code>、<code>workInProgressRootRenderLanes</code> 等值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  root.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeoutHandle = root.timeoutHandle;</span><br><span class="line">  <span class="keyword">if</span> (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">    <span class="comment">// The root previous suspended and scheduled a timeout to commit a fallback</span></span><br><span class="line">    <span class="comment">// state. Now that we have additional work, cancel the timeout.</span></span><br><span class="line">    root.timeoutHandle = noTimeout;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above</span></span><br><span class="line">    cancelTimeout(timeoutHandle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cancelPendingCommit = root.cancelPendingCommit;</span><br><span class="line">  <span class="keyword">if</span> (cancelPendingCommit !== <span class="literal">null</span>) &#123;</span><br><span class="line">    root.cancelPendingCommit = <span class="literal">null</span>;</span><br><span class="line">    cancelPendingCommit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetWorkInProgressStack();</span><br><span class="line">  workInProgressRoot = root; <span class="comment">// FiberRoot</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rootWorkInProgress = createWorkInProgress(root.current, <span class="literal">null</span>); <span class="comment">// Fiber</span></span><br><span class="line"></span><br><span class="line">  workInProgress = rootWorkInProgress; <span class="comment">// Fiber</span></span><br><span class="line">  workInProgressRootRenderLanes = lanes;</span><br><span class="line">  workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">  workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidAttachPingListener = <span class="literal">false</span>;</span><br><span class="line">  workInProgressRootExitStatus = RootInProgress;</span><br><span class="line">  workInProgressRootFatalError = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootSkippedLanes = NoLanes;</span><br><span class="line">  workInProgressRootInterleavedUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootPingedLanes = NoLanes;</span><br><span class="line">  workInProgressDeferredLane = NoLane;</span><br><span class="line">  workInProgressRootConcurrentErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRecoverableErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidIncludeRecursiveRenderUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the lanes that are entangled with whatever we're about to render. We</span></span><br><span class="line">  <span class="comment">// track these separately so we can distinguish the priority of the render</span></span><br><span class="line">  <span class="comment">// task from the priority of the lanes it is entangled with. For example, a</span></span><br><span class="line">  <span class="comment">// transition may not be allowed to finish unless it includes the Sync lane,</span></span><br><span class="line">  <span class="comment">// which is currently suspended. We should be able to render the Transition</span></span><br><span class="line">  <span class="comment">// and Sync lane in the same batch, but at Transition priority, because the</span></span><br><span class="line">  <span class="comment">// Sync lane already suspended.</span></span><br><span class="line"></span><br><span class="line">  entangledRenderLanes = getEntangledLanes(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把concurrentQueues的内容添加到fiber的queue中，即给fiber的lanes、childLanes赋值</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rootWorkInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-1-workLoopSync"><a href="#1-4-1-workLoopSync" class="headerlink" title="1.4.1 workLoopSync"></a>1.4.1 workLoopSync</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work without checking if we need to yield between fiber.</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootSync，while循环，只要workInProgress有值，就会一直循环执行performUnitOfWork，直到workInProgress === null。</p>
<p>所以同步渲染模式，一旦开始这个Fiber Reconciler协调流程，就会进入一直循环的逻辑，直到创建出完整的FiberTree，这个过程无法中断。</p>
<p>下面我们来看看并发渲染模式的方法。</p>
<h3 id="1-4-2-workLoopConcurrent"><a href="#1-4-2-workLoopConcurrent" class="headerlink" title="1.4.2 workLoopConcurrent"></a>1.4.2 workLoopConcurrent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootConcurrent，可以看见和同步渲染模式基本一样，唯一的区别就是while循环的多了一个判断条件：当前程序运行时间是否小于帧间隔时间frameInterval【默认5ms】。</p>
<ul>
<li>如果小于：则返回false，代表还有剩余可执行时间。取反后为true，表示可以继续创建FiberTree的工作循环。</li>
<li>如果大于：则返回true，代表没有剩余可执行时间。取反后为false，则while循环的条件将不再满足，会暂停创建FiberTree的工作，结束本次宏任务，剩下的工作会留待下一次宏任务再处理。</li>
</ul>
<p>所以并发渲染模式和同步渲染模式的主要区别就是在这里：它可以中断FiberTree的创建过程，而同步渲染模式是无法中断这个过程的，它只能从开始到创建完成。</p>
<p>并且在这里我们也可以看出，它们的while循环里面都是执行了一个相同的performUnitOfWork方法，所以后面的逻辑也就没有什么模式的区分了，都是执行的一样的内容。</p>
<h3 id="1-4-3-并发模式下暂停工作与恢复执行"><a href="#1-4-3-并发模式下暂停工作与恢复执行" class="headerlink" title="1.4.3 并发模式下暂停工作与恢复执行"></a>1.4.3 并发模式下暂停工作与恢复执行</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发渲染模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoopConcurrent();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleError(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查tree工作是否完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Still work remaining.</span></span><br><span class="line">    <span class="keyword">return</span> RootInProgress;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>workLoopConcurrent</code> 并发渲染的工作被中断后，就会退出 <code>do while</code> 循环，然后就会检查当前的 <code>workInProgress</code> 是否为 <code>null</code>，很明显被暂停的情况，<code>workInProgress</code> 是一定有值的，它的值为下一个即将处理的 <code>Fiber</code> 节点。</p>
<p>此时 <code>workInProgress</code> 不为 <code>null</code>，就会返回 <code>RootInProgress</code> 的渲染状态，表示还有剩下的工作。</p>
<p>这里 return 之后，就会回到 <code>performConcurrentWorkOnRoot</code> 方法之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params">root, didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回未完成的渲染状态</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据渲染状态 继续执行逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染未完成的情况：</span></span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// 渲染暂停的情况：继续返回performConcurrentWorkOnRoot，下一次宏任务继续处理</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost()) ) &#123;</span><br><span class="line">        <span class="comment">// This currentTask hasn't expired, and we've reached the deadline.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback就是performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">        <span class="comment">// continuationCallback 如果返回也是 performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="comment">// 说明任务还未完成，将任务继续设置未当前任务的callback，等待下次继续执行</span></span><br><span class="line">          <span class="comment">// 这里没有删除这个任务，则下次取出的第一个任务，还是这个任务，</span></span><br><span class="line">          currentTask.callback = continuationCallback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 还有工作，则会生成一个新的宏任务，在下次的宏任务中继续执行剩下的任务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在workLoop方法之中，就会将返回的内容再次赋值给当前任务currentTask的callback属性，表示还有未完成的工作。workLoop方法中的while循环就会被中断，原因同样是shouldYieldToHost方法。</p>
<p>在workLoop方法最后就会判断当前任务currentTask是否为null，很明显被中断的情况，currentTask是有值的，所以就会返回true，这里会一直向上return：</p>
<p>最后会将结果返回performWorkUntilDeadline方法之中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span><br><span class="line">	<span class="comment">// 此时hasMoreWork为true</span></span><br><span class="line">    <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">      <span class="comment">// 如果还有任务,则又触发创建宏任务事件，生成新的宏任务，即在下一个消息事件继续执行任务</span></span><br><span class="line">      schedulePerformWorkUntilDeadline();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时hasMoreWork为true，就会调用schedulePerformWorkUntilDeadline方法，生成一个新的宏任务，在下个宏任务中继续执行剩下的任务。</p>
<p>恢复执行的原理也很简单：在下次的宏任务中继续创建FiberTree的时候，因为workInProgress是一个全局变量，一直保存在内存之中，并且它内容为下一个即将处理的Fiber节点，所以下次再回到这里时，就会自动从这个Fiber节点开始继续执行剩下的创建工作。</p>
<h3 id="1-5-performUnitOfWork"><a href="#1-5-performUnitOfWork" class="headerlink" title="1.5 performUnitOfWork"></a>1.5 performUnitOfWork</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存的上一次的Fiber</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.alternate;</span><br><span class="line">  setCurrentDebugFiberInDEV(unitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始工作</span></span><br><span class="line">  <span class="keyword">let</span> next = beginWork(current, unitOfWork, entangledRenderLanes);</span><br><span class="line"></span><br><span class="line">  resetCurrentDebugFiberInDEV();</span><br><span class="line">  <span class="comment">// ! 把pendingProps更新到memoizedProps</span></span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注意：当遍历到叶子元素，即没有子FiberNode时，performUnitOfWork会进入归的阶段。</span></span><br><span class="line"><span class="comment">   * 这个阶段会调用completeUnitOfWork处理FiberNode，当某个FiberNode阶段执行completeUnitOfWork方法后，</span></span><br><span class="line"><span class="comment">   * 如果存在其他的兄弟节点【FiberNode.sibling !== null】，会进入兄弟节点的归阶段，</span></span><br><span class="line"><span class="comment">   * 如果不存在其他兄弟节点，则进入父节点的归阶段，递阶段和归阶段会交替进行直到HostFiber的归阶段</span></span><br><span class="line"><span class="comment">   * 至此，render工作结束，Fiber树创建完成。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn't spawn new work, complete the current work.</span></span><br><span class="line">    <span class="comment">// 如果不再产生新的work，那么当前work结束</span></span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 Fiber 为null</span></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fiber-树结构"><a href="#Fiber-树结构" class="headerlink" title="Fiber 树结构"></a>Fiber 树结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom/client'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">root.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyFun <span class="keyword">from</span> <span class="string">'./views/MyFun'</span>;</span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'./views/MyClass'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'App组件运行了'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;react源码调试&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyFun name='MyFun'&gt;&lt;/</span>MyFun&gt;</span><br><span class="line">      &lt;MyClass name=<span class="string">'MyClass'</span>&gt;&lt;<span class="regexp">/MyClass&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MyFun.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyFun</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MyFun组件运行了'</span>)</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'MyFun'</span>&gt;</span><br><span class="line">      &lt;div&gt;MyFun组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;state: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;name: &#123;props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件运行了'</span>)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件mount完成'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'MyClass'</span>&gt;</span><br><span class="line">        &lt;div&gt;MyClass组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;state: &#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;name: &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-4.png" alt="alt text"></p>
<h4 id="1-5-1-beginWork"><a href="#1-5-1-beginWork" class="headerlink" title="1.5.1 beginWork"></a>1.5.1 beginWork</h4><p>简单来说，就是生成 fiber 树。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> didReceiveUpdate: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update更新流程</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged() ||</span><br><span class="line">      <span class="comment">// Force a re-render if the implementation changed due to hot reload:</span></span><br><span class="line">      (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// If props or context changed, mark the fiber as having performed work.</span></span><br><span class="line">      <span class="comment">// This may be unset if the props are determined to be equal later (memo).</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither props nor legacy context changes. Check if there's a pending</span></span><br><span class="line">      <span class="comment">// update or context change.</span></span><br><span class="line">      <span class="keyword">const</span> hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span><br><span class="line">        current,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !hasScheduledUpdateOrContext &amp;&amp;</span><br><span class="line">        <span class="comment">// If this is the second pass of an error or suspense boundary, there</span></span><br><span class="line">        <span class="comment">// may not be work scheduled on `current`, so we check for this flag.</span></span><br><span class="line">        (workInProgress.flags &amp; DidCapture) === NoFlags</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No pending updates or context. Bail out now.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> attemptEarlyBailoutIfNoScheduledUpdate(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// This is a special case that only exists for legacy mode.</span></span><br><span class="line">        <span class="comment">// See https://github.com/facebook/react/pull/19216.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// An update was scheduled on this fiber, but there are no new props</span></span><br><span class="line">        <span class="comment">// nor legacy context. Set this to false. If an update queue or context</span></span><br><span class="line">        <span class="comment">// consumer produces a changed value, it will set this to true. Otherwise,</span></span><br><span class="line">        <span class="comment">// the component will assume the children have not changed and bail out.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating() &amp;&amp; isForkedChild(workInProgress)) &#123;</span><br><span class="line">      <span class="comment">// Check if this child belongs to a list of muliple children in</span></span><br><span class="line">      <span class="comment">// its parent.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In a true multi-threaded implementation, we would render children on</span></span><br><span class="line">      <span class="comment">// parallel threads. This would represent the beginning of a new render</span></span><br><span class="line">      <span class="comment">// thread for this subtree.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We only use this for id generation during hydration, which is why the</span></span><br><span class="line">      <span class="comment">// logic is located in this special branch.</span></span><br><span class="line">      <span class="keyword">const</span> slotIndex = workInProgress.index;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = getForksAtLevel(workInProgress);</span><br><span class="line">      pushTreeId(workInProgress, numberOfForks, slotIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear pending update priority.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This assumes that we're about to evaluate the component and process</span></span><br><span class="line">  <span class="comment">// the update queue. However, there's an exception: SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// sometimes bails out later in the begin phase. This indicates that we should</span></span><br><span class="line">  <span class="comment">// move this assignment out of the common path and into each branch.</span></span><br><span class="line">  <span class="comment">// 在进入开始阶段之前，清除待处理的更新优先级。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 这假设我们即将评估组件并处理更新队列。然而，有一个例外情况：SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// 有时会在开始阶段后退出。这表明我们应该将这个赋值移出常规路径，放到每个分支中。</span></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountLazyComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类组件</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根Fiber（第一次都会走这里）</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostHoistable:</span><br><span class="line">      <span class="keyword">if</span> (enableFloat &amp;&amp; supportsResources) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostHoistable(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> HostSingleton:</span><br><span class="line">      <span class="keyword">if</span> (supportsSingletons) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostSingleton(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 原生标签，div span等标签</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      <span class="keyword">return</span> updatePortalComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === type</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateForwardRef(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">return</span> updateFragment(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">return</span> updateMode(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">return</span> updateProfiler(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="keyword">return</span> updateContextProvider(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">return</span> updateContextConsumer(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// Resolve outer props first, then resolve inner props.</span></span><br><span class="line">      <span class="keyword">let</span> resolvedProps = resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      resolvedProps = resolveDefaultProps(type.type, resolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSimpleMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        workInProgress.pendingProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> mountIncompleteClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseListComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseListComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ScopeComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableScopeAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateScopeComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> OffscreenComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateOffscreenComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LegacyHiddenComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableLegacyHidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateLegacyHiddenComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CacheComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateCacheComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TracingMarkerComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableTransitionTracing) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateTracingMarkerComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">`Unknown unit of work tag (<span class="subst">$&#123;workInProgress.tag&#125;</span>). This error is likely caused by a bug in `</span> +</span><br><span class="line">      <span class="string">'React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-1-updateHostRoot"><a href="#1-5-1-1-updateHostRoot" class="headerlink" title="1.5.1.1 updateHostRoot"></a>1.5.1.1 updateHostRoot</h5><ol>
<li>更新当前 fiber，比如 props/state 更新，生命周期函数执行、Hooks 函数执行等。</li>
<li>返回一个下一个 fiber。</li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// current是根fiber，current的的stateNode是FiberRoot</span></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should have a current fiber. This is a bug in React.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. 更新props、state、updateQuue、transition</span></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState.element;</span><br><span class="line">  <span class="comment">// 把current上的updateQueue复用到 workInProgress 上一份。</span></span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextState: RootState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  pushRootTransition(workInProgress, root, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 2. bailout or 协调子节点，如果新旧children相同，则会进入优化的逻辑，跳过本次reconcile协调流程，复用原来的节点内容</span></span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 3. 返回子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-2-updateHostComponent"><a href="#1-5-1-2-updateHostComponent" class="headerlink" title="1.5.1.2 updateHostComponent"></a>1.5.1.2 updateHostComponent</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    <span class="comment">// We special case a direct text child of a host node. This is a common</span></span><br><span class="line">    <span class="comment">// case. We won't handle it as a reified child. We will instead handle</span></span><br><span class="line">    <span class="comment">// this in the host environment that also has access to this prop. That</span></span><br><span class="line">    <span class="comment">// avoids allocating another HostText fiber and traversing it.</span></span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    <span class="comment">// If we're switching from a direct text child to a normal child, or to</span></span><br><span class="line">    <span class="comment">// empty, we need to schedule the text content to be reset.</span></span><br><span class="line">    workInProgress.flags |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableFormActions &amp;&amp; enableAsyncActions) &#123;</span><br><span class="line">    <span class="keyword">const</span> memoizedState = workInProgress.memoizedState;</span><br><span class="line">    <span class="keyword">if</span> (memoizedState !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This fiber has been upgraded to a stateful component. The only way</span></span><br><span class="line">      <span class="comment">// happens currently is for form actions. We use hooks to track the</span></span><br><span class="line">      <span class="comment">// pending and error state of the form.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Once a fiber is upgraded to be stateful, it remains stateful for the</span></span><br><span class="line">      <span class="comment">// rest of its lifetime.</span></span><br><span class="line">      <span class="keyword">const</span> newState = renderTransitionAwareHostComponentWithHooks(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the transition state changed, propagate the change to all the</span></span><br><span class="line">      <span class="comment">// descendents. We use Context as an implementation detail for this.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This is intentionally set here instead of pushHostContext because</span></span><br><span class="line">      <span class="comment">// pushHostContext gets called before we process the state hook, to avoid</span></span><br><span class="line">      <span class="comment">// a state mismatch in the event that something suspends.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> This assumes that there cannot be nested transition providers,</span></span><br><span class="line">      <span class="comment">// because the only renderer that implements this feature is React DOM,</span></span><br><span class="line">      <span class="comment">// and forms cannot be nested. If we did support nested providers, then</span></span><br><span class="line">      <span class="comment">// we would need to push a context value even for host fibers that</span></span><br><span class="line">      <span class="comment">// haven't been upgraded yet.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrimaryRenderer) &#123;</span><br><span class="line">        HostTransitionContext._currentValue = newState;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HostTransitionContext._currentValue2 = newState;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableLazyContextPropagation) &#123;</span><br><span class="line">        <span class="comment">// In the lazy propagation implementation, we don't scan for matching</span></span><br><span class="line">        <span class="comment">// consumers until something bails out.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (didReceiveUpdate) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldStateHook: Hook = current.memoizedState;</span><br><span class="line">            <span class="keyword">const</span> oldState: TransitionStatus = oldStateHook.memoizedState;</span><br><span class="line">            <span class="comment">// This uses regular equality instead of Object.is because we assume</span></span><br><span class="line">            <span class="comment">// that host transition state doesn't include NaN as a valid type.</span></span><br><span class="line">            <span class="keyword">if</span> (oldState !== newState) &#123;</span><br><span class="line">              propagateContextChange(</span><br><span class="line">                workInProgress,</span><br><span class="line">                HostTransitionContext,</span><br><span class="line">                renderLanes,</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-3-bailout"><a href="#1-5-1-3-bailout" class="headerlink" title="1.5.1.3 bailout"></a>1.5.1.3 bailout</h5><p>bailout阶段，返回null。</p>
<p>不会发生在组件初次渲染阶段，仅仅发生在组件更新阶段。当组件⼦节点没有发⽣变化，或者是被⼿动挡住（如类组件的 shouldComponentUpdate、memo 等），组件⼦节点不需要协调的时候。</p>
<h5 id="1-5-1-4-协调子节点-reconcileChildren"><a href="#1-5-1-4-协调子节点-reconcileChildren" class="headerlink" title="1.5.1.4 协调子节点 reconcileChildren"></a>1.5.1.4 协调子节点 reconcileChildren</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 组件初次挂载</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress, <span class="comment">// 父节点</span></span><br><span class="line">      current.child, <span class="comment">// 旧的child</span></span><br><span class="line">      nextChildren, <span class="comment">// 新的child</span></span><br><span class="line">      renderLanes, <span class="comment">// 本次更新的lanes</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最终执行的函数是同一个，都是 <code>createChildReconciler</code>，而 <code>createChildReconciler</code> 是一个 wrapper function。最终会返回内部的 <code>reconcileChildFibers</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers: ChildReconciler =</span><br><span class="line">  createChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers: ChildReconciler = createChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-5-reconcileChildFibers"><a href="#1-5-1-5-reconcileChildFibers" class="headerlink" title="1.5.1.5 reconcileChildFibers"></a>1.5.1.5 reconcileChildFibers</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 协调子节点，构建新的子fiber结构，并且返回新的子fiber</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null, <span class="regexp">//</span> 老fiber的第一个子节点</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> firstChildFiber = reconcileChildFibersImpl(</span><br><span class="line">      returnFiber,</span><br><span class="line">      currentFirstChild,</span><br><span class="line">      newChild,</span><br><span class="line">      lanes,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// debugInfo</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> firstChildFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-5-1-6-reconcileChildFibersImpl"><a href="#1-5-1-6-reconcileChildFibersImpl" class="headerlink" title="1.5.1.6 reconcileChildFibersImpl"></a>1.5.1.6 reconcileChildFibersImpl</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibersImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果newChild是Fragment类型，且没有key，则直接协调其子节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新的child类型，进行不同的处理</span></span><br><span class="line">    <span class="comment">// 单个节点、数组、迭代器、promise、context处理，最常见的react-element元素类型：react中类组件，函数组件，普通dom组件都属于此类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              debugInfo,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_LAZY_TYPE:</span><br><span class="line">          <span class="keyword">const</span> payload = newChild._payload;</span><br><span class="line">          <span class="keyword">const</span> init = newChild._init;</span><br><span class="line">          <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            init(payload),</span><br><span class="line">            lanes,</span><br><span class="line">            mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2，数组节点的处理，即多个子节点，比如div.App下面有三个子节点</span></span><br><span class="line">      <span class="comment">// 循环创建多个子节点，最后返回第一个子节点，firstChild</span></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Usables are a valid React node type. When React encounters a Usable in</span></span><br><span class="line">      <span class="comment">// a child position, it unwraps it using the same algorithm as `use`. For</span></span><br><span class="line">      <span class="comment">// example, for promises, React will throw an exception to unwind the</span></span><br><span class="line">      <span class="comment">// stack, then replay the component once the promise resolves.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A difference from `use` is that React will keep unwrapping the value</span></span><br><span class="line">      <span class="comment">// until it reaches a non-Usable type.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// e.g. Usable&lt;Usable&lt;Usable&lt;T&gt;&gt;&gt; should resolve to T</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The structure is a bit unfortunate. Ideally, we shouldn't need to</span></span><br><span class="line">      <span class="comment">// replay the entire begin phase of the parent fiber in order to reconcile</span></span><br><span class="line">      <span class="comment">// the children again. This would require a somewhat significant refactor,</span></span><br><span class="line">      <span class="comment">// because reconcilation happens deep within the begin phase, and</span></span><br><span class="line">      <span class="comment">// depending on the type of work, not always at the end. We should</span></span><br><span class="line">      <span class="comment">// consider as an future improvement.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> thenable: Thenable&lt;any&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          unwrapThenable(thenable),</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, thenable._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newChild.$$<span class="keyword">typeof</span> === REACT_CONTEXT_TYPE) &#123;</span><br><span class="line">        <span class="keyword">const</span> context: ReactContext&lt;mixed&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          readContextDuringReconcilation(returnFiber, context, lanes),</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，处理文本子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (<span class="keyword">typeof</span> newChild === <span class="string">'string'</span> &amp;&amp; newChild !== <span class="string">''</span>) ||</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'number'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          <span class="string">''</span> + newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-6-reconcileSingleElement"><a href="#1-5-1-6-reconcileSingleElement" class="headerlink" title="1.5.1.6 reconcileSingleElement"></a>1.5.1.6 reconcileSingleElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查老的fiber单链表中是否有可以复用的节点</span></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">        <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">            <span class="comment">// 新老都是Fragment</span></span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props.children);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            child.elementType === elementType ||</span><br><span class="line">            <span class="comment">// Keep this check inline so it only runs on the false path:</span></span><br><span class="line">            (__DEV__</span><br><span class="line">              ? isCompatibleFamilyForHotReloading(child, element)</span><br><span class="line">              : <span class="literal">false</span>) ||</span><br><span class="line">            <span class="comment">// Lazy types should reconcile their resolved type.</span></span><br><span class="line">            <span class="comment">// We need to do this after the Hot Reloading check above,</span></span><br><span class="line">            <span class="comment">// because hot reloading has different semantics than prod because</span></span><br><span class="line">            <span class="comment">// it doesn't resuspend. So we can't let the call below suspend.</span></span><br><span class="line">            (<span class="keyword">typeof</span> elementType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">              elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              elementType.$$<span class="keyword">typeof</span> === REACT_LAZY_TYPE &amp;&amp;</span><br><span class="line">              resolveLazy(elementType) === child.type)</span><br><span class="line">          ) &#123;</span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">            coerceRef(returnFiber, child, existing, element);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果key相同，类型不相同。不再查找</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个老节点没法复用</span></span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初次挂载 2. 没有找到可以复用的老节点</span></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        element.props.children,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        lanes,</span><br><span class="line">        element.key,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据React-element元素对象，创建FiberNode节点</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line">      coerceRef(returnFiber, currentFirstChild, created, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-7-createFiberFromElement"><a href="#1-5-1-7-createFiberFromElement" class="headerlink" title="1.5.1.7 createFiberFromElement"></a>1.5.1.7 createFiberFromElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> owner = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = element.type; <span class="comment">// 存储原始的组件内容，比如function，class</span></span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">const</span> pendingProps = element.props; <span class="comment">// 等待处理的，最新的props</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber节点： 根据元素的type ，针对组件来说：type值一般为class类 或者Function函数</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiberFromTypeAndProps(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    pendingProps,</span><br><span class="line">    owner,</span><br><span class="line">    mode,</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createFiberFromElement</code> 方法很重要，<code>react</code> 所有 <code>reactElement</code> 元素都是通过这个方法来创建对应的 <code>Fiber</code> 节点。比如常见的 class组件，function组件，原生dom元素等。我们在项目中定义的组件和元素在被编译之后，最终在加载时都会通过jsxRuntime.jsx方法转换为一个reactElement元素对象。</p>
<h5 id="1-5-1-8-createFiberFromTypeAndProps"><a href="#1-5-1-8-createFiberFromTypeAndProps" class="headerlink" title="1.5.1.8 createFiberFromTypeAndProps"></a>1.5.1.8 createFiberFromTypeAndProps</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromTypeAndProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: any, <span class="regexp">//</span> React$ElementType</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  owner: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberTag = IndeterminateComponent;</span><br><span class="line">  <span class="keyword">let</span> resolvedType = type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据元素的type进行不同的逻辑处理，class也是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 针对类组件的特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (shouldConstruct(type)) &#123;</span><br><span class="line">      <span class="comment">// 根据type 设置fiberTag 为class组件</span></span><br><span class="line">      fiberTag = ClassComponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通函数组件，没有更新tag【重要，伏笔】</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 原生dom的处理</span></span><br><span class="line">    fiberTag = HostComponent;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他type类型的处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiber(fiberTag, pendingProps, key, mode);</span><br><span class="line">  fiber.elementType = type;</span><br><span class="line">  fiber.type = resolvedType;</span><br><span class="line">  fiber.lanes = lanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在react应用中我们定义的class组件，都是通过继承react的内部组件Component来定义的，所以通过它原型上的isReactComponent属性可以来区分当前组件是不是类组件，返回true则是类组件，返回false则是函数组件。</p>
<p>如果是类组件就会更新fiberTag为ClassComponent的值。</p>
<p>如果是函数组件，这里并没有更新fiberTag，所以函数组件的fiberTag还是为待定的IndeterminateComponent的值。</p>
<p>最后是针对普通的dom元素的处理，更新为HostComponent的值。</p>
<h5 id="1-5-1-9-多子节点的创建-reconcileChildrenArray"><a href="#1-5-1-9-多子节点的创建-reconcileChildrenArray" class="headerlink" title="1.5.1.9 多子节点的创建 - reconcileChildrenArray"></a>1.5.1.9 多子节点的创建 - reconcileChildrenArray</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: Array&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 存储新生成的child</span></span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 上一个新建的child</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild; <span class="comment">// 旧的Fiber节点</span></span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ! 1. 从左边往右遍历，比较新老节点，如果节点可以复用，继续往右，否则就停止</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That's</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn't reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we're not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don't want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.1 新节点没了，（老节点还有）。则删除剩余的老节点即可</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We've reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 2.2 (新节点还有)，老节点没了</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don't have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.3 新老节点都还有节点，但是因为老fiber是链表，不方便快速get与delete，</span></span><br><span class="line">    <span class="comment">// !   因此把老fiber链表中的节点放入Map中，后续操作这个Map的get与delete</span></span><br><span class="line">    <span class="comment">// 0 1|   4 5</span></span><br><span class="line">    <span class="comment">// 0 1| 7 8 2 3</span></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don't add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !3. 如果是组件更新阶段，此时新节点已经遍历完了，能复用的老节点都用完了，</span></span><br><span class="line">    <span class="comment">// ! 则最后查找Map里是否还有元素，如果有，则证明是新节点里不能复用的，也就是要被删除的元素，此时删除这些元素就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren't consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">      pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从 hostFiber 根节点开始，react 的深度优先遍历算法，会一直创建到再无 Child 子节点。</p>
<p>此时叶子结点所对应的Fiber节点创建完成后，它会继续开启属于它的 beginWork 工作，来创建它的子节点，但是因为它已经没有子节点了，所以它最终会返回一个null。</p>
<p>然后一直向上return，直到回到performUnitOfWork方法中：将进入此 Fiber 节点的 completeWork 工作，也就是归的阶段</p>
<h4 id="1-5-2-completeUnitOfWork"><a href="#1-5-2-completeUnitOfWork" class="headerlink" title="1.5.2 completeUnitOfWork"></a>1.5.2 completeUnitOfWork</h4><p>completeWork 代表一个 Fiber 节点的结束工作，completeUnitOfWork 是 completeWork 阶段的入口函数。简单来说，就是生成 dom 树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 取出当前的Fiber节点</span></span><br><span class="line">  <span class="keyword">let</span> completedWork: Fiber = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 取出节点对应的current</span></span><br><span class="line">    <span class="keyword">const</span> current = completedWork.alternate;</span><br><span class="line">    <span class="comment">// 取出节点的父级节点</span></span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!enableProfilerTimer || (completedWork.mode &amp; ProfileMode) === NoMode) &#123;</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startProfilerTimer(completedWork);</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">      <span class="comment">// Update render duration assuming we didn't error.</span></span><br><span class="line">      stopProfilerTimerIfRunningAndRecordDelta(completedWork, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">      workInProgress = next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个节点的completeWork工作完成后，寻找是否存在兄弟节点</span></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.sibling;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果兄弟节点存在，则设置为新的workInProgress，跳出当前函数，回到performUnitOfWork方法中</span></span><br><span class="line">      <span class="comment">// 这将开始sibling兄弟节点的beginWork工作【自上而下】</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【自下而上的处理】</span></span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则将父级节点设置为completedWork，开始父级节点的completedWork工作</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    <span class="comment">// 更新workInProgress，可能会开启新的beginWork工作</span></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We've reached the root.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === RootInProgress) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>completeUnitOfWork方法中重点就是一个do while循环：<code>completedWork !== null</code>。这个循环的条件是completedWork不等于null，即它是一个有效的Fiber节点。</p>
<h5 id="1-5-2-1-completeWork"><a href="#1-5-2-1-completeWork" class="headerlink" title="1.5.2.1 completeWork"></a>1.5.2.1 completeWork</h5><p>根据tag值区别不同fiber<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-2.png" alt="alt text"></p>
<h5 id="1-5-2-2-bubbleProperties"><a href="#1-5-2-2-bubbleProperties" class="headerlink" title="1.5.2.2 bubbleProperties"></a>1.5.2.2 bubbleProperties</h5><p>向上冒泡 subtreeFlags 和 childLanes</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleProperties</span>(<span class="params">completedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.alternate.child === completedWork.child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = NoLanes;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="comment">// “向上冒泡”最早的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// ! 2. 将他们的subtreeFlags和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 子树的flags</span></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “静态”标志（Static flags）与它们所属的 Fiber 或 Hook 共享生命周期，因此即使在放弃（bailout）时，也应该将这些flags向上冒泡。</span></span><br><span class="line">        <span class="comment">// 而其他所有flags仅在单次render + commit 的生命周期内存在，因此我们应该忽略它们。</span></span><br><span class="line">        <span class="comment">// ! 2. 将他们的（subtreeFlags&amp;StaticMask)和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新return pointer以保持树的一致性。这被描述为一种代码异味（code smell），因为它假设commit阶段永远不会与 render 阶段并发。</span></span><br><span class="line">        <span class="comment">// 在重构为交替模型（alternate model）时将会解决这个问题。</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 后代节点的lanes</span></span><br><span class="line">  completedWork.childLanes = newChildLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中"><a href="#1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中" class="headerlink" title="1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中"></a>1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中</h5><p>如果组件是HostComponent，即原生标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = createInstance(</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext,</span><br><span class="line">    workInProgress,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 把DOM子节点添加到父DOM节点中去</span></span><br><span class="line">appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 当节点是原生标签，比如div、span等，会在这里添加到fiber属性stateNode上</span></span><br><span class="line">workInProgress.stateNode = instance;</span><br></pre></td></tr></table></figure>

<h5 id="总结执行流程图"><a href="#总结执行流程图" class="headerlink" title="总结执行流程图"></a>总结执行流程图</h5><p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-3.png" alt="alt text"></p>
<h3 id="1-6-重置-workInProgressX"><a href="#1-6-重置-workInProgressX" class="headerlink" title="1.6 重置 workInProgressX"></a>1.6 重置 workInProgressX</h3><p>这里没有重置 workInProgress，因为 workInProgress 已经在 performUnitOfWork 阶段更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-再遍历一遍更新队列"><a href="#1-7-再遍历一遍更新队列" class="headerlink" title="1.7 再遍历一遍更新队列"></a>1.7 再遍历一遍更新队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishQueueingConcurrentUpdates()</span><br></pre></td></tr></table></figure>

<h3 id="管理更新队列-finishQueueingConcurrentUpdates"><a href="#管理更新队列-finishQueueingConcurrentUpdates" class="headerlink" title="管理更新队列 finishQueueingConcurrentUpdates"></a>管理更新队列 finishQueueingConcurrentUpdates</h3><p><code>finishQueueingConcurrentUpdates</code> 把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中，后续才是根据 <code>VDOM</code> 更新 <code>DOM</code></p>
<p>在 <code>render</code> 阶段，有两处调⽤ <code>finishQueueingConcurrentUpdates</code> ，分别是</p>
<ol>
<li><code>render</code> 开始的时候，在 <code>prepareFreshStack</code> 函数中；<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image.png" alt="alt text"></li>
<li>在 <code>render</code> 结束的时候，最后再调⽤⼀遍。<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-1.png" alt="alt text"></li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">finishQueueingConcurrentUpdates</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> endIndex = concurrentQueuesIndex;</span><br><span class="line">  concurrentQueuesIndex = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  concurrentlyUpdatedLanes = NoLanes; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; endIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber: Fiber = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> queue: ConcurrentQueue = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> update: ConcurrentUpdate = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> lane: Lane = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里构建完之后的fiber.updateQueue.shared.pending数据类型是Update，但是其实这里构建成了一个单向循环链表。</span></span><br><span class="line">    <span class="comment">// 所以fiber.updateQueue.shared.pending其实是指最后一个update，它的next指向的是第一个update</span></span><br><span class="line">    <span class="keyword">if</span> (queue !== <span class="literal">null</span> &amp;&amp; update !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">      <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">        update.next = update;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update.next = pending.next;</span><br><span class="line">        pending.next = update;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.pending = update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// 更新fiber.lanes</span></span><br><span class="line">    <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">      markUpdateLaneFromFiberToRoot(fiber, update, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="markUpdateLaneFromFiberToRoot"><a href="#markUpdateLaneFromFiberToRoot" class="headerlink" title="markUpdateLaneFromFiberToRoot"></a>markUpdateLaneFromFiberToRoot</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  sourceFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: ConcurrentUpdate | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update the source fiber's lanes</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="keyword">let</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Walk the parent path to the root and update the child lanes.</span></span><br><span class="line">  <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">  <span class="keyword">let</span> isHidden = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);</span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent.tag === OffscreenComponent) &#123;</span><br><span class="line">      <span class="keyword">const</span> offscreenInstance: OffscreenInstance | <span class="literal">null</span> = parent.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        offscreenInstance !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(offscreenInstance._visibility &amp; OffscreenVisible)</span><br><span class="line">      ) &#123;</span><br><span class="line">        isHidden = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理更新队列-processUpdateQueue"><a href="#处理更新队列-processUpdateQueue" class="headerlink" title="处理更新队列 processUpdateQueue"></a>处理更新队列 processUpdateQueue</h3><p>这个函数⽤来处理更新队列。</p>
<p><code>processUpdateQueue</code> 在 <code>beginWork</code> 阶段会被两个地⽅调⽤：</p>
<ol>
<li><p>updateHostRoot <font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br></pre></td></tr></table></figure></li>
<li><p>updateClassInstance <font color=gray><em>packages\react-reconciler\src\ReactFiberClassComponent.js</em></font></p>
<p>在类组件的 mount、resumeMount、更新阶段，均会调⽤。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="processUpdateQueue-流程"><a href="#processUpdateQueue-流程" class="headerlink" title="processUpdateQueue 流程"></a>processUpdateQueue 流程</h4><ol>
<li><p>检查是否有 pending update。</p>
<ol>
<li>如果有，将它们转移到 baseQueue。</li>
<li>pending update 是个单向循环链表，转移到 单链表 firstBaseUpdate-&gt;…-&gt;lastBaseUpdate 中去。</li>
</ol>
</li>
<li><p>遍历 queue，根据这些 update 计算出最后的结果</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理这个更新</span></span><br><span class="line">newState = getStateFromUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    queue,</span><br><span class="line">    update,</span><br><span class="line">    newState,</span><br><span class="line">    props,</span><br><span class="line">    instance,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>更新到 fiber 上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.lanes = newLanes;</span><br><span class="line">workInProgress.memoizedState = newState; <span class="comment">// 更新状态</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/react18-2/" rel="tag"># react18.2</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89scheduleUpdateOnFiber%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0.html" rel="prev" title="react18.2源码分析（二）scheduleUpdateOnFiber调度更新">
      <i class="fa fa-chevron-left"></i> react18.2源码分析（二）scheduleUpdateOnFiber调度更新
    </a></div>
      <div class="post-nav-item">
    <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89render-commit%E9%98%B6%E6%AE%B5.html" rel="next" title="react18.2源码分析（四）render-commit阶段">
      react18.2源码分析（四）render-commit阶段 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#react源码分析（三）render-render阶段"><span class="nav-number">1.</span> <span class="nav-text">react源码分析（三）render-render阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-render阶段-renderRootSync"><span class="nav-number">1.1.</span> <span class="nav-text">1. render阶段 - renderRootSync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-记录-render-阶段-开始"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 记录 render 阶段 开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-workInProgressTransitions赋值"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 workInProgressTransitions赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-prepareFreshStack-初始化"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 prepareFreshStack 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-workLoopSync"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4.1 workLoopSync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-workLoopConcurrent"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.4.2 workLoopConcurrent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-并发模式下暂停工作与恢复执行"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.4.3 并发模式下暂停工作与恢复执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-performUnitOfWork"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.5 performUnitOfWork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fiber-树结构"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">Fiber 树结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-beginWork"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">1.5.1 beginWork</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-1-updateHostRoot"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">1.5.1.1 updateHostRoot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-2-updateHostComponent"><span class="nav-number">1.1.7.2.2.</span> <span class="nav-text">1.5.1.2 updateHostComponent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-3-bailout"><span class="nav-number">1.1.7.2.3.</span> <span class="nav-text">1.5.1.3 bailout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-4-协调子节点-reconcileChildren"><span class="nav-number">1.1.7.2.4.</span> <span class="nav-text">1.5.1.4 协调子节点 reconcileChildren</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-5-reconcileChildFibers"><span class="nav-number">1.1.7.2.5.</span> <span class="nav-text">1.5.1.5 reconcileChildFibers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-6-reconcileChildFibersImpl"><span class="nav-number">1.1.7.2.6.</span> <span class="nav-text">1.5.1.6 reconcileChildFibersImpl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-6-reconcileSingleElement"><span class="nav-number">1.1.7.2.7.</span> <span class="nav-text">1.5.1.6 reconcileSingleElement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-7-createFiberFromElement"><span class="nav-number">1.1.7.2.8.</span> <span class="nav-text">1.5.1.7 createFiberFromElement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-8-createFiberFromTypeAndProps"><span class="nav-number">1.1.7.2.9.</span> <span class="nav-text">1.5.1.8 createFiberFromTypeAndProps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-9-多子节点的创建-reconcileChildrenArray"><span class="nav-number">1.1.7.2.10.</span> <span class="nav-text">1.5.1.9 多子节点的创建 - reconcileChildrenArray</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">1.1.7.2.11.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-completeUnitOfWork"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">1.5.2 completeUnitOfWork</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-1-completeWork"><span class="nav-number">1.1.7.3.1.</span> <span class="nav-text">1.5.2.1 completeWork</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-2-bubbleProperties"><span class="nav-number">1.1.7.3.2.</span> <span class="nav-text">1.5.2.2 bubbleProperties</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中"><span class="nav-number">1.1.7.3.3.</span> <span class="nav-text">1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结执行流程图"><span class="nav-number">1.1.7.3.4.</span> <span class="nav-text">总结执行流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-重置-workInProgressX"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.6 重置 workInProgressX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-再遍历一遍更新队列"><span class="nav-number">1.1.9.</span> <span class="nav-text">1.7 再遍历一遍更新队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理更新队列-finishQueueingConcurrentUpdates"><span class="nav-number">1.1.10.</span> <span class="nav-text">管理更新队列 finishQueueingConcurrentUpdates</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#markUpdateLaneFromFiberToRoot"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">markUpdateLaneFromFiberToRoot</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理更新队列-processUpdateQueue"><span class="nav-number">1.1.11.</span> <span class="nav-text">处理更新队列 processUpdateQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#processUpdateQueue-流程"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">processUpdateQueue 流程</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
