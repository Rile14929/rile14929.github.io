<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 加载过程执行函数组件 Fiber 节点的 beginWork 工作，根据 tag 类型，进入 IndeterminateComponent 待定组件的逻辑处理【case IndeterminateComponent】： 每个函数组件的首次加载都是走的 IndeterminateComponent 分支逻辑，这是因为在创建函数组件 Fiber 的时候，react 没有更新它的 tag 值，所以">
<meta property="og:type" content="article">
<meta property="og:title" content="react18.2函数组件加载过程">
<meta property="og:url" content="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="1. 加载过程执行函数组件 Fiber 节点的 beginWork 工作，根据 tag 类型，进入 IndeterminateComponent 待定组件的逻辑处理【case IndeterminateComponent】： 每个函数组件的首次加载都是走的 IndeterminateComponent 分支逻辑，这是因为在创建函数组件 Fiber 的时候，react 没有更新它的 tag 值，所以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png">
<meta property="og:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png">
<meta property="article:published_time" content="2024-10-25T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-25T16:00:00.000Z">
<meta property="article:author" content="rile">
<meta property="article:tag" content="react18.2">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rile14929.github.io/images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png">

<link rel="canonical" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>react18.2函数组件加载过程 | 右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          react18.2函数组件加载过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-26T00:00:00+08:00">2024-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h2><p>执行函数组件 <code>Fiber</code> 节点的 <code>beginWork</code> 工作，根据 <code>tag</code> 类型，进入 <code>IndeterminateComponent</code> 待定组件的逻辑处理【case IndeterminateComponent】：</p>
<p>每个函数组件的首次加载都是走的 <code>IndeterminateComponent</code> 分支逻辑，这是因为在创建函数组件 <code>Fiber</code> 的时候，<code>react</code> 没有更新它的 <code>tag</code> 值，所以它的首次 <code>beginWork</code> 工作就会进入 <code>IndeterminateComponent</code> 分支，在<code>mountIndeterminateComponent</code> 方法中才会更新它的 <code>tag</code>，使函数组件的Fiber在更新阶段执行 <code>beginWork</code> 时，能够进入正确的 <code>FunctionComponent</code> 分支。</p>
<h3 id="1-1-mountIndeterminateComponent"><a href="#1-1-mountIndeterminateComponent" class="headerlink" title="1.1 mountIndeterminateComponent"></a>1.1 mountIndeterminateComponent</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出函数组件的props</span></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储FirstChild内容</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  # 调用函数组件</span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对类组件和函数组件进行不同的处理</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    value.$$<span class="keyword">typeof</span> === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">	# 类组件的处理逻辑 【只是类组件现在已经不走这里了】</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    # 函数组件处理</span><br><span class="line">    <span class="comment">// 更新tag为函数组件类型的值，下个逻辑就可以直接进入函数组件的处理【节点更新的时候】</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    # 创建子节点</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出当前函数组件FIber节点上的最新的props，方便函数组件加载的使用，然后调用renderWithHooks方法，这个方法会执行我们定义的函数组件，返回值就是函数中return的内容，也就是jsx内容【处理过后的react-element元素对象】。</p>
<h4 id="1-1-1-renderWithHooks"><a href="#1-1-1-renderWithHooks" class="headerlink" title="1.1.1 renderWithHooks"></a>1.1.1 renderWithHooks</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  # 设置为当前渲染中的Fiber</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  # 重置函数组件节点的数据</span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置首次加载的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current = current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  # 调用这个函数，即调用组件，循环生成Element对象，</span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line">  <span class="comment">// 重置一些信息</span></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-1-ReactCurrentDispatcher"><a href="#1-1-1-1-ReactCurrentDispatcher" class="headerlink" title="1.1.1.1 ReactCurrentDispatcher"></a>1.1.1.1 ReactCurrentDispatcher</h5><p><code>ReactCurrentDispatcher</code> 对象是一个全局变量，它是在react源码中的react包定义的：</p>
<p><font color=gray><em>packages\react\src\ReactCurrentDispatcher.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure>

<p>然后将它包装在一个新的对象中：</p>
<p><font color=gray><em>packages\react\src\ReactSharedInternalsClient.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactSharedInternals = &#123;</span><br><span class="line">  ReactCurrentDispatcher,</span><br><span class="line">  ReactCurrentCache,</span><br><span class="line">  ReactCurrentBatchConfig,</span><br><span class="line">  ReactCurrentOwner,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>而shared包【通用工具包】会引入这个对象，然后暴露给全局：</p>
<p><font color=gray><em>packages\shared\ReactSharedInternals.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternalsClient'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>其他资源包就可以通过shared工具包来拿到这个对象，所以我们在函数组件加载时才能使用这个对象：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'shared/ReactSharedInternals'</span>;</span><br><span class="line"><span class="comment">// 拿到ReactCurrentDispatcher对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;ReactCurrentDispatcher, ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>知道了 <code>ReactCurrentDispatcher</code> 对象的由来，我们才能更好地理解它的作用，因为函数组件的每个 <code>hook</code> 实际就是在调用这个对象中的同名方法，比如 <code>useState</code>：</p>
<p><font color=gray><em>packages\react\src\ReactHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>resolveDispatcher</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="comment">// 返回获取到的dispatcher</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 hook 也是一样的原理。</p>
<h5 id="1-1-1-2-函数组件调用"><a href="#1-1-1-2-函数组件调用" class="headerlink" title="1.1.1.2 函数组件调用"></a>1.1.1.2 函数组件调用</h5><p>函数组件的加载核心就是执行一次函数的内容，理解起来也很简单。最后触发 return 关键字，这里的 jsx 内容会在 react 内部通过 <code>jsxRuntime.jsx</code> 方法进行处理，生成 <code>react-element</code> 对象，最后返回值就是创建的 react 元素对象。</p>
<p>最后返回生成的 <code>react-element</code> 对象，<code>renderWithHooks</code> 方法执行完成。</p>
<p>函数组件初始化执行完成后，就会更新函数组件Fiber节点的tag值为正确的类型FunctionComponent【后续逻辑函数组件节点便可以进入Function分支了】。</p>
<p>然后根据新建的value【react元素对象】创建子Fiber节点，最后返回子节点，函数组件的加载过程就基本完成了。</p>
<h3 id="1-2-hooks的加载"><a href="#1-2-hooks的加载" class="headerlink" title="1.2 hooks的加载"></a>1.2 hooks的加载</h3><p>根据上文得知，我们查看先前的 <code>ReactCurrentDispatcher</code> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnMount</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useInsertionEffect: mountInsertionEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState, <span class="comment">// 加载state</span></span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useSyncExternalStore: mountSyncExternalStore,</span><br><span class="line">  useId: mountId,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>例如我们在函数中依次使用useState、useEffect、useLayoutEffect，我们来看一下执行过程：</p>
<h4 id="1-2-1-mountState"><a href="#1-2-1-mountState" class="headerlink" title="1.2.1 mountState"></a>1.2.1 mountState</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  # hook加载工作</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 等待处理的update链表</span></span><br><span class="line">    lanes: NoLanes,</span><br><span class="line">    dispatch: <span class="literal">null</span>, <span class="comment">// dispatchSetState方法</span></span><br><span class="line">    lastRenderedReducer: basicStateReducer, <span class="comment">// 一个函数，通过action和lastRenderedState计算最新的state</span></span><br><span class="line">    lastRenderedState: initialState, <span class="comment">// 上一次的state</span></span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = queue;</span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line">  # 返回值</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-1-mountWorkInProgressHook"><a href="#1-2-1-1-mountWorkInProgressHook" class="headerlink" title="1.2.1.1 mountWorkInProgressHook"></a>1.2.1.1 mountWorkInProgressHook</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  # hook对象</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个hook</span></span><br><span class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 后面的hook对象添加到第一个hook的next属性上，形成一个单向链表</span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>hook</code> 对象，<code>workInProgressHook</code> 默认为 <code>null</code>，它代表当前正在处理中的 <code>hook</code> 对象。</p>
<p>当前 <code>useState</code> 为函数组件中的第一个调用的 <code>hook</code> ，所以这时 <code>workInProgressHook</code> 肯定为 <code>null</code>：</p>
<p>将新建 <code>hook</code> 对象赋值给 <code>workInProgressHook</code>，表示为正在处理中的 <code>hook</code> 对象。</p>
<p>同时也将第一个 <code>hook</code> 对象赋值给当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png" alt="alt text"></p>
<p>继续回到 <code>mountState</code> 方法中:</p>
<p>在 <code>hook</code> 新建完成之后，判断传入的参数 <code>initialState</code> 是否为函数，如果为函数则调用此函数，将结果赋值为新的 <code>initialState</code>。</p>
<p>然后设置 <code>hook</code> 对象的 <code>memoizedState</code> 和 <code>baseState</code> 属性为初始的数据 <code>initialState</code>。</p>
<p>接下来创建一个queue对象，这里要注意两个属性：</p>
<ol>
<li>lastRenderedReducer：它是一个函数，作用是根据action和lastRenderedState计算最新的state。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action就是setCount传入的参数，如果为一个函数，则将state传入进行计算，返回新的state</span></span><br><span class="line">  <span class="comment">// 如果不是函数，则action就是最新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lastRenderedState：代表上一次渲染的state</li>
</ol>
<p>然后更新 <code>hook</code> 对象的 <code>queue</code> 属性，同时设置 <code>queue</code> 对象的 <code>dispatch</code> 属性为一个修改函数 <code>dispatchSetState</code></p>
<p>最后返回一个数组，这就是 <code>useState hook</code> 的返回值：一个初始state和一个修改函数。</p>
<h4 id="1-2-2-mountEffect"><a href="#1-2-2-mountEffect" class="headerlink" title="1.2.2 mountEffect"></a>1.2.2 mountEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进入effect加载</span></span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, # Passive标记对应的是useEffect</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-1-mountEffectImpl"><a href="#1-2-2-1-mountEffectImpl" class="headerlink" title="1.2.2.1 mountEffectImpl"></a>1.2.2.1 mountEffectImpl</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  # 创建的新的hook对象</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 确定当前hook的deps依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 当前渲染中的Fiber节点，即函数组件对应的，打上effect钩子的flags</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 设置hook的memoizedState属性</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是先调用 <code>mountWorkInProgressHook</code> 创建一个 <code>hook</code> 对象，所以这里是先将第一个 <code>hook</code> 对象的 <code>next</code> 属性指向新建的 <code>hook</code>，然后再更新 <code>workInProgressHook</code> 的值为当前的 <code>hook</code> 对象。</p>
<p>此时函数组件Fiber节点的memoizedState属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png" alt="alt text"></p>
<p>在 <code>hook</code> 创建完成之后，确定当前 <code>hook</code> 对象的 <code>deps</code> 依赖，因为我们传递的依赖为[]，所以此时 <code>deps</code> 为一个空数组。然后更新当前 <code>Fiber</code> 节点的 <code>flags</code> 标记，最后设置 <code>hook</code> 对象的 <code>memoizedState</code> 属性内容，这里属性的结果为<code>pushEffect</code> 方法调用的返回值</p>
<h5 id="1-2-2-2-pushEffect"><a href="#1-2-2-2-pushEffect" class="headerlink" title="1.2.2.2 pushEffect"></a>1.2.2.2 pushEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  # 创建副作用对象</span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create, <span class="comment">// 回调函数</span></span><br><span class="line">    destroy, <span class="comment">// 销毁函数</span></span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 取出当前函数组件的UpdateQueue</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null时: 创建当前函数组件的UpdateQueue</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span><br><span class="line">    <span class="comment">// 第一个effect对象: 它的next属性会执行自己,形成一个单向环状链表</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次加载其他的effect时: 将</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      # 上一个effect的next属性指向新建的effect</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      # 新建的next属性指向第一个effect</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了一个effect对象，查看它的内容：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png" alt="alt text"></p>
<ol>
<li><code>create</code> 属性即为我们传入的回调函数。</li>
<li><code>deps</code> 属性是当前 <code>useEffect hook</code>的依赖。</li>
<li><code>destory</code> 属性为 <code>undefined</code>，它存储的是 <code>useEffect hook</code>返回的clean清理函数或者说销毁函数，但是它不是在这里赋值的，并且当前我们也没有返回这个函数。</li>
</ol>
<p>然后取出当前函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性内容赋值给变量 <code>componentUpdateQueue</code>。</p>
<p>然后判断 <code>componentUpdateQueue</code> 是否为 <code>null</code>：</p>
<p>为 <code>null</code> 时，然后调用 <code>createFunctionComponentUpdateQueue</code> 方法更新它的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>): <span class="title">FunctionComponentUpdateQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    stores: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前创建的 <code>effect</code> 对象的 <code>next</code> 属性指向了自身，且同时更新 <code>updateQueue.lastEffect</code> 属性为当前 <code>effect</code> 对象，由此形成一个单向环状链表。</p>
<p>所以此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png" alt="alt text"></p>
<p><code>pushEffect</code> 方法最后，返回当前创建的 <code>effect</code> 对象。</p>
<p>再回到 <code>mountEffectImpl</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect()</span><br></pre></td></tr></table></figure>

<p>所以 <code>hook</code> 对象的 <code>memoizedState</code> 属性值为一个 <code>effect</code> 对象。</p>
<p>从这里我们可以发现，虽然每个hook对象都是相同的属性，但是不同的 <code>hook</code> 类型它存储的内容却完全不同。</p>
<ul>
<li><code>useState</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为数据 <code>state</code>。</li>
<li><code>useEffect</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为一个 <code>effect</code> 对象。</li>
</ul>
<h4 id="1-2-3-mountLayoutEffect"><a href="#1-2-3-mountLayoutEffect" class="headerlink" title="1.2.3 mountLayoutEffect"></a>1.2.3 mountLayoutEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberFlags: Flags = UpdateEffect;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">    fiberFlags |= LayoutStaticEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(fiberFlags, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现useEffect和useLayoutEffect共用了同一个加载方法 <code>mountEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<p><code>hook</code> 对象创建和处理，此时函数组件Fiber节点的memoizedState属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png" alt="alt text"></p>
<p><code>effect</code> 对象创建和处理，依然是 <code>pushEffect</code> 方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # 第二次加载其他的effect时:</span><br><span class="line">  <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="comment">// 上一个effect的next属性指向新建的effect</span></span><br><span class="line">    lastEffect.next = effect;</span><br><span class="line">    <span class="comment">// 新建的next属性指向第一个effect</span></span><br><span class="line">    effect.next = firstEffect;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前为第二个effect相关的 <code>hook</code> 处理，所以此时 <code>Fiber.updateQueue</code>【即componentUpdateQueue】是有值的，进入else分支处理。</p>
<p>更新<code>Fiber.updateQueue.lastEffect</code>属性指向为当前新建的 <code>effect2</code>，将 <code>effect2</code> 的 <code>next</code> 属性指向为之前的 <code>effect</code> 对象。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png" alt="alt text"></p>
<p>到此，函数组件加载阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="1-3-commit阶段"><a href="#1-3-commit阶段" class="headerlink" title="1.3 commit阶段"></a>1.3 commit阶段</h3><p>前面全部的加载逻辑都是在 <code>Fiber Reconciler</code> 协调流程中执行的，即函数组件大部分的加载逻辑都是在 <code>reconciler</code> 协调流程中完成的【更新阶段同理】，还有剩下的一部分逻辑在 <code>commit</code> 阶段之中处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发起调度处理useEffect回调</span></span><br><span class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">	<span class="comment">// 这个回调就是处理useEffect的</span></span><br><span class="line">	flushPassiveEffects();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1，BeforeMutation阶段</span></span><br><span class="line">  commitBeforeMutationEffects()</span><br><span class="line">  <span class="comment">// 2，Mutation阶段，渲染真实DOM加载到页面</span></span><br><span class="line">  commitMutationEffects()</span><br><span class="line">  <span class="comment">// 3，Layout阶段</span></span><br><span class="line">  commitLayoutEffects()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit</code> 阶段的内容都是同步执行，在进入具体的执行之前，都会先调用 <code>scheduleCallback</code> 方法发起一个新的调度，即创建一个新的任务 <code>task</code>，最后会生成一个新的宏任务来异步处理副作用【即执行useEffect的回调钩子】。</p>
<p>上面是 <code>useEffect</code> 的回调处理，我们再查看 <code>useLayoutEffect</code> 的回调处理。</p>
<h3 id="1-4-Layout阶段"><a href="#1-4-Layout阶段" class="headerlink" title="1.4 Layout阶段"></a>1.4 Layout阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 根据组件类型</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">          <span class="comment">// 函数组件的处理</span></span><br><span class="line">          <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">              <span class="comment">// 传入的是layout相关的flag标记</span></span><br><span class="line">              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-commitHookEffectListMount"><a href="#1-4-1-commitHookEffectListMount" class="headerlink" title="1.4.1 commitHookEffectListMount"></a>1.4.1 commitHookEffectListMount</h4><p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListMount</span>(<span class="params">flags: HookFlags, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  # 当前函数组件的updateQueue属性，存储的是副作用链表</span><br><span class="line">  <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">  <span class="comment">// 取出最后一个effect对象</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个effect对象</span></span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 开始循环处理</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">        <span class="comment">// Mount</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.create;</span><br><span class="line">        # 执行回调函数</span><br><span class="line">        effect.destroy = create();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从当前函数组件 <code>Fiber</code> 节点取出它的 <code>updateQueue</code> 属性内容，在前面我们已经知道了 <code>Fiber.updateQueue</code> 存储的是副作用相关的链表，定义一个 <code>lastEffect</code> 变量存储 <code>updateQueue.lastEffect</code> 的内容，即最后一个 <code>effect</code> 对象。</p>
<p>判断 <code>lastEffect</code> 是否为 <code>null</code> ，如果 <code>lastEffect</code> 为 <code>null</code>，代表当前函数组件没有使用过 <code>effect</code> 相关的 <code>hook</code>。</p>
<p>当前肯定是有值的，继续向下执行。从 <code>lastEffect.next</code> 中取出第一个 <code>effect</code> 对象，开始按顺序循环处理副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">	<span class="comment">// Mount</span></span><br><span class="line">	<span class="keyword">const</span> create = effect.create;</span><br><span class="line">	<span class="comment">// 执行回调函数</span></span><br><span class="line">	effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">  effect = effect.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>

<p>注意在执行之前有一个条件判断，只有存在 <code>effect</code> 相关的 <code>flags</code> 标记才会执行对应副作用回调。</p>
<p>而在之前 <code>hook</code> 加载是有进行设置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect(</span><br><span class="line">  HookHasEffect | hookFlags, <span class="comment">// HookHasEffect标记就是表示有需要执行副作用</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在函数组件加载阶段时，每个 <code>useEffect</code> 和 <code>useLayoutEffect</code> 都有打上 <code>HookHasEffect</code> 的标记，表示在加载阶段都会默认执行一次。</p>
<p>需要注意的是：之前 <code>commitHookEffectListMount</code> 传入的是与 <code>Layout</code> 相关的 <code>flags</code> 标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); <span class="comment">// Layout</span></span><br></pre></td></tr></table></figure>

<p>所以这里只有 <code>layout hook</code> 的回调才能执行，第一个 <code>effect</code> 对象对应的是 <code>useEffect</code>，不满足判断条件</p>
<p>从当前 <code>effect</code> 对象的 <code>next</code> 属性取出下一个 <code>effect</code> 对象，开始第二次循环。</p>
<p>第二个 <code>effect</code> 对象对应的是 <code>useLayoutEffect</code>，满足判断条件，执行它的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = effect.create;</span><br><span class="line"><span class="comment">// 执行回调函数</span></span><br><span class="line">effect.destroy = create();</span><br></pre></td></tr></table></figure>

<p>到此 hook 相关的回调处理完成，函数组件加载逻辑全部执行完成。</p>
<h2 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h2><h3 id="2-1-dispatchSetState"><a href="#2-1-dispatchSetState" class="headerlink" title="2.1 dispatchSetState"></a>2.1 dispatchSetState</h3><p>当操作更新触发 <code>setState</code> 时, 就是触发之前 <code>useState</code> 加载返回的 <code>dispatch</code> 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line"># 返回值</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A, <span class="regexp">//</span> state <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求更新优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// 1. 创建update更新对象</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// state 1</span></span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 调度之前的一个优化策略校验: eagerState</span><br><span class="line">    <span class="comment">// 快速计算出本次最新的state，与原来的进行对比，如果没有发生变化，则跳过后续的更新逻辑</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当前的state，即旧的state</span></span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="comment">// 快速计算最新的state</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            # 如果state没变，组件不做更新。此处和useReducer对比下，useReducer还是会让函数组件更新</span><br><span class="line">            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将更新对象入队</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      <span class="comment">// 3. 开启一个新的调度更新任务</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-eagerState"><a href="#2-1-1-eagerState" class="headerlink" title="2.1.1 eagerState"></a>2.1.1 eagerState</h4><p>首先看 <code>dispatchSetState</code> 方法的整个结构和类组件的更新方法 <code>enqueueSetState</code> 基本相同，还有 <code>react</code> 应用的初始加载 <code>updateContainer</code>，其实一个react应用的更新场景就只有这三种，而它们的更新逻辑就是以下几个步骤：</p>
<ol>
<li>获取更新优先级 <code>lane</code>。</li>
<li>创建 <code>update</code> 更新对象 。</li>
<li>将 <code>update</code> 更新对象添加到目标Fiber对象的更新队列中。</li>
<li>开启一个新的调度更新任务。</li>
</ol>
<p>它们的区别主要在于函数组件这里在调度之前有一个eagerState优化策略校验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的state，即旧的state</span></span><br><span class="line"><span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line"><span class="comment">// 快速计算最新的state</span></span><br><span class="line"><span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">update.eagerState = eagerState;</span><br><span class="line"><span class="comment">// 比较新旧state</span></span><br><span class="line"><span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个优化策略的作用是：调用 <code>queue.lastRenderedReducer</code> 方法，通过原来的 <code>state</code> 和当前传入的 <code>action</code> 参数，快速的计算出本次最新的 <code>state</code> 【即eagerState】，通过比较新旧 <code>state</code> 来判断数据是否变化，如果没有变化则可以跳过后续的更新逻辑，即不会开启新的调度更新任务。当前我们的 <code>state</code> 是有变化的，所以不满足优化策略，将继续向下执行更新。</p>
<h4 id="2-1-2-enqueueConcurrentHookUpdate"><a href="#2-1-2-enqueueConcurrentHookUpdate" class="headerlink" title="2.1.2 enqueueConcurrentHookUpdate"></a>2.1.2 enqueueConcurrentHookUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentHookUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: HookQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: HookUpdate&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// 通用的入队方法</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// 找到根节点并返回</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>dispatchSetState</code> 方法中，最后还是会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h4 id="2-1-3-flushSyncWorkOnAllRoots"><a href="#2-1-3-flushSyncWorkOnAllRoots" class="headerlink" title="2.1.3 flushSyncWorkOnAllRoots"></a>2.1.3 flushSyncWorkOnAllRoots</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>microtask</code> 结束时，<code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>直接快进到performSyncWorkOnRoot方法中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用renderRootSync方法，开始FiberTree的创建过程。</p>
<p><strong>在这之前，还有一个处理要注意：把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	prepareFreshStack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	finishQueueingConcurrentUpdates()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png" alt="alt text"></p>
<h4 id="2-1-4-updateFunctionComponent"><a href="#2-1-4-updateFunctionComponent" class="headerlink" title="2.1.4 updateFunctionComponent"></a>2.1.4 updateFunctionComponent</h4><p>下面进入 <code>beginWork</code> 工作的 <code>FunctionComponent</code> 处理分支，开始函数组件的更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  # 调用函数组件</span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  # 函数组件默认的bailout策略，满足条件比较苛刻</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见 <code>updateFunctionComponent</code> 方法主要有两个处理：</p>
<ol>
<li>调用renderWithHooks【函数组件加载也是调用了这个方法】。</li>
<li>判断是否满足Bailout优化策略，满足则进入优化逻辑，跳过本组件的更新。不满足，则执行正常的组件更新逻辑。</li>
</ol>
<h4 id="2-1-5-renderWithHooks"><a href="#2-1-5-renderWithHooks" class="headerlink" title="2.1.5 renderWithHooks"></a>2.1.5 renderWithHooks</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// 设置为当前渲染中的Fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置函数组件节点的数据</span></span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置更新的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current =current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  <span class="comment">// 调用这个函数，即调用组件，循环生成Element对象，</span></span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新阶段时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</span><br></pre></td></tr></table></figure>

<p><code>renderWithHooks</code> 方法的重点依然是组件的调用 <code>Component()</code>，这里的逻辑依然只是重新调用一遍我们定义的函数，最后返回最新的jsx内容【即reactElement对象】</p>
<h4 id="2-1-6-hooks的更新"><a href="#2-1-6-hooks的更新" class="headerlink" title="2.1.6 hooks的更新"></a>2.1.6 hooks的更新</h4><p>首先查看 <code>useState</code> 的更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123;</span><br><span class="line">	useState: updateState, <span class="comment">// 更新state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState:</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init?</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 更新hook工作</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-updateWorkInProgressHook"><a href="#2-1-7-updateWorkInProgressHook" class="headerlink" title="2.1.7 updateWorkInProgressHook"></a>2.1.7 updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即将处理的hook</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 第一此进入更新时，currentHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出当前正在更新的函数组件Fiber的旧节点</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.alternate;</span><br><span class="line">    <span class="comment">// 更新阶段，current都是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将旧节点的memoizedState 设置为下一个处理的Hook</span></span><br><span class="line">      <span class="comment">// 将组件加载时，初始化的hook链表取出，memoizedState指向的是hook1</span></span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个hook更新开始，会走这里</span></span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置下一个工作中的Hook为null</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 组件的第一个Hook更新时，workInProgressHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将当前函数组件Fiber节点的memoizedState 设置为下一个处理的hook【默认是null】</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一个Hook，则取next指向的下一个</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个不为null， 说明当前hook不是最后一个更新的hook，只有最后一个hook更新时，nextWorkInProgressHook才为null</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's already a work-in-progress. Reuse it.</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新currentHook 为第一个hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象，复用原来的内容</span></span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      baseQueue: currentHook.baseQueue,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>, <span class="comment">// 但是清空了next指向</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个hook更新时，workInProgressHook为null，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      <span class="comment">// 更新当前函数的组件的memoizedState为第一个hook对象，同时设置为当前正在工作中的hook</span></span><br><span class="line">      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      <span class="comment">// 非第一个Hook,直接添加到上一个hook对象的next属性中</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回当前正在工作中的hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像函数组件的hook在加载时都会调用一个 <code>mountWorkInProgressHook</code> 方法，生成一个hook链表。</p>
<p>而函数组件的hook在更新时也会调用一个 <code>updateWorkInProgressHook</code> 方法，生成对应的hook链表。</p>
<p>所以 <code>updateWorkInProgressHook</code> 方法的作用是：确定当前函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容，也就是生成它的 <code>hook</code> 链表。</p>
<p>它的做法就是从 <code>current</code> 节点上取出函数组件加载时生成的 <code>hook</code> 链表，按顺序取出原来的 <code>hook</code> 对象，根据原来的对象信息创建生成新的 <code>newHook</code> 对象，最后按顺序一个一个添加到新的 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性上。</p>
<p><strong>注意：</strong>这里是一个重点，如果没有清空 <code>next</code> 属性，那更新当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性，直接拿到第一个 <code>hook</code> 对象，就可以拿到整个 <code>hook</code> 链表，然后后续的 <code>hook</code> 更新就不需要再调用 <code>updateWorkInProgressHook</code> 方法了。</p>
<p>但是函数组件为啥不能如此处理呢？</p>
<p>因为react不能保证开发者是一定按照规范来使用的 <code>hook</code> ，如果开发者将 <code>hook</code> 置于条件语句中，在更新阶段出现了原来 <code>hook</code> 链表中不存在的 <code>hook</code> 对象，则在渲染时就会发生异常，所以react在函数组件更新时需要主动中断 <code>hook</code> 对象的next属性指向，按原来的链表顺序重新一个一个添加，如果出现了不匹配的 <code>hook</code> 对象，就会主动抛出异常，提示用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-计算state"><a href="#2-1-8-计算state" class="headerlink" title="2.1.8 计算state"></a>2.1.8 计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line"><span class="function">  <span class="title">initialArg</span>: <span class="title">I</span>,</span></span><br><span class="line"><span class="function">  <span class="title">init</span>?: <span class="title">I</span> =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 返回新的hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer; <span class="comment">// 还是basicStateReducer，无变化</span></span><br><span class="line">  <span class="keyword">const</span> current = currentHook; <span class="comment">// 旧的hook对象，加载时useState创建的hook对象</span></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.baseQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="comment">// 等待处理的更新链表：默认指向的是最后一个update对象</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// pendingQueue不为null，代表有需要处理的更新对象，然后需要将它们添加到baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Merge the pending queue and the base queue.</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们有一个队列要处理</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = current.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line"></span><br><span class="line">    # 循环处理update更新对象</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">        <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line">            action: update.action,</span><br><span class="line">            hasEagerState: update.hasEagerState,</span><br><span class="line">            eagerState: update.eagerState,</span><br><span class="line">            next: (<span class="literal">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	# 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>updateWorkInProgressHook</code> 方法调用完成之后，返回值就是 <code>useState</code> 对应的hook对象：</p>
<p>取出hook对象的queue队列，如果queue为null，则会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的逻辑看似比较多，但其实比较简单，而且和this.setState计算state的逻辑基本一致。</p>
<p><strong>它的核心逻辑：</strong>按顺序正向循环 <code>update</code> 更新队列，定义一个变量 <code>newState</code> 来存储最新的 <code>state</code>，然后根据原来 <code>state</code> 和 <code>update</code> 对象里面的信息计算最新的数据更新变量 <code>newState</code>，每循环一次就会从 <code>update</code> 对象的 <code>next</code> 属性取出下一个参与计算的 <code>update</code>，直接到所有的 <code>update</code> 处理完成。</p>
<p>当前 <code>pendingQueue</code> 结构【单向环状链表】：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png" alt="alt text"></p>
<p>在类组件中，会根据pendingQueue的内容重构生成一个新的单向链表，不再是环状，有明确的结束。</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png" alt="alt text"></p>
<p>和类组件不同的是，函数组件这里并没有额外处理pendingQueue，而是直接复制给baseQueue，从baseQueue.next取出第一个update对象【即first】开始计算state。</p>
<p>所以函数组件这里的do while循环多了一个结束的判断条件，就是不能等于first，不然就会陷入无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first)</span><br></pre></td></tr></table></figure>

<p>然后就是函数组件计算state的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while循环中，计算state的核心逻辑</span></span><br><span class="line"><span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">  newState = ((update.eagerState: any): S);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action = update.action;</span><br><span class="line">  newState = reducer(newState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果eagerState存在，则直接使用eagerState的值为新的state。</p>
<p>如果不存在，则调用reducer【basicStateReducer】，根据最新的newState和当前update对象的action重新计算state。</p>
<p>循环结束，在更新state之前，还有一个校验需要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line"><span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">  markWorkInProgressReceivedUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对一个状态的批量处理之后，有一个状态变化的校验，针对的是函数组件内部的 <code>Bailout</code> 策略。</p>
<p>即如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量 <code>ReceivedUpdate</code> 为 <code>false</code>，表示改组件没有更新的内容，这样就可以在 <code>renderWithHooks</code> 方法执行完成后，进入 <code>Bailout</code> 策略。</p>
<p>然后更新 <code>hook</code> 对象的 <code>memoizedState</code> 属性为最新的 <code>newState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储最新的state</span></span><br><span class="line">hook.memoizedState = newState;</span><br></pre></td></tr></table></figure>

<p>到此，<code>useState hook</code> 的更新程序执行完成，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆state</span></span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p>同时这里我们也可以明白：函数组件 <code>useState hook</code> 能够缓存变量结果的原因，因为它的 <code>state</code> 存储在 <code>hook</code> 对象的属性之中，并且这个属性可以在函数组件重新渲染过程中得到更新。</p>
<h3 id="2-2-updateEffect"><a href="#2-2-updateEffect" class="headerlink" title="2.2 updateEffect"></a>2.2 updateEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 取出新的依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 重置销毁方法</span></span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的pushEffect方法</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    <span class="comment">// 继承原来的destroy方法</span></span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面校验为true的情况下，这里就不会再执行</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先依然是调用一个 <code>updateWorkInProgressHook</code> 方法，前面已经详细讲解了它的作用。所以这里调用此方法后，就会新建一个 <code>newHook</code> 对象，添加到第一个 <code>hook</code> 对象的 <code>next</code> 属性之上，形成一个链表，后续如果还有新的 <code>newHook</code> 对象则继续执行同样的逻辑。</p>
<p>此时函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png" alt="alt text"></p>
<h3 id="2-2-1-areHookInputsEqual"><a href="#2-2-1-areHookInputsEqual" class="headerlink" title="2.2.1 areHookInputsEqual"></a>2.2.1 areHookInputsEqual</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况1，无依赖参数，每次渲染都会执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况2，有至少一项依赖参数，循环判断每个依赖是否相等，任何一个依赖变化则会重新执行副作用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 情况3，即空数组的情况，重新渲染不执行副作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前我们依赖为一个空数组，所以满足第三种情况，直接返回 <code>true</code>。</p>
<ul>
<li><p>在依赖校验为 <code>true</code> 的情况下，即表示没有变化，此时更新 <code>hook.memoizedState</code> 属性，最后触发 <code>return</code> 关键字，<code>updateEffect</code> 方法执行完成。</p>
</li>
<li><p>在依赖变化时，也会重新设置 <code>hook.memoizedState</code> 属性，依赖校验为true的情况下就是第一个参数不同，会打上 <code>HookHasEffect</code> 的标记。</p>
<ul>
<li>这个值会存储到 <code>effect</code> 对象的tag属性上，表示此effect对象有需要执行的副作用回调。</li>
<li><code>hookFlags</code> 表示副作用的类型标记，比如 <code>HookPassive</code>，<code>HookLayout</code>。</li>
<li>所以依赖发生变化的唯一区别就是：打上了 <code>HookHasEffect</code> 标记。最终会 <code>commit</code> 阶段中执行回调时，判断 <code>effect.tag</code> 的值来判断是否执行回调。</li>
</ul>
</li>
</ul>
<p>到此，函数组件的第二个hook：useEffect更新完成。</p>
<h3 id="2-3-updateLayoutEffect"><a href="#2-3-updateLayoutEffect" class="headerlink" title="2.3 updateLayoutEffect"></a>2.3 updateLayoutEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>useEffect</code> 和 <code>useLayoutEffect</code> 共用了同一个更新方法 <code>updateEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<ul>
<li>调用 <code>updateWorkInProgressHook</code> 方法：创建新 <code>hook</code> 对象，此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向更新为：</li>
</ul>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png" alt="alt text"></p>
<ul>
<li>判断 <code>deps</code> 依赖是否变化，如果变化则为对应的 <code>effect</code> 对象打上 <code>HookHasEffect</code> 的标记。</li>
</ul>
<p>到此，函数组件更新阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>函数组件更新阶段主要有这两个重点逻辑：</p>
<ul>
<li>根据 <code>updateQueue</code> 更新队列，循环计算 <code>state</code>，最后将最新的 <code>state</code> 数据存储到 <code>Fiber.memoizedState</code> 属性上并返回。</li>
<li>更新 <code>Effect</code>类 <code>hook</code> 时，判断依赖是否变化打上 <code>HookHasEffect</code>，最后会根据 <code>effect.tag</code> 值来决定本次更新是否执行回调。</li>
</ul>
<p><code>useEffect</code> 和 <code>useLayoutEffect</code>的区别：<code>useLayoutEffect</code> 是 <code>useEffect</code> 的一个变种，它们都是在 <code>React</code> 组件中处理副作用的方法。两者之间的主要区别在于它们的执行时机。</p>
<ul>
<li><code>useEffect</code> 的回调函数会在每次渲染结束后异步执行，这意味着它不会阻塞浏览器的渲染过程。换句话说，<code>React</code> 会在处理 <code>useEffect</code> 内部的状态更新之前，让浏览器先绘制屏幕。</li>
<li>而 <code>useLayoutEffect</code> 的回调函数会在每次渲染结束后同步执行。这意味着它会阻塞浏览器的渲染过程，直到其执行完毕。因此，<code>useLayoutEffect</code> 可以在浏览器重新绘制屏幕之前触发。</li>
</ul>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 会阻塞浏览器的渲染过程，如果过度使用，可能会导致应用程序变慢，甚至引发性能问题。因此，在大多数情况下，应优先考虑使用 <code>useEffect</code>。只有在某些特定情况下，例如需要在 <code>DOM</code> 更新后立即进行某些操作，或者需要在用户看到渲染结果之前进行某些操作，才考虑使用 <code>useLayoutEffect</code>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/react18-2/" rel="tag"># react18.2</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" rel="prev" title="react18.2类组件加载过程">
      <i class="fa fa-chevron-left"></i> react18.2类组件加载过程
    </a></div>
      <div class="post-nav-item">
    <a href="/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html" rel="next" title="react18.2和react16批处理实现和对比">
      react18.2和react16批处理实现和对比 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-加载过程"><span class="nav-number">1.</span> <span class="nav-text">1. 加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-mountIndeterminateComponent"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 mountIndeterminateComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-renderWithHooks"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 renderWithHooks</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-1-ReactCurrentDispatcher"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1.1 ReactCurrentDispatcher</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-2-函数组件调用"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.1.2 函数组件调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-hooks的加载"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 hooks的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-mountState"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 mountState</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-1-mountWorkInProgressHook"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1.2.1.1 mountWorkInProgressHook</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-mountEffect"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 mountEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-1-mountEffectImpl"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1.2.2.1 mountEffectImpl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-2-pushEffect"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1.2.2.2 pushEffect</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-mountLayoutEffect"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 mountLayoutEffect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-commit阶段"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 commit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Layout阶段"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Layout阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-commitHookEffectListMount"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 commitHookEffectListMount</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-更新过程"><span class="nav-number">2.</span> <span class="nav-text">2. 更新过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-dispatchSetState"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 dispatchSetState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-eagerState"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 eagerState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-enqueueConcurrentHookUpdate"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 enqueueConcurrentHookUpdate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-flushSyncWorkOnAllRoots"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 flushSyncWorkOnAllRoots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-updateFunctionComponent"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 updateFunctionComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-renderWithHooks"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 renderWithHooks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-hooks的更新"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.6 hooks的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-7-updateWorkInProgressHook"><span class="nav-number">2.1.7.</span> <span class="nav-text">2.1.7 updateWorkInProgressHook</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-8-计算state"><span class="nav-number">2.1.8.</span> <span class="nav-text">2.1.8 计算state</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-updateEffect"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 updateEffect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-areHookInputsEqual"><span class="nav-number">2.3.</span> <span class="nav-text">2.2.1 areHookInputsEqual</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-updateLayoutEffect"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 updateLayoutEffect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-总结"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/IMG_2044.jpg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
