<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言Vue3 官网中有下面这样一张图，基本展现出了 Vue3 的渲染原理：  本文会从源码角度来简单的看一下 Vue3 的运行全流程，旨在加深对上图的理解。 初始化渲染从下面这个很简单的使用示例开始： 1234567891011121314import &amp;#123; createApp, ref &amp;#125; from &#39;vue&#39;createApp(&amp;#123;  template: &#96;">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3初始化渲染流程分析">
<meta property="og:url" content="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="前言Vue3 官网中有下面这样一张图，基本展现出了 Vue3 的渲染原理：  本文会从源码角度来简单的看一下 Vue3 的运行全流程，旨在加深对上图的理解。 初始化渲染从下面这个很简单的使用示例开始： 1234567891011121314import &amp;#123; createApp, ref &amp;#125; from &#39;vue&#39;createApp(&amp;#123;  template: &#96;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rile14929.github.io/images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image.png">
<meta property="og:image" content="https://rile14929.github.io/images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-1.png">
<meta property="article:published_time" content="2023-11-16T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-16T16:00:00.000Z">
<meta property="article:author" content="rile">
<meta property="article:tag" content="vue">
<meta property="article:tag" content="vue3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rile14929.github.io/images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image.png">

<link rel="canonical" href="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>vue3初始化渲染流程分析 | 右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          vue3初始化渲染流程分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue3 官网中有下面这样一张图，基本展现出了 Vue3 的渲染原理：</p>
<p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<p>本文会从源码角度来简单的看一下 Vue3 的运行全流程，旨在加深对上图的理解。</p>
<h2 id="初始化渲染"><a href="#初始化渲染" class="headerlink" title="初始化渲染"></a>初始化渲染</h2><p>从下面这个很简单的使用示例开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">createApp(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="card"&gt;</span></span><br><span class="line"><span class="string">            &lt;button type="button" @click="count++"&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: ref(<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>首先调用了 <code>createApp</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以看到重点在于 <code>ensureRenderer</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rendererOptions = <span class="comment">/*#__PURE__*/</span> extend(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="comment">// 因为 ensureRenderer 是在执行 createApp 的时候调用的，如果你不执行 createApp 而只使用 vue 的一些响应式 API，就不会创建这个渲染器，所以说延时渲染。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rendererOptions</code>是一个对象，渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法。</p>
<p>这么做主要是方便跨平台，比如在其他非浏览器环境，可以替换成对应的节点操作方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rendererOptions</span></span><br><span class="line">&#123;</span><br><span class="line">  insert: <span class="function">(<span class="params">child, parent, anchor</span>) =&gt;</span> &#123;</span><br><span class="line">    parent.insertBefore(child, anchor || <span class="literal">null</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  remove: <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = child.parentNode</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      parent.removeChild(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options: RendererOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseCreateRenderer(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>baseCreateRenderer</code>, 这个函数简直可以用庞大来形容，patch、mount、diff均在这个方法中实现，回头我们再来细看实现，现在我们只需要关心他最后返回的什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RendererOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  createHydrationFns?: typeof createHydrationFunctions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略2000行</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render,</span><br><span class="line">        hydrate,</span><br><span class="line">        createApp: createAppAPI(render, hydrate),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现createApp是通过createAppAPI方法调用返回的，下面我们看createAppAPI。</p>
<h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI"></a>createAppAPI</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction&lt;HostElement&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = null</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(rootComponent)) &#123;</span><br><span class="line">      rootComponent = extend(&#123;&#125;, rootComponent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootProps != <span class="literal">null</span> &amp;&amp; !isObject(rootProps)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(<span class="string">`root props passed to app.mount() must be an object.`</span>)</span><br><span class="line">      rootProps = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context = createAppContext()</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line">      _instance: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> config() &#123;</span><br><span class="line">        <span class="keyword">return</span> context.config</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">set</span> config(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`app.config cannot be replaced. Modify individual options instead.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 都是一些眼熟的方法</span></span><br><span class="line">      <span class="comment">// 注册plugin</span></span><br><span class="line">      use(plugin: Plugin, ...options: any[]) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 全局混入</span></span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局组件</span></span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局指令</span></span><br><span class="line">      directive(name: string, directive?: Directive) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 挂载根组件</span></span><br><span class="line">      mount(</span><br><span class="line">        rootContainer: HostElement, <span class="comment">// 挂载容器</span></span><br><span class="line">        isHydrate?: boolean,</span><br><span class="line">        namespace?: boolean | ElementNamespace,</span><br><span class="line">      ): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 卸载</span></span><br><span class="line">      unmount() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 分享数据</span></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是最终的 <code>createApp</code>方法，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象。</p>
<p>所谓的应用实例app其实就是一个对象，我们传进去的组件选项作为根组件存储在_component属性上，另外还可以看到应用实例提供的一些方法，比如注册插件的use方法，挂载实例的mount方法等。</p>
<h4 id="createAppContext-实现"><a href="#createAppContext-实现" class="headerlink" title="createAppContext 实现"></a>createAppContext 实现</h4><p>context其实也是一个普通对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> any,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    optionsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    propsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    emitsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是vue的初次渲染逻辑，首先官方解构了mount方法， 然后又重写了app.mount，并调用normalizeContainer校验挂载元素，临时保存了需要渲染的内容。并对vue2的写法做了兼容处理，挂载元素进行渲染。</p>
<p>在以上整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化的技巧，很好地实现了参数保留。比如，在执行 app.mount 的时候，并不需要传入渲染器 render，这是因为在执行 createAppAPI 的时候渲染器 render 参数已经被保留下来了。</p>
<p>至此，createApp的流程大概到此结束，下一部分来分析mount挂载部分。</p>
<h3 id="mounted挂载"><a href="#mounted挂载" class="headerlink" title="mounted挂载"></a>mounted挂载</h3><h4 id="重写app-mount方法"><a href="#重写app-mount方法" class="headerlink" title="重写app.mount方法"></a>重写app.mount方法</h4><p>createApp 函数中，首先取出 app 对象中的 mount 函数，然后通过 app.mount = () =&gt; {} 对 mount 函数进行重写：</p>
<ol>
<li>首先调用 normalizeContainer 函数来获取container节点；</li>
<li>判断该节点是否存在，若不存在，则直接返回；</li>
<li>清空container的innerHTML；</li>
<li>调用mount函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)这里重写的目的是考虑到跨平台(app.mount里面只包含和平台无关的代码)</span></span><br><span class="line"><span class="comment">    (2)这些重写的代码是完善web平台下的渲染逻辑(比如其他平台也可以进行类似的重写)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  app.mount = (containerOrSelector: Element | ShadowRoot | string): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根组件容器 选择器字符串兼容</span></span><br><span class="line">    <span class="keyword">const</span> container = normalizeContainer(containerOrSelector)</span><br><span class="line">    <span class="keyword">if</span> (!container) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// rootComponent</span></span><br><span class="line">    <span class="keyword">const</span> component = app._component</span><br><span class="line">    <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">    <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      <span class="comment">// __UNSAFE__</span></span><br><span class="line">      <span class="comment">// Reason: potential execution of JS expressions in in-DOM template.</span></span><br><span class="line">      <span class="comment">// The user must make sure the in-DOM template is trusted. If it's</span></span><br><span class="line">      <span class="comment">// rendered by the server, the template should not contain any user data.</span></span><br><span class="line">      component.template = container.innerHTML</span><br><span class="line">      <span class="comment">// 2.x compat check</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * __COMPAT__ 是启动的时候通过rollup去注入进去的</span></span><br><span class="line"><span class="comment">       * 用来判断是否向下兼容</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (__COMPAT__ &amp;&amp; __DEV__) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; container.attributes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> attr = container.attributes[i]</span><br><span class="line">          <span class="keyword">if</span> (attr.name !== <span class="string">'v-cloak'</span> &amp;&amp; <span class="regexp">/^(v-|:|@)/</span>.test(attr.name)) &#123;</span><br><span class="line">            compatUtils.warnDeprecation(</span><br><span class="line">              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,</span><br><span class="line">              <span class="literal">null</span>,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear content before mounting</span></span><br><span class="line">    container.innerHTML = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 调用初始app.mount，挂载元素进行渲染</span></span><br><span class="line">    <span class="keyword">const</span> proxy = mount(container, <span class="literal">false</span>, resolveRootNamespace(container))</span><br><span class="line">    <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      <span class="comment">// vue2的话，会给#app设置一个v-cloak属性，在render的时候清空掉</span></span><br><span class="line">      container.removeAttribute(<span class="string">'v-cloak'</span>)</span><br><span class="line">      container.setAttribute(<span class="string">'data-v-app'</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器），然后做一个 if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容；接着在挂载前清空容器内容，最终再调用 app.mount 的方法走标准的组件渲染流程。</p>
<p>在这里，重写的逻辑都是和 Web 平台相关的，所以要放在外部实现。此外，这么做的目的是既能让用户在使用 API 时可以更加灵活，也兼容了 Vue.js 2.x 的写法，比如 app.mount 的第一个参数就同时支持选择器字符串和 DOM 对象两种类型。</p>
<p>从 app.mount 开始，才算真正进入组件渲染流程。</p>
<h3 id="真正的挂载mounted"><a href="#真正的挂载mounted" class="headerlink" title="真正的挂载mounted"></a>真正的挂载mounted</h3><p><strong>核心流程：</strong></p>
<ol>
<li><strong>根据传入的根组件App创建vnode</strong></li>
<li><strong>渲染vnode。</strong></li>
</ol>
<h4 id="mount方法"><a href="#mount方法" class="headerlink" title="mount方法"></a>mount方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mount(</span><br><span class="line">    rootContainer: HostElement,</span><br><span class="line">    isHydrate?: boolean,</span><br><span class="line">    namespace?: boolean | ElementNamespace,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">        <span class="comment">// #5571</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; (rootContainer <span class="keyword">as</span> any).__vue_app__) &#123;</span><br><span class="line">            warn(</span><br><span class="line">                <span class="string">`There is already an app instance mounted on the host container.\n`</span> +</span><br><span class="line">                <span class="string">` If you want to mount another app on the same host container,`</span> +</span><br><span class="line">                <span class="string">` you need to unmount the previous app by calling \`app.unmount()\` first.`</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line">        <span class="comment">// store app context on the root VNode.</span></span><br><span class="line">        <span class="comment">// this will be set on the root instance on initial mount.</span></span><br><span class="line">        vnode.appContext = context</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (namespace === <span class="literal">true</span>) &#123;</span><br><span class="line">            namespace = <span class="string">'svg'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace === <span class="literal">false</span>) &#123;</span><br><span class="line">            namespace = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HMR root reload</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        context.reload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// casting to ElementNamespace because TS doesn't guarantee type narrowing</span></span><br><span class="line">            <span class="comment">// over function boundaries</span></span><br><span class="line">            render(</span><br><span class="line">                cloneVNode(vnode),</span><br><span class="line">                rootContainer,</span><br><span class="line">                namespace <span class="keyword">as</span> ElementNamespace,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode <span class="keyword">as</span> VNode&lt;Node, Element&gt;, rootContainer <span class="keyword">as</span> any)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(vnode, rootContainer, namespace)</span><br><span class="line">        &#125;</span><br><span class="line">        isMounted = <span class="literal">true</span></span><br><span class="line">        app._container = rootContainer</span><br><span class="line">        <span class="comment">// for devtools and telemetry</span></span><br><span class="line">        ;(rootContainer <span class="keyword">as</span> any).__vue_app__ = app</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            app._instance = vnode.component</span><br><span class="line">            devtoolsInitApp(app, version)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getExposeProxy(vnode.component!) || vnode.component!.proxy</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">        <span class="string">`App has already been mounted.\n`</span> +</span><br><span class="line">            <span class="string">`If you want to remount the same app, move your app creation logic `</span> +</span><br><span class="line">            <span class="string">`into a factory function and create fresh app instances for each `</span> +</span><br><span class="line">            <span class="string">`mount - e.g. \`const createMyApp = () =&gt; createApp(App)\``</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createVNode"><a href="#createVNode" class="headerlink" title="createVNode"></a>createVNode</h4><p>createVNode方法会根据组件的类型生成一个标志，后续会通过这个标志做一些优化处理。我们传的是一个组件选项，也就是一个普通对象，shapeFlag的值为4。后续我们会重点关注我们的主线组件 vnode 和普通元素 vnode。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createVNode = _createVNode;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createVNode</span>(<span class="params">type, props = null, children = null, patchFlag = <span class="number">0</span>, dynamicProps = null, isBlockNode = false</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> shapeFlag = isString(type)</span><br><span class="line">        ? <span class="number">1</span> <span class="comment">/* ShapeFlags.ELEMENT */</span></span><br><span class="line">        : isSuspense(type)</span><br><span class="line">            ? <span class="number">128</span> <span class="comment">/* ShapeFlags.SUSPENSE */</span></span><br><span class="line">            : isTeleport(type)</span><br><span class="line">                ? <span class="number">64</span> <span class="comment">/* ShapeFlags.TELEPORT */</span></span><br><span class="line">                : isObject(type)</span><br><span class="line">                    ? <span class="number">4</span> <span class="comment">/* ShapeFlags.STATEFUL_COMPONENT */</span></span><br><span class="line">                    : isFunction(type)</span><br><span class="line">                        ? <span class="number">2</span> <span class="comment">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span></span><br><span class="line">                        : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用了createBaseVNode方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBaseVNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: (Data &amp; VNodeProps</span>) | <span class="title">null</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">children</span>: <span class="title">unknown</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">patchFlag</span> = 0,</span></span><br><span class="line">  dynamicProps: string[] | null = null,</span><br><span class="line">  shapeFlag = type === Fragment ? <span class="number">0</span> : ShapeFlags.ELEMENT,</span><br><span class="line">  isBlockNode = <span class="literal">false</span>,</span><br><span class="line">  needFullChildrenNormalization = <span class="literal">false</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    __v_isVNode: <span class="literal">true</span>,</span><br><span class="line">    __v_skip: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    key: props &amp;&amp; normalizeKey(props),</span><br><span class="line">    ref: props &amp;&amp; normalizeRef(props),</span><br><span class="line">    scopeId: currentScopeId,</span><br><span class="line">    slotScopeIds: <span class="literal">null</span>,</span><br><span class="line">    children,</span><br><span class="line">    component: <span class="literal">null</span>,</span><br><span class="line">    suspense: <span class="literal">null</span>,</span><br><span class="line">    ssContent: <span class="literal">null</span>,</span><br><span class="line">    ssFallback: <span class="literal">null</span>,</span><br><span class="line">    dirs: <span class="literal">null</span>,</span><br><span class="line">    transition: <span class="literal">null</span>,</span><br><span class="line">    el: <span class="literal">null</span>,</span><br><span class="line">    anchor: <span class="literal">null</span>,</span><br><span class="line">    target: <span class="literal">null</span>,</span><br><span class="line">    targetAnchor: <span class="literal">null</span>,</span><br><span class="line">    staticCount: <span class="number">0</span>,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    dynamicChildren: <span class="literal">null</span>,</span><br><span class="line">    appContext: <span class="literal">null</span>,</span><br><span class="line">    ctx: currentRenderingInstance,</span><br><span class="line">  &#125; <span class="keyword">as</span> VNode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到返回的虚拟DOM也是一个普通对象，我们传进去的组件选项会存储在type属性上。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>虚拟DOM创建完后就会调用render方法将虚拟DOM渲染为实际的DOM节点，render方法就是在baseCreateRenderer中创建的，通过参数传给createAppAPI的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container, namespace</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新vnode不存在</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 卸载</span></span><br><span class="line">      <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建或者更新组件</span></span><br><span class="line">      patch(</span><br><span class="line">        container._vnode || <span class="literal">null</span>, <span class="comment">// 如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可</span></span><br><span class="line">        vnode,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        namespace,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">      isFlushing = <span class="literal">true</span></span><br><span class="line">      flushPreFlushCbs()</span><br><span class="line">      flushPostFlushCbs()</span><br><span class="line">      isFlushing = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">    container._vnode = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要渲染的新VNode不存在，那么从容器元素上获取之前VNode进行卸载，否则调用patch方法进行打补丁，如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可，否则会对比新旧VNode，使用diff算法进行打补丁，Vue2中使用的是双端diff算法，Vue3中使用的是快速diff算法。</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>看看render方法里调用的patch方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1, <span class="comment">// n1 表示旧的vnode，当n1为null时就表示是一次挂载（挂载or更新由n1决定）</span></span><br><span class="line">    n2, <span class="comment">// n2 表示新的vnode，根据n2的type进行不同的处理</span></span><br><span class="line">    container, <span class="comment">// 渲染后会将vnode渲染到container上</span></span><br><span class="line">    anchor = <span class="literal">null</span>,</span><br><span class="line">    parentComponent = <span class="literal">null</span>,</span><br><span class="line">    parentSuspense = <span class="literal">null</span>,</span><br><span class="line">    namespace = <span class="literal">undefined</span>,</span><br><span class="line">    slotScopeIds = <span class="literal">null</span>,</span><br><span class="line">    optimized = __DEV__ &amp;&amp; isHmrUpdating ? <span class="literal">false</span> : !!n2.dynamicChildren,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 === n2) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">    <span class="comment">// 如果新的节点和旧的节点类型不同，则销毁旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        anchor = getNextHostNode(n1)</span><br><span class="line">        unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">        n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n2.patchFlag === PatchFlags.BAIL) &#123;</span><br><span class="line">        optimized = <span class="literal">false</span></span><br><span class="line">        n2.dynamicChildren = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; type, ref, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Text: <span class="comment">//... 处理文本节点</span></span><br><span class="line">        <span class="keyword">case</span> Comment: <span class="comment">//... 处理注释节点</span></span><br><span class="line">        <span class="keyword">case</span> Static: <span class="comment">//... 处理静态节点</span></span><br><span class="line">        <span class="keyword">case</span> Fragment: <span class="comment">//... 处理Fragment组件节点</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">          <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">           processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            namespace,</span><br><span class="line">            slotScopeIds,</span><br><span class="line">            optimized,</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">          <span class="comment">// 处理组件</span></span><br><span class="line">            processComponent(</span><br><span class="line">                n1,</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                slotScopeIds,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;</span><br><span class="line">          	<span class="comment">// 处理 TELEPORT</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">          	<span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            warn(<span class="string">'Invalid VNode type:'</span>, type, <span class="string">`(<span class="subst">$&#123;<span class="keyword">typeof</span> type&#125;</span>)`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span> &amp;&amp; parentComponent) &#123;</span><br><span class="line">        setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM。</p>
<p>patch的多个参数中，重点关注前三个：</p>
<ol>
<li><p>第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程；</p>
</li>
<li><p>第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；</p>
</li>
<li><p>第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</p>
</li>
</ol>
<p>switch里面根据VNode的类型不同做的处理也不同，因为我们的例子传的是一个组件选项对象，所以会走processComponent处理分支：</p>
<h4 id="processComponent"><a href="#processComponent" class="headerlink" title="processComponent"></a>processComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = (</span><br><span class="line">    n1: VNode | <span class="literal">null</span>,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    slotScopeIds: string[] | <span class="literal">null</span>,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    n2.slotScopeIds = slotScopeIds</span><br><span class="line">    <span class="comment">// n1等于null，表示挂载组件</span></span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            ;(parentComponent!.ctx <span class="keyword">as</span> KeepAliveContext).activate(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用mountComponent挂载组件</span></span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// n1不为null，表示更新组件</span></span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否存在旧的VNode判断是调用挂载方法还是更新方法，先看mountComponent方法：</p>
<h5 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent: MountComponentFn = (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 2.x compat may pre-create the component instance before actually</span></span><br><span class="line">    <span class="comment">// mounting</span></span><br><span class="line">    <span class="keyword">const</span> compatMountInstance =</span><br><span class="line">      __COMPAT__ &amp;&amp; initialVNode.isCompatRoot &amp;&amp; initialVNode.component</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.调用ComponentInternalInstance创建组件的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance: ComponentInternalInstance =</span><br><span class="line">      compatMountInstance ||</span><br><span class="line">      <span class="comment">// 调用createComponentInstance函数创建一个实例对象，其属性皆为没有值</span></span><br><span class="line">      (initialVNode.component = createComponentInstance(</span><br><span class="line">        initialVNode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">      ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve props and slots for setup context</span></span><br><span class="line">    <span class="keyword">if</span> (!(__COMPAT__ &amp;&amp; compatMountInstance)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2.设置组件实例</span></span><br><span class="line">      <span class="comment">// 初始化组件, 主要是对组件的props/slots进行初始化处理</span></span><br><span class="line">      <span class="comment">// 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</span></span><br><span class="line">      setupComponent(instance)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line">    <span class="comment">// before proceeding</span></span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3.调用设置和运行有副作用的渲染函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 创建一个组件更新函数</span></span><br><span class="line">      <span class="comment">//  1.1 render获得vnode</span></span><br><span class="line">      <span class="comment">//  1.2 patch(oldVnode, newVnode)</span></span><br><span class="line">      <span class="comment">// 2 创建更新机制 new ReactiveEffect(更新函数)</span></span><br><span class="line">      <span class="comment">// 执行渲染副作用函数</span></span><br><span class="line">      setupRenderEffect(</span><br><span class="line">        instance,</span><br><span class="line">        initialVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        namespace,</span><br><span class="line">        optimized,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      popWarningContext()</span><br><span class="line">      endMeasure(instance, <span class="string">`mount`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用ComponentInternalInstance创建组件的实例</li>
<li>设置组件实例，初始化组件 处理setup的两个参数, 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</li>
<li>调用设置和运行有副作用的渲染函数</li>
</ol>
<p>下面我们依次来看这三个方法：</p>
<h5 id="1-createComponentInstance"><a href="#1-createComponentInstance" class="headerlink" title="1. createComponentInstance"></a>1. createComponentInstance</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  parent: ComponentInternalInstance | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  suspense: SuspenseBoundary | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = vnode.type <span class="keyword">as</span> ConcreteComponent</span><br><span class="line">  <span class="comment">// inherit parent app context - or - if root, adopt from root vnode</span></span><br><span class="line">  <span class="keyword">const</span> appContext =</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance: ComponentInternalInstance = &#123;</span><br><span class="line">    uid: uid++,</span><br><span class="line">    vnode,</span><br><span class="line">    type,</span><br><span class="line">    parent,</span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// 还有非常多属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-setupComponent"><a href="#2-setupComponent" class="headerlink" title="2. setupComponent"></a>2. setupComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(isSSR)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vnode的props和子元素</span></span><br><span class="line">  <span class="keyword">const</span> &#123; props, children &#125; = instance.vnode</span><br><span class="line">  <span class="comment">// 是否是有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = isStatefulComponent(instance)</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="comment">// 初始化slots</span></span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  <span class="comment">// 执行setupStatefulComponent获取setupResult</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR) <span class="comment">// 执行setup</span></span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到setupComponent会初始化props和slots，然后执行setupStatefulComponent，这里主要是执行setup函数，并返回结果</p>
<h6 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent"></a>setupStatefulComponent</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 组件描述对象</span></span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0. create render proxy property access cache</span></span><br><span class="line">  <span class="comment">// 创建render proxy属性访问缓存 作用是缓存访问过的属性</span></span><br><span class="line">  instance.accessCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 1. create public instance / render proxy</span></span><br><span class="line">  <span class="comment">// also mark it raw so it's never observed</span></span><br><span class="line">  <span class="comment">// 代理ctx，拦截ctx的属性访问 从而实现取值的优先级：setupState &gt; data &gt; props &gt; ctx</span></span><br><span class="line">  instance.proxy = markRaw(<span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, PublicInstanceProxyHandlers))</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    exposePropsOnRenderContext(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. call setup()</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component</span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 创建setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instance赋值给currentInstance</span></span><br><span class="line">    <span class="comment">// 设置当前实例为instance 为了在setup中可以通过getCurrentInstance获取到当前实例</span></span><br><span class="line">    <span class="comment">// 同时开启instance.scope.on()</span></span><br><span class="line">    <span class="keyword">const</span> reset = setCurrentInstance(instance)</span><br><span class="line">    <span class="comment">// 暂停tracking 暂停收集副作用函数</span></span><br><span class="line">    pauseTracking()</span><br><span class="line">    <span class="comment">// 执行setup</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [</span><br><span class="line">        __DEV__ ? shallowReadonly(instance.props) : instance.props,</span><br><span class="line">        setupContext,</span><br><span class="line">      ],</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 重新开启副作用收集</span></span><br><span class="line">    resetTracking()</span><br><span class="line">    <span class="comment">// currentInstance置为空</span></span><br><span class="line">    <span class="comment">// activeEffectScope赋值为instance.scope.parent</span></span><br><span class="line">    <span class="comment">// 同时instance.scope.off()</span></span><br><span class="line">    reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPromise(setupResult)) &#123;</span><br><span class="line">      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">      <span class="keyword">if</span> (isSSR) &#123;</span><br><span class="line">        <span class="comment">// return the promise so server-renderer can wait on it</span></span><br><span class="line">        <span class="keyword">return</span> setupResult</span><br><span class="line">          .then(<span class="function">(<span class="params">resolvedResult: unknown</span>) =&gt;</span> &#123;</span><br><span class="line">            handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        <span class="comment">// async setup returned Promise.</span></span><br><span class="line">        <span class="comment">// bail here and wait for re-entry.</span></span><br><span class="line">        instance.asyncDep = setupResult</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; !instance.suspense) &#123;</span><br><span class="line">          <span class="keyword">const</span> name = Component.name ?? <span class="string">'Anonymous'</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Component &lt;<span class="subst">$&#123;name&#125;</span>&gt;: setup function returned a promise, but no `</span> +</span><br><span class="line">              <span class="string">`&lt;Suspense&gt; boundary was found in the parent component tree. `</span> +</span><br><span class="line">              <span class="string">`A component with async setup() must be nested in a &lt;Suspense&gt; `</span> +</span><br><span class="line">              <span class="string">`in order to be rendered.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`setup() returned a Promise, but the version of Vue you are using `</span> +</span><br><span class="line">            <span class="string">`does not support it yet.`</span>,</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里会调用组件选项的setup方法，这个函数中返回的对象会暴露给模板和组件实例，看一下handleSetupResult方法：</p>
<h6 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult"></a>handleSetupResult</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params">instance, setupResult, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFunction(setupResult)) &#123;</span><br><span class="line">        instance.render = setupResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123;</span><br><span class="line">        instance.setupState = proxyRefs(setupResult);</span><br><span class="line">    &#125;</span><br><span class="line">    finishComponentSetup(instance, isSSR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果setup返回的是一个函数，那么这个函数会直接被作为渲染函数。否则如果返回的是一个对象，会使用proxyRefs将这个对象转为Proxy代理的响应式对象。</p>
<h6 id="finishComponentSetup"><a href="#finishComponentSetup" class="headerlink" title="finishComponentSetup"></a>finishComponentSetup</h6><p>最后又调用了finishComponentSetup方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span>(<span class="params">instance, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Component = instance.type;</span><br><span class="line">    <span class="keyword">if</span> (!instance.render) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSSR &amp;&amp; compile &amp;&amp; !Component.render) &#123;</span><br><span class="line">            <span class="keyword">const</span> template = Component.template ||</span><br><span class="line">                  resolveMergedOptions(instance).template;</span><br><span class="line">            <span class="keyword">if</span> (template) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; isCustomElement, compilerOptions &#125; = instance.appContext.config;</span><br><span class="line">                <span class="keyword">const</span> &#123; delimiters, <span class="attr">compilerOptions</span>: componentCompilerOptions &#125; = Component;</span><br><span class="line">                <span class="keyword">const</span> finalCompilerOptions = extend(extend(&#123;</span><br><span class="line">                    isCustomElement,</span><br><span class="line">                    delimiters</span><br><span class="line">                &#125;, compilerOptions), componentCompilerOptions);</span><br><span class="line">                Component.render = compile(template, finalCompilerOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        instance.render = (Component.render || NOOP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是判断组件是否存在渲染函数render，如果不存在则判断是否存在template选项，我们传的组件选项显然是没有render属性，而是传的模板template，所以会使用compile方法来将模板编译成渲染函数。</p>
<h5 id="3-setupRenderEffect"><a href="#3-setupRenderEffect" class="headerlink" title="3. setupRenderEffect"></a>3. setupRenderEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode, <span class="comment">// 组件 vnode</span></span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 组件更新方法</span></span><br><span class="line">    <span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">    <span class="comment">// 创建一个effect, 将componentUpdateFn更新方法传入响应式更新方法</span></span><br><span class="line">    <span class="keyword">const</span> effect = (instance.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">      componentUpdateFn,</span><br><span class="line">      NOOP,</span><br><span class="line">      () =&gt; queueJob(update),</span><br><span class="line">      instance.scope, <span class="comment">// track it in component's effect scope</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件更新函数</span></span><br><span class="line">    <span class="keyword">const</span> update: SchedulerJob = <span class="function">(<span class="params">instance.update = (</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect.dirty) &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    update.id = instance.uid</span><br><span class="line">    <span class="comment">// allowRecurse</span></span><br><span class="line">    <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">    toggleRecurse(instance, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      effect.onTrack = instance.rtc</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtc!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      effect.onTrigger = instance.rtg</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtg!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      update.ownerInstance = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行组件更新</span></span><br><span class="line">    update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就涉及到Vue3的响应式原理了，核心就是使用Proxy拦截数据，然后在属性读取时将属性和读取该属性的函数（称为副作用函数）关联起来，然后在更新该属性时取出该属性关联的副作用函数出来执行。</p>
<p>简化后的ReactiveEffect类就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactiveEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn, scheduler = null, scope) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        activeEffect = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fn();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            activeEffect = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行它的run方法时会把自身赋值给全局的activeEffect变量，然后执行副作用函数时如果读取了Proxy代理后的对象的某个属性时就会将对象、属性和这个ReactiveEffect示例关联存储起来，如果属性发生改变，会取出关联的ReactiveEffect实例，执行它的run方法，达到自动更新的目的。</p>
<h6 id="componentUpdateFn"><a href="#componentUpdateFn" class="headerlink" title="componentUpdateFn"></a>componentUpdateFn</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断组件是否已经挂载</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">const</span> &#123; el, props &#125; = initialVNode</span><br><span class="line">    <span class="comment">// 生命周期和父instance</span></span><br><span class="line">    <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance</span><br><span class="line">    <span class="keyword">const</span> isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><br><span class="line">    toggleRecurse(instance, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// beforeMount hook</span></span><br><span class="line">    <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">      invokeArrayFns(bm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeBeforeMount</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">      <span class="comment">// ssr 相关</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行render函数获得subTree(也是一个vnode) 将subTree挂载到instance上 以供更新使用</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance)) <span class="comment">// 整个组件渲染生成 DOM 对应的 vnode 树</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// patch subTree初次挂载</span></span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        subTree,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// el同步到initialVNode</span></span><br><span class="line">      initialVNode.el = subTree.el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mounted hook</span></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      queuePostRenderEffect(m, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeMounted</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 组件已经挂载</span></span><br><span class="line">    instance.isMounted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">      devtoolsComponentAdded(instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2458: deference mount-only object parameters to prevent memleaks</span></span><br><span class="line">    initialVNode = container = anchor = <span class="literal">null</span> <span class="keyword">as</span> any</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">    <span class="keyword">let</span> originNext = next</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      next.el = vnode.el</span><br><span class="line">      <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">      updateComponentPreRender(instance, next, optimized)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行render函数获得nextTree</span></span><br><span class="line">    <span class="keyword">const</span> nextTree = renderComponentRoot(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取老的subTree</span></span><br><span class="line">    <span class="keyword">const</span> prevTree = instance.subTree</span><br><span class="line">    instance.subTree = nextTree</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patch新旧节点更新组件</span></span><br><span class="line">    patch(</span><br><span class="line">      prevTree,</span><br><span class="line">      nextTree,</span><br><span class="line">      <span class="comment">// parent may have changed if it's in a teleport</span></span><br><span class="line">      hostParentNode(prevTree.el!)!,</span><br><span class="line">      <span class="comment">// anchor may have changed if it's in a fragment</span></span><br><span class="line">      getNextHostNode(prevTree),</span><br><span class="line">      instance,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的patch操作其实就是调用本章开头的那个patch，可以看到patch其实是一个递归操作，这里patch subtree如果根组件的根元素是组件则会继续执行processComponent，如果是一个element元素则会执行processElement，processElement中会处理children，又会调用patch，如此递归直到整个组件挂载完成。</p>
<p>组件无论是首次挂载，还是更新，做的事情核心是一样的，先调用renderComponentRoot方法生成组件模板的虚拟DOM，然后调用patch方法打补丁。</p>
<h6 id="renderComponentRoot"><a href="#renderComponentRoot" class="headerlink" title="renderComponentRoot"></a>renderComponentRoot</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponentRoot</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component, vnode, proxy, withProxy, props, <span class="attr">propsOptions</span>: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs &#125; = instance;</span><br><span class="line">	  <span class="comment">// 执行render函数</span></span><br><span class="line">  	<span class="comment">// render函数内部会通过_createVNode或者_createElementVNode等函数进一步生成子vnode</span></span><br><span class="line">    <span class="keyword">let</span> result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderComponentRoot核心就是调用组件的渲染函数render方法生成组件模板的虚拟DOM，然后扔给patch方法更新就好了。</p>
<h5 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h5><p>看完了mountComponent方法，再来看看updateComponent方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponent = <span class="function">(<span class="params">n1, n2, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = (n2.component = n1.component);</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdateComponent(n1, n2, optimized)) &#123;</span><br><span class="line">        <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">        instance.next = n2;</span><br><span class="line">        <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    	  invalidateJob(instance.update)</span><br><span class="line">        <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">        instance.update();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要更新</span></span><br><span class="line">        n2.el = n1.el;</span><br><span class="line">        instance.vnode = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用shouldUpdateComponent方法判断组件是否需要更新，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。</p>
<p>如果需要更新，那么会执行instance.update方法，这个方法就是前面setupRenderEffect方法里保存的effect.run方法，所以最终执行的也是componentUpdateFn方法。</p>
<h6 id="updateComponentPreRender"><a href="#updateComponentPreRender" class="headerlink" title="updateComponentPreRender"></a>updateComponentPreRender</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponentPreRender = (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    nextVNode: VNode,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.component = instance</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.vnode.props</span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.vnode = nextVNode</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.next = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  updateProps(instance, nextVNode.props, prevProps, optimized)</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  updateSlots(instance, nextVNode.children, optimized)</span><br><span class="line"></span><br><span class="line">  pauseTracking()</span><br><span class="line">  <span class="comment">// props update may have triggered pre-flush watchers.</span></span><br><span class="line">  <span class="comment">// flush them before the render update.</span></span><br><span class="line">  flushPreFlushCbs(instance)</span><br><span class="line">  resetTracking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">'svg'</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p>
<p>我们接着来看挂载元素的 mountElement 函数的实现：</p>
<h6 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is)</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况</span></span><br><span class="line">    mountChildren(vnode.children, el, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG &amp;&amp; type !== <span class="string">'foreignObject'</span>, optimized || !!vnode.dynamicChildren)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。</p>
<p>首先是创建 DOM 元素节点，通过 hostCreateElement 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag, isSVG, is</span>) </span>&#123;</span><br><span class="line">  isSVG ? <span class="built_in">document</span>.createElementNS(svgNS, tag)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(tag, is ? &#123; is &#125; : <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了底层的 DOM API document.createElement 创建元素，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。</p>
<p>创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。</p>
<p>接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p>
<p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElementText</span>(<span class="params">el, text</span>) </span>&#123;</span><br><span class="line">  el.textContent = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子节点是数组，则执行 mountChildren 方法：</p>
<h6 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountChildren = <span class="function">(<span class="params">children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 预处理 child</span></span><br><span class="line">    <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">      ? cloneIfMounted(children[i])</span><br><span class="line">      : normalizeVNode(children[i]))</span><br><span class="line">    <span class="comment">// 递归 patch 挂载 child</span></span><br><span class="line">    patch(<span class="literal">null</span>, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。</p>
<p>可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。</p>
<p>另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。</p>
<p>处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">child, parent, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (anchor) &#123;</span><br><span class="line">    parent.insertBefore(child, anchor)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。</p>
<p>因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-1.png" alt="image-1"></p>
<p>到这里，从我们创建实例到页面渲染，再到更新的全流程就讲完了，总结一下，大致就是:</p>
<ol>
<li><p>每个Vue组件都需要产出一份虚拟DOM，也就是组件的render函数的返回值，render函数你可以直接手写，也可以通过template传递模板字符串，由Vue内部来编译成渲染函数，平常我们开发时写的Vue单文件，最终也会编译成普通的Vue组件选项对象；</p>
</li>
<li><p>render函数会作为副作用函数执行，也就是如果在模板中使用到了响应式数据（所谓响应式数据就是能拦截到它的各种读取、修改操作），那么响应式数据和属性会与render函数关联起来，那么当响应式数据被修改以后，就能找到依赖它的render函数，那么就可以通知依赖的组件进行更新；</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/vue/" rel="tag"># vue</a>
              <a href="/tags/vue3/" rel="tag"># vue3</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zh-CN/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%88Update%20the%20rendering%EF%BC%89%E7%9A%84%E6%97%B6%E6%9C%BA.html" rel="prev" title="EventLoop规范 - 更新渲染（Update the rendering）的时机验证">
      <i class="fa fa-chevron-left"></i> EventLoop规范 - 更新渲染（Update the rendering）的时机验证
    </a></div>
      <div class="post-nav-item">
    <a href="/zh-CN/vue3%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%89%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%A6%E8%A7%A3.html" rel="next" title="vue3组件渲染前初始化详解">
      vue3组件渲染前初始化详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化渲染"><span class="nav-number">2.</span> <span class="nav-text">初始化渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#createAppAPI"><span class="nav-number">2.1.</span> <span class="nav-text">createAppAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#createAppContext-实现"><span class="nav-number">2.1.1.</span> <span class="nav-text">createAppContext 实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mounted挂载"><span class="nav-number">2.2.</span> <span class="nav-text">mounted挂载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重写app-mount方法"><span class="nav-number">2.2.1.</span> <span class="nav-text">重写app.mount方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#真正的挂载mounted"><span class="nav-number">2.3.</span> <span class="nav-text">真正的挂载mounted</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mount方法"><span class="nav-number">2.3.1.</span> <span class="nav-text">mount方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createVNode"><span class="nav-number">2.3.2.</span> <span class="nav-text">createVNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#render"><span class="nav-number">2.3.3.</span> <span class="nav-text">render</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#patch"><span class="nav-number">2.3.4.</span> <span class="nav-text">patch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processComponent"><span class="nav-number">2.3.5.</span> <span class="nav-text">processComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mountComponent"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">mountComponent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-createComponentInstance"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">1. createComponentInstance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-setupComponent"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">2. setupComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#setupStatefulComponent"><span class="nav-number">2.3.5.3.1.</span> <span class="nav-text">setupStatefulComponent</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#handleSetupResult"><span class="nav-number">2.3.5.3.2.</span> <span class="nav-text">handleSetupResult</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#finishComponentSetup"><span class="nav-number">2.3.5.3.3.</span> <span class="nav-text">finishComponentSetup</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-setupRenderEffect"><span class="nav-number">2.3.5.4.</span> <span class="nav-text">3. setupRenderEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#componentUpdateFn"><span class="nav-number">2.3.5.4.1.</span> <span class="nav-text">componentUpdateFn</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#renderComponentRoot"><span class="nav-number">2.3.5.4.2.</span> <span class="nav-text">renderComponentRoot</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#updateComponent"><span class="nav-number">2.3.5.5.</span> <span class="nav-text">updateComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#updateComponentPreRender"><span class="nav-number">2.3.5.5.1.</span> <span class="nav-text">updateComponentPreRender</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processElement"><span class="nav-number">2.3.6.</span> <span class="nav-text">processElement</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#mountElement"><span class="nav-number">2.3.6.0.1.</span> <span class="nav-text">mountElement</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mountChildren"><span class="nav-number">2.3.6.0.2.</span> <span class="nav-text">mountChildren</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
