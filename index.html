<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2高优先级任务插队和饥饿任务问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-28T00:00:00+08:00">2024-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>时间切片是 <code>Concurrent Mode</code> 的核心机制之一。它的主要目的是将长任务分解为小的任务单元,每个单元只执行一小段时间,然后让出控制权,避免长时间阻塞主线程。</p>
<p>react 的并发模式在 render 阶段 <strong>每处理一个 fiber 就会根据以下两点判断一次是否应该打断并把控制权交换给主线程：</strong></p>
<ol>
<li>是否超过分片时间（5ms）</li>
<li>根据 <code>isInputPending</code> 判断是否有用户输入</li>
</ol>
<p>但是并不会根据优先级来打断，优先级只会影响任务队列的任务排序，所以按照按优先级排序好的任务顺序来执行，也就能让高优先级任务得到及时处理。</p>
<p>当一个任务开始执行时, <code>Scheduler</code> 会为其分配一个时间片 (通常为 5ms)。在这个时间片内,任务可以连续执行。</p>
<ul>
<li>如果任务在时间片内完成，则直接结束</li>
<li>如果任务执行时间超过了时间片，则 <code>Scheduler</code> 会中断任务的执行，保存当前的进度，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
<li>如果任务执行中，遇到用户输入等需要浏览器及时反馈的操作，会通过判断 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduling/isInputPending" target="_blank" rel="noopener"><code>isInputPending</code></a>，会中断当前任务，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>shouldYield</code> 判断，具体方法就详细说明了，可以去看<a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react调度器scheduler源码分析》</a></p>
<h2 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h2><p><code>scheduleTaskForRootDuringMicrotask</code> 每次执行都会判断上一次中断任务优先级和root下的最高优先级是否一样。</p>
<ul>
<li>如果一样，说明没有更高优先级的更新产生，可以继续上次未完成的协调；</li>
<li>如果不一样，说明有更高优先级的更新进来，要清空之前已开始的协调过程，从根节点开始重新协调。等高优先级更新处理完成以后，再次从根节点开始处理低优先级更新。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberRootScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，或者在渲染任务的最后，在我们将控制权交还给主线程之前被调用。它绝对不应该被同步调用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有任何lanes被其他work饿死。如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们。</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">  <span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line">  <span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line">  <span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Check if there's nothing to work on</span></span><br><span class="line">    nextLanes === NoLanes ||</span><br><span class="line">    <span class="comment">// If this root is currently suspended and waiting for data to resolve, don't</span></span><br><span class="line">    <span class="comment">// schedule a task to render it. We'll either wait for a ping, or wait to</span></span><br><span class="line">    <span class="comment">// receive an update.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Suspended render phase</span></span><br><span class="line">    (root === workInProgressRoot &amp;&amp; isWorkLoopSuspendedOnData()) ||</span><br><span class="line">    <span class="comment">// Suspended commit phase</span></span><br><span class="line">    root.cancelPendingCommit !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There's nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="keyword">return</span> NoLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a new callback in the host environment.</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// sy- setState</span></span><br><span class="line">    <span class="comment">// sy-no 初次渲染</span></span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        ReactCurrentActQueue.current !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn't changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We'll schedule a new one below.</span></span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="keyword">switch</span> (lanesToEventPriority(nextLanes)) &#123;</span><br><span class="line">      <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">        schedulerPriorityLevel = ImmediateSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">        schedulerPriorityLevel = UserBlockingSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DefaultEventPriority: <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// ? sy 页面初次渲染、transition(128)</span></span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdleEventPriority:</span><br><span class="line">        schedulerPriorityLevel = IdleSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-高优先级打断低优先级"><a href="#1-高优先级打断低优先级" class="headerlink" title="1. 高优先级打断低优先级"></a>1. 高优先级打断低优先级</h2><h3 id="cancelCallback"><a href="#cancelCallback" class="headerlink" title="cancelCallback"></a>cancelCallback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cancelCallback(existingCallbackNode)</code>，<code>cancelCallback</code> 函数就是将 <code>root.callbackNode</code> 赋值为 <code>null</code></p>
<h3 id="performConcurrentWorkOnRoot"><a href="#performConcurrentWorkOnRoot" class="headerlink" title="performConcurrentWorkOnRoot"></a>performConcurrentWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是commit，要么是，如果有什么被暂停了，就等待一段时间后再commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getContinuationForRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  originalCallbackNode: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is called at the end of `performConcurrentWorkOnRoot` to determine</span></span><br><span class="line">  <span class="comment">// if we need to schedule a continuation task.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;</span></span><br><span class="line">  <span class="comment">// however, since most of the logic for determining if we need a continuation</span></span><br><span class="line">  <span class="comment">// versus a new task is the same, we cheat a bit and call it here. This is</span></span><br><span class="line">  <span class="comment">// only safe to do because we know we're at the end of the browser task.</span></span><br><span class="line">  <span class="comment">// So although it's not an actual microtask, it might as well be.</span></span><br><span class="line">  scheduleTaskForRootDuringMicrotask(root, now());</span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// The task node scheduled for this root is the same one that's</span></span><br><span class="line">    <span class="comment">// currently executed. Need to return a continuation.</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performConcurrentWorkOnRoot</code> 函数是每个并发任务的入口，下面简要分析以下它的运行流程：</p>
<ol>
<li>会先把 <code>root.callbackNode</code> 缓存起来，存在 <code>originalCallbackNode</code> 变量中</li>
<li>并发模式下会使用 <code>renderRootConcurrent</code> 执行<ol>
<li>在 <code>render</code> 阶段中也有可能在代码执行中，触发更高优先级事件，例如点击事件，高优先级事件又触发了 <code>setState</code> 就是相对高优先级的</li>
<li><code>setState</code> 执行 <code>scheduleUpdateOnFiber</code> 的 <code>prepareFreshStack</code>和 <code>markRootUpdated</code> 函数，就已经把 <code>update</code> 添加到 <code>fiber</code> 上并且将更新优先级标记到 <code>root</code> 的 <code>pendingLanes</code> 上了</li>
</ol>
</li>
<li>如果render阶段结束，做一些检查，commit阶段，如果render阶段中断，会直接跳过上述操作，走到函数的末尾</li>
<li>在函数末尾会调用 <code>getContinuationForRoot</code> 函数，先执行 <code>scheduleTaskForRootDuringMicrotask</code> 就是把 <code>render</code> 中目前最高优先级事件和当前任务优先级作对比，进行 <code>cancelCallback</code> 或者 <code>scheduleCallback</code>，同时 <code>root.callbackNode</code> 也可能被改掉了</li>
<li>再判断 <code>root.callbackNode</code> 和开始缓存起来的值  <code>originalCallbackNode</code>  是否一样，如果不一样，就代表 <code>root.callbackNode</code> 被赋值为 <code>null</code> 或者其他的<code>task</code> 值，代表有更高优先级任务进来。</li>
<li>此时 <code>performConcurrentWorkOnRoot</code> 返回值为 <code>null</code></li>
</ol>
<h3 id="pop-taskQueue"><a href="#pop-taskQueue" class="headerlink" title="pop(taskQueue)"></a>pop(taskQueue)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">    <span class="comment">// 返回值continuationCallback是函数，也就是performConcurrentWorkOnRoot执行后的返回值performConcurrentWorkOnRoot.bind(null, root)或null，如果是函数就继续，不是的话，如果判断如果currentTask === peek(taskQueue)，currentTask 出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// If a continuation is returned, immediately yield to the main thread</span></span><br><span class="line">        <span class="comment">// regardless of how much time is left in the current time slice.</span></span><br><span class="line">        <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskYield(currentTask, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskCompleted(currentTask, currentTime);</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">          currentTask.isQueued = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pop(taskQueue);</span><br><span class="line">&#125;</span><br><span class="line">currentTask = peek(taskQueue);</span><br></pre></td></tr></table></figure>

<p>上面是 <code>Scheduler</code> 模块里面 <code>workLoop</code> 函数的代码片段，<code>currentTask.callback</code> 就是 <code>scheduleCallback</code> 的第二个参数，也就是<code>performConcurrentWorkOnRoot</code> 函数。</p>
<p>承接上个主题，如果 <code>performConcurrentWorkOnRoot</code> 函数返回了 <code>null</code>，<code>workLoop</code> 内部就会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出。</p>
<h3 id="低优先级任务重启"><a href="#低优先级任务重启" class="headerlink" title="低优先级任务重启"></a>低优先级任务重启</h3><p>上一步中说道一个低优先级任务从 <code>taskQueue</code> 中被弹出。那高优先级任务执行完毕之后，如何重启回之前的低优先级任务呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span><br><span class="line">markRootFinished(root, remainingLanes, spawnedLane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Always call this before exiting `commitRoot`, to ensure that any</span></span><br><span class="line"><span class="comment">// additional work on this root is scheduled.</span></span><br><span class="line">ensureRootIsScheduled(root, now());</span><br></pre></td></tr></table></figure>

<p><code>markRootFinished</code> 函数刚刚上面说了是释放已完成任务的 <code>Lane</code>，那也就是说未完成任务依然会存在 <code>lanes</code> 中，所以我们可以重新调用 <code>ensureRootIsScheduled</code> 发起一次新的调度，去重启低优先级任务的执行。我们可以看下重启部分的判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line"><span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 如果 nextLanes 为 NoLanes，就证明所有任务都执行完毕了</span></span><br><span class="line"><span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="comment">// 只要 nextLanes 为 NoLanes，就可以结束调度了</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 nextLanes 不为 NoLanes，就代表还有任务未执行完，也就是那些被打断的低优先级任务</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol>
<li>任务通过 <code>unstable_scheduleCallback</code> 进行调度，将任务添加到 <code>taskQueue</code> 中，如果是首次加载通过 <code>requestHostCallback</code> 调度宏任务</li>
<li><code>Scheduler</code> 里执行 <code>flush</code> 后执行 <code>workLoop</code> 方法，在 <code>workLoop</code> 方法中取出第一个任务，判断是否超出切片时间或者有更需要及时反馈的用户操作，如果没有，那当执行任务的 <code>callback</code> 时，也就是 <code>performConcurrentWorkOnRoot</code> 方法，执行流程可以看上面。所以我们知道 <code>performConcurrentWorkOnRoot</code> 方法可能会返回null，也可能会返回 <code>performConcurrentWorkOnRoot</code></li>
<li>当返回 <code>null</code> 时候，<code>Scheduler</code> 会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出</li>
<li>低优先级任务重启，<code>commitRootImpl</code> 最后会再次调用 <code>ensureRootIsScheduled(root, now())</code>，判断如果 <code>nextLanes</code> 为 <code>NoLanes</code>，就证明所有任务都执行完毕了，如果 <code>nextLanes</code> 不为 <code>NoLanes</code>，就代表还有任务未执行完，也就是那些被打断的低优先级任务，会重新进行调度</li>
</ol>
<h2 id="2-饥饿任务问题"><a href="#2-饥饿任务问题" class="headerlink" title="2. 饥饿任务问题"></a>2. 饥饿任务问题</h2><p>上面说到，在高优先级任务执行完毕之后，低优先级任务就会被重启，但假设如果持续有高优先级任务持续进来，那低优先级任务岂不是没有重启之日？</p>
<p>所以 <code>react</code> 为了处理解决饥饿任务问题，在 <code>ensureRootIsScheduled</code> 函数开始的时候做了以下处理：（参考markStarvedLanesAsExpired函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 调度更新的过程中会被调用</span></span><br><span class="line"><span class="comment">// 检查是有lanes挨饿，如果有，则标记他们过期，即提升优先级（以便下次执行）。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This gets called every time we yield. We can optimize by storing</span></span><br><span class="line">  <span class="comment">// the earliest expiration time on the root. Then use that to quickly bail out</span></span><br><span class="line">  <span class="comment">// of this function.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">const</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">const</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">const</span> expirationTimes = root.expirationTimes; <span class="comment">// 数组，初始化的时候，值都是-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate through the pending lanes and check if we've reached their</span></span><br><span class="line">  <span class="comment">// expiration time. If so, we'll assume the update is being starved and mark</span></span><br><span class="line">  <span class="comment">// it as expired to force it to finish.</span></span><br><span class="line">  <span class="comment">// 遍历pending lanes，并检查是否已经达到它们的过期时间。</span></span><br><span class="line">  <span class="comment">// 如果是，我们就认为这个update挨饿了，并将其标记为已过期，以强制其完成。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should be able to replace this with upgradePendingLanesToSync</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We exclude retry lanes because those must always be time sliced, in order</span></span><br><span class="line">  <span class="comment">// to unwrap uncached promises.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write a test for this</span></span><br><span class="line">  <span class="keyword">let</span> lanes = enableRetryLaneExpiration</span><br><span class="line">    ? pendingLanes <span class="comment">//  ? sy</span></span><br><span class="line">    : pendingLanes &amp; ~RetryLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面两行代码的作用是找到lanes中最低位的1，即优先级最</span></span><br><span class="line">    <span class="keyword">const</span> index = pickArbitraryLaneIndex(lanes);</span><br><span class="line">    <span class="comment">// 把1左移index位，即得到一个只有第index位为1的子掩码</span></span><br><span class="line">    <span class="keyword">const</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expirationTime = expirationTimes[index];</span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">      <span class="comment">// sy- console.log('%c [  ]-1469', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">      <span class="comment">// Found a pending lane with no expiration time. If it's not suspended, or</span></span><br><span class="line">      <span class="comment">// if it's pinged, assume it's CPU-bound. Compute a new expiration time</span></span><br><span class="line">      <span class="comment">// using the current time.</span></span><br><span class="line">      <span class="comment">// 如果这个 pending lane 没有过期时间</span></span><br><span class="line">      <span class="comment">// 如果它没有被挂起且需要更新，我们就认为它是CPU密集型操作。</span></span><br><span class="line">      <span class="comment">// 用当前时间计算出一个新的过期时间给它。</span></span><br><span class="line">      <span class="comment">// CPU bound  / IO Bound</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (lane &amp; suspendedLanes) === NoLanes ||</span><br><span class="line">        (lane &amp; pingedLanes) !== NoLanes</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// sy- console.log('%c [ 饿死 ]-482', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">        <span class="comment">// Assumes timestamps are monotonically increasing.</span></span><br><span class="line">        <span class="comment">// 假设timestamps(时间戳)是单调递增的</span></span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 这个 pending lane 已经过期了</span></span><br><span class="line">      <span class="comment">// This lane expired</span></span><br><span class="line">      root.expiredLanes |= lane;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把lane从lanes中移除，计算下一个lane</span></span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>render</code> 阶段执行的函数 <code>performConcurrentWorkOnRoot</code> 中的代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 1. render</span></span><br><span class="line"><span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes)</span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// 不用时间切片</span></span><br></pre></td></tr></table></figure>

<p>可以看到只要 <code>shouldTimeSlice</code> 只要返回 <code>false</code>，就会执行 <code>renderRootSync</code>，也就是以同步优先级进入 <code>render</code> 阶段。而 <code>shouldTimeSlice</code> 的逻辑也就是刚刚的 <code>expiredLanes</code> 属性相关</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp;</span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查root是否包含过期的lane</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">includesExpiredLane</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a separate check from includesBlockingLane because a lane can</span></span><br><span class="line">  <span class="comment">// expire after a render has already started.</span></span><br><span class="line">  <span class="keyword">return</span> (lanes &amp; root.expiredLanes) !== NoLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2并发模式（Concurrent Mode）分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-26T00:00:00+08:00">2024-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li>并发指的是：多个任务，在同一时间段内同时发生，多个任务会有互相抢占资源的情况。</li>
<li>并行指的是：多个任务，在同一时间点上同时发生，多个任务之间不会互相抢占资源。</li>
</ul>
<p>在这里，我们千万不要理解 <code>Concurrent Mode</code> 是在同时执行多个任务，相信很多人包括我在内都理解混淆，在看源码后，才恍然大悟。</p>
<p>它是同一段时间内，可以执行多个任务：</p>
<ul>
<li>因为高优先级任务可以插队并打断低优先级任务</li>
<li>或当时间切片的某一条任务执行超时后，将执行权交给主线程，当主线程执行完成，又继续执行之前的切片任务</li>
</ul>
<h2 id="为什么需要并发模式"><a href="#为什么需要并发模式" class="headerlink" title="为什么需要并发模式"></a>为什么需要并发模式</h2><p>我们知道在同步模式下，从 <code>setState</code> 到 <code>虚拟DOM遍历</code>，再到 <code>真实DOM</code> 更新，整个过程都是同步执行且无法被中断的，这样可能就会出现一个问题 —— 用户事件触发的更新被阻塞。</p>
<p>因为我们期望一些不重要的更新不会影响一些重要的更新，比如长列表渲染不会阻塞用户 <code>input</code> 输入，从而提升用户体验。</p>
<h2 id="并发模式特点"><a href="#并发模式特点" class="headerlink" title="并发模式特点"></a>并发模式特点</h2><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>对于 <code>React</code> 来说，任务可能很多，如果不区分优先级，那就是先来后到的顺序。如果高优先级任务来了，但是低优先级任务还没有处理完毕，就会造成高优先级任务等待的局面。</p>
<p>由此可见，对于复杂项目来说，任务可中断这件事情很重要。那么问题来了，<code>React</code> 是如何做到的呢，其实基础还是 <code>fiber</code>，<code>fiber</code> 本身链表结构，就是指针，想指向别的地方加个属性值就行了。</p>
<h3 id="可遗弃"><a href="#可遗弃" class="headerlink" title="可遗弃"></a>可遗弃</h3><p>在 <code>Concurrent 模式</code>下，有些update可能会被遗弃掉。</p>
<p>比如我想在淘宝搜索“老人与海”，那么我在输入框输入“老人与海”的过程中，“老人”会有对应的模糊查询结果，但是不一定是我想要的结果，所以这个时候的模糊查询框的update就是低优先级，“老人”对应UI的update相对input的update，优先级就会低一些。在现在React18中，这个模糊查询相关的UI可以被当做transition。</p>
<h3 id="状态复用"><a href="#状态复用" class="headerlink" title="状态复用"></a>状态复用</h3><p>在 <code>Concurrent 模式</code> 下，还支持状态的复用。某些情况下，比如用户走了，又回来，那么上一次的页面状态应当被保存下来，而不是完全从头再来。当然实际情况下不能缓存所有的页面，不然内存不得爆炸，所以还得做成可选的。</p>
<p>目前， <code>React</code> 正在用 <code>Offscreen</code> 组件来实现这个功能。</p>
<p>另外，使用 <code>OffScreen</code>，除了可以复用原先的状态，我们也可以使用它来当做新UI的缓存准备，就是虽然新UI还没登场，但是可以先在后台准备着，这样一旦轮到它，就可以立马快速地渲染出来。</p>
<h2 id="如何实现并发模式（Concurrent-Mode）"><a href="#如何实现并发模式（Concurrent-Mode）" class="headerlink" title="如何实现并发模式（Concurrent Mode）"></a>如何实现并发模式（Concurrent Mode）</h2><p><code>Concurrent Mode</code> 这种中断渲染的行为，带来了几个关键问题：</p>
<ul>
<li>怎样做到中断渲染？</li>
<li>怎样定义任务的重要程度和执行顺序？</li>
<li>何时中断任务，怎样划分时间片？</li>
</ul>
<p>个人总结主要通过三个方面完成：</p>
<ul>
<li>颗粒化更新节点来解决递归不可中断问题；</li>
<li>任务增加优先级来解决任务执行顺序；</li>
<li>创建任务调度机制来解决时间分片和任务中断，任务恢复；</li>
</ul>
<p>对应到React的实现就是：<code>Fiber架构</code>，<code>lane模型</code>，<code>scheduler任务调度</code></p>
<h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><p>在重构 <code>Fiber</code> 架构之前，<code>React</code> 是没办法解决这些问题的。因为在此之前，<code>React</code> 的渲染更新主要是通过对比更新前后的 <code>虚拟DOM</code>，找出不同进行更新，而对比的过程因为 <code>虚拟DOM</code> 树结构的限制，只能采用递归更新，我们知道递归一旦开始，中途就无法中断。</p>
<p>那 <code>Fiber</code> 架构为什么能解决这个问题呢？</p>
<ul>
<li>每个 <code>Fiber</code> 节点对应一个 <code>React Element</code>，保存有该组件的所有基本状态信息；</li>
<li>每个 <code>Fiber</code> 节点保存有该组件的更新信息；</li>
</ul>
<p>因为 <code>Fiber</code> 节点承载了基本状态和更新信息，这样 <code>React</code> 就可以将 <code>Fiber</code> 节点视为最小的工作单元，可以实现 <code>Fiber</code> 节点这种粒度的更新，因为粒度的细化也就使得异步可中断更新成为了可能。</p>
<p><code>Fiber</code> 节点的基本状态保存了它的父节点，子节点，兄弟节点信息，这样可以将之前的递归遍历改变为循环遍历，使渲染中断成为可能。</p>
<h3 id="Lane模型"><a href="#Lane模型" class="headerlink" title="Lane模型"></a>Lane模型</h3><p><code>lane模型</code> 主要解决的是任务优先级问题。</p>
<p>我们想中断渲染的本质是想让有更高优先级的任务可以中断低优先级任务来插队执行。</p>
<p>那怎么定义任务优先级呢，<code>lane模型</code> 通过31位的位运算符来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * lane 值越小，优先级越高</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TotalLanes = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有优先级</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLanes: Lanes = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步优先级，表示同步的任务一次只能执行一个，例如：用户的交互事件产生的更新任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续触发优先级，例如：滚动事件，拖动事件等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousHydrationLane: Lane = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lanes = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认优先级，例如使用setTimeout，请求数据返回等造成的更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultHydrationLane: Lane = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lanes = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡优先级，例如: Suspense、useTransition、useDeferredValue等拥有的优先级</span></span><br><span class="line"><span class="keyword">const</span> TransitionHydrationLane: Lane = <span class="comment">/*                */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLanes: Lanes = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111111111111000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane1: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000001000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane2: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000010000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane3: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane4: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000010000000000</span>; <span class="comment">// 1024</span></span><br><span class="line"><span class="keyword">const</span> TransitionLane5: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000100000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane6: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane7: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000010000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane8: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000100000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane9: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000001000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane10: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000010000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane11: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000100000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane12: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000001000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane13: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000010000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane14: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000100000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane15: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000001000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RetryLanes: Lanes = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane1: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000010000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane2: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000100000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane3: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000001000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane4: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SelectiveHydrationLane: Lane = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleHydrationLane: Lane = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> OffscreenLane: Lane = <span class="comment">/*                   */</span> <span class="number">0b0100000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DeferredLane: Lane = <span class="comment">/*                    */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>React</code> 定义的优先级：</p>
<p>同步任务 &gt; 连续触发事件任务 &gt; setTimeout，请求更新任务 &gt; 过渡任务（React18新特性）</p>
<h4 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): * </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">      <span class="comment">// 同步优先级</span></span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">      <span class="comment">// 连续触发优先级</span></span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>EventPriority</th>
<th></th>
<th>Lane</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>DiscreteEventPriority</td>
<td>离散事件。click、keydown、focusin等，事件的触发不是连续，可以做到快速响应</td>
<td>SyncLane</td>
<td>1</td>
</tr>
<tr>
<td>ContinuousEventPriority</td>
<td>连续事件。drag、scroll、mouseover等，事件的是连续触发的，快速响应可能会阻塞渲染，优先级较离散事件低</td>
<td>InputContinuousLane</td>
<td>4</td>
</tr>
<tr>
<td>DefaultEventPriority</td>
<td>默认的事件优先级</td>
<td>DefaultLane</td>
<td>16</td>
</tr>
<tr>
<td>IdleEventPriority</td>
<td>空闲的优先级</td>
<td>IdleLane</td>
<td>536870912</td>
</tr>
</tbody></table>
<h4 id="调度优先级"><a href="#调度优先级" class="headerlink" title="调度优先级"></a>调度优先级</h4><table>
<thead>
<tr>
<th>SchedulerPriority</th>
<th>EventPriority</th>
<th>大于&gt;17.0.2</th>
<th>小于&gt;17.0.2</th>
</tr>
</thead>
<tbody><tr>
<td>ImmediatePriority</td>
<td>DiscreteEventPriority</td>
<td>1</td>
<td>99</td>
</tr>
<tr>
<td>UserblockingPriority</td>
<td>Userblocking</td>
<td>2</td>
<td>98</td>
</tr>
<tr>
<td>NormalPriority</td>
<td>DefaultEventPriority</td>
<td>3</td>
<td>97</td>
</tr>
<tr>
<td>LowPriority</td>
<td>DefaultEventPriority</td>
<td>4</td>
<td>96</td>
</tr>
<tr>
<td>IdlePriority</td>
<td>IdleEventPriority</td>
<td>5</td>
<td>95</td>
</tr>
<tr>
<td>NoPriority</td>
<td></td>
<td>0</td>
<td>90</td>
</tr>
</tbody></table>
<h4 id="优先级间的转换"><a href="#优先级间的转换" class="headerlink" title="优先级间的转换"></a>优先级间的转换</h4><ul>
<li><p>lane优先级 转 event优先级（参考 lanesToEventPriority 函数）</p>
<ul>
<li>转换规则：以区间的形式根据传入的lane返回对应的 event 优先级。比如传入的优先级不大于 Discrete 优先级，就返回 Discrete 优先级，以此类推</li>
</ul>
</li>
<li><p>event优先级 转 scheduler优先级（参考 ensureRootIsScheduled 函数下的 lanesToEventPriority）</p>
<ul>
<li>转换规则：可以参考上面调度优先级表</li>
</ul>
</li>
<li><p>event优先级 转 lane优先级（参考 getEventPriority 函数）</p>
<ul>
<li>转换规则：对于非离散、连续的事件，会根据一定规则作转换，具体课参考上面 event 优先级表</li>
</ul>
</li>
</ul>
<h4 id="任务饥饿"><a href="#任务饥饿" class="headerlink" title="任务饥饿"></a>任务饥饿</h4><p>任务饥饿是讲一个低优先级的任务一直被高优先级的任务插队，导致这个任务已经过了执行期限依然没有得到执行，在这种情况下，<code>React</code> 会将该任务置为同步渲染任务，在下次更新时立即执行。</p>
<h4 id="任务插队"><a href="#任务插队" class="headerlink" title="任务插队"></a>任务插队</h4><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">《react18.2批处理场景原理并结合优先级进行的分析》</a></p>
<h3 id="scheduler任务调度"><a href="#scheduler任务调度" class="headerlink" title="scheduler任务调度"></a>scheduler任务调度</h3><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react18.2调度器scheduler源码分析》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2批处理场景原理并结合优先级进行的分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-23 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-23T00:00:00+08:00">2024-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactEventPriorities.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级从上往下，越来越小</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DiscreteEventPriority: EventPriority = SyncLane; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContinuousEventPriority: EventPriority = InputContinuousLane; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultEventPriority: EventPriority = DefaultLane; <span class="comment">// 页面初次渲染的lane 32, transition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleEventPriority: EventPriority = IdleLane;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberLane.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000010</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lane = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000001000</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lane = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000100000</span>; <span class="comment">// 32</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="各种批处理操作场景和结果"><a href="#各种批处理操作场景和结果" class="headerlink" title="各种批处理操作场景和结果"></a>各种批处理操作场景和结果</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onPerform = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !情况1 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 点击：页面变成3 + render 1次，划入：页面变成3 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况4 点击：页面变成1 + render 2次，划入：页面变成1 + render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 点击：页面变成2 + render 1次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况6 点击：页面变成1 + render 2次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况7 点击：页面变成4 + render 2次，划入：页面变成4 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 3') // hook update 3</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 4') // hook update 4</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况8 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况9 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况10 点击：页面变成2 + render 2次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// !情况11 页面变成1 + render 1次</span></span><br><span class="line">  <span class="comment">//   const changeValue = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     console.log(count) // react18 输出的是更新前的值 --&gt; 0</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   document.body.addEventListener('click', changeValue, false)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; milliseconds) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onPerform&#125; onMouseEnter=&#123;onPerform&#125;&gt;</span><br><span class="line">        Hello CodeSandbox &#123;count&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程和原理"><a href="#执行流程和原理" class="headerlink" title="执行流程和原理"></a>执行流程和原理</h2><p><code>dispatchSetState</code> 的源码在 setState文章中 展示过一次。这里只是重复什么是批-更新的说法，通过点击事件或者鼠标划入事件触发setState，其实就是调用 <code>dispatchSetState</code> 方法。<code>dispatchSetState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react更新</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// ! 1. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 把update暂存到concurrentQueues数组中</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 3. 调度更新</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不纠结 <code>fiber</code> 和 <code>queue</code> 的细节的话，就批处理而言，这就是 <code>setState</code>的全部了。</p>
<h3 id="步骤1：获取本次更新的优先级-requestUpdateLane"><a href="#步骤1：获取本次更新的优先级-requestUpdateLane" class="headerlink" title="步骤1：获取本次更新的优先级 - requestUpdateLane"></a>步骤1：获取本次更新的优先级 - requestUpdateLane</h3><p><code>dispatchSetState</code> 方法在 <code>创建update</code> 前，会通过 <code>requestUpdateLane</code> 方法取到 <code>update</code> 的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber: Fiber</span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special cases</span></span><br><span class="line">  <span class="keyword">const</span> mode = fiber.mode;</span><br><span class="line">  <span class="comment">// 1. 非ConcurrentMode模式 2. 目前不支持</span></span><br><span class="line">  <span class="keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">    <span class="keyword">return</span> (SyncLane: Lane);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoContext &amp;&amp;</span><br><span class="line">    workInProgressRootRenderLanes !== NoLanes</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. These are not officially supported. The</span></span><br><span class="line">    <span class="comment">// old behavior is to give this the same "thread" (lanes) as</span></span><br><span class="line">    <span class="comment">// whatever is currently rendering. So if you call `setState` on a component</span></span><br><span class="line">    <span class="comment">// that happens later in the same render, it will flush. Ideally, we want to</span></span><br><span class="line">    <span class="comment">// remove the special case and treat them as if they came from an</span></span><br><span class="line">    <span class="comment">// interleaved event. Regardless, this pattern is not officially supported.</span></span><br><span class="line">    <span class="comment">// This behavior is only a fallback. The flag only exists until we can roll</span></span><br><span class="line">    <span class="comment">// out the setState warning, since existing code might accidentally rely on</span></span><br><span class="line">    <span class="comment">// the current behavior.</span></span><br><span class="line">    <span class="keyword">return</span> pickArbitraryLane(workInProgressRootRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通更新与非紧急更新(18)</span></span><br><span class="line">  <span class="keyword">const</span> transition = requestCurrentTransition();</span><br><span class="line">  <span class="comment">// 如果有transition</span></span><br><span class="line">  <span class="keyword">if</span> (transition !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionScopeLane = peekEntangledActionLane();</span><br><span class="line">    <span class="keyword">return</span> actionScopeLane !== NoLane</span><br><span class="line">      ? <span class="comment">// We're inside an async action scope. Reuse the same lane.</span></span><br><span class="line">        actionScopeLane</span><br><span class="line">      : <span class="comment">// We may or may not be inside an async action scope. If we are, this</span></span><br><span class="line">        <span class="comment">// is the first update in that scope. Either way, we need to get a</span></span><br><span class="line">        <span class="comment">// fresh transition lane.</span></span><br><span class="line">        requestTransitionLane(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React内部的一些update，比如flushSync，会通过上下文变量来跟踪其优先级</span></span><br><span class="line">  <span class="keyword">const</span> updateLane: Lane = (getCurrentUpdatePriority(): any);</span><br><span class="line">  <span class="keyword">if</span> (updateLane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// ? sy setState click 2</span></span><br><span class="line">    <span class="keyword">return</span> updateLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React外部的update，根据事件类型，向当前环境获取对应的优先级。</span></span><br><span class="line">  <span class="keyword">const</span> eventLane: Lane = (getCurrentEventPriority(): any);</span><br><span class="line">  <span class="keyword">return</span> eventLane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getCurrentEventPriority"><a href="#getCurrentEventPriority" class="headerlink" title="getCurrentEventPriority"></a>getCurrentEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentEventPriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentEvent = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (currentEvent === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getEventPriority(currentEvent.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getEventPriority"><a href="#getEventPriority" class="headerlink" title="getEventPriority"></a>getEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="comment">// Used by SimpleEventPlugin:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'contextmenu'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cut'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'auxclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dblclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'invalid'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keypress'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousedown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'paste'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'play'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointercancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerdown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ratechange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'resize'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'seeked'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'volumechange'</span>:</span><br><span class="line">    <span class="comment">// Used by polyfills: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectionchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionupdate'</span>:</span><br><span class="line">    <span class="comment">// Only enableCreateEventHandleAPI: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeblur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'afterblur'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeinput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'fullscreenchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'hashchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'popstate'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectstart'</span>:</span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragexit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointermove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'toggle'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerleave'</span>:</span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'message'</span>: &#123;</span><br><span class="line">      <span class="comment">// We might be in the Scheduler callback.</span></span><br><span class="line">      <span class="comment">// Eventually this mechanism will be replaced by a check</span></span><br><span class="line">      <span class="comment">// of the current priority on the native scheduler.</span></span><br><span class="line">      <span class="keyword">const</span> schedulerPriority = getCurrentSchedulerPriorityLevel();</span><br><span class="line">      <span class="keyword">switch</span> (schedulerPriority) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediateSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">        <span class="keyword">case</span> UserBlockingSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">        <span class="keyword">case</span> NormalSchedulerPriority:</span><br><span class="line">        <span class="keyword">case</span> LowSchedulerPriority:</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</span></span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">        <span class="keyword">case</span> IdleSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过一系列操作：</p>
<ul>
<li><code>click</code> 事件对应的优先级是 <code>DiscreteEventPriority</code>，优先级值也就是 <code>2</code></li>
<li><code>mouseenter</code> 对应的优先级是 <code>ContinuousEventPriority</code>，优先级值也就是 <code>8</code></li>
<li><code>setTimeout</code> 对应的优先级的值是默认优先级 <code>32</code></li>
</ul>
<blockquote>
<p>一般在合成事件创建之初，就会通过 <code>createEventListenerWrapperWithPriority</code> 各个事件的设置优先级，所以一般 <code>click</code>、<code>mouseenter</code> 等react内部的事件，都会通过 <code>getCurrentUpdatePriority</code> 拿到 <code>updateLane</code>。<br>类似 <code>setTimeout</code>，会走到 <code>getCurrentEventPriority</code> 返回 <code>DefaultEventPriority</code><br>如果是通过 <code>document.body.addEventListener(&#39;click&#39;, changeValue, false)</code> 触发的事件，也会走到 <code>getCurrentEventPriority</code>，通过<code>getEventPriority</code> 拿到 <code>window.event</code> 所对应的优先级</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>requestUpdateLane</code> 中获取优先级：</p>
<ol>
<li>先通过requestCurrentTransition请求并判断是否有非紧急更新</li>
<li>再通过getCurrentUpdatePriority</li>
<li>最后通过getCurrentEventPriority根据事件类型，项当前环境获取对应的优先级。</li>
</ol>
<h3 id="步骤2：创建-update-对象"><a href="#步骤2：创建-update-对象" class="headerlink" title="步骤2：创建 update 对象"></a>步骤2：创建 update 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ! 1. 创建update</span></span><br><span class="line"><span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤3：scheduleUpdateOnFiber"><a href="#步骤3：scheduleUpdateOnFiber" class="headerlink" title="步骤3：scheduleUpdateOnFiber"></a>步骤3：scheduleUpdateOnFiber</h3><p>忽略一些琐碎的细节后，你可以发现这个函数的核心逻辑甚至更简单：</p>
<ul>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ensureRootIsScheduled"><a href="#ensureRootIsScheduled" class="headerlink" title="ensureRootIsScheduled"></a>ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processRootScheduleInMicrotask"><a href="#processRootScheduleInMicrotask" class="headerlink" title="processRootScheduleInMicrotask"></a>processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行流程小结"><a href="#执行流程小结" class="headerlink" title="执行流程小结"></a>执行流程小结</h4><p>通过微任务调度 <code>processRootScheduleInMicrotask</code> 方法，此方法核心就是调用 <code>scheduleTaskForRootDuringMicrotask</code>，而在 <code>microtask</code> 结束时，调用 <code>flushSyncWorkOnAllRoots</code> 方法 <code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>在 <code>scheduleTaskForRootDuringMicrotask</code> 中：</p>
<ol>
<li>先是检查是否有饿死的任务，如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们</li>
<li>获取当前所有优先级中最高的优先级 <code>nextLanes</code></li>
<li>先判断是否包含同步优先级，如果包含，取消其它任务并返回，不包含就继续执行</li>
<li>再判断现存的任务优先级和新任务的优先级，如果相等，就合并执行且 <code>return</code></li>
<li>如果不相等，就取消现存任务</li>
<li>继续根据 <code>nextLanes</code>，通过 <code>lanesToEventPriority</code> 方法，获取 <code>schedulerPriorityLevel</code> 调度的优先级，最后通过 <code>scheduleCallback</code> 进行调度</li>
</ol>
<h2 id="调用-scheduleTaskForRootDuringMicrotask-中的两大问题"><a href="#调用-scheduleTaskForRootDuringMicrotask-中的两大问题" class="headerlink" title="调用 scheduleTaskForRootDuringMicrotask 中的两大问题"></a>调用 scheduleTaskForRootDuringMicrotask 中的两大问题</h2><p>请看《react18.2高优先级任务插队和饥饿任务问题分析》</p>
<h2 id="updateReducerImpl"><a href="#updateReducerImpl" class="headerlink" title="updateReducerImpl"></a>updateReducerImpl</h2><p>我们以函数式组件的处理 <code>setState</code> 时的实际执行函数 <code>updateReducerImpl</code> 为例，来看一下相关处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducerImpl</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  hook: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录reducer</span></span><br><span class="line">  queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = hook.baseQueue; <span class="comment">// ! 单向循环链表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有 pendingQueue，说明有未处理的更新</span></span><br><span class="line">    <span class="comment">// 把pendingQueue添加到baseQueue中</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// pending queue合并到base queue中。</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseQueue 被设置为 pendingQueue，也就是待更新的 update 对象队列</span></span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    <span class="comment">// 需要清空 pending 队列，这样本次执行 hook 的 pending 队列不会影响到下一次</span></span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseState = hook.baseState;</span><br><span class="line">  <span class="comment">// 如果基础更新队列中有 update 对象，说明需要执行更新，就按照优先级依次处理每一个 update 对象（下面会进行批量更新）</span></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有pendingQueue，那么memoizedState应该等于baseState</span></span><br><span class="line">    hook.memoizedState = baseState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有待处理的queue，接下来遍历即可</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast: Update&lt;S, A&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="keyword">let</span> didReadFromEntangledAsyncAction = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前任务的优先级不够，也就是说当前的 renderLanes 比该 update 对象的优先级高。需要先跳过，之后再处理。</span></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          revertLane: update.revertLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果在当前被跳过的 update 对象之前没有其他的 update 被跳过，该对象就是作为新的基础更新对象。</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果之前有更新被跳过，那么将这个更新对象添加到队列最后</span></span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前正在工作的 Fiber 节点（workInProgress）的优先级，标记这个更新对象的优先级由于不匹配当前的 renderLane，因此已经被跳过。</span></span><br><span class="line">        <span class="comment">// 在同文件的 renderWithHook() 方法中可以知道 currentlyRenderingFiber 对应了 workInProgress，表示当前正在工作的 fiber 树</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 优先级足够</span></span><br><span class="line">        <span class="comment">// 优先级足够的时候理论上可以考虑对哪些 update 对象进行收集更新，但是此时还需要考虑一个 revertLane（还原的优先级），以保证组件状态的正确。</span></span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this is an optimistic update.</span></span><br><span class="line">        <span class="keyword">const</span> revertLane = update.revertLane;</span><br><span class="line">        <span class="keyword">if</span> (!enableAsyncActions || revertLane === NoLane) &#123;</span><br><span class="line">          <span class="comment">// ? sy</span></span><br><span class="line">          <span class="comment">// This is not an optimistic update, and we're going to apply it now.</span></span><br><span class="line">          <span class="comment">// But, if there were earlier updates that were skipped, we need to</span></span><br><span class="line">          <span class="comment">// leave this update in the queue so it can be rebased later.</span></span><br><span class="line">          <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">              <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">              <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              revertLane: NoLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">          <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">          <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">          <span class="keyword">if</span> (updateLane === peekEntangledActionLane()) &#123;</span><br><span class="line">            <span class="comment">// ? sy-no</span></span><br><span class="line">            didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// This is an optimistic update. If the "revert" priority is</span></span><br><span class="line">          <span class="comment">// sufficient, don't apply the update. Otherwise, apply the update,</span></span><br><span class="line">          <span class="comment">// but leave it in the queue so it can be either reverted or</span></span><br><span class="line">          <span class="comment">// rebased in a subsequent render.</span></span><br><span class="line">          <span class="keyword">if</span> (isSubsetOfLanes(renderLanes, revertLane)) &#123;</span><br><span class="line">            <span class="comment">// The transition that this optimistic update is associated with</span></span><br><span class="line">            <span class="comment">// has finished. Pretend the update doesn't exist by skipping</span></span><br><span class="line">            <span class="comment">// over it.</span></span><br><span class="line">            update = update.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">            <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">            <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">            <span class="keyword">if</span> (revertLane === peekEntangledActionLane()) &#123;</span><br><span class="line">              didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// Once we commit an optimistic update, we shouldn't uncommit it</span></span><br><span class="line">              <span class="comment">// until the transition it is associated with has finished</span></span><br><span class="line">              <span class="comment">// (represented by revertLane). Using NoLane here works because 0</span></span><br><span class="line">              <span class="comment">// is a subset of all bitmasks, so this will never be skipped by</span></span><br><span class="line">              <span class="comment">// the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              <span class="comment">// Reuse the same revertLane so we know when the transition</span></span><br><span class="line">              <span class="comment">// has finished.</span></span><br><span class="line">              revertLane: update.revertLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">              newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">              newBaseState = newState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">            <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">            currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">              currentlyRenderingFiber.lanes,</span><br><span class="line">              revertLane,</span><br><span class="line">            );</span><br><span class="line">            markSkippedUpdateLanes(revertLane);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 update 对象的优先级足够，因此开始处理它的 action，收集新的 state 状态</span></span><br><span class="line">        <span class="keyword">const</span> action = update.action;</span><br><span class="line">        <span class="keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;</span><br><span class="line">          reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ! 计算useReducer的新的state</span></span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 循环 baseQueue（实际上就是 pendingQueue），处理该队列中的每个 update 对象，</span></span><br><span class="line">      <span class="comment">// 并把对应的 action 操作得到的结果更新到 newState 中（即收集新状态）</span></span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark that the fiber performed work, but only if the new state is</span></span><br><span class="line">    <span class="comment">// different from the current state.</span></span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (didReadFromEntangledAsyncAction) &#123;</span><br><span class="line">        <span class="keyword">const</span> entangledActionThenable = peekEntangledActionThenable();</span><br><span class="line">        <span class="keyword">if</span> (entangledActionThenable !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> entangledActionThenable;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新到hook上</span></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line"></span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// `queue.lanes` is used for entangling transitions. We can set it back to</span></span><br><span class="line">    <span class="comment">// zero once the queue is empty.</span></span><br><span class="line">    queue.lanes = NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看到，<code>updateReducerImpl</code> 方法核心内容分为四个部分：</p>
<ul>
<li>获取 <code>Hook</code> 对象中的更新队列、基础更新队列、基础状态、<code>reduce</code> 函数等信息。</li>
<li>如果更新队列中有待处理的更新对象，就将其加入到基础更新队列中。</li>
<li>按照优先级高低区分是否跳过该更新或者依次处理基础更新队列中的更新对象，计算新的状态。</li>
<li>判断新的状态和旧的状态是否相同，如果相同就不做重新渲染，反之需要重新渲染。</li>
<li>返回更新后的状态和 <code>dispatch</code> 方法。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>所以通过对执行流程和原理的分析，对于以上提到的这么多批处理的场景，也就能通过源码并结合eventLoop的知识解释的通了。</p>
<p>关于批处理的逻辑，主要有三点：</p>
<ul>
<li>通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>对比上次等待的更新和本次更新的优先级，即 <code>newCallbackPriority === existingCallbackPriority</code>，如果相等，则提前 <code>return</code></li>
<li>在更新阶段，以 <code>setState</code> 为例，会根据优先级来判断是否要同一批次执行</li>
</ul>
<p>在 <code>scheduleUpdateOnFiber</code> 中已经对 <code>setState</code> 对应的优先级做了标记，所以那个优先级在这里是可以被读取到的。如果两次更新的优先级相同，批处理就会起作用。</p>
<blockquote>
<p>批处理的发生当然意味着代码进入上述的 <code>newCallbackPriority === existingCallbackPriority</code> 分支内。但是即使是其他情形也有可能进入这个分支。<br>例如，当连续的两次 <code>setState</code> 被调用，前者优先级高于后者，那么当第二次 <code>setState</code> 被调用，从而进入 <code>ensureRootIsScheduled</code> 时，<code>existingCallbackPriority与newCallbackPriority</code> 都是第一次调用时的优先级（每次所取的都是最高优先级），导致函数提前返回。这并不意味着低优先级的更新被忽略，在高优先级的更新即将完成时，<code>ensureRootIsScheduled</code> 会被再次调用，确保所有更新会被执行。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html" class="post-title-link" itemprop="url">react18.2和react16批处理实现和对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-18T00:00:00+08:00">2024-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="react16-半自动批处理"><a href="#react16-半自动批处理" class="headerlink" title="react16 - 半自动批处理"></a>react16 - 半自动批处理</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：同步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中的this.setState或者setState：会批量处理</li>
<li>合成事件和钩子函数中的this.setState或者setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中任何情况：不会批量处理</li>
</ul>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-this-updater"><a href="#2-this-updater" class="headerlink" title="2. this.updater"></a>2. this.updater</h4><p><code>this.updater</code> 是在哪个地方进行赋值暂时不用关心，只需要知道他被赋值为 <code>classComponentUpdater</code>。</p>
<p><code>classComponentUpdater</code> 和 <code>render</code> 流程里面的 <code>ReactDOM.render</code>中 <code>scheduleRootUpdate</code> 非常的相似，其实他们就是同一个更新原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">    <span class="comment">// inst 就是我们调用this.setState的this，也就是classComponent实例</span></span><br><span class="line">    <span class="comment">// 获取到当前实例上的fiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = ReactInstanceMap.get(inst);</span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="comment">// 计算当前fiber的到期时间（优先级）</span></span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建更新一个更新update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload是setState传进来的要更新的对象</span></span><br><span class="line">    update.payload = payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//callback就是setState(&#123;&#125;,()=&gt;&#123;&#125;)的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把更新放到队列UpdateQueue</span></span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进入React异步渲染的核心：React Scheduler</span></span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态更新都会创建一个保存更新状态相关内容的对象 <code>Update</code>。在 <code>render</code> 阶段的 <code>beginWork</code> 中会根据 <code>Update</code> 计算新的 <code>state</code>。</p>
<p>这里讲这个 <code>Update</code> 通过 <code>enqueueUpdate</code> 放到队列 <code>UpdateQueue</code>。</p>
<h4 id="3-requestWork"><a href="#3-requestWork" class="headerlink" title="3. requestWork"></a>3. requestWork</h4><p><code>scheduleWork</code> 里会执行 <code>requestWork</code> 方法。</p>
<p><code>requestWork</code> 中可以看到有多个 <code>if</code> 判断，这里就是 <code>setState</code> <strong>在不同的场景使用会出现同步和异步的根本原因</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将根节点添加到调度任务中</span></span><br><span class="line">  addRootToSchedule(root, expirationTime)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isRendering是全局变量，在后面生命周期函数我们会具体分析到</span></span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isBatchingUpdates、isUnbatchingUpdates是全局变量</span></span><br><span class="line">  <span class="comment">// react事件时有对他们进行重新赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      ....</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景1-合成事件"><a href="#场景1-合成事件" class="headerlink" title="场景1 - 合成事件"></a>场景1 - 合成事件</h3><p>React有着一套自己的合成事件机制，在一个事件调用的时候会经过一些处理，这里不详细描述，最重要的一个函数就是 <code>interactiveUpdates$1</code>，在执行一个事件的时候会先调用这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: <span class="string">'吴彦祖'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name) <span class="comment">// 狗蛋</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        age: <span class="string">'18'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.age) <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interactiveUpdates-1方法"><a href="#interactiveUpdates-1方法" class="headerlink" title="interactiveUpdates$1方法"></a>interactiveUpdates$1方法</h4><ul>
<li>isBatchingUpdates = true;让setState不马上更新</li>
<li>try finally 语句;先执行一个事件里的代码最后才更新</li>
<li>isBatchingUpdates = previousIsBatchingUpdates;合成事件里setTimeout能马上更新的原因</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interactiveUpdates$1</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// Synchronously flush pending interactive updates.</span></span><br><span class="line">    performWork(lowestPendingInteractiveExpirationTime, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    lowestPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingInteractiveUpdates = <span class="literal">true</span>;</span><br><span class="line">  isBatchingUpdates = <span class="literal">true</span>;  <span class="comment">// 把requestWork中的isBatchingUpdates标识改为true</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isBatchingUpdates变量"><a href="#isBatchingUpdates变量" class="headerlink" title="isBatchingUpdates变量"></a>isBatchingUpdates变量</h4><p><code>interactiveUpdates$1</code> 这个方法中把 <code>isBatchingUpdates</code> 设为了 <code>true</code>, 导致在 <code>requestWork</code> 方法中， <code>isBatchingUpdates</code> 为 <code>true</code> ，但是 <code>isUnbatchingUpdates</code> 是 <code>false</code> ，而被直接 <code>return</code> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requestWork</span></span><br><span class="line"><span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就导致了 <code>requestWork</code> 根本没有执行到任何更新的函数，比如 <code>performSyncWork</code>，但在最开始的 <code>enqueueSetState</code> 这个方法里还是已经将每一次更新都存到了一个 <code>update</code> 队列里。</p>
<p>所以合成事件里的 <code>setState</code> 不会马上更新，而是存入了一个更新队列里（enqueueUpdate）</p>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try finally"></a>try finally</h4><p><code>interactiveUpdates$1</code> 最后执行了一个 <code>try finally</code> 语法，会先执行 <code>try</code> 代码块中的语句，然后再执行 <code>finally</code> 中的代码，而 <code>fn(a, b)</code> 是在 <code>try</code> 代码块中执行相关的事件回调，而在 <code>finally</code> 里才有 <code>performSyncWork()</code>;</p>
<p>也就是说我们写的事件监听函数在 <code>try</code> 中执行，但更新在 <code>finally</code> 里，这就导致了所谓的”异步”，<code>state</code> 并没有马上更新并渲染到UI上，而是等到事件执行完之后才更新的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">        performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景2-setTimeout"><a href="#场景2-setTimeout" class="headerlink" title="场景2 - setTimeout"></a>场景2 - setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出更新后的值 --&gt; 1</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>try</code> 代码块执行到 <code>setTimeout</code> 的时候，这是一个宏任务，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块。</p>
<p>等 <code>finally</code> 执行的时候会执行 <code>isBatchingUpdates = previousIsBatchingUpdates</code>; 将 <code>isBatchingUpdates</code> 重置为了 <code>false</code>。</p>
<p>导致最后下次事件循环的时候去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync if</code>分支， 可以同步拿到最新的 <code>state</code> 值。</p>
<h3 id="场景3-生命周期函数中的setState"><a href="#场景3-生命周期函数中的setState" class="headerlink" title="场景3 - 生命周期函数中的setState"></a>场景3 - 生命周期函数中的setState</h3><p>三个全局变量：isRendering、isWorking、isCommitting</p>
<ul>
<li>isRendering：开始react更新就为true</li>
<li>isWorking：进入reconciler阶段就为true、进入commit阶段就为true</li>
<li>isCommitting：进入commit阶段就为true</li>
</ul>
<p>render前生命周期属于reconciler阶段：isRendering = true、isWorking = true Fiber Reconciler 的执行阶段：</p>
<ul>
<li>阶段一是生成 Fiber 树的渐进阶段，可以被打断。</li>
<li>阶段二是批量更新节点的阶段，不可被打断。</li>
</ul>
<p><img src="../images/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94/image.png" alt="alt text"></p>
<p>现在回过头来看 <code>requestWork</code> 里的第一个if判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和合成事件一样，当 <code>componentDidmount</code> 执行的时候，<code>isRendering</code> 为 <code>true</code>，react内部并没有更新就先 <code>return</code> 了，执行完 <code>componentDidmount</code> 后才去 <code>commitUpdateQueue</code> 更新。这就导致你在 <code>componentDidmount</code> 中 <code>setState</code> 完去 <code>console.log</code> 拿的结果还是更新前的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的还是更新前的值 --&gt; 0</span></span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="场景4-原生事件"><a href="#场景4-原生事件" class="headerlink" title="场景4 - 原生事件"></a>场景4 - 原生事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的是更新后的值 --&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发 <code>click</code> 事件，到 <code>requestWork</code> ,在 <code>requestWork</code> 里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被 <code>return</code>，所以当你在原生事件中 <code>setState</code>后，能同步拿到更新后的 <code>state</code> 值。</p>
<h3 id="场景5-setState批量更新的情况"><a href="#场景5-setState批量更新的情况" class="headerlink" title="场景5 - setState批量更新的情况"></a>场景5 - setState批量更新的情况</h3><h5 id="简单分析源码"><a href="#简单分析源码" class="headerlink" title="简单分析源码"></a>简单分析源码</h5><p><code>React</code> 加入 <code>fiber</code> 架构后，调度之前通过 <code>enqueueUpdate</code> 函数维护的 <code>UpdateQueue</code> 就是挂载在组件对应的 <code>fiber</code> 节点上，我们更新的通过调度最后会进入到 <code>updateClassComponent</code> 方法，里面最终会调用一个<code>getStateFromUpdate</code> 来获取最终的 <code>state</code> 状态。</p>
<p><code>getStateFromUpdate</code> 函数外面是对 <code>UpdateQueue</code> 队列的一个 <code>while</code> 循环，比如我们连续 <code>setState</code> 三次，那每次都会创建一个 <code>update</code> 实例通过 <code>enqueueUpdate</code> 放入 <code>fiber</code> 的 <code>UpdateQueue</code> 中，这里就是把这三次的<code>state</code> 合并计算出一个最终的值以提高性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resultState作为参数prevState传入getStateFromUpdate，然后getStateFromUpdate会合并生成</span></span><br><span class="line"><span class="comment">     * 新的状态再次赋值给resultState。完成整个循环遍历，resultState即为最终要更新的state。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resultState = getStateFromUpdate(</span><br><span class="line">        workInProgress,</span><br><span class="line">        queue,</span><br><span class="line">        update,</span><br><span class="line">        resultState,</span><br><span class="line">        props,</span><br><span class="line">        instance,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历下一个update对象</span></span><br><span class="line">    update = update.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getStateFromUpdate</code> 函数主要功能是将存储在更新对象 <code>update</code> 上的 <code>partialState</code> 与上一次的 <code>prevState</code> 进行对象合并，生成一个全新的状态 <code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevState: State,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setState会创建update对象，其属性tag当时被标记为UpdateState</span></span><br><span class="line">    <span class="keyword">case</span> UpdateState: &#123;</span><br><span class="line">      <span class="comment">// payload 存放的是要更新的状态state</span></span><br><span class="line">      <span class="keyword">const</span> payload = update.payload;</span><br><span class="line">      <span class="keyword">let</span> partialState;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取要更新的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> payload === <span class="string">'function'</span>) &#123;</span><br><span class="line">        partialState = payload.call(instance, prevState, nextProps);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        partialState = payload;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// partialState 为null 或者 undefined，则视为未操作，返回上次状态</span></span><br><span class="line">      <span class="keyword">if</span> (partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意：此处通过Object.assign生成一个全新的状态state， state的引用地址发生了变化。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prevState, partialState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="setState传入对象会合并对象"><a href="#setState传入对象会合并对象" class="headerlink" title="setState传入对象会合并对象"></a>setState传入对象会合并对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementByObject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.increment = <span class="keyword">this</span>.increment.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        <span class="comment">// 会批量更新，只会render一次，结果是 1</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;IncrementByObject&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;span&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果是一个 <code>Object</code> ，直接看最后的 <code>Object.assign({}, prevState, partialState);</code></p>
<p><code>Object.assign</code> 的作用： 主要是将所有可枚举属性的值从一个或多个源对象复制到目标对象，同时返回目标对象。如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性。</p>
<p>之前提过在合成事件中或者在生命周期了 <code>state</code> 是不会马上刷新的，是在事件执行完后也就是 <code>try finally</code> 的 <code>finally</code> 里才真正刷新，这就导致了每次 <code>Object.assign</code> 的 <code>partialState</code> 都是 <code>this.state.count + 1</code>，而 <code>state</code> 的 <code>count</code> 在三次 <code>setState</code> 的时候都不会改变都是0，所以计算过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>很明显最终的 <code>state</code> 的 <code>count</code> 只会增加 1。</p>
<h5 id="setState传入函数"><a href="#setState传入函数" class="headerlink" title="setState传入函数"></a>setState传入函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">increment() &#123;</span><br><span class="line">    <span class="comment">// 采用传入函数的方式来更新 state，会批量，只会render一次，更新但结果是 3</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是一个回调函数function 可以发现 <code>if (typeof payload === &#39;function&#39;)</code> 这里对传入的是否是方法做了判断，如果是方法，就执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partialState = payload.call(instance, prevState, nextProps);</span><br></pre></td></tr></table></figure>

<p><code>instance</code> 对于类组件来说，这里保存类组件的实例在外层的 <code>updateClassInstance</code>函数中 <code>const instance = workInProgress.stateNode;</code> 赋值的。</p>
<p>这里其实只看 <code>payload</code> 和 <code>prevState</code> 就行了，<code>payload</code> 是我们通过 <code>setState</code> 传入的回调函数，返回最新的 <code>state</code>，<code>while</code> 循环调用 <code>getStateFromUpdate</code> 每次传入的是 <code>resultState</code>，也就是说接受的 <code>state</code> 都是上一轮计算之后的新值，因此循环计算的过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到最终的 <code>state</code> 的 <code>count</code> 为增加 3。</p>
<h2 id="react18-自动批处理"><a href="#react18-自动批处理" class="headerlink" title="react18 - 自动批处理"></a>react18 - 自动批处理</h2><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：异步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中：会批量处理</li>
<li>setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中：会批量处理</li>
</ul>
</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>具体解析可以看 <a href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">《react18.2优先级和批处理场景解析》</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !情况1 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 页面变成3，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况4 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 页面变成2，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况6 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况7 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况8 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况9 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onClick&#125;&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>批处理：React 会尝试将同一上下文中触发的更新合并为一个更新。</p>
<p>就 React18 而言当说到批处理的时候，需同时具备以下三者：</p>
<ul>
<li>包括了多个react<strong>更新</strong></li>
<li>每个更新具有相同的<strong>优先级</strong></li>
<li>每个更新都是<strong>待执行</strong>的</li>
</ul>
<p>这样做的好处也显而易见：</p>
<ul>
<li>合并不必要的更新，减少更新流程调用次数</li>
<li>状态按顺序保存下来，更新时不会出现「竞争问题」</li>
<li>最终触发的更新是异步流程，减少浏览器掉帧可能性</li>
</ul>
<h4 id="1-更新"><a href="#1-更新" class="headerlink" title="1. 更新"></a>1. 更新</h4><p>对于 <code>hook</code> 有更新队列，对于 <code>react</code> 也有相应的更新（通常伴随着组件render），当然对浏览器还存在页面视图的更新。</p>
<p>当我们调用dispatch或者setState时，上述三种更新都是有涉及的。但是要特别指出的是，批处理中的更新就是指 <code>react</code> 的更新，包含了render，commit阶段等。在后续的批处理部分你将看到三者的差异。</p>
<p>如果我们看 <code>dispatchSetState</code> 的源码，会发现它们主要做了两件事：</p>
<ul>
<li>记录一次 <code>hook</code> 更新（<code>enqueueConcurrentHookUpdate</code>）</li>
<li>调度一次 <code>react</code> 更新（<code>scheduleUpdateOnFiber</code>）</li>
</ul>
<p>批中的更新就是指调度一次 <code>react</code> 更新 <code>scheduleUpdateOnFiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 dispatchReducerAction 中同样包含的逻辑</span></span><br><span class="line"><span class="comment">// 这个函数中 fiber 和 queue 都是通过 dispatchSetState.bind 提前绑定好的，我们调用 setState 时传入的参数是 action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...异常情形</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><p>在更新部分的相关源码示例中，可以看到 <code>lane</code> 字段，它表示的就是这次更新的优先级。只有优先级相同的多个更新才在一个批中，与之相应的就是这些更新被批处理，反之则不然。</p>
<p>一般而言，如果优先级没有被手动改变，那么相同场景下多次调用 <code>setState</code> 或者 <code>dispatch</code> 对应的更新优先级是相同的。</p>
<p>例外的情况是具有一整个序列而非单一的优先级，像 <code>TransitionLanes</code> 和 <code>RetryLanes</code>。以 <code>TransitionLanes</code> 为例，它们包含了许多个优先级并不相同并且依次排列的 <code>lane</code>，但是在 <code>render</code> 场景下，这些 <code>lane</code> 是一起被处理的。</p>
<p>像下面这样的示例中的更新是不会被视为同一批的，<code>startTransition</code> 改变了第二个更新的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">2</span>)) <span class="comment">// startTransition引自react</span></span><br></pre></td></tr></table></figure>

<h4 id="3-待执行"><a href="#3-待执行" class="headerlink" title="3. 待执行"></a>3. 待执行</h4><p>待执行指的是已经调度但还未被执行。通常执行相对于调度而言是异步的。假如两个更新具有相同的优先级，那么：</p>
<ul>
<li>只要一个已执行，另一个未执行，无法批处理</li>
<li>只要都未执行，就能批处理（一些异步场景可能带来迷惑性）</li>
</ul>
<p>对于第一点，当我们手动调用同步执行更新的api时，后续的更新就无法与同步的更新成批，在下面的示例中，你会发现点击将带来两次render。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    flushSync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    setCount(count + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然而，这样做是可以批处理的</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;点击数字&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>flushSync</code> 可以使更新同步地被执行，这样一来，第二个 <code>setCount</code> 带来的更新与第一个 <code>setCount</code> 的更新无法被批处理，因为 <code>setCount(count + 2)</code> 调用时，第一个更新已经执行完了。</p>
<p>对于第二点，考虑到js事件循环带来的复杂异步特性，在一些让人意想不到的场景也能批处理，下面是一个有趣的示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;划入render一次，点击render两次&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>click事件对应的更新优先级是被调度在微任务中的，而mouseEnter事件则是另一类。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState-1"><a href="#1-setState-1" class="headerlink" title="1. setState"></a>1. setState</h4><p><code>setState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react</code> 更新</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-scheduleUpdateOnFiber"><a href="#2-scheduleUpdateOnFiber" class="headerlink" title="2. scheduleUpdateOnFiber"></a>2. scheduleUpdateOnFiber</h4><p>忽略一些琐碎的细节后，可以发现这个函数的核心逻辑甚至更简单：</p>
<ol>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ensureRootIsScheduled"><a href="#3-ensureRootIsScheduled" class="headerlink" title="3. ensureRootIsScheduled"></a>3. ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-processRootScheduleInMicrotask"><a href="#4-processRootScheduleInMicrotask" class="headerlink" title="4. processRootScheduleInMicrotask"></a>4. processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="5-scheduleTaskForRootDuringMicrotask"><a href="#5-scheduleTaskForRootDuringMicrotask" class="headerlink" title="5. scheduleTaskForRootDuringMicrotask"></a>5. scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">      root.callbackPriority = newCallbackPriority;</span><br><span class="line">      root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于批处理有三点：</p>
<ol>
<li>多次调用 <code>setState</code> 时候，在 <code>ensureRootIsScheduled</code> 中通过 <code>didScheduleMicrotask</code> 标记，第一次进入标记为 <code>true</code>，再次进入便不再调度微任务触发 <code>processRootScheduleInMicrotask</code></li>
<li>当触发后续微任务触发 <code>processRootScheduleInMicrotask</code> 方法，通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>如果是同步优先级，直接return，因为<code>processRootScheduleInMicrotask</code> 方法最后会调用 <code>flushSyncWorkOnAllRoots</code> 执行一遍同步任务， 否则对比上次等待的更新和本次更新的优先级，即 <code>existingCallbackPriority === newCallbackPriority</code>，如果相等，则提前return，否则通过 <code>scheduleCallback</code> 调度更新流程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2函数组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-16T00:00:00+08:00">2024-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h2><p>执行函数组件 <code>Fiber</code> 节点的 <code>beginWork</code> 工作，根据 <code>tag</code> 类型，进入 <code>IndeterminateComponent</code> 待定组件的逻辑处理【case IndeterminateComponent】：</p>
<p>每个函数组件的首次加载都是走的 <code>IndeterminateComponent</code> 分支逻辑，这是因为在创建函数组件 <code>Fiber</code> 的时候，<code>react</code> 没有更新它的 <code>tag</code> 值，所以它的首次 <code>beginWork</code> 工作就会进入 <code>IndeterminateComponent</code> 分支，在<code>mountIndeterminateComponent</code> 方法中才会更新它的 <code>tag</code>，使函数组件的Fiber在更新阶段执行 <code>beginWork</code> 时，能够进入正确的 <code>FunctionComponent</code> 分支。</p>
<h3 id="1-1-mountIndeterminateComponent"><a href="#1-1-mountIndeterminateComponent" class="headerlink" title="1.1 mountIndeterminateComponent"></a>1.1 mountIndeterminateComponent</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出函数组件的props</span></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储FirstChild内容</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  # 调用函数组件</span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对类组件和函数组件进行不同的处理</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    value.$$<span class="keyword">typeof</span> === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">	# 类组件的处理逻辑 【只是类组件现在已经不走这里了】</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    # 函数组件处理</span><br><span class="line">    <span class="comment">// 更新tag为函数组件类型的值，下个逻辑就可以直接进入函数组件的处理【节点更新的时候】</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    # 创建子节点</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出当前函数组件FIber节点上的最新的props，方便函数组件加载的使用，然后调用renderWithHooks方法，这个方法会执行我们定义的函数组件，返回值就是函数中return的内容，也就是jsx内容【处理过后的react-element元素对象】。</p>
<h4 id="1-1-1-renderWithHooks"><a href="#1-1-1-renderWithHooks" class="headerlink" title="1.1.1 renderWithHooks"></a>1.1.1 renderWithHooks</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  # 设置为当前渲染中的Fiber</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  # 重置函数组件节点的数据</span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置首次加载的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current = current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  # 调用这个函数，即调用组件，循环生成Element对象，</span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line">  <span class="comment">// 重置一些信息</span></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-1-ReactCurrentDispatcher"><a href="#1-1-1-1-ReactCurrentDispatcher" class="headerlink" title="1.1.1.1 ReactCurrentDispatcher"></a>1.1.1.1 ReactCurrentDispatcher</h5><p><code>ReactCurrentDispatcher</code> 对象是一个全局变量，它是在react源码中的react包定义的：</p>
<p><font color=gray><em>packages\react\src\ReactCurrentDispatcher.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure>

<p>然后将它包装在一个新的对象中：</p>
<p><font color=gray><em>packages\react\src\ReactSharedInternalsClient.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactSharedInternals = &#123;</span><br><span class="line">  ReactCurrentDispatcher,</span><br><span class="line">  ReactCurrentCache,</span><br><span class="line">  ReactCurrentBatchConfig,</span><br><span class="line">  ReactCurrentOwner,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>而shared包【通用工具包】会引入这个对象，然后暴露给全局：</p>
<p><font color=gray><em>packages\shared\ReactSharedInternals.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternalsClient'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>其他资源包就可以通过shared工具包来拿到这个对象，所以我们在函数组件加载时才能使用这个对象：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'shared/ReactSharedInternals'</span>;</span><br><span class="line"><span class="comment">// 拿到ReactCurrentDispatcher对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;ReactCurrentDispatcher, ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>知道了 <code>ReactCurrentDispatcher</code> 对象的由来，我们才能更好地理解它的作用，因为函数组件的每个 <code>hook</code> 实际就是在调用这个对象中的同名方法，比如 <code>useState</code>：</p>
<p><font color=gray><em>packages\react\src\ReactHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>resolveDispatcher</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="comment">// 返回获取到的dispatcher</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 hook 也是一样的原理。</p>
<h5 id="1-1-1-2-函数组件调用"><a href="#1-1-1-2-函数组件调用" class="headerlink" title="1.1.1.2 函数组件调用"></a>1.1.1.2 函数组件调用</h5><p>函数组件的加载核心就是执行一次函数的内容，理解起来也很简单。最后触发 return 关键字，这里的 jsx 内容会在 react 内部通过 <code>jsxRuntime.jsx</code> 方法进行处理，生成 <code>react-element</code> 对象，最后返回值就是创建的 react 元素对象。</p>
<p>最后返回生成的 <code>react-element</code> 对象，<code>renderWithHooks</code> 方法执行完成。</p>
<p>函数组件初始化执行完成后，就会更新函数组件Fiber节点的tag值为正确的类型FunctionComponent【后续逻辑函数组件节点便可以进入Function分支了】。</p>
<p>然后根据新建的value【react元素对象】创建子Fiber节点，最后返回子节点，函数组件的加载过程就基本完成了。</p>
<h3 id="1-2-hooks的加载"><a href="#1-2-hooks的加载" class="headerlink" title="1.2 hooks的加载"></a>1.2 hooks的加载</h3><p>根据上文得知，我们查看先前的 <code>ReactCurrentDispatcher</code> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnMount</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useInsertionEffect: mountInsertionEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState, <span class="comment">// 加载state</span></span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useSyncExternalStore: mountSyncExternalStore,</span><br><span class="line">  useId: mountId,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>例如我们在函数中依次使用useState、useEffect、useLayoutEffect，我们来看一下执行过程：</p>
<h4 id="1-2-1-mountState"><a href="#1-2-1-mountState" class="headerlink" title="1.2.1 mountState"></a>1.2.1 mountState</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  # hook加载工作</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 等待处理的update链表</span></span><br><span class="line">    lanes: NoLanes,</span><br><span class="line">    dispatch: <span class="literal">null</span>, <span class="comment">// dispatchSetState方法</span></span><br><span class="line">    lastRenderedReducer: basicStateReducer, <span class="comment">// 一个函数，通过action和lastRenderedState计算最新的state</span></span><br><span class="line">    lastRenderedState: initialState, <span class="comment">// 上一次的state</span></span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = queue;</span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line">  # 返回值</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-1-mountWorkInProgressHook"><a href="#1-2-1-1-mountWorkInProgressHook" class="headerlink" title="1.2.1.1 mountWorkInProgressHook"></a>1.2.1.1 mountWorkInProgressHook</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  # hook对象</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个hook</span></span><br><span class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 后面的hook对象添加到第一个hook的next属性上，形成一个单向链表</span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>hook</code> 对象，<code>workInProgressHook</code> 默认为 <code>null</code>，它代表当前正在处理中的 <code>hook</code> 对象。</p>
<p>当前 <code>useState</code> 为函数组件中的第一个调用的 <code>hook</code> ，所以这时 <code>workInProgressHook</code> 肯定为 <code>null</code>：</p>
<p>将新建 <code>hook</code> 对象赋值给 <code>workInProgressHook</code>，表示为正在处理中的 <code>hook</code> 对象。</p>
<p>同时也将第一个 <code>hook</code> 对象赋值给当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png" alt="alt text"></p>
<p>继续回到 <code>mountState</code> 方法中:</p>
<p>在 <code>hook</code> 新建完成之后，判断传入的参数 <code>initialState</code> 是否为函数，如果为函数则调用此函数，将结果赋值为新的 <code>initialState</code>。</p>
<p>然后设置 <code>hook</code> 对象的 <code>memoizedState</code> 和 <code>baseState</code> 属性为初始的数据 <code>initialState</code>。</p>
<p>接下来创建一个queue对象，这里要注意两个属性：</p>
<ol>
<li>lastRenderedReducer：它是一个函数，作用是根据action和lastRenderedState计算最新的state。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action就是setCount传入的参数，如果为一个函数，则将state传入进行计算，返回新的state</span></span><br><span class="line">  <span class="comment">// 如果不是函数，则action就是最新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lastRenderedState：代表上一次渲染的state</li>
</ol>
<p>然后更新 <code>hook</code> 对象的 <code>queue</code> 属性，同时设置 <code>queue</code> 对象的 <code>dispatch</code> 属性为一个修改函数 <code>dispatchSetState</code></p>
<p>最后返回一个数组，这就是 <code>useState hook</code> 的返回值：一个初始state和一个修改函数。</p>
<h4 id="1-2-2-mountEffect"><a href="#1-2-2-mountEffect" class="headerlink" title="1.2.2 mountEffect"></a>1.2.2 mountEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进入effect加载</span></span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, # Passive标记对应的是useEffect</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-1-mountEffectImpl"><a href="#1-2-2-1-mountEffectImpl" class="headerlink" title="1.2.2.1 mountEffectImpl"></a>1.2.2.1 mountEffectImpl</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  # 创建的新的hook对象</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 确定当前hook的deps依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 当前渲染中的Fiber节点，即函数组件对应的，打上effect钩子的flags</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 设置hook的memoizedState属性</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是先调用 <code>mountWorkInProgressHook</code> 创建一个 <code>hook</code> 对象，所以这里是先将第一个 <code>hook</code> 对象的 <code>next</code> 属性指向新建的 <code>hook</code>，然后再更新 <code>workInProgressHook</code> 的值为当前的 <code>hook</code> 对象。</p>
<p>此时函数组件Fiber节点的memoizedState属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png" alt="alt text"></p>
<p>在 <code>hook</code> 创建完成之后，确定当前 <code>hook</code> 对象的 <code>deps</code> 依赖，因为我们传递的依赖为[]，所以此时 <code>deps</code> 为一个空数组。然后更新当前 <code>Fiber</code> 节点的 <code>flags</code> 标记，最后设置 <code>hook</code> 对象的 <code>memoizedState</code> 属性内容，这里属性的结果为<code>pushEffect</code> 方法调用的返回值</p>
<h5 id="1-2-2-2-pushEffect"><a href="#1-2-2-2-pushEffect" class="headerlink" title="1.2.2.2 pushEffect"></a>1.2.2.2 pushEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  # 创建副作用对象</span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create, <span class="comment">// 回调函数</span></span><br><span class="line">    destroy, <span class="comment">// 销毁函数</span></span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 取出当前函数组件的UpdateQueue</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null时: 创建当前函数组件的UpdateQueue</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span><br><span class="line">    <span class="comment">// 第一个effect对象: 它的next属性会执行自己,形成一个单向环状链表</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次加载其他的effect时: 将</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      # 上一个effect的next属性指向新建的effect</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      # 新建的next属性指向第一个effect</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了一个effect对象，查看它的内容：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png" alt="alt text"></p>
<ol>
<li><code>create</code> 属性即为我们传入的回调函数。</li>
<li><code>deps</code> 属性是当前 <code>useEffect hook</code>的依赖。</li>
<li><code>destory</code> 属性为 <code>undefined</code>，它存储的是 <code>useEffect hook</code>返回的clean清理函数或者说销毁函数，但是它不是在这里赋值的，并且当前我们也没有返回这个函数。</li>
</ol>
<p>然后取出当前函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性内容赋值给变量 <code>componentUpdateQueue</code>。</p>
<p>然后判断 <code>componentUpdateQueue</code> 是否为 <code>null</code>：</p>
<p>为 <code>null</code> 时，然后调用 <code>createFunctionComponentUpdateQueue</code> 方法更新它的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>): <span class="title">FunctionComponentUpdateQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    stores: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前创建的 <code>effect</code> 对象的 <code>next</code> 属性指向了自身，且同时更新 <code>updateQueue.lastEffect</code> 属性为当前 <code>effect</code> 对象，由此形成一个单向环状链表。</p>
<p>所以此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png" alt="alt text"></p>
<p><code>pushEffect</code> 方法最后，返回当前创建的 <code>effect</code> 对象。</p>
<p>再回到 <code>mountEffectImpl</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect()</span><br></pre></td></tr></table></figure>

<p>所以 <code>hook</code> 对象的 <code>memoizedState</code> 属性值为一个 <code>effect</code> 对象。</p>
<p>从这里我们可以发现，虽然每个hook对象都是相同的属性，但是不同的 <code>hook</code> 类型它存储的内容却完全不同。</p>
<ul>
<li><code>useState</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为数据 <code>state</code>。</li>
<li><code>useEffect</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为一个 <code>effect</code> 对象。</li>
</ul>
<h4 id="1-2-3-mountLayoutEffect"><a href="#1-2-3-mountLayoutEffect" class="headerlink" title="1.2.3 mountLayoutEffect"></a>1.2.3 mountLayoutEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberFlags: Flags = UpdateEffect;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">    fiberFlags |= LayoutStaticEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(fiberFlags, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现useEffect和useLayoutEffect共用了同一个加载方法 <code>mountEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<p><code>hook</code> 对象创建和处理，此时函数组件Fiber节点的memoizedState属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png" alt="alt text"></p>
<p><code>effect</code> 对象创建和处理，依然是 <code>pushEffect</code> 方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # 第二次加载其他的effect时:</span><br><span class="line">  <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="comment">// 上一个effect的next属性指向新建的effect</span></span><br><span class="line">    lastEffect.next = effect;</span><br><span class="line">    <span class="comment">// 新建的next属性指向第一个effect</span></span><br><span class="line">    effect.next = firstEffect;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前为第二个effect相关的 <code>hook</code> 处理，所以此时 <code>Fiber.updateQueue</code>【即componentUpdateQueue】是有值的，进入else分支处理。</p>
<p>更新<code>Fiber.updateQueue.lastEffect</code>属性指向为当前新建的 <code>effect2</code>，将 <code>effect2</code> 的 <code>next</code> 属性指向为之前的 <code>effect</code> 对象。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png" alt="alt text"></p>
<p>到此，函数组件加载阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="1-3-commit阶段"><a href="#1-3-commit阶段" class="headerlink" title="1.3 commit阶段"></a>1.3 commit阶段</h3><p>前面全部的加载逻辑都是在 <code>Fiber Reconciler</code> 协调流程中执行的，即函数组件大部分的加载逻辑都是在 <code>reconciler</code> 协调流程中完成的【更新阶段同理】，还有剩下的一部分逻辑在 <code>commit</code> 阶段之中处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发起调度处理useEffect回调</span></span><br><span class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">	<span class="comment">// 这个回调就是处理useEffect的</span></span><br><span class="line">	flushPassiveEffects();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1，BeforeMutation阶段</span></span><br><span class="line">  commitBeforeMutationEffects()</span><br><span class="line">  <span class="comment">// 2，Mutation阶段，渲染真实DOM加载到页面</span></span><br><span class="line">  commitMutationEffects()</span><br><span class="line">  <span class="comment">// 3，Layout阶段</span></span><br><span class="line">  commitLayoutEffects()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit</code> 阶段的内容都是同步执行，在进入具体的执行之前，都会先调用 <code>scheduleCallback</code> 方法发起一个新的调度，即创建一个新的任务 <code>task</code>，最后会生成一个新的宏任务来异步处理副作用【即执行useEffect的回调钩子】。</p>
<p>上面是 <code>useEffect</code> 的回调处理，我们再查看 <code>useLayoutEffect</code> 的回调处理。</p>
<h3 id="1-4-Layout阶段"><a href="#1-4-Layout阶段" class="headerlink" title="1.4 Layout阶段"></a>1.4 Layout阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 根据组件类型</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">          <span class="comment">// 函数组件的处理</span></span><br><span class="line">          <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">              <span class="comment">// 传入的是layout相关的flag标记</span></span><br><span class="line">              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-commitHookEffectListMount"><a href="#1-4-1-commitHookEffectListMount" class="headerlink" title="1.4.1 commitHookEffectListMount"></a>1.4.1 commitHookEffectListMount</h4><p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListMount</span>(<span class="params">flags: HookFlags, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  # 当前函数组件的updateQueue属性，存储的是副作用链表</span><br><span class="line">  <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">  <span class="comment">// 取出最后一个effect对象</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个effect对象</span></span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 开始循环处理</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">        <span class="comment">// Mount</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.create;</span><br><span class="line">        # 执行回调函数</span><br><span class="line">        effect.destroy = create();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从当前函数组件 <code>Fiber</code> 节点取出它的 <code>updateQueue</code> 属性内容，在前面我们已经知道了 <code>Fiber.updateQueue</code> 存储的是副作用相关的链表，定义一个 <code>lastEffect</code> 变量存储 <code>updateQueue.lastEffect</code> 的内容，即最后一个 <code>effect</code> 对象。</p>
<p>判断 <code>lastEffect</code> 是否为 <code>null</code> ，如果 <code>lastEffect</code> 为 <code>null</code>，代表当前函数组件没有使用过 <code>effect</code> 相关的 <code>hook</code>。</p>
<p>当前肯定是有值的，继续向下执行。从 <code>lastEffect.next</code> 中取出第一个 <code>effect</code> 对象，开始按顺序循环处理副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">	<span class="comment">// Mount</span></span><br><span class="line">	<span class="keyword">const</span> create = effect.create;</span><br><span class="line">	<span class="comment">// 执行回调函数</span></span><br><span class="line">	effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">  effect = effect.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>

<p>注意在执行之前有一个条件判断，只有存在 <code>effect</code> 相关的 <code>flags</code> 标记才会执行对应副作用回调。</p>
<p>而在之前 <code>hook</code> 加载是有进行设置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect(</span><br><span class="line">  HookHasEffect | hookFlags, <span class="comment">// HookHasEffect标记就是表示有需要执行副作用</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在函数组件加载阶段时，每个 <code>useEffect</code> 和 <code>useLayoutEffect</code> 都有打上 <code>HookHasEffect</code> 的标记，表示在加载阶段都会默认执行一次。</p>
<p>需要注意的是：之前 <code>commitHookEffectListMount</code> 传入的是与 <code>Layout</code> 相关的 <code>flags</code> 标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); <span class="comment">// Layout</span></span><br></pre></td></tr></table></figure>

<p>所以这里只有 <code>layout hook</code> 的回调才能执行，第一个 <code>effect</code> 对象对应的是 <code>useEffect</code>，不满足判断条件</p>
<p>从当前 <code>effect</code> 对象的 <code>next</code> 属性取出下一个 <code>effect</code> 对象，开始第二次循环。</p>
<p>第二个 <code>effect</code> 对象对应的是 <code>useLayoutEffect</code>，满足判断条件，执行它的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = effect.create;</span><br><span class="line"><span class="comment">// 执行回调函数</span></span><br><span class="line">effect.destroy = create();</span><br></pre></td></tr></table></figure>

<p>到此 hook 相关的回调处理完成，函数组件加载逻辑全部执行完成。</p>
<h2 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h2><h3 id="2-1-dispatchSetState"><a href="#2-1-dispatchSetState" class="headerlink" title="2.1 dispatchSetState"></a>2.1 dispatchSetState</h3><p>当操作更新触发 <code>setState</code> 时, 就是触发之前 <code>useState</code> 加载返回的 <code>dispatch</code> 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line"># 返回值</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A, <span class="regexp">//</span> state <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求更新优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// 1. 创建update更新对象</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// state 1</span></span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 调度之前的一个优化策略校验: eagerState</span><br><span class="line">    <span class="comment">// 快速计算出本次最新的state，与原来的进行对比，如果没有发生变化，则跳过后续的更新逻辑</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当前的state，即旧的state</span></span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="comment">// 快速计算最新的state</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            # 如果state没变，组件不做更新。此处和useReducer对比下，useReducer还是会让函数组件更新</span><br><span class="line">            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将更新对象入队</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      <span class="comment">// 3. 开启一个新的调度更新任务</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-eagerState"><a href="#2-1-1-eagerState" class="headerlink" title="2.1.1 eagerState"></a>2.1.1 eagerState</h4><p>首先看 <code>dispatchSetState</code> 方法的整个结构和类组件的更新方法 <code>enqueueSetState</code> 基本相同，还有 <code>react</code> 应用的初始加载 <code>updateContainer</code>，其实一个react应用的更新场景就只有这三种，而它们的更新逻辑就是以下几个步骤：</p>
<ol>
<li>获取更新优先级 <code>lane</code>。</li>
<li>创建 <code>update</code> 更新对象 。</li>
<li>将 <code>update</code> 更新对象添加到目标Fiber对象的更新队列中。</li>
<li>开启一个新的调度更新任务。</li>
</ol>
<p>它们的区别主要在于函数组件这里在调度之前有一个eagerState优化策略校验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的state，即旧的state</span></span><br><span class="line"><span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line"><span class="comment">// 快速计算最新的state</span></span><br><span class="line"><span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">update.eagerState = eagerState;</span><br><span class="line"><span class="comment">// 比较新旧state</span></span><br><span class="line"><span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个优化策略的作用是：调用 <code>queue.lastRenderedReducer</code> 方法，通过原来的 <code>state</code> 和当前传入的 <code>action</code> 参数，快速的计算出本次最新的 <code>state</code> 【即eagerState】，通过比较新旧 <code>state</code> 来判断数据是否变化，如果没有变化则可以跳过后续的更新逻辑，即不会开启新的调度更新任务。当前我们的 <code>state</code> 是有变化的，所以不满足优化策略，将继续向下执行更新。</p>
<h4 id="2-1-2-enqueueConcurrentHookUpdate"><a href="#2-1-2-enqueueConcurrentHookUpdate" class="headerlink" title="2.1.2 enqueueConcurrentHookUpdate"></a>2.1.2 enqueueConcurrentHookUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentHookUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: HookQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: HookUpdate&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// 通用的入队方法</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// 找到根节点并返回</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>dispatchSetState</code> 方法中，最后还是会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h4 id="2-1-3-flushSyncWorkOnAllRoots"><a href="#2-1-3-flushSyncWorkOnAllRoots" class="headerlink" title="2.1.3 flushSyncWorkOnAllRoots"></a>2.1.3 flushSyncWorkOnAllRoots</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>microtask</code> 结束时，<code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>直接快进到performSyncWorkOnRoot方法中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用renderRootSync方法，开始FiberTree的创建过程。</p>
<p><strong>在这之前，还有一个处理要注意：把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	prepareFreshStack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	finishQueueingConcurrentUpdates()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png" alt="alt text"></p>
<h4 id="2-1-4-updateFunctionComponent"><a href="#2-1-4-updateFunctionComponent" class="headerlink" title="2.1.4 updateFunctionComponent"></a>2.1.4 updateFunctionComponent</h4><p>下面进入 <code>beginWork</code> 工作的 <code>FunctionComponent</code> 处理分支，开始函数组件的更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  # 调用函数组件</span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  # 函数组件默认的bailout策略，满足条件比较苛刻</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见 <code>updateFunctionComponent</code> 方法主要有两个处理：</p>
<ol>
<li>调用renderWithHooks【函数组件加载也是调用了这个方法】。</li>
<li>判断是否满足Bailout优化策略，满足则进入优化逻辑，跳过本组件的更新。不满足，则执行正常的组件更新逻辑。</li>
</ol>
<h4 id="2-1-5-renderWithHooks"><a href="#2-1-5-renderWithHooks" class="headerlink" title="2.1.5 renderWithHooks"></a>2.1.5 renderWithHooks</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// 设置为当前渲染中的Fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置函数组件节点的数据</span></span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置更新的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current =current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  <span class="comment">// 调用这个函数，即调用组件，循环生成Element对象，</span></span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新阶段时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</span><br></pre></td></tr></table></figure>

<p><code>renderWithHooks</code> 方法的重点依然是组件的调用 <code>Component()</code>，这里的逻辑依然只是重新调用一遍我们定义的函数，最后返回最新的jsx内容【即reactElement对象】</p>
<h4 id="2-1-6-hooks的更新"><a href="#2-1-6-hooks的更新" class="headerlink" title="2.1.6 hooks的更新"></a>2.1.6 hooks的更新</h4><p>首先查看 <code>useState</code> 的更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123;</span><br><span class="line">	useState: updateState, <span class="comment">// 更新state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState:</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init?</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 更新hook工作</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-updateWorkInProgressHook"><a href="#2-1-7-updateWorkInProgressHook" class="headerlink" title="2.1.7 updateWorkInProgressHook"></a>2.1.7 updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即将处理的hook</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 第一此进入更新时，currentHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出当前正在更新的函数组件Fiber的旧节点</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.alternate;</span><br><span class="line">    <span class="comment">// 更新阶段，current都是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将旧节点的memoizedState 设置为下一个处理的Hook</span></span><br><span class="line">      <span class="comment">// 将组件加载时，初始化的hook链表取出，memoizedState指向的是hook1</span></span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个hook更新开始，会走这里</span></span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置下一个工作中的Hook为null</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 组件的第一个Hook更新时，workInProgressHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将当前函数组件Fiber节点的memoizedState 设置为下一个处理的hook【默认是null】</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一个Hook，则取next指向的下一个</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个不为null， 说明当前hook不是最后一个更新的hook，只有最后一个hook更新时，nextWorkInProgressHook才为null</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's already a work-in-progress. Reuse it.</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新currentHook 为第一个hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象，复用原来的内容</span></span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      baseQueue: currentHook.baseQueue,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>, <span class="comment">// 但是清空了next指向</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个hook更新时，workInProgressHook为null，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      <span class="comment">// 更新当前函数的组件的memoizedState为第一个hook对象，同时设置为当前正在工作中的hook</span></span><br><span class="line">      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      <span class="comment">// 非第一个Hook,直接添加到上一个hook对象的next属性中</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回当前正在工作中的hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像函数组件的hook在加载时都会调用一个 <code>mountWorkInProgressHook</code> 方法，生成一个hook链表。</p>
<p>而函数组件的hook在更新时也会调用一个 <code>updateWorkInProgressHook</code> 方法，生成对应的hook链表。</p>
<p>所以 <code>updateWorkInProgressHook</code> 方法的作用是：确定当前函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容，也就是生成它的 <code>hook</code> 链表。</p>
<p>它的做法就是从 <code>current</code> 节点上取出函数组件加载时生成的 <code>hook</code> 链表，按顺序取出原来的 <code>hook</code> 对象，根据原来的对象信息创建生成新的 <code>newHook</code> 对象，最后按顺序一个一个添加到新的 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性上。</p>
<p><strong>注意：</strong>这里是一个重点，如果没有清空 <code>next</code> 属性，那更新当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性，直接拿到第一个 <code>hook</code> 对象，就可以拿到整个 <code>hook</code> 链表，然后后续的 <code>hook</code> 更新就不需要再调用 <code>updateWorkInProgressHook</code> 方法了。</p>
<p>但是函数组件为啥不能如此处理呢？</p>
<p>因为react不能保证开发者是一定按照规范来使用的 <code>hook</code> ，如果开发者将 <code>hook</code> 置于条件语句中，在更新阶段出现了原来 <code>hook</code> 链表中不存在的 <code>hook</code> 对象，则在渲染时就会发生异常，所以react在函数组件更新时需要主动中断 <code>hook</code> 对象的next属性指向，按原来的链表顺序重新一个一个添加，如果出现了不匹配的 <code>hook</code> 对象，就会主动抛出异常，提示用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-计算state"><a href="#2-1-8-计算state" class="headerlink" title="2.1.8 计算state"></a>2.1.8 计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line"><span class="function">  <span class="title">initialArg</span>: <span class="title">I</span>,</span></span><br><span class="line"><span class="function">  <span class="title">init</span>?: <span class="title">I</span> =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 返回新的hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer; <span class="comment">// 还是basicStateReducer，无变化</span></span><br><span class="line">  <span class="keyword">const</span> current = currentHook; <span class="comment">// 旧的hook对象，加载时useState创建的hook对象</span></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.baseQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="comment">// 等待处理的更新链表：默认指向的是最后一个update对象</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// pendingQueue不为null，代表有需要处理的更新对象，然后需要将它们添加到baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Merge the pending queue and the base queue.</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们有一个队列要处理</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = current.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line"></span><br><span class="line">    # 循环处理update更新对象</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">        <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line">            action: update.action,</span><br><span class="line">            hasEagerState: update.hasEagerState,</span><br><span class="line">            eagerState: update.eagerState,</span><br><span class="line">            next: (<span class="literal">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	# 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>updateWorkInProgressHook</code> 方法调用完成之后，返回值就是 <code>useState</code> 对应的hook对象：</p>
<p>取出hook对象的queue队列，如果queue为null，则会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的逻辑看似比较多，但其实比较简单，而且和this.setState计算state的逻辑基本一致。</p>
<p><strong>它的核心逻辑：</strong>按顺序正向循环 <code>update</code> 更新队列，定义一个变量 <code>newState</code> 来存储最新的 <code>state</code>，然后根据原来 <code>state</code> 和 <code>update</code> 对象里面的信息计算最新的数据更新变量 <code>newState</code>，每循环一次就会从 <code>update</code> 对象的 <code>next</code> 属性取出下一个参与计算的 <code>update</code>，直接到所有的 <code>update</code> 处理完成。</p>
<p>当前 <code>pendingQueue</code> 结构【单向环状链表】：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png" alt="alt text"></p>
<p>在类组件中，会根据pendingQueue的内容重构生成一个新的单向链表，不再是环状，有明确的结束。</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png" alt="alt text"></p>
<p>和类组件不同的是，函数组件这里并没有额外处理pendingQueue，而是直接复制给baseQueue，从baseQueue.next取出第一个update对象【即first】开始计算state。</p>
<p>所以函数组件这里的do while循环多了一个结束的判断条件，就是不能等于first，不然就会陷入无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first)</span><br></pre></td></tr></table></figure>

<p>然后就是函数组件计算state的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while循环中，计算state的核心逻辑</span></span><br><span class="line"><span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">  newState = ((update.eagerState: any): S);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action = update.action;</span><br><span class="line">  newState = reducer(newState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果eagerState存在，则直接使用eagerState的值为新的state。</p>
<p>如果不存在，则调用reducer【basicStateReducer】，根据最新的newState和当前update对象的action重新计算state。</p>
<p>循环结束，在更新state之前，还有一个校验需要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line"><span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">  markWorkInProgressReceivedUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对一个状态的批量处理之后，有一个状态变化的校验，针对的是函数组件内部的 <code>Bailout</code> 策略。</p>
<p>即如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量 <code>ReceivedUpdate</code> 为 <code>false</code>，表示改组件没有更新的内容，这样就可以在 <code>renderWithHooks</code> 方法执行完成后，进入 <code>Bailout</code> 策略。</p>
<p>然后更新 <code>hook</code> 对象的 <code>memoizedState</code> 属性为最新的 <code>newState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储最新的state</span></span><br><span class="line">hook.memoizedState = newState;</span><br></pre></td></tr></table></figure>

<p>到此，<code>useState hook</code> 的更新程序执行完成，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆state</span></span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p>同时这里我们也可以明白：函数组件 <code>useState hook</code> 能够缓存变量结果的原因，因为它的 <code>state</code> 存储在 <code>hook</code> 对象的属性之中，并且这个属性可以在函数组件重新渲染过程中得到更新。</p>
<h3 id="2-2-updateEffect"><a href="#2-2-updateEffect" class="headerlink" title="2.2 updateEffect"></a>2.2 updateEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 取出新的依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 重置销毁方法</span></span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的pushEffect方法</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    <span class="comment">// 继承原来的destroy方法</span></span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面校验为true的情况下，这里就不会再执行</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先依然是调用一个 <code>updateWorkInProgressHook</code> 方法，前面已经详细讲解了它的作用。所以这里调用此方法后，就会新建一个 <code>newHook</code> 对象，添加到第一个 <code>hook</code> 对象的 <code>next</code> 属性之上，形成一个链表，后续如果还有新的 <code>newHook</code> 对象则继续执行同样的逻辑。</p>
<p>此时函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png" alt="alt text"></p>
<h3 id="2-2-1-areHookInputsEqual"><a href="#2-2-1-areHookInputsEqual" class="headerlink" title="2.2.1 areHookInputsEqual"></a>2.2.1 areHookInputsEqual</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况1，无依赖参数，每次渲染都会执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况2，有至少一项依赖参数，循环判断每个依赖是否相等，任何一个依赖变化则会重新执行副作用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 情况3，即空数组的情况，重新渲染不执行副作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前我们依赖为一个空数组，所以满足第三种情况，直接返回 <code>true</code>。</p>
<ul>
<li><p>在依赖校验为 <code>true</code> 的情况下，即表示没有变化，此时更新 <code>hook.memoizedState</code> 属性，最后触发 <code>return</code> 关键字，<code>updateEffect</code> 方法执行完成。</p>
</li>
<li><p>在依赖变化时，也会重新设置 <code>hook.memoizedState</code> 属性，依赖校验为true的情况下就是第一个参数不同，会打上 <code>HookHasEffect</code> 的标记。</p>
<ul>
<li>这个值会存储到 <code>effect</code> 对象的tag属性上，表示此effect对象有需要执行的副作用回调。</li>
<li><code>hookFlags</code> 表示副作用的类型标记，比如 <code>HookPassive</code>，<code>HookLayout</code>。</li>
<li>所以依赖发生变化的唯一区别就是：打上了 <code>HookHasEffect</code> 标记。最终会 <code>commit</code> 阶段中执行回调时，判断 <code>effect.tag</code> 的值来判断是否执行回调。</li>
</ul>
</li>
</ul>
<p>到此，函数组件的第二个hook：useEffect更新完成。</p>
<h3 id="2-3-updateLayoutEffect"><a href="#2-3-updateLayoutEffect" class="headerlink" title="2.3 updateLayoutEffect"></a>2.3 updateLayoutEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>useEffect</code> 和 <code>useLayoutEffect</code> 共用了同一个更新方法 <code>updateEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<ul>
<li>调用 <code>updateWorkInProgressHook</code> 方法：创建新 <code>hook</code> 对象，此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向更新为：</li>
</ul>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png" alt="alt text"></p>
<ul>
<li>判断 <code>deps</code> 依赖是否变化，如果变化则为对应的 <code>effect</code> 对象打上 <code>HookHasEffect</code> 的标记。</li>
</ul>
<p>到此，函数组件更新阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>函数组件更新阶段主要有这两个重点逻辑：</p>
<ul>
<li>根据 <code>updateQueue</code> 更新队列，循环计算 <code>state</code>，最后将最新的 <code>state</code> 数据存储到 <code>Fiber.memoizedState</code> 属性上并返回。</li>
<li>更新 <code>Effect</code>类 <code>hook</code> 时，判断依赖是否变化打上 <code>HookHasEffect</code>，最后会根据 <code>effect.tag</code> 值来决定本次更新是否执行回调。</li>
</ul>
<p><code>useEffect</code> 和 <code>useLayoutEffect</code>的区别：<code>useLayoutEffect</code> 是 <code>useEffect</code> 的一个变种，它们都是在 <code>React</code> 组件中处理副作用的方法。两者之间的主要区别在于它们的执行时机。</p>
<ul>
<li><code>useEffect</code> 的回调函数会在每次渲染结束后异步执行，这意味着它不会阻塞浏览器的渲染过程。换句话说，<code>React</code> 会在处理 <code>useEffect</code> 内部的状态更新之前，让浏览器先绘制屏幕。</li>
<li>而 <code>useLayoutEffect</code> 的回调函数会在每次渲染结束后同步执行。这意味着它会阻塞浏览器的渲染过程，直到其执行完毕。因此，<code>useLayoutEffect</code> 可以在浏览器重新绘制屏幕之前触发。</li>
</ul>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 会阻塞浏览器的渲染过程，如果过度使用，可能会导致应用程序变慢，甚至引发性能问题。因此，在大多数情况下，应优先考虑使用 <code>useEffect</code>。只有在某些特定情况下，例如需要在 <code>DOM</code> 更新后立即进行某些操作，或者需要在用户看到渲染结果之前进行某些操作，才考虑使用 <code>useLayoutEffect</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2类组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-09T00:00:00+08:00">2024-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1. 加载阶段"></a>1. 加载阶段</h2><h3 id="1-1-updateClassComponent"><a href="#1-1-updateClassComponent" class="headerlink" title="1.1 updateClassComponent"></a>1.1 updateClassComponent</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasContext;</span><br><span class="line">  <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = <span class="literal">true</span>;</span><br><span class="line">    pushLegacyContextProvider(workInProgress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hasContext = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line">  <span class="comment">// 类组件节点的stateNode 不是存储dom元素，而是组件实例 【hostComponent的stateNode才是dom元素】</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  # 第一次class组件加载，instance都为null</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化构建组件实例</span></span><br><span class="line">    constructClassInstance(workInProgress, Component, nextProps);</span><br><span class="line">    <span class="comment">// 加载组件实例</span></span><br><span class="line">    mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// In a resume, we'll already have an instance we can reuse.</span></span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update阶段：判断是否更新class组件</span></span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 最后：创建class组件child</span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  # 返回child子节点</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassComponent</code> 方法的内容并不复杂，主要就是两个逻辑的执行：</p>
<ol>
<li>class组件实例的创建或者更新。</li>
<li>创建组件的child子节点，最后返回子节点。</li>
</ol>
<h3 id="1-2-构建class组件实例-constructClassInstance"><a href="#1-2-构建class组件实例-constructClassInstance" class="headerlink" title="1.2 构建class组件实例 - constructClassInstance"></a>1.2 构建class组件实例 - constructClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  # 创建class实例对象，参数为props和context</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将instance实例对象的state数据同步到Fiber节点的memoizedState属性</span></span><br><span class="line">  <span class="keyword">const</span> state = (workInProgress.memoizedState =</span><br><span class="line">    instance.state !== <span class="literal">null</span> &amp;&amp; instance.state !== <span class="literal">undefined</span></span><br><span class="line">      ? instance.state</span><br><span class="line">      : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  # 确定class组件实例：即链接FiberNode与对应的组件实例</span><br><span class="line">  adoptClassInstance(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dev开发环境下的警告：如果class组件使用了过时的生命周期钩子，发出对应的警告</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  # 返回创建完成的实例</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-adoptClassInstance"><a href="#1-2-1-adoptClassInstance" class="headerlink" title="1.2.1 adoptClassInstance"></a>1.2.1 adoptClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adoptClassInstance</span>(<span class="params">workInProgress: Fiber, instance: any</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  instance.updater = classComponentUpdater;</span><br><span class="line">  <span class="comment">// Fiber节点存储instance实例</span></span><br><span class="line">  workInProgress.stateNode = instance;</span><br><span class="line">  <span class="comment">// instance对象定义一个_reactInternal内部属性存储Fiber节点</span></span><br><span class="line">  setInstance(instance, workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-加载组件-mountClassInstance"><a href="#1-3-加载组件-mountClassInstance" class="headerlink" title="1.3 加载组件 - mountClassInstance"></a>1.3 加载组件 - mountClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出class组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="comment">// props</span></span><br><span class="line">  instance.props = newProps;</span><br><span class="line">  <span class="comment">// 同步state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line">  <span class="comment">// ref：默认为空对象</span></span><br><span class="line">  instance.refs = emptyRefsObject;</span><br><span class="line">  <span class="comment">// 初始化一个Fiber节点的更新队列</span></span><br><span class="line">  # 设置更新队列对象：fiber.updateQueue = queue;</span><br><span class="line">  initializeUpdateQueue(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步组件实例的state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">    applyDerivedStateFromProps(</span><br><span class="line">      workInProgress,</span><br><span class="line">      ctor,</span><br><span class="line">      getDerivedStateFromProps,</span><br><span class="line">      newProps,</span><br><span class="line">    );</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to support react-lifecycles-compat polyfilled components,</span></span><br><span class="line">  <span class="comment">// Unsafe lifecycles should not be invoked for components using the new APIs.</span></span><br><span class="line">  <span class="comment">// 不应该使用旧的生命周期钩子</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> ctor.getDerivedStateFromProps !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="string">'function'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> instance.componentWillMount === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    # 触发WillMount生命周期钩子</span><br><span class="line">    callComponentWillMount(workInProgress, instance);</span><br><span class="line">    <span class="comment">// If we had additional state updates during this life-cycle, let's</span></span><br><span class="line">    <span class="comment">// process them now.</span></span><br><span class="line">    processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 如果设置了class组件的componentDidMount生命周期钩子函数，则需要在组件的FiberNode上设置对应的flags</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidMount === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fiberFlags: Flags = Update;</span><br><span class="line">    <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">      fiberFlags |= LayoutStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workInProgress.flags |= fiberFlags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先更新了 <code>instance</code> 组件实例上的一些属性，然后初始化了当前组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个更新队列对象</span></span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState, <span class="comment">// 初始state数据</span></span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>, <span class="comment">// 存储update链表</span></span><br><span class="line">      lanes: NoLanes,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置updateQueue属性</span></span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是针对 <code>componentWillMount</code> 生命周期钩子函数的处理，虽然是过时的API，但是如果定义了还是需要在这里触发。</p>
<p>最后如果定义了 <code>componentDidMount</code> 钩子函数，则需要给该 <code>Fiber</code> 节点的 <code>flags</code> 属性设置对应的副作用标记。</p>
<p><code>flags</code> 标记的作用是在 <code>commit</code> 阶段执行对应的副作用操作，所以 <code>componentDidMount</code> 钩子函数会在 <code>commit</code> 阶段中进行触发调用。</p>
<p>到此，类组件的加载就完成了。</p>
<h2 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># setState原理</span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用updater中的一个方法</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-enqueueSetState"><a href="#2-1-enqueueSetState" class="headerlink" title="2.1 enqueueSetState"></a>2.1 enqueueSetState</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  enqueueSetState(inst: any, <span class="attr">payload</span>: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ! 1. 获取current和lane</span></span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 创建update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(lane);</span><br><span class="line">    update.payload = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 3. update入队fiber.updateQueue中, 并返回应用的root根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueUpdate(fiber, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 4. 调度更新(开启一个从root根节点开始的更新调度)</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      <span class="comment">// ! 5. 处理transitions，非紧急更新</span></span><br><span class="line">      entangleTransitions(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">      markStateUpdateScheduled(fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueReplaceState(inst: any, <span class="attr">payload</span>: any, <span class="attr">callback</span>: <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueForceUpdate(inst: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-enqueueUpdate"><a href="#2-1-1-enqueueUpdate" class="headerlink" title="2.1.1 enqueueUpdate"></a>2.1.1 enqueueUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateQueue = fiber.updateQueue;</span><br><span class="line">  <span class="keyword">const</span> sharedQueue: SharedQueue&lt;State&gt; = (updateQueue: any).shared;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-enqueueConcurrentClassUpdate"><a href="#2-1-2-enqueueConcurrentClassUpdate" class="headerlink" title="2.1.2 enqueueConcurrentClassUpdate"></a>2.1.2 enqueueConcurrentClassUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentClassUpdate</span>(<span class="params">fiber, sharedQueue, update, lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> interleaved = sharedQueue.interleaved;</span><br><span class="line">  <span class="comment">// 第一个update对象入队</span></span><br><span class="line">  <span class="keyword">if</span> (interleaved === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.next = update;</span><br><span class="line">    pushConcurrentUpdateQueue(sharedQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他的update对象入队</span></span><br><span class="line">    update.next = interleaved.next;</span><br><span class="line">    interleaved.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  sharedQueue.interleaved = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>enqueueSetState</code> 方法中，这个方法最后会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h3 id="2-2-performSyncWorkOnRoot"><a href="#2-2-performSyncWorkOnRoot" class="headerlink" title="2.2 performSyncWorkOnRoot"></a>2.2 performSyncWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// If passive effects were flushed, exit to the outer work loop in the root</span></span><br><span class="line">    <span class="comment">// scheduler, so we can recompute the priority.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We don't actually need this `ensureRootIsScheduled` call because</span></span><br><span class="line">    <span class="comment">// this path is only reachable if the root is already part of the schedule.</span></span><br><span class="line">    <span class="comment">// I'm including it only for consistency with the other exit points from</span></span><br><span class="line">    <span class="comment">// this function. Can address in a subsequent refactor.</span></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; enableProfilerNestedUpdatePhase) &#123;</span><br><span class="line">    syncNestedUpdateFlag();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * setState</span></span><br><span class="line">  <span class="comment">// !1. render阶段</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">  <span class="keyword">if</span> (root.tag !== LegacyRoot &amp;&amp; exitStatus === RootErrored) &#123;</span><br><span class="line">    <span class="comment">// If something threw an error, try rendering one more time. We'll render</span></span><br><span class="line">    <span class="comment">// synchronously to block concurrent data mutations, and we'll includes</span></span><br><span class="line">    <span class="comment">// all pending updates are included. If it still fails after the second</span></span><br><span class="line">    <span class="comment">// attempt, we'll give up and commit the resulting tree.</span></span><br><span class="line">    <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">    <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">      root,</span><br><span class="line">      originallyAttemptedLanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">      lanes = errorRetryLanes;</span><br><span class="line">      exitStatus = recoverFromConcurrentError(</span><br><span class="line">        root,</span><br><span class="line">        originallyAttemptedLanes,</span><br><span class="line">        errorRetryLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">    <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">    prepareFreshStack(root, NoLanes);</span><br><span class="line">    markRootSuspended(root, lanes, NoLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">throw</span> fatalError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">    <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">    <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">    <span class="comment">// consistent tree or committing.</span></span><br><span class="line">    markRootSuspended(root, lanes, workInProgressDeferredLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We now have a consistent tree. Because this is a sync render, we</span></span><br><span class="line">  <span class="comment">// will commit it even if something suspended.</span></span><br><span class="line">  <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">  root.finishedWork = finishedWork;</span><br><span class="line">  root.finishedLanes = lanes;</span><br><span class="line">  <span class="comment">// ! 2. commit阶段</span></span><br><span class="line">  commitRoot(</span><br><span class="line">    root,</span><br><span class="line">    workInProgressRootRecoverableErrors,</span><br><span class="line">    workInProgressTransitions,</span><br><span class="line">    workInProgressRootDidIncludeRecursiveRenderUpdate,</span><br><span class="line">    workInProgressDeferredLane,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before exiting, make sure there's a callback scheduled for the next</span></span><br><span class="line">  <span class="comment">// pending level.</span></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-updateClassInstance"><a href="#2-3-updateClassInstance" class="headerlink" title="2.3 updateClassInstance"></a>2.3 updateClassInstance</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassInstance</code> 方法里面的内容比较多，我们分成以下几个部分来分析</p>
<h4 id="2-3-1-根据updateQueue计算state"><a href="#2-3-1-根据updateQueue计算state" class="headerlink" title="2.3.1 根据updateQueue计算state"></a>2.3.1 根据updateQueue计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出组件实例</span></span><br><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"># 从旧节点上克隆updateQueue信息，包含了shared.pending中等待处理的更新操作</span><br><span class="line">cloneUpdateQueue(current, workInProgress);</span><br><span class="line"><span class="comment">// 旧的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedOldProps = workInProgress.memoizedProps;</span><br><span class="line"><span class="keyword">const</span> oldProps =</span><br><span class="line">  workInProgress.type === workInProgress.elementType</span><br><span class="line">    ? unresolvedOldProps</span><br><span class="line">    : resolveDefaultProps(workInProgress.type, unresolvedOldProps);</span><br><span class="line">instance.props = oldProps;</span><br><span class="line"><span class="comment">// 新的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedNewProps = workInProgress.pendingProps;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line"><span class="keyword">const</span> hasNewLifecycles =</span><br><span class="line">  <span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span> ||</span><br><span class="line">  <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出旧的数据</span></span><br><span class="line"><span class="keyword">const</span> oldState = workInProgress.memoizedState;</span><br><span class="line"><span class="keyword">let</span> newState = (instance.state = oldState);</span><br><span class="line"># 更新组件实例的数据</span><br><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">newState = workInProgress.memoizedState;</span><br></pre></td></tr></table></figure>
<p>首先处理之前的 <code>updateQueue</code> 信息：</p>
<p>这里就是将 <code>current</code> 节点中的 <code>updateQueue</code> 信息克隆到 <code>workInProgress</code> 节点中对应的属性中。<br><strong>注意：</strong>react应用每次更新都会执行Fiber Reconciler流程【即FiberTree的创建流程】，在进入此流程之前，current节点会存储本次更新相关的一些信息，但是在进入此流程之后，current就变成了旧的节点，workInProgress代表新建的节点，此时就需要将current节点上的一些信息保存到新的节点之中，也就是对应的workInProgress。</p>
<p>从class类中取出 <code>getDerivedStateFromProps</code> 钩子，判断当前类组件有没有使用此钩子，如果没有使用则设置变量 <code>hasNewLifecycles</code> 为 <code>false</code>，此变量的作用是后续判断其他生命周期钩子的执行与否。</p>
<p>下面开始对state的处理：</p>
<ol>
<li>首先取出旧的state数据：</li>
<li>重点：调用processUpdateQueue方法，根据updateQueue信息，计算生成新的state数据。</li>
</ol>
<h5 id="2-3-1-1-processUpdateQueue"><a href="#2-3-1-1-processUpdateQueue" class="headerlink" title="2.3.1.1 processUpdateQueue"></a>2.3.1.1 processUpdateQueue</h5><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = workInProgress.updateQueue;</span><br><span class="line">  <span class="keyword">let</span> firstBaseUpdate = queue.firstBaseUpdate; <span class="comment">// 第一个处理的update，一个完整指向的队列</span></span><br><span class="line">  <span class="keyword">let</span> lastBaseUpdate = queue.lastBaseUpdate; <span class="comment">// 最后一个处理的update</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if there are pending updates. If so, transfer them to the base queue.</span></span><br><span class="line">  <span class="comment">// pending：等待处理的更新操作</span></span><br><span class="line">  <span class="comment">// 如果pending存在内容，则重置它，将它的内容转移到基础队列 firstBaseUpdate</span></span><br><span class="line">  <span class="keyword">let</span> pendingQueue = queue.shared.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 重置pending：因为workInProgress和current同用一个shared对象，所以current的pengding也重置了</span></span><br><span class="line">    queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    # 重构pendingQueue，将单向环状链表变成普通的单向链表</span><br><span class="line">    <span class="comment">// 最后处理的update对象</span></span><br><span class="line">    <span class="keyword">const</span> lastPendingUpdate = pendingQueue;</span><br><span class="line">    <span class="comment">// 第一个处理的update对象</span></span><br><span class="line">    <span class="keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;</span><br><span class="line">    <span class="comment">// 断开链接：最后一个update不再指向第一个update，形成一个单向链表，不再首尾相连</span></span><br><span class="line">    lastPendingUpdate.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Append pending updates to base queue</span></span><br><span class="line">    <span class="comment">// 将等待处理的更新对象添加到firstBaseUpdate基础更新队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstBaseUpdate = firstPendingUpdate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastBaseUpdate.next = firstPendingUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These values may change as we process the queue.</span></span><br><span class="line">  <span class="comment">// 当我们处理队列时，这些值可能会发生变化。</span></span><br><span class="line">  <span class="keyword">if</span> (firstBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Iterate through the list of updates to compute the result.</span></span><br><span class="line">    <span class="keyword">let</span> newState = queue.baseState;</span><br><span class="line">    <span class="keyword">let</span> newLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newFirstBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newLastBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">    # 第一个更新的update</span><br><span class="line">    <span class="keyword">let</span> update = firstBaseUpdate;</span><br><span class="line"></span><br><span class="line">    # 循环update链表计算state</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Don't need this field anymore</span></span><br><span class="line">      <span class="keyword">const</span> updateEventTime = update.eventTime;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据每个update对象的lane来判断是否更新：</span></span><br><span class="line">      <span class="comment">// 检查此更新update是否是在隐藏树时进行的。如果是，组件在隐藏时不需要更新</span></span><br><span class="line">      <span class="comment">// 跳过更新</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// 不必更新【跳过更新】</span></span><br><span class="line">		...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line">        <span class="comment">// 此更新具有足够的优先级【正常更新】</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newLastBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;State&gt; = &#123;</span><br><span class="line">            eventTime: updateEventTime,</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line"></span><br><span class="line">            tag: update.tag,</span><br><span class="line">            payload: update.payload,</span><br><span class="line">            callback: update.callback,</span><br><span class="line"></span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        # 处理当前update对象</span><br><span class="line">        newState = getStateFromUpdate(</span><br><span class="line">          workInProgress,</span><br><span class="line">          queue,</span><br><span class="line">          update,</span><br><span class="line">          newState,</span><br><span class="line">          props,</span><br><span class="line">          instance,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">const</span> callback = update.callback;</span><br><span class="line">        <span class="comment">// If the update was already committed, we should not queue its</span></span><br><span class="line">        <span class="comment">// callback again.</span></span><br><span class="line">        # 如果存在回调函数，则添加到队列的effects数组中，表示有副作用等待执行</span><br><span class="line">        <span class="keyword">if</span> (callback !== <span class="literal">null</span> &amp;&amp; update.lane !== NoLane) &#123;</span><br><span class="line">          workInProgress.flags |= Callback;</span><br><span class="line">          <span class="keyword">const</span> effects = queue.effects;</span><br><span class="line">          <span class="keyword">if</span> (effects === <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.effects = [update];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effects.push(update);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新update为下一个等待处理的对象</span></span><br><span class="line">      update = update.next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update有值，开启下一次循环</span></span><br><span class="line">      <span class="keyword">if</span> (update === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为null，代表链表执行完成，退出循环，表示本次更新state计算完成</span></span><br><span class="line">        pendingQueue = queue.shared.pending;</span><br><span class="line">        <span class="keyword">if</span> (pendingQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// An update was scheduled from inside a reducer. Add the new</span></span><br><span class="line">          <span class="comment">// pending updates to the end of the list and keep processing.</span></span><br><span class="line">          <span class="keyword">const</span> lastPendingUpdate = pendingQueue;</span><br><span class="line">          <span class="comment">// Intentionally unsound. Pending updates form a circular list, but we</span></span><br><span class="line">          <span class="comment">// unravel them when transferring them to the base queue.</span></span><br><span class="line">          <span class="keyword">const</span> firstPendingUpdate = ((lastPendingUpdate.next: any): Update&lt;State&gt;);</span><br><span class="line">          lastPendingUpdate.next = <span class="literal">null</span>;</span><br><span class="line">          update = firstPendingUpdate;</span><br><span class="line">          queue.lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">          queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.baseState = ((newBaseState: any): State);</span><br><span class="line">    queue.firstBaseUpdate = newFirstBaseUpdate;</span><br><span class="line">    queue.lastBaseUpdate = newLastBaseUpdate;</span><br><span class="line"></span><br><span class="line">    markSkippedUpdateLanes(newLanes);</span><br><span class="line">    workInProgress.lanes = newLanes;</span><br><span class="line">    <span class="comment">// 更新state数据</span></span><br><span class="line">    workInProgress.memoizedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-调用getDerivedStateFromProps钩子"><a href="#2-3-2-调用getDerivedStateFromProps钩子" class="headerlink" title="2.3.2 调用getDerivedStateFromProps钩子"></a>2.3.2 调用getDerivedStateFromProps钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  applyDerivedStateFromProps(</span><br><span class="line">    workInProgress,</span><br><span class="line">    ctor,</span><br><span class="line">    getDerivedStateFromProps,</span><br><span class="line">    newProps,</span><br><span class="line">  );</span><br><span class="line">  newState = workInProgress.memoizedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>getDerivedStateFromProps</code> 钩子函数，则在此触发此回调。</p>
<h4 id="2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新"><a href="#2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新" class="headerlink" title="2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新"></a>2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldUpdate =</span><br><span class="line">    <span class="comment">// 检查是否为强制更新</span></span><br><span class="line">    checkHasForceUpdateAfterProcessing() ||</span><br><span class="line">    <span class="comment">// 调用shouldComponentUpdate钩子，检查是否应该更新</span></span><br><span class="line">    checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)</span><br></pre></td></tr></table></figure>


<h5 id="2-3-3-1-checkHasForceUpdateAfterProcessing"><a href="#2-3-3-1-checkHasForceUpdateAfterProcessing" class="headerlink" title="2.3.3.1 checkHasForceUpdateAfterProcessing"></a>2.3.3.1 checkHasForceUpdateAfterProcessing</h5><p><code>checkHasForceUpdateAfterProcessing</code> 方法返回一个变量的状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">checkHasForceUpdateAfterProcessing</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasForceUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasForceUpdate</code> 是一个全局变量，它默认为 <code>false</code> ，表示非强制更新，它的修改就在之前计算state的逻辑中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newState = getStateFromUpdate(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line">		<span class="keyword">case</span> ReplaceState: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> CaptureUpdate: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> UpdateState: &#123;&#125;</span><br><span class="line">		<span class="comment">// 强制更新 场景</span></span><br><span class="line">		<span class="keyword">case</span> ForceUpdate: &#123;</span><br><span class="line">      		hasForceUpdate = <span class="literal">true</span>;</span><br><span class="line">      		<span class="keyword">return</span> prevState;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为 <code>this.forceUpdate</code> 触发的场景，就会进入 <code>ForceUpdate</code> 分支，更新变量 <code>hasForceUpdate</code> 的值为 <code>true</code>。</p>
<p>这时在校验组件是否应该更新时，就会返回 <code>true</code>，代表组件需要更新。</p>
<p>而我们当前是通过 <code>this.setState</code> 修改数据触发的更新，所以当前 <code>hasForceUpdate</code> 是为 <code>false</code> 的，这也是绝大部分类组件更新的场景。</p>
<h5 id="2-3-3-2-checkShouldComponentUpdate"><a href="#2-3-3-2-checkShouldComponentUpdate" class="headerlink" title="2.3.3.2 checkShouldComponentUpdate"></a>2.3.3.2 checkShouldComponentUpdate</h5><p>查看 <code>checkShouldComponentUpdate</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkShouldComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldState,</span></span></span><br><span class="line"><span class="function"><span class="params">  newState,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.shouldComponentUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      nextContext,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对PureComponent纯组件的 内部校验</span></span><br><span class="line">  <span class="keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkShouldComponentUpdate</code> 方法也比较简单，主要就是调用一次我们定义的 <code>shouldComponentUpdate</code> 钩子，根据调用的返回值来决定类组件是否应该更新，如果我们没有使用 <code>shouldComponentUpdate</code> 钩子，则类组件是默认需要更新的。</p>
<p>同时在这里我们还可以发现有一个针对 <code>PureComponent</code> 纯组件的更新校验，这其实就是 <code>PureComponent</code> 和 <code>Component</code> 唯一的区别，纯组件 <code>PureComponent</code>在react内部自动帮助我们对 <code>props</code> 和 <code>state</code> 进行了浅比较，任何一个变化则返回 <code>true</code>，需要更新组件。</p>
<h4 id="2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"><a href="#2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记" class="headerlink" title="2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"></a>2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 执行componentWillUpdate钩子</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	instance.componentWillUpdate(newProps, newState, nextContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新flags标记</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Update;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Snapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>componentWillUpdate</code> 生命周期钩子函数，则会在此处调用此函数。</p>
<p>然后如果类组件定义了 <code>componentDidUpdate</code> 或者 <code>getSnapshotBeforeUpdate</code> 生命周期钩子函数，就会更新组件 <code>Fiber</code> 的 <code>flags</code> 副作用标记。</p>
<p>这些生命周期钩子会在commit阶段，真实DOM渲染完成之后，被触发执行。</p>
<p>最后同步更新组件实例instance的props和state：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance.props = newProps;</span><br><span class="line">instance.state = newState;</span><br></pre></td></tr></table></figure>

<p>到此，一个类组件的更新程序基本执行完成。</p>
<h3 id="2-4-commit阶段"><a href="#2-4-commit阶段" class="headerlink" title="2.4 commit阶段"></a>2.4 commit阶段</h3><p>前面全部的加载逻辑都是在Fiber Reconciler协调流程中执行的，即类组件大部分的加载或者更新逻辑都是在reconciler协调流程中完成的，还有剩下的一部分逻辑在commit阶段之中处理。</p>
<p>对于类组件的更新来说，在commit阶段主要还有以下两部分逻辑需要处理：</p>
<ol>
<li>执行类组件的 <code>componentDidUpdate</code> 生命周期钩子函数。</li>
<li>执行 <code>this.setState</code> 方法传入的回调函数。</li>
</ol>
<p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">    <span class="comment">// 根据组件类型：进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 类组件的处理</span></span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="comment">// 组件实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">			  <span class="comment">// mount加载阶段</span></span><br><span class="line"></span><br><span class="line">              # 触发componentDidMount 生命周期钩子函数【这类静态方法：是存储在instance对象原型上的】</span><br><span class="line">              instance.componentDidMount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// update更新阶段</span></span><br><span class="line">              <span class="keyword">const</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps</span><br><span class="line">                  : resolveDefaultProps( finishedWork.type, current.memoizedProps);</span><br><span class="line">              <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">			  # 触发componentDidUpdate 生命周期钩子函数</span><br><span class="line">              instance.componentDidUpdate( prevProps,prevState,</span><br><span class="line">                  instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 取出当前组件节点的updateQueue更新对象</span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishedWork代表当前处理的类组件Fiber节点，首先从fiber.stateNode属性中取出组件实例instance。然后根据进行判断，只有存在相关的副作用标记才会继续内部的逻辑：</p>
<p>然后判断current是否为null，current表示旧的虚拟DOM节点，在组件的更新阶段，它肯定是存在的。然后直接调用 <code>componentDidUpdate</code> 生命周期钩子函数即可。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>类组件的更新逻辑主要内容是以下两点：</p>
<ol>
<li><code>reconciler</code> 协调流程中循环 <code>update</code> 链表计算出最新的 <code>state</code>。</li>
<li><code>commit</code> 阶段中触发 <code>componentDidUpdate</code> 生命周期钩子函数以及循环执行 <code>this.setState</code> 的回调。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2调度器scheduler源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-15T00:00:00+08:00">2024-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心算法-最小堆"><a href="#核心算法-最小堆" class="headerlink" title="核心算法 - 最小堆"></a>核心算法 - 最小堆</h2><p><font color=gray><em>packages\scheduler\src\SchedulerMinHeap.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">type Heap&lt;T: Node&gt; = <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">type Node = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = heap.length;</span><br><span class="line">  heap.push(node);</span><br><span class="line">  siftUp(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">peek</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heap.length === <span class="number">0</span> ? <span class="literal">null</span> : heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (heap.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> last = heap.pop();</span><br><span class="line">  <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">    heap[<span class="number">0</span>] = last;</span><br><span class="line">    siftDown(heap, last, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftUp</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> parent = heap[parentIndex];</span><br><span class="line">    <span class="keyword">if</span> (compare(parent, node) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// The parent is larger. Swap positions.</span></span><br><span class="line">      heap[parentIndex] = node;</span><br><span class="line">      heap[index] = parent;</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The parent is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftDown</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">const</span> length = heap.length;</span><br><span class="line">  <span class="keyword">const</span> halfLength = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; halfLength) &#123;</span><br><span class="line">    <span class="keyword">const</span> leftIndex = (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = heap[leftIndex];</span><br><span class="line">    <span class="keyword">const</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> right = heap[rightIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the left or right node is smaller, swap with the smaller of those.</span></span><br><span class="line">    <span class="keyword">if</span> (compare(left, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        heap[index] = right;</span><br><span class="line">        heap[rightIndex] = node;</span><br><span class="line">        index = rightIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap[index] = left;</span><br><span class="line">        heap[leftIndex] = node;</span><br><span class="line">        index = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[index] = right;</span><br><span class="line">      heap[rightIndex] = node;</span><br><span class="line">      index = rightIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a: Node, b: Node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Compare sort index first, then task id.</span></span><br><span class="line">  <span class="keyword">const</span> diff = a.sortIndex - b.sortIndex;</span><br><span class="line">  <span class="keyword">return</span> diff !== <span class="number">0</span> ? diff : a.id - b.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h2><p>通过调用 <code>scheduleCallback</code> 方法进入调度器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从下面开始，我们将深入scheduler的源码：</p>
<h3 id="1-定义全局变量"><a href="#1-定义全局变量" class="headerlink" title="1. 定义全局变量"></a>1. 定义全局变量</h3><p><font color=gray><em>packages\scheduler\src\forks\Scheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;push, pop, peek&#125; <span class="keyword">from</span> <span class="string">'../SchedulerMinHeap'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerPriorities'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  enableIsInputPending,</span><br><span class="line">  enableIsInputPendingContinuous,</span><br><span class="line">  frameYieldMs,</span><br><span class="line">  continuousYieldMs,</span><br><span class="line">  maxYieldMs,</span><br><span class="line">  userBlockingPriorityTimeout,</span><br><span class="line">  lowPriorityTimeout,</span><br><span class="line">  normalPriorityTimeout,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerFeatureFlags'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  markTaskRun,</span><br><span class="line">  markTaskYield,</span><br><span class="line">  markTaskCompleted,</span><br><span class="line">  markTaskCanceled,</span><br><span class="line">  markTaskErrored,</span><br><span class="line">  markSchedulerSuspended,</span><br><span class="line">  markSchedulerUnsuspended,</span><br><span class="line">  markTaskStart,</span><br><span class="line">  stopLoggingProfilingEvents,</span><br><span class="line">  startLoggingProfilingEvents,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerProfiling'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Callback = <span class="function"><span class="params">boolean</span> =&gt;</span> ?Callback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> opaque type Task = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  callback: Callback | <span class="literal">null</span>,</span><br><span class="line">  priorityLevel: PriorityLevel,</span><br><span class="line">  startTime: number,</span><br><span class="line">  expirationTime: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  isQueued?: boolean,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间，通过performance或者Date</span></span><br><span class="line"><span class="keyword">let</span> getCurrentTime: <span class="function"><span class="params">()</span> =&gt;</span> number | DOMHighResTimeStamp;</span><br><span class="line"><span class="keyword">const</span> hasPerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> performance.now === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasPerformanceNow) &#123;</span><br><span class="line">  <span class="keyword">const</span> localPerformance = performance;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localPerformance.now();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> localDate = <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">const</span> initialTime = localDate.now();</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localDate.now() - initialTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tasks are stored on a min heap</span></span><br><span class="line"><span class="keyword">var</span> taskQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 没有延迟的任务</span></span><br><span class="line"><span class="keyword">var</span> timerQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 有延迟的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自增id，标记task唯一性</span></span><br><span class="line"><span class="comment">// Incrementing id counter. Used to maintain insertion order.</span></span><br><span class="line"><span class="keyword">var</span> taskIdCounter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line"><span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentTask = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> currentPriorityLevel = NormalPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="comment">// 是否有work在执行</span></span><br><span class="line"><span class="comment">// This is set while performing work, to prevent re-entrance.</span></span><br><span class="line"><span class="keyword">var</span> isPerformingWork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程是否在调度</span></span><br><span class="line"><span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有任务在倒计时</span></span><br><span class="line"><span class="keyword">var</span> isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taskTimeoutID: TimeoutID = (<span class="number">-1</span>: any);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> needsPaint = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capture local references to native APIs, in case a polyfill overrides them.</span></span><br><span class="line"><span class="keyword">const</span> localSetTimeout = <span class="keyword">typeof</span> setTimeout === <span class="string">'function'</span> ? setTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localClearTimeout =</span><br><span class="line">  <span class="keyword">typeof</span> clearTimeout === <span class="string">'function'</span> ? clearTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localSetImmediate =</span><br><span class="line">  <span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> ? setImmediate : <span class="literal">null</span>; <span class="comment">// IE and Node.js + jsdom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前是否有所有类型的输入事件，包括按键、鼠标、滚轮触控等DOM UI事件</span></span><br><span class="line"><span class="keyword">const</span> isInputPending =</span><br><span class="line">  <span class="keyword">typeof</span> navigator !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[prop-missing]</span></span><br><span class="line">  navigator.scheduling !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[incompatible-type]</span></span><br><span class="line">  navigator.scheduling.isInputPending !== <span class="literal">undefined</span></span><br><span class="line">    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否应该把控制权交换给主线程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldYieldToHost</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前程序运行时间</span></span><br><span class="line">  <span class="keyword">const</span> timeElapsed = getCurrentTime() - startTime;</span><br><span class="line">  <span class="comment">// 如果运行时间小于帧间隔时间5ms</span></span><br><span class="line">  <span class="keyword">if</span> (timeElapsed &lt; frameInterval) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main thread has been blocked for a non-negligible amount of time. We</span></span><br><span class="line">  <span class="comment">// may want to yield control of the main thread, so the browser can perform</span></span><br><span class="line">  <span class="comment">// high priority tasks. The main ones are painting and user input. If there's</span></span><br><span class="line">  <span class="comment">// a pending paint or a pending input, then we should yield. But if there's</span></span><br><span class="line">  <span class="comment">// neither, then we can yield less often while remaining responsive. We'll</span></span><br><span class="line">  <span class="comment">// eventually yield regardless, since there could be a pending paint that</span></span><br><span class="line">  <span class="comment">// wasn't accompanied by a call to `requestPaint`, or other main thread tasks</span></span><br><span class="line">  <span class="comment">// like network events.</span></span><br><span class="line">  <span class="keyword">if</span> (enableIsInputPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needsPaint) &#123;</span><br><span class="line">      <span class="comment">// There's a pending paint (signaled by `requestPaint`). Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeElapsed &lt; continuousInputInterval) &#123;</span><br><span class="line">      <span class="comment">// We haven't blocked the thread for that long. Only yield if there's a</span></span><br><span class="line">      <span class="comment">// pending discrete input (e.g. click). It's OK if there's pending</span></span><br><span class="line">      <span class="comment">// continuous input (e.g. mouseover).</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeElapsed &lt; maxInterval) &#123;</span><br><span class="line">      <span class="comment">// Yield if there's either a pending discrete or continuous input.</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending(continuousOptions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We've blocked the thread for a long time. Even if there's no pending</span></span><br><span class="line">      <span class="comment">// input, there may be some other scheduled work that we don't know about,</span></span><br><span class="line">      <span class="comment">// like a network event. Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `isInputPending` isn't available. Yield now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-根据环境设置生成宏任务调度函数"><a href="#2-根据环境设置生成宏任务调度函数" class="headerlink" title="2. 根据环境设置生成宏任务调度函数"></a>2. 根据环境设置生成宏任务调度函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE.</span></span><br><span class="line">  <span class="comment">// There's a few reasons for why we prefer setImmediate.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span></span><br><span class="line">  <span class="comment">// (Even though this is a DOM fork of the Scheduler, you could get here</span></span><br><span class="line">  <span class="comment">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// But also, it runs earlier which is the semantic we want.</span></span><br><span class="line">  <span class="comment">// If other browsers ever implement it, it's better to use it.</span></span><br><span class="line">  <span class="comment">// Although both of these would be inferior to native scheduling.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetImmediate(performWorkUntilDeadline);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetTimeout(performWorkUntilDeadline, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-任务调度器的入口函数"><a href="#3-任务调度器的入口函数" class="headerlink" title="3. 任务调度器的入口函数"></a>3. 任务调度器的入口函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务调度器的入口函数：并发模式下调度一个回调函数 【这里传入的callback就是performConcurrentWorkOnRoot】</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  priorityLevel: PriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: Callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: &#123;delay: number&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime(); <span class="comment">// 获取当前程序执行时间，performance.now()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime; <span class="comment">// 定义任务开始时间，不是执行时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'object'</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">'number'</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在延期，则开始时间 = 当前时间 + 延期时间</span></span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，开始时间 = 当前时间</span></span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开始时间直接等于currentTime</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义超时时间 【根据优先级，设置不同的超时时间】</span></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      <span class="comment">// Times out immediately，立即超时</span></span><br><span class="line">      timeout = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = userBlockingPriorityTimeout; <span class="comment">// 250</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="comment">// Never times out，永不超时</span></span><br><span class="line">      timeout = maxSigned31BitInt; <span class="comment">// Math.pow(2, 30) - 1， 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = lowPriorityTimeout; <span class="comment">// 10000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = normalPriorityTimeout; <span class="comment">// 5000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过期时间，也是理论上的任务执行时间，值越小，说明优先级越高，需要优先执行</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newTask: Task = &#123;</span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,</span><br><span class="line">    expirationTime,</span><br><span class="line">    sortIndex: <span class="number">-1</span>, <span class="comment">// 调度执行任务的依据</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始时间 大于当前时间：说明是延期任务，先加入到延时队列timerQueue</span></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// 有delay的任务</span></span><br><span class="line">    newTask.sortIndex = startTime; <span class="comment">// sortIndex是把任务从timerQueue中取出来放到taskQueue中的依据</span></span><br><span class="line">    push(timerQueue, newTask); <span class="comment">// 暂时存到timerQueue，等晚点到了执行时间，再放到taskQueue，再执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">      <span class="comment">// 所有任务都延迟了，而这是延迟时间最短的任务。</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">        <span class="comment">// 取消现有的setTimeout</span></span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule a timeout.</span></span><br><span class="line">      <span class="comment">// setTimeout</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有delay的任务，直接加入任务队列</span></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line">    <span class="comment">// Schedule a host callback, if needed. If we're already performing work,</span></span><br><span class="line">    <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">    <span class="comment">// 如果需要的话，调度一个HostCallback。如果我们已经在执行work，就等到下次我们让出控制权的时候。</span></span><br><span class="line">    <span class="comment">// 判断host回调任务是否已经被调度，以及是否正在工作中，只有host回调任务还没有被调度 且 当前并未在工作中；才会开启一个新的host回调任务</span></span><br><span class="line">    <span class="comment">// 【首次加载时，需要调度一个host回调任务】</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 设置host回调任务，触发localSetImmediate、MessageChannel或localSetTimeout，生成新的宏任务，在宏任务中执行工作循环workLoop</span></span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-调度异步执行，创建新的宏任务"><a href="#4-调度异步执行，创建新的宏任务" class="headerlink" title="4. 调度异步执行，创建新的宏任务"></a>4. 调度异步执行，创建新的宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 调度异步执行，创建新的宏任务</span></span><br><span class="line">    schedulePerformWorkUntilDeadline();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-异步执行宏任务"><a href="#5-异步执行宏任务" class="headerlink" title="5. 异步执行宏任务"></a>5. 异步执行宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在有效时间内执行工作</span></span><br><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line">    <span class="comment">// Keep track of the start time so we can measure how long the main thread</span></span><br><span class="line">    <span class="comment">// has been blocked.</span></span><br><span class="line">    <span class="comment">// 记录了一个work的起始时间，其实就是一个时间切片的起始时间，是个时间戳</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a scheduler task throws, exit the current browser task so the</span></span><br><span class="line">    <span class="comment">// error can be observed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Intentionally not using a try-catch, since that makes some debugging</span></span><br><span class="line">    <span class="comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span></span><br><span class="line">    <span class="comment">// remain true, and we'll continue the work loop.</span></span><br><span class="line">    <span class="keyword">let</span> hasMoreWork = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据返回判断是否还有工作</span></span><br><span class="line">      hasMoreWork = flushWork(currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">        <span class="comment">// 如果还有任务,则又触发调度宏任务事件，生成新的宏任务，即在下一个event loop中继续执行任务</span></span><br><span class="line">        schedulePerformWorkUntilDeadline();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Yielding to the browser will give it a chance to paint, so we can</span></span><br><span class="line">  <span class="comment">// reset this.</span></span><br><span class="line">  needsPaint = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We'll need a host callback the next time work is scheduled.</span></span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">    <span class="comment">// We scheduled a timeout but it's no longer needed. Cancel it.</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    cancelHostTimeout();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isPerformingWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> workLoop(initialTime);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有很多task，每个task都有一个callback，callback执行完了，就执行下一个task</span></span><br><span class="line"><span class="comment">// 一个work就是一个时间切片内执行的一些task</span></span><br><span class="line"><span class="comment">// 时间切片要循环，就是work要循环</span></span><br><span class="line"><span class="comment">// 返回为true，表示还有任务没有执行完，需要继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  <span class="comment">// 如果timerQueue中有*有效任务*到达执行时间，就放到taskQueue中</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line">  <span class="comment">// 从任务队列中取出队列第一个任务【注意：taskQueue中是按任务的到期时间expirationTime排序的，越小越先执行】</span></span><br><span class="line">  currentTask = peek(taskQueue);</span><br><span class="line">  <span class="comment">// 循环从taskQueue中取出任务</span></span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【重点判断】</span></span><br><span class="line"><span class="comment">     * 1，如果当前任务到期时间 大于 当前时间，说明任务还未过期</span></span><br><span class="line"><span class="comment">     * 2，shouldYieldToHost为true应该暂停</span></span><br><span class="line"><span class="comment">     * 总结：如果同时满足这两个条件，即任务还没过期，但是没有剩余可执行时间了，就应该跳出本次工作循环，</span></span><br><span class="line"><span class="comment">     * 让出主线程，交给渲染流水线，等待下一个宏任务执行task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      currentTask.callback = <span class="literal">null</span>;</span><br><span class="line">      currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">      <span class="comment">// 是否属于过期的任务，可能存在还没过期的任务。</span></span><br><span class="line">      <span class="keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span><br><span class="line">      <span class="comment">// 执行任务</span></span><br><span class="line">      <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">      currentTime = getCurrentTime();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果执行完后又返回了 function，赋值给当前任务的callback</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话，将当前任务移除。中断在这个位置发生，高优先任务会把低优先任务的callback置空。</span></span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pop(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTask = peek(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Return whether there's additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回是否还有任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 说明 currentTask 执行完了</span></span><br><span class="line">    <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理 timerQueue</span></span><br><span class="line">      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler periodically yields in case there is other work on the main</span></span><br><span class="line"><span class="comment">// thread, like user events. By default, it yields multiple times per frame.</span></span><br><span class="line"><span class="comment">// It does not attempt to align with frame boundaries, since most tasks don't</span></span><br><span class="line"><span class="comment">// need to be frame aligned; for those that do, use requestAnimationFrame.</span></span><br><span class="line"><span class="keyword">let</span> frameInterval = frameYieldMs;</span><br><span class="line"><span class="keyword">const</span> continuousInputInterval = continuousYieldMs;</span><br><span class="line"><span class="keyword">const</span> maxInterval = maxYieldMs;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuousOptions = &#123;<span class="attr">includeContinuous</span>: enableIsInputPendingContinuous&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceTimers</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check for tasks that are no longer delayed and add them to the queue.</span></span><br><span class="line">  <span class="keyword">let</span> timer = peek(timerQueue);</span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 无效的任务</span></span><br><span class="line">      <span class="comment">// Timer was cancelled.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.startTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      <span class="comment">// 任务已到达开始时间，转入taskQueue中</span></span><br><span class="line">      <span class="comment">// Timer fired. Transfer to the task queue.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">      timer.sortIndex = timer.expirationTime;</span><br><span class="line">      push(taskQueue, timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Remaining timers are pending.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = peek(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 把延迟任务从timerQueue中推入taskQueue</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Null out the callback to indicate the task has been canceled. (Can't</span></span><br><span class="line">  <span class="comment">// remove from the queue because you can't remove arbitrary nodes from an</span></span><br><span class="line">  <span class="comment">// array based heap, only the first one.)</span></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentPriorityLevel</span>(<span class="params"></span>): <span class="title">PriorityLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentPriorityLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostTimeout</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  callback: (currentTime: number</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">ms</span>: <span class="title">number</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  taskTimeoutID = localSetTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHostTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  localClearTimeout(taskTimeoutID);</span><br><span class="line">  taskTimeoutID = ((<span class="number">-1</span>: any): TimeoutID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  scheduleCallback,</span><br><span class="line">  cancelCallback,</span><br><span class="line">  getCurrentPriorityLevel,</span><br><span class="line">  shouldYieldToHost <span class="keyword">as</span> unstable_shouldYield,</span><br><span class="line">  getCurrentTime,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="核心流程图"><a href="#核心流程图" class="headerlink" title="核心流程图"></a>核心流程图</h2><h3 id="1-使用了-Scheduler-任务调度的流程图（Concurrent模式）"><a href="#1-使用了-Scheduler-任务调度的流程图（Concurrent模式）" class="headerlink" title="1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）"></a>1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<h3 id="2-没有使用-Scheduler-任务调度的流程图（legacy模式）"><a href="#2-没有使用-Scheduler-任务调度的流程图（legacy模式）" class="headerlink" title="2. 没有使用 Scheduler 任务调度的流程图（legacy模式）"></a>2. 没有使用 Scheduler 任务调度的流程图（legacy模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-1.png" alt="alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个比较泛的流程示例：<br><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-2.png" alt="alt text"></p>
<ul>
<li>在 React 中宏观来看，针对浏览器、Scheduler 、Reconciler 其实是有3层 Loop。浏览器级别的 eventLoop，Scheduler 级别的 workLoop，Reconciler 级别 workLoopConcurrent 。<ul>
<li>浏览器的 eventLoop 与 Scheduler 的关系<ul>
<li>每次 eventLoop 会执行宏任务的队列的宏任务，而 React 中的 Scheduler 就是用宏任务 setImmediate等 触发的。</li>
<li>当 eventLoop 开始执行跟 Scheduler 有关的宏任务时，Scheduler 会启动一次 workLoop，就是在遍历执行 Scheduler 中已存在的 taskQueue 队列的每个 task。</li>
</ul>
</li>
<li>Scheduler 与 Reconciler 的关系<ul>
<li>Scheduler中的 workLoop 中每执行一次 task，是通过调用 Reconciler 中的 performConcurrentWorkOnRoot 方法，即每一个 task 可以理解为是一个 performConcurrentWorkOnRoot 方法的调用。</li>
<li>performConcurrentWorkOnRoot 方法每次调用，其本质是在执行 workLoopConcurrent 方法，这个方法是在循环 performUnitOfWork 这个构建 Fiber 树中每个 Fiber 的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此可以梳理出来，3个大循环，从最开始的 eventLoop 的单个宏任务执行，会逐步触发 Scheduler 和 Reconciler 的任务循环执行。</p>
<ul>
<li>任务的中断与恢复，实现中断与恢复的逻辑分了2个部分，第一个是 Scheduler 中正在执行的 workLoop 的任务中断，第二个是 Reconciler 中正在执行的 workLoopConcurrent 的任务中断<ul>
<li>Reconciler 中的任务中断与恢复：在 workLoopConcurrent 的 while 循环中，通过 shouldYield() 方法来判断当前构建 fiber 树的执行过程是否超时，如果超时，则中断当前的 while 循环。由于每次 while 执行的 fiber 构建方法，即 performUnitOfWork 是按照每个 fiberNode 来遍历的，也就是说每完成一次 fiberNode 的 beginWork + completeWork 树的构建过程，会设置下一次 nextNode 的值 ，可以理解为中断时已经保留了下一次要构建的 fiberNode 指针，以至于不会下一次不知道从哪里继续。</li>
<li>Scheduler 中的任务中断与恢复：当执行任务时间超时后，如果 Reconciler 中的 performConcurrentWorkOnRoot 方法没有执行完成，会返回其自身。在 Scheduler 中，发现当前任务还有下一个任务没有执行完，则不会将当前任务从 taskQueue 中取出，同时会把 reconciler 中返回的待执行的回调函数继续赋值给当前任务，于是下一次继续启动 Scheduler 的任务时，也就连接上了。同时退出这次中断的任务前，会通过 messageChannel 向 eventLoop 的宏任务队列放入一个新的宏任务。</li>
<li>所以任务的恢复，其实就是从下一次 eventLoop 开始执行 Scheduler 相关的宏任务，而执行的宏任务也是 Reconciler 中断前赋值的 fiberNode，也就实现了整体的任务恢复。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89render-commit%E9%98%B6%E6%AE%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89render-commit%E9%98%B6%E6%AE%B5.html" class="post-title-link" itemprop="url">react18.2源码分析（四）render-commit阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-12T00:00:00+08:00">2024-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !3. commit</span></span><br><span class="line"><span class="comment">// 我们现在有了一个一致的树。下一步要么是 commit，要么是，如果有什么被暂停了，就等待一段时间后再 commit。</span></span><br><span class="line">root.finishedWork = finishedWork;</span><br><span class="line">root.finishedLanes = lanes;</span><br><span class="line">finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br></pre></td></tr></table></figure>

<h2 id="2-commit阶段-finishConcurrentRender"><a href="#2-commit阶段-finishConcurrentRender" class="headerlink" title="2. commit阶段 - finishConcurrentRender"></a>2. commit阶段 - finishConcurrentRender</h2><h3 id="2-1-finishConcurrentRender"><a href="#2-1-finishConcurrentRender" class="headerlink" title="2.1 finishConcurrentRender"></a>2.1 finishConcurrentRender</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishConcurrentRender</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  exitStatus: RootExitStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  commitRootWhenReady(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">      workInProgressRootRecoverableErrors,</span><br><span class="line">      workInProgressTransitions,</span><br><span class="line">      workInProgressRootDidIncludeRecursiveRenderUpdate,</span><br><span class="line">      lanes,</span><br><span class="line">      workInProgressDeferredLane,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-commitRootWhenReady"><a href="#2-2-commitRootWhenReady" class="headerlink" title="2.2 commitRootWhenReady"></a>2.2 commitRootWhenReady</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootWhenReady</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: Array&lt;CapturedValue&lt;mixed&gt;&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, commit immediately.</span></span><br><span class="line">  commitRoot(</span><br><span class="line">    root,</span><br><span class="line">    recoverableErrors,</span><br><span class="line">    transitions,</span><br><span class="line">    didIncludeRenderPhaseUpdate,</span><br><span class="line">    spawnedLane,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-commitRoot"><a href="#2-3-commitRoot" class="headerlink" title="2.3 commitRoot"></a>2.3 commitRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This no longer makes any sense. We already wrap the mutation and</span></span><br><span class="line">  <span class="comment">// layout phases. Should be able to remove.</span></span><br><span class="line">  <span class="keyword">const</span> previousUpdateLanePriority = getCurrentUpdatePriority();</span><br><span class="line">  <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">    setCurrentUpdatePriority(DiscreteEventPriority);</span><br><span class="line">    commitRootImpl(</span><br><span class="line">      root,</span><br><span class="line">      recoverableErrors,</span><br><span class="line">      transitions,</span><br><span class="line">      didIncludeRenderPhaseUpdate,</span><br><span class="line">      previousUpdateLanePriority,</span><br><span class="line">      spawnedLane,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ReactCurrentBatchConfig.transition = prevTransition;</span><br><span class="line">    setCurrentUpdatePriority(previousUpdateLanePriority);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-commitRootImpl"><a href="#2-4-commitRootImpl" class="headerlink" title="2.4 commitRootImpl"></a>2.4 commitRootImpl</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: EventPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> finishedWork = root.finishedWork;</span><br><span class="line">  <span class="keyword">const</span> lanes = root.finishedLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||</span><br><span class="line">    (finishedWork.flags &amp; PassiveMask) !== NoFlags</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">      rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">      pendingPassiveEffectsRemainingLanes = remainingLanes;</span><br><span class="line"></span><br><span class="line">      pendingPassiveTransitions = transitions;</span><br><span class="line">      scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ! 1. 异步执行 passive effects</span></span><br><span class="line">        flushPassiveEffects();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查HostFiber的子孙元素是存在副作用</span></span><br><span class="line">  <span class="keyword">const</span> subtreeHasEffects =</span><br><span class="line">    (finishedWork.subtreeFlags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line">  <span class="comment">// 检查HostFiber自身存在副作用</span></span><br><span class="line">  <span class="keyword">const</span> rootHasEffect =</span><br><span class="line">    (finishedWork.flags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何一个有副作用，说明需要更新，进入commit逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (subtreeHasEffects || rootHasEffect) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line">    ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前更新优先级</span></span><br><span class="line">    <span class="keyword">const</span> previousPriority = getCurrentUpdatePriority();</span><br><span class="line">    <span class="comment">// 设置同步优先级，commit必须同步执行</span></span><br><span class="line">    setCurrentUpdatePriority(DiscreteEventPriority);</span><br><span class="line">    <span class="comment">// 当前上下文</span></span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 进入commit阶段</span></span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在调用生命周期之前将其重置为null</span></span><br><span class="line">    ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 3. BeforeMutation阶段【这个阶段执行与flags相关的副作用】</span></span><br><span class="line">    <span class="keyword">const</span> shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 4. mutation阶段 (完成真实的dom渲染，更新页面)</span></span><br><span class="line">    commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染后，重置container容器信息</span></span><br><span class="line">    resetAfterCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Fiber双缓冲机制，完成Current Fiber Tree的切换</span></span><br><span class="line">    <span class="comment">// 其实也并不一定叫切换，就是将最新work内容存储为当前的内容，下一次的work就可以利用当前的内容</span></span><br><span class="line">    <span class="comment">// 注意：到这里是页面已经完成了更新渲染，这个交互Fiber Tree是为了保留最新的Tree，提供给下次更新使用</span></span><br><span class="line">    <span class="comment">// 同时也方便调用生命周期钩子时是最新的DOM</span></span><br><span class="line">    root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 5. layout阶段</span></span><br><span class="line">    commitLayoutEffects(finishedWork, root, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No effects.</span></span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-异步执行-passive-effects"><a href="#2-4-1-异步执行-passive-effects" class="headerlink" title="2.4.1 异步执行 passive effects"></a>2.4.1 异步执行 passive effects</h4><p>执行 useEffect 的 effects</p>
<h4 id="2-4-2-进入-commit-阶段"><a href="#2-4-2-进入-commit-阶段" class="headerlink" title="2.4.2 进入 commit 阶段"></a>2.4.2 进入 commit 阶段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executionContext |= CommitContext</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-beforeMutation阶段-commitBeforeMutationEffects"><a href="#2-4-3-beforeMutation阶段-commitBeforeMutationEffects" class="headerlink" title="2.4.3 beforeMutation阶段 - commitBeforeMutationEffects"></a>2.4.3 beforeMutation阶段 - commitBeforeMutationEffects</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  firstChild: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  focusedInstanceHandle = prepareForCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置第一个处理的节点为 hostFiber</span></span><br><span class="line">  nextEffect = firstChild;</span><br><span class="line">  <span class="comment">// 提交开始</span></span><br><span class="line">  commitBeforeMutationEffects_begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> shouldFire = shouldFireAfterActiveInstanceBlur;</span><br><span class="line">  shouldFireAfterActiveInstanceBlur = <span class="literal">false</span>;</span><br><span class="line">  focusedInstanceHandle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shouldFire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 <code>nextEffect</code> 变量，这里的 <code>firstChild</code> 代表第一个处理的节点为 <code>hostFiber</code>。</p>
<p>然后调用 <code>commitBeforeMutationEffects_begin</code>，开始递归遍历 <code>FiberTree</code>，处理有副作用的 <code>Fiber</code> 节点。</p>
<h5 id="2-4-3-1-commitBeforeMutationEffects-begin"><a href="#2-4-3-1-commitBeforeMutationEffects-begin" class="headerlink" title="2.4.3.1 commitBeforeMutationEffects_begin"></a>2.4.3.1 commitBeforeMutationEffects_begin</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects_begin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// while循环，处理所有节点</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// 取出子节点， 刚开始是hostFiber节点的child： 即App 组件</span></span><br><span class="line">    <span class="keyword">const</span> child = fiber.child;</span><br><span class="line">    <span class="comment">// 如果该fiber的子节点存在BeforeMutation阶段相关的flgas标记 且 child不为null;  则继续循环，</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (fiber.subtreeFlags &amp; BeforeMutationMask) !== NoFlags &amp;&amp;</span><br><span class="line">      child !== <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      child.return = fiber;</span><br><span class="line">      <span class="comment">// 设置child为下一个处理的节点</span></span><br><span class="line">      nextEffect = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 只有当fiber的子节点不存在BeforeMutation阶段相关的flgas标记 且 child为null; 【叶子节点】</span></span><br><span class="line">      <span class="comment">// 和reconciler流程一样，第一个进入complete工作的都是【div react源码调试】节点</span></span><br><span class="line">      commitBeforeMutationEffects_complete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-2-commitBeforeMutationEffects-complete"><a href="#2-4-3-2-commitBeforeMutationEffects-complete" class="headerlink" title="2.4.3.2 commitBeforeMutationEffects_complete"></a>2.4.3.2 commitBeforeMutationEffects_complete</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects_complete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    setCurrentDebugFiberInDEV(fiber);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理当前节点的副作用</span></span><br><span class="line">      commitBeforeMutationEffectsOnFiber(fiber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(fiber, fiber.return, error);</span><br><span class="line">    &#125;</span><br><span class="line">    resetCurrentDebugFiberInDEV();</span><br><span class="line">    <span class="comment">// 取出兄弟节点</span></span><br><span class="line">    <span class="keyword">const</span> sibling = fiber.sibling;</span><br><span class="line">    <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">      sibling.return = fiber.return;</span><br><span class="line">      <span class="comment">// 将兄弟节点设置为下一个nextEffect 【回到begin工作】</span></span><br><span class="line">      nextEffect = sibling;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = fiber.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitBeforeMutationEffects_complete方法也是一个while循环，对当前Fiber节点执行flags标记对应的操作，即执行commitBeforeMutationEffectsOnFiber方法。执行完成后，如果当前Fiber节点存在sibling兄弟节点，则将兄弟节点设置为最新的nextEffect，退出当前函数，开启兄弟节点的begin工作。如果不存在兄弟节点，则将当前Fiber节点的父级节点设置为最新的nextEffect，执行父级节点的commitBeforeMutationEffects_complete工作。</p>
<p>根据上面可以看出，BeforeMutation阶段逻辑和之前创建FiberTree的逻辑基本相同，都是深度优先遍历的顺序从HostFiber根节点开始【自上而下】遍历处理每一个满足条件的Fiber节点，执行flags对应的副作用操作，即相似的begin和complete工作逻辑。这里主要的执行内容在commitBeforeMutationEffectsOnFiber方法之中。</p>
<blockquote>
<p>注意，其实commit阶段中三个子阶段的逻辑：基本都是以这种逻辑方式来处理相关的副作用内容。</p>
</blockquote>
<h5 id="2-4-3-3-commitBeforeMutationEffectsOnFiber"><a href="#2-4-3-3-commitBeforeMutationEffectsOnFiber" class="headerlink" title="2.4.3.3 commitBeforeMutationEffectsOnFiber"></a>2.4.3.3 commitBeforeMutationEffectsOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffectsOnFiber</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点的类型，进行不同的副作用处理</span></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableUseEffectEventHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Update) !== NoFlags) &#123;</span><br><span class="line">          commitUseEffectEventMount(finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> prevProps = current.memoizedProps;</span><br><span class="line">          <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">          <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">const</span> snapshot = instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType === finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState,</span><br><span class="line">          );</span><br><span class="line">          instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hostFiber节点的处理</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">          <span class="comment">// 应用根节点</span></span><br><span class="line">          <span class="keyword">const</span> root = finishedWork.stateNode;</span><br><span class="line">          <span class="comment">// 设置textContent = ''; 也就是清空#div容器内容， 方便Mutation阶段的渲染</span></span><br><span class="line">          clearContainer(root.containerInfo);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="keyword">case</span> HostHoistable:</span><br><span class="line">    <span class="keyword">case</span> HostSingleton:</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent:</span><br><span class="line">      <span class="comment">// Nothing to do for these component types</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">'This unit of work tag should not have side-effects. This error is '</span> +</span><br><span class="line">            <span class="string">'likely caused by a bug in React. Please file an issue.'</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">    resetCurrentDebugFiberInDEV();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 <code>commitBeforeMutationEffectsOnFiber</code> 方法后，发现只有 <code>Snapshot</code> 标记的副作用才会执行。</p>
<blockquote>
<p><code>hostFiber</code> 节点的 <code>Snapshot</code> 副作用是在 <code>completeWork</code> 工作中被标记的。</p>
</blockquote>
<h5 id="2-4-3-4-BeforeMutation阶段总结"><a href="#2-4-3-4-BeforeMutation阶段总结" class="headerlink" title="2.4.3.4 BeforeMutation阶段总结"></a>2.4.3.4 BeforeMutation阶段总结</h5><p>所以BeforeMutation阶段最终只会执行这两种副作用：</p>
<ol>
<li>触发类组件的getSnapshotBeforeUpdate钩子。</li>
<li>处理HostRoot类型节点【HostFiber】，清空#root容器内容， 方便下面Mutation阶段的DOM挂载。</li>
</ol>
<h4 id="2-4-4-mutation-阶段-commitMutationEffects"><a href="#2-4-4-mutation-阶段-commitMutationEffects" class="headerlink" title="2.4.4 mutation 阶段 - commitMutationEffects"></a>2.4.4 mutation 阶段 - commitMutationEffects</h4><p>前面我们已经知道了 <code>MutationMask</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;</span><br></pre></td></tr></table></figure>

<p>而 <code>MutationMask</code> 就是代表 <code>Mutation</code> 阶段所需要执行的哪些副作用类型，虽然可以看到 <code>MutationMask</code> 集成了很多的副作用标记，但是 <code>Mutation</code> 阶段的重点内容：还是针对 <code>Fiber</code> 节点上 <code>DOM</code> 内容的处理，然后将最终的 <code>DOM</code> 内容渲染到页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);</span><br><span class="line"></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-1-commitMutationEffectsOnFiber"><a href="#2-4-4-1-commitMutationEffectsOnFiber" class="headerlink" title="2.4.4.1 commitMutationEffectsOnFiber"></a>2.4.4.1 commitMutationEffectsOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffectsOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧hostFiber 节点</span></span><br><span class="line">  <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">  <span class="comment">// 取出dom操作的标识flags</span></span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点tag，执行不同的逻辑</span></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数组件处理</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="comment">// recursivelyTraverse：递归遍历</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      <span class="comment">// app组件跳出了循环，向下继续执行</span></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          commitHookEffectListUnmount(</span><br><span class="line">            HookInsertion | HookHasEffect,</span><br><span class="line">            finishedWork,</span><br><span class="line">            finishedWork.return,</span><br><span class="line">          );</span><br><span class="line">          commitHookEffectListMount(</span><br><span class="line">            HookInsertion | HookHasEffect,</span><br><span class="line">            finishedWork,</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          enableProfilerTimer &amp;&amp;</span><br><span class="line">          enableProfilerCommitHooks &amp;&amp;</span><br><span class="line">          finishedWork.mode &amp; ProfileMode</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            startLayoutEffectTimer();</span><br><span class="line">            commitHookEffectListUnmount(</span><br><span class="line">              HookLayout | HookHasEffect,</span><br><span class="line">              finishedWork,</span><br><span class="line">              finishedWork.return,</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">          recordLayoutEffectDuration(finishedWork);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            commitHookEffectListUnmount(</span><br><span class="line">              HookLayout | HookHasEffect,</span><br><span class="line">              finishedWork,</span><br><span class="line">              finishedWork.return,</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类组件处理</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Ref) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          safelyDetachRef(current, current.return);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原生dom元素处理</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="comment">// 递归遍历</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      <span class="comment">// 处理dom</span></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Ref) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          safelyDetachRef(current, current.return);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">        <span class="comment">// 如果flags标记为ContentReset</span></span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; ContentReset) &#123;</span><br><span class="line">          <span class="comment">// dom实例</span></span><br><span class="line">          <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重置dom的内容</span></span><br><span class="line">            resetTextContent(instance);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果flgas标记为Update更新</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          <span class="comment">// 取出当前节点对应的DOM对象</span></span><br><span class="line">          <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">            <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">            <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">            <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">            <span class="comment">// this case.</span></span><br><span class="line">            <span class="keyword">const</span> oldProps =</span><br><span class="line">              current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">            <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">            <span class="keyword">const</span> updatePayload: <span class="literal">null</span> | UpdatePayload = (finishedWork.updateQueue: any);</span><br><span class="line">            finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                commitUpdate(</span><br><span class="line">                  instance,</span><br><span class="line">                  updatePayload,</span><br><span class="line">                  type,</span><br><span class="line">                  oldProps,</span><br><span class="line">                  newProps,</span><br><span class="line">                  finishedWork,</span><br><span class="line">                );</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                captureCommitPhaseError(</span><br><span class="line">                  finishedWork,</span><br><span class="line">                  finishedWork.return,</span><br><span class="line">                  error,</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文本处理</span></span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">          <span class="keyword">if</span> (finishedWork.stateNode === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">'This should have a text node initialized. This error is likely '</span> +</span><br><span class="line">                <span class="string">'caused by a bug in React. Please file an issue.'</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> textInstance: TextInstance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">const</span> newText: string = finishedWork.memoizedProps;</span><br><span class="line">          <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">          <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">          <span class="comment">// this case.</span></span><br><span class="line">          <span class="keyword">const</span> oldText: string =</span><br><span class="line">            current !== <span class="literal">null</span> ? current.memoizedProps : newText;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hostFiber根节点处理 【第一次会走根节点， 从根节点向下递归渲染dom】</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="comment">// recursivelyTraverse：递归遍历 【页面显示】</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation &amp;&amp; supportsHydration) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevRootState: RootState = current.memoizedState;</span><br><span class="line">            <span class="keyword">if</span> (prevRootState.isDehydrated) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                commitHydratedContainer(root.containerInfo);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                captureCommitPhaseError(</span><br><span class="line">                  finishedWork,</span><br><span class="line">                  finishedWork.return,</span><br><span class="line">                  error,</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (supportsPersistence) &#123;</span><br><span class="line">          <span class="keyword">const</span> containerInfo = root.containerInfo;</span><br><span class="line">          <span class="keyword">const</span> pendingChildren = root.pendingChildren;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            replaceContainerChildren(containerInfo, pendingChildren);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitMutationEffectsOnFiber</code> 方法内容很多，但是它的核心逻辑依然是switch case结构：根据当前Fiber节点tag值，对不同组件类型进行不同的逻辑处理。</p>
<p>要处理的组件类型有很多，我们主要掌握几个常见的组件类型处理逻辑：</p>
<ul>
<li>FunctionComponent：函数组件。</li>
<li>ClassComponent：类组件。</li>
<li>HostComponent：DOM节点。</li>
<li>HostText：文本节点。</li>
<li>HostRoot：HostFiber根节点。</li>
</ul>
<p>从上面几个组件类型的处理逻辑来看，它们都是一套相同的处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1，删除DOM</span></span><br><span class="line">recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line"><span class="comment">// 2，插入DOM</span></span><br><span class="line">commitReconciliationEffects(finishedWork);</span><br><span class="line"><span class="comment">// 3，更新(DOM内容)</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-2-Mutation阶段执行顺序"><a href="#2-4-4-2-Mutation阶段执行顺序" class="headerlink" title="2.4.4.2 Mutation阶段执行顺序"></a>2.4.4.2 Mutation阶段执行顺序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commitMutationEffectsOnFiber  =&gt; commit()</span><br><span class="line">recursivelyTraverseMutationEffects  这个方法中使用了循环，并且调用了上面的方法=&gt; <span class="keyword">for</span>()</span><br><span class="line"><span class="comment">// 2，插入DOM</span></span><br><span class="line">commitReconciliationEffects(finishedWork);  <span class="comment">// 2，3两部分视为一个内容 =&gt; content()</span></span><br><span class="line"><span class="comment">// 3，更新(DOM内容)</span></span><br><span class="line">commitPlacement(finishedWork);</span><br></pre></td></tr></table></figure>

<p>所以Mutation阶段的执行顺序就可以表示为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fiber顺序: <span class="function"><span class="params">HostFiber</span>  =&gt;</span>    fun App    =&gt; 	 div.App  =&gt;   ...</span><br><span class="line"><span class="comment">// 代码执行顺序</span></span><br><span class="line">commit</span><br><span class="line">	      <span class="keyword">for</span></span><br><span class="line">			      commit</span><br><span class="line">			  		  	    <span class="keyword">for</span></span><br><span class="line">						  		   commit</span><br><span class="line">						  				      <span class="keyword">for</span></span><br><span class="line">						  				  		     commit</span><br><span class="line">						  				  		  		      ...</span><br><span class="line">						  				      content</span><br><span class="line">						    content</span><br><span class="line">	      content</span><br></pre></td></tr></table></figure>

<p>执行顺序为从上往下，通过这种递归遍历方式，可以发现HostFiber虽然是第一个进入commit逻辑的节点，但是它的content内容却是最后一个执行，也就是说在HostFiber的content内容处理完成之后，即代表完整的DOM树已经渲染到页面。实际上最后执行插入到页面的操作是在【fun App】组件节点上执行的，后续会有说明，这部分内容在第三章也有解释。</p>
<p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9Brender-commit%E9%98%B6%E6%AE%B5/image.png" alt="alt text"></p>
<h5 id="2-4-4-3-recursivelyTraverseMutationEffects"><a href="#2-4-4-3-recursivelyTraverseMutationEffects" class="headerlink" title="2.4.4.3 recursivelyTraverseMutationEffects"></a>2.4.4.3 recursivelyTraverseMutationEffects</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyTraverseMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot, <span class="regexp">//</span> root</span></span></span><br><span class="line"><span class="function"><span class="params">  parentFiber: Fiber, <span class="regexp">//</span> HostFiber</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  # 删除标记，是否存在</span><br><span class="line">  <span class="keyword">const</span> deletions = parentFiber.deletions;</span><br><span class="line">  <span class="keyword">if</span> (deletions !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deletions.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> childToDelete = deletions[i];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行删除副作用</span></span><br><span class="line">        commitDeletionEffects(root, parentFiber, childToDelete);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        captureCommitPhaseError(childToDelete, parentFiber, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 如果子节点树有副作用标记</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.subtreeFlags &amp; MutationMask) &#123;</span><br><span class="line">    <span class="comment">// 取出子节点</span></span><br><span class="line">    <span class="keyword">let</span> child = parentFiber.child;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 开始递归渲染</span></span><br><span class="line">      commitMutationEffectsOnFiber(child, root, lanes);</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码可以看出，<code>recursivelyTraverseMutationEffects</code> 方法主要就两个逻辑：</p>
<ul>
<li>判断当前 <code>Fiber</code> 节点是否存在 <code>deletions</code> 删除标记，如果存在则循环 <code>deletions</code>，删除子节点对应DOM元素的内容。</li>
<li>遍历子树，递归调用 <code>commitMutationEffectsOnFiber</code>。</li>
</ul>
<p>这里主要讲解第一点内容删除的逻辑，第二点遍历的内容就是前面 <code>Mutation</code> 阶段执行顺序的内容。<br>具体的删除逻辑就是执行 <code>commitDeletionEffects</code> 方法，真实的删除逻辑比较复杂，删除一个DOM元素要考虑很多东西，这里我们不会展开 <code>commitDeletionEffects</code> 方法，但是还是要了解一下可能会造成的一些副作用影响：</p>
<ul>
<li>执行子树所有组件的 <code>unmount</code> 卸载逻辑。</li>
<li>执行子树某些类组件的 <code>componentWillUnmount</code> 方法。</li>
<li>执行子树某些函数组件的 <code>useEffect</code>，<code>useLayoutEffect</code>等 hooks 的 <code>destory</code> 销毁方法。</li>
<li>执行子树所有 <code>ref</code> 属性的卸载操作。</li>
</ul>
<p>这里将删除DOM的逻辑放在每个组件的第一个执行，也是非常必要的。因为Mutation阶段的核心就是DOM操作，如果对应的DOM都已经被删除了，那么也就没有必要再去执行剩下的修改更新了。</p>
<h5 id="2-4-4-4-commitReconciliationEffects"><a href="#2-4-4-4-commitReconciliationEffects" class="headerlink" title="2.4.4.4 commitReconciliationEffects"></a>2.4.4.4 commitReconciliationEffects</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitReconciliationEffects</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line">  <span class="comment">// 如果是插入/移动标记</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; Placement) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      # 执行dom插入添加操作</span><br><span class="line">      commitPlacement(finishedWork);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">    &#125;</span><br><span class="line">    finishedWork.flags &amp;= ~Placement;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; Hydrating) &#123;</span><br><span class="line">    finishedWork.flags &amp;= ~Hydrating;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>commitReconciliationEffects</code> 方法就是执行 <code>DOM</code> 的插入或者移动操作，判断当前 <code>Fiber</code> 节点是否存在 <code>Placement</code> 标记，存在就会执行 <code>commitPlacement</code> 方法，执行相关的 <code>DOM</code> 的操作。</p>
<h5 id="2-4-4-5-commitPlacement"><a href="#2-4-4-5-commitPlacement" class="headerlink" title="2.4.4.5 commitPlacement"></a>2.4.4.5 commitPlacement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// finishedWork: fun App 它的父级节点为HostFIber</span></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    # 普通DOM节点</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> parent: Instance = parentFiber.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (parentFiber.flags &amp; ContentReset) &#123;</span><br><span class="line">        resetTextContent(parent);</span><br><span class="line">        parentFiber.flags &amp;= ~ContentReset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      <span class="comment">// 插入节点</span></span><br><span class="line">      insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 处理HostFiber节点的插入动作：</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="keyword">case</span> HostPortal: &#123;</span><br><span class="line">      <span class="comment">// #div</span></span><br><span class="line">      <span class="keyword">const</span> parent: Container = parentFiber.stateNode.containerInfo;</span><br><span class="line">      <span class="comment">// 无兄弟节点</span></span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      # 将离屏的DOM树插入到#div； 马上页面上显示出DOM内容</span><br><span class="line">      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够执行 <code>Placement</code> 副作用的，只有两种组件节点 <code>HostComponent</code> 和 <code>HostRoot</code>。</p>
<p>对于 <code>HostComponent</code> 来说，就是常规的 <code>DOM</code> 插入和移动，即调用原生的 <code>DOM</code> 方法执行对应的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生DOM操作</span></span><br><span class="line">parentNode.appendChild()</span><br><span class="line">parentNode.insertBefore()</span><br></pre></td></tr></table></figure>

<h5 id="mutation阶段总结"><a href="#mutation阶段总结" class="headerlink" title="mutation阶段总结"></a>mutation阶段总结</h5><p>mutation 阶段的主要工作是：</p>
<ul>
<li>对 <code>DOM</code> 内容的增删改操作，最后将构建完成的离屏 <code>DOM</code> 树渲染到页面。</li>
<li>针对函数组件触发 <code>useInsertionEffect hook</code> 的副作用以及 <code>useLayoutEffect hook</code> 的 <code>destroy</code> 方法。</li>
<li>针对类组件和普通 <code>DOM</code> 组件重置 <code>ref</code> 对象的内容。</li>
</ul>
<h4 id="2-4-5-layout-阶段-commitLayoutEffects"><a href="#2-4-5-layout-阶段-commitLayoutEffects" class="headerlink" title="2.4.5 layout 阶段 - commitLayoutEffects"></a>2.4.5 layout 阶段 - commitLayoutEffects</h4><p>前面我们已经知道了 <code>LayoutMask</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutMask = Update | Callback | Ref | Visibility;</span><br></pre></td></tr></table></figure>

<p>而 <code>LayoutMask</code> 就是代表 <code>Layout</code> 阶段所需要执行的哪些副作用类型：</p>
<ul>
<li>类组件的 <code>componentDidMount/componentDidUpdate</code> 生命周期钩子函数的执行。</li>
<li>类组件调用 <code>this.setState</code> 时传递的 <code>callback</code> 回调函数的会被保存到 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性中在这里执行。</li>
<li>执行函数组件的 <code>useLayoutEffect hook</code> 回调。</li>
</ul>
<p>可以说 Layout 阶段的主要内容：就是在DOM渲染完成后，执行函数组件和类组件定义的一些callback回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HostFiber</span></span><br><span class="line">  nextEffect = finishedWork;</span><br><span class="line">  # 又是begin 和complete工作逻辑</span><br><span class="line">  # 相当于递归循环触发每个组件的生命周期钩子函数 以及相关的 hooks 回调</span><br><span class="line">  commitLayoutEffects_begin(finishedWork, root, committedLanes);</span><br><span class="line"></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-1-commitLayoutEffects-begin"><a href="#2-4-5-1-commitLayoutEffects-begin" class="headerlink" title="2.4.5.1 commitLayoutEffects_begin"></a>2.4.5.1 commitLayoutEffects_begin</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects_begin</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subtreeRoot: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isModernRoot = (subtreeRoot.mode &amp; ConcurrentMode) !== NoMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环触发</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// HostFiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// fun App组件节点</span></span><br><span class="line">    <span class="keyword">const</span> firstChild = fiber.child;</span><br><span class="line"></span><br><span class="line">    # 说明子树存在副作用，需要更新nextEffect为子节点，进入下一级的循环</span><br><span class="line">    <span class="keyword">if</span> ((fiber.subtreeFlags &amp; LayoutMask) !== NoFlags &amp;&amp; firstChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      firstChild.return = fiber;</span><br><span class="line">      nextEffect = firstChild;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      # 说明副作用在自身节点了，进入complete阶段</span><br><span class="line">      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-2-commitLayoutMountEffects-complete"><a href="#2-4-5-2-commitLayoutMountEffects-complete" class="headerlink" title="2.4.5.2 commitLayoutMountEffects_complete"></a>2.4.5.2 commitLayoutMountEffects_complete</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutMountEffects_complete</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subtreeRoot: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// while循环</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// 存在layout相关的副作用 才会进入</span></span><br><span class="line">    <span class="keyword">if</span> ((fiber.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = fiber.alternate;</span><br><span class="line">      setCurrentDebugFiberInDEV(fiber);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        # 执行副作用</span><br><span class="line">        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        captureCommitPhaseError(fiber, fiber.return, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 当回到HostFiber时，代表循环完成，退出layout工作</span><br><span class="line">    <span class="keyword">if</span> (fiber === subtreeRoot) &#123;</span><br><span class="line">      nextEffect = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 存在兄弟节点，开始兄弟节点的工作</span><br><span class="line">    <span class="keyword">const</span> sibling = fiber.sibling;</span><br><span class="line">    <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">      sibling.return = fiber.return;</span><br><span class="line">      nextEffect = sibling;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	# 不存在兄弟节点，则返回父级节点</span><br><span class="line">    nextEffect = fiber.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-3-commitLayoutEffectOnFiber"><a href="#2-4-5-3-commitLayoutEffectOnFiber" class="headerlink" title="2.4.5.3 commitLayoutEffectOnFiber"></a>2.4.5.3 commitLayoutEffectOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">    # 根据组件类型：进行不同的处理</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      # 1，函数组件的处理</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) &#123;</span><br><span class="line">          <span class="comment">// 处理副作用</span></span><br><span class="line">          commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      # 2，类组件的处理</span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="comment">// 组件实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">			  <span class="comment">// mount加载阶段</span></span><br><span class="line"></span><br><span class="line">              # 触发componentDidMount 生命周期钩子函数【这类静态方法：是存储在instance对象原型上的】</span><br><span class="line">              instance.componentDidMount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// update更新阶段</span></span><br><span class="line">              <span class="keyword">const</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps</span><br><span class="line">                  : resolveDefaultProps( finishedWork.type, current.memoizedProps);</span><br><span class="line">              <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">			  # 触发componentDidUpdate 生命周期钩子函数</span><br><span class="line">              instance.componentDidUpdate( prevProps,prevState,</span><br><span class="line">                  instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 取出当前组件节点的updateQueue更新对象</span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> I think this is now always non-null by the time it reaches the</span></span><br><span class="line">        <span class="comment">// commit phase. Consider removing the type check.</span></span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (finishedWork.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (finishedWork.child.tag) &#123;</span><br><span class="line">              <span class="keyword">case</span> HostComponent:</span><br><span class="line">                instance = getPublicInstance(finishedWork.child.stateNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ClassComponent:</span><br><span class="line">                instance = finishedWork.child.stateNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">        <span class="comment">// 取出DOM对象</span></span><br><span class="line">        <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (current === <span class="literal">null</span> &amp;&amp; finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">          <span class="keyword">const</span> props = finishedWork.memoizedProps;</span><br><span class="line">          # 针对一些特殊的DOM元素做加载处理：button,input等做自动聚焦，对Img图片做加载</span><br><span class="line">          commitMount(instance, type, props, finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitLayoutEffectOnFiber</code> 方法依然是和前面两个阶段的逻辑一样，根据不同的组件节点进行不同的逻辑处理，这里我们还是理解几个重点组件类型即可。</p>
<ul>
<li><p>函数组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br></pre></td></tr></table></figure>
<p>同步执行当前函数组件节点的useLayoutEffect 回调。</p>
</li>
<li><p>类组件<br>根据当前Fiber节点是否存在current【旧的Fiber】来区分是mount阶段还是update阶段：</p>
<ul>
<li>mount阶段：执行当前类组件的componentDidMount生命周期钩子函数。</li>
<li>update阶段：执行当前类组件的componentDidUpdate生命周期钩子函数。</li>
</ul>
</li>
</ul>
<h5 id="layout阶段总结"><a href="#layout阶段总结" class="headerlink" title="layout阶段总结"></a>layout阶段总结</h5><p>在真实DOM加载完成后：</p>
<ul>
<li>执行函数组件的useLayoutEffect hook的回调。</li>
<li>类组件执⾏ componentDidMount 或者 componentDidUpdate。。</li>
<li>由此可⻅，函数组件的 effects 和类组件中⽣命周期执⾏时机是不同的</li>
</ul>
<h3 id="FiberTree的切换"><a href="#FiberTree的切换" class="headerlink" title="FiberTree的切换"></a>FiberTree的切换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2，Mutation阶段</span></span><br><span class="line">commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"># FiberTree的切换</span><br><span class="line">root.current = finishedWork;</span><br><span class="line"><span class="comment">// 3, Layout阶段</span></span><br><span class="line">commitLayoutEffects(finishedWork, root, lanes);</span><br></pre></td></tr></table></figure>

<p>在 <code>Mutation</code> 阶段和 <code>Layout</code> 阶段之间还有一个重要处理没有说明，那就是 <code>FiberTree</code> 的切换。</p>
<p>通过前面我们已经知道，<code>Mutation</code> 阶段处理完成之后，页面就已经完成了真实的 <code>DOM</code> 渲染。所以此时<code>finishedWork</code> 就是最新的 <code>FiberTree</code> 以及存储着最新的 <code>DOM</code> 内容，在这里更新 <code>current</code> 的内容，主要有两个方面的作用：</p>
<ul>
<li>保留最新的 <code>Fiber</code> 树结构，在下一次更新时就可以利用本次的 <code>FiberTree</code> 来做数据的复用以及差异对比。</li>
<li>对于类组件来说：当在 <code>Layout</code> 阶段执行 <code>componentDidMount</code> 或者 <code>componentDidUpdate</code> 生命周期钩子时就可以获取最新的 <code>DOM</code> 内容。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，react18.2源码解析最重要的内容：即一个react应用的基本加载流程算是解析完成了，虽然其中一些逻辑描述可能不够准确，但整体来说还是比较符合。当然其中也有一些逻辑的细节并没有展开讲解，这是因为本身应用的加载流程就已经比较复杂了，如果在解析过程中每个逻辑都放在一起讲解，那文章的内容可能翻倍不止，阅读效果也会大打折扣。所以关于一些细节方面的逻辑处理会在新的章节里面展开讲解，比如类组件，函数组件的具体加载过程、hooks原理、合成事件等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html" class="post-title-link" itemprop="url">react18.2源码分析（三）render-render阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-03T00:00:00+08:00">2024-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react源码分析（三）render-render阶段"><a href="#react源码分析（三）render-render阶段" class="headerlink" title="react源码分析（三）render-render阶段"></a>react源码分析（三）render-render阶段</h1><blockquote>
<p>如果以下代码没有特殊标记，路径都是 <font color=gray><em>src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js</em></font></p>
</blockquote>
<p>这个 <code>performConcurrentWorkOnRoot</code> 函数中包含两个重要的阶段，<code>render</code> 和 <code>commit</code> 阶段。这是每个并发任务的入口点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the entry point for every concurrent task, i.e. anything that goes through Scheduler.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ??</span></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// Something in the passive effect phase may have canceled the current task.</span></span><br><span class="line">    <span class="comment">// Check if the task node for this root was changed.</span></span><br><span class="line">    <span class="keyword">if</span> (root.callbackNode !== originalCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The current task was canceled. Exit. We don't need to call</span></span><br><span class="line">      <span class="comment">// `ensureRootIsScheduled` because the check above implies either that</span></span><br><span class="line">      <span class="comment">// there's a new task, or that there's no remaining work on this root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current task was not canceled. Continue.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, using the fields stored</span></span><br><span class="line">  <span class="comment">// on the root.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This was already computed in the caller. Pass it as an argument.</span></span><br><span class="line">  <span class="keyword">let</span> lanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// Defensive coding. This is never expected to happen.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We disable time-slicing in some cases: if the work has been CPU-bound</span></span><br><span class="line">  <span class="comment">// for too long ("expired" work, to prevent starvation), or we're in</span></span><br><span class="line">  <span class="comment">// sync-updates-by-default mode.</span></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We only check `didTimeout` defensively, to account for a Scheduler</span></span><br><span class="line">  <span class="comment">// bug we're still investigating. Once the bug in Scheduler is fixed,</span></span><br><span class="line">  <span class="comment">// we can remove this, since we track expiration ourselves.</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line">        <span class="comment">// The render completed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this render may have yielded to a concurrent event, and if so,</span></span><br><span class="line">        <span class="comment">// confirm that any newly rendered stores are consistent.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It's possible that even a concurrent render may never have yielded</span></span><br><span class="line">        <span class="comment">// to the main thread, if it was fast enough, or if it expired. We could</span></span><br><span class="line">        <span class="comment">// skip the consistency check in that case, too.</span></span><br><span class="line">        <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          renderWasConcurrent &amp;&amp;</span><br><span class="line">          !isRenderConsistentWithExternalStores(finishedWork)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// A store was mutated in an interleaved event. Render again,</span></span><br><span class="line">          <span class="comment">// synchronously, to block further mutations.</span></span><br><span class="line">          exitStatus = renderRootSync(root, lanes);</span><br><span class="line">          <span class="comment">// We assume the tree is now consistent because we didn't yield to any</span></span><br><span class="line">          <span class="comment">// concurrent events.</span></span><br><span class="line">          renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// Need to check the exit status again.</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if something threw</span></span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">          <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">            root,</span><br><span class="line">            originallyAttemptedLanes,</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">            lanes = errorRetryLanes;</span><br><span class="line">            exitStatus = recoverFromConcurrentError(</span><br><span class="line">              root,</span><br><span class="line">              originallyAttemptedLanes,</span><br><span class="line">              errorRetryLanes,</span><br><span class="line">            );</span><br><span class="line">            renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">          prepareFreshStack(root, NoLanes);</span><br><span class="line">          markRootSuspended(root, lanes, NoLane);</span><br><span class="line">          ensureRootIsScheduled(root);</span><br><span class="line">          <span class="keyword">throw</span> fatalError;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是 commit，要么是，如果有什么被暂停了，就等待一段时间后再 commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-render阶段-renderRootSync"><a href="#1-render阶段-renderRootSync" class="headerlink" title="1. render阶段 - renderRootSync"></a>1. render阶段 - renderRootSync</h2><p>进入 <code>render</code> 阶段的，同步渲染模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 1. 记录 render阶段 开始</span></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= RenderContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevDispatcher = pushDispatcher(root.containerInfo);</span><br><span class="line">  <span class="keyword">const</span> prevCacheDispatcher = pushCacheDispatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the root or lanes have changed, throw out the existing stack</span></span><br><span class="line">  <span class="comment">// and prepare a fresh one. Otherwise we'll continue where we left off.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableUpdaterTracking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDevToolsPresent) &#123;</span><br><span class="line">        <span class="keyword">const</span> memoizedUpdaters = root.memoizedUpdaters;</span><br><span class="line">        <span class="keyword">if</span> (memoizedUpdaters.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          restorePendingUpdaters(root, workInProgressRootRenderLanes);</span><br><span class="line">          memoizedUpdaters.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span></span><br><span class="line">        <span class="comment">// If we bailout on this work, we'll move them back (like above).</span></span><br><span class="line">        <span class="comment">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span></span><br><span class="line">        <span class="comment">// That way we can keep the current update and future updates separate.</span></span><br><span class="line">        movePendingFibersToMemoized(root, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. workInProgressTransitions赋值（用于dev环境）</span></span><br><span class="line">    workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br><span class="line">    <span class="comment">// ! 3. 初始化</span></span><br><span class="line">    prepareFreshStack(root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStarted(lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didSuspendInShell = <span class="literal">false</span>;</span><br><span class="line">  outer: <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        workInProgressSuspendedReason !== NotSuspended &amp;&amp;</span><br><span class="line">        workInProgress !== <span class="literal">null</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// The work loop is suspended. During a synchronous render, we don't</span></span><br><span class="line">        <span class="comment">// yield to the main thread. Immediately unwind the stack. This will</span></span><br><span class="line">        <span class="comment">// trigger either a fallback or an error boundary.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> For discrete and "default" updates (anything that's not</span></span><br><span class="line">        <span class="comment">// flushSync), we want to wait for the microtasks the flush before</span></span><br><span class="line">        <span class="comment">// unwinding. Will probably implement this using renderRootConcurrent,</span></span><br><span class="line">        <span class="comment">// or merge renderRootSync and renderRootConcurrent into the same</span></span><br><span class="line">        <span class="comment">// function and fork the behavior some other way.</span></span><br><span class="line">        <span class="keyword">const</span> unitOfWork = workInProgress;</span><br><span class="line">        <span class="keyword">const</span> thrownValue = workInProgressThrownValue;</span><br><span class="line">        <span class="keyword">switch</span> (workInProgressSuspendedReason) &#123;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnHydration: &#123;</span><br><span class="line">            <span class="comment">// Selective hydration. An update flowed into a dehydrated tree.</span></span><br><span class="line">            <span class="comment">// Interrupt the current render so the work loop can switch to the</span></span><br><span class="line">            <span class="comment">// hydration lane.</span></span><br><span class="line">            resetWorkInProgressStack();</span><br><span class="line">            workInProgressRootExitStatus = RootDidNotComplete;</span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnImmediate:</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnData: &#123;</span><br><span class="line">            <span class="keyword">if</span> (!didSuspendInShell &amp;&amp; getSuspenseHandler() === <span class="literal">null</span>) &#123;</span><br><span class="line">              didSuspendInShell = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intentional fallthrough</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="comment">// Unwind then continue with the normal work loop.</span></span><br><span class="line">            workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">            workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ! 4. workLoopSync</span></span><br><span class="line">      workLoopSync();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleThrow(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Check if something suspended in the shell. We use this to detect an</span></span><br><span class="line">  <span class="comment">// infinite ping loop caused by an uncached promise.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Only increment this counter once per synchronous render attempt across the</span></span><br><span class="line">  <span class="comment">// whole tree. Even if there are many sibling components that suspend, this</span></span><br><span class="line">  <span class="comment">// counter only gets incremented once.</span></span><br><span class="line">  <span class="keyword">if</span> (didSuspendInShell) &#123;</span><br><span class="line">    root.shellSuspendCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  popDispatcher(prevDispatcher);</span><br><span class="line">  popCacheDispatcher(prevCacheDispatcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is a sync render, so we should have finished the whole tree.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Cannot commit an incomplete root. This error is likely caused by a '</span> +</span><br><span class="line">        <span class="string">'bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStopped();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 6. 再遍历一遍更新队列</span></span><br><span class="line">  <span class="comment">// It's safe to process the queue now that the render phase is complete.</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressRootExitStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-记录-render-阶段-开始"><a href="#1-1-记录-render-阶段-开始" class="headerlink" title="1.1 记录 render 阶段 开始"></a>1.1 记录 render 阶段 开始</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">executionContext |= RenderContext;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-workInProgressTransitions赋值"><a href="#1-2-workInProgressTransitions赋值" class="headerlink" title="1.2 workInProgressTransitions赋值"></a>1.2 workInProgressTransitions赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-prepareFreshStack-初始化"><a href="#1-3-prepareFreshStack-初始化" class="headerlink" title="1.3 prepareFreshStack 初始化"></a>1.3 prepareFreshStack 初始化</h3><p>初始化 <code>workInProgressRoot</code>、<code>workInProgress</code>、<code>workInProgressRootRenderLanes</code> 等值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  root.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeoutHandle = root.timeoutHandle;</span><br><span class="line">  <span class="keyword">if</span> (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">    <span class="comment">// The root previous suspended and scheduled a timeout to commit a fallback</span></span><br><span class="line">    <span class="comment">// state. Now that we have additional work, cancel the timeout.</span></span><br><span class="line">    root.timeoutHandle = noTimeout;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above</span></span><br><span class="line">    cancelTimeout(timeoutHandle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cancelPendingCommit = root.cancelPendingCommit;</span><br><span class="line">  <span class="keyword">if</span> (cancelPendingCommit !== <span class="literal">null</span>) &#123;</span><br><span class="line">    root.cancelPendingCommit = <span class="literal">null</span>;</span><br><span class="line">    cancelPendingCommit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetWorkInProgressStack();</span><br><span class="line">  workInProgressRoot = root; <span class="comment">// FiberRoot</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rootWorkInProgress = createWorkInProgress(root.current, <span class="literal">null</span>); <span class="comment">// Fiber</span></span><br><span class="line"></span><br><span class="line">  workInProgress = rootWorkInProgress; <span class="comment">// Fiber</span></span><br><span class="line">  workInProgressRootRenderLanes = lanes;</span><br><span class="line">  workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">  workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidAttachPingListener = <span class="literal">false</span>;</span><br><span class="line">  workInProgressRootExitStatus = RootInProgress;</span><br><span class="line">  workInProgressRootFatalError = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootSkippedLanes = NoLanes;</span><br><span class="line">  workInProgressRootInterleavedUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootPingedLanes = NoLanes;</span><br><span class="line">  workInProgressDeferredLane = NoLane;</span><br><span class="line">  workInProgressRootConcurrentErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRecoverableErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidIncludeRecursiveRenderUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the lanes that are entangled with whatever we're about to render. We</span></span><br><span class="line">  <span class="comment">// track these separately so we can distinguish the priority of the render</span></span><br><span class="line">  <span class="comment">// task from the priority of the lanes it is entangled with. For example, a</span></span><br><span class="line">  <span class="comment">// transition may not be allowed to finish unless it includes the Sync lane,</span></span><br><span class="line">  <span class="comment">// which is currently suspended. We should be able to render the Transition</span></span><br><span class="line">  <span class="comment">// and Sync lane in the same batch, but at Transition priority, because the</span></span><br><span class="line">  <span class="comment">// Sync lane already suspended.</span></span><br><span class="line"></span><br><span class="line">  entangledRenderLanes = getEntangledLanes(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把concurrentQueues的内容添加到fiber的queue中，即给fiber的lanes、childLanes赋值</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rootWorkInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-1-workLoopSync"><a href="#1-4-1-workLoopSync" class="headerlink" title="1.4.1 workLoopSync"></a>1.4.1 workLoopSync</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work without checking if we need to yield between fiber.</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootSync，while循环，只要workInProgress有值，就会一直循环执行performUnitOfWork，直到workInProgress === null。</p>
<p>所以同步渲染模式，一旦开始这个Fiber Reconciler协调流程，就会进入一直循环的逻辑，直到创建出完整的FiberTree，这个过程无法中断。</p>
<p>下面我们来看看并发渲染模式的方法。</p>
<h3 id="1-4-2-workLoopConcurrent"><a href="#1-4-2-workLoopConcurrent" class="headerlink" title="1.4.2 workLoopConcurrent"></a>1.4.2 workLoopConcurrent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootConcurrent，可以看见和同步渲染模式基本一样，唯一的区别就是while循环的多了一个判断条件：当前程序运行时间是否小于帧间隔时间frameInterval【默认5ms】。</p>
<ul>
<li>如果小于：则返回false，代表还有剩余可执行时间。取反后为true，表示可以继续创建FiberTree的工作循环。</li>
<li>如果大于：则返回true，代表没有剩余可执行时间。取反后为false，则while循环的条件将不再满足，会暂停创建FiberTree的工作，结束本次宏任务，剩下的工作会留待下一次宏任务再处理。</li>
</ul>
<p>所以并发渲染模式和同步渲染模式的主要区别就是在这里：它可以中断FiberTree的创建过程，而同步渲染模式是无法中断这个过程的，它只能从开始到创建完成。</p>
<p>并且在这里我们也可以看出，它们的while循环里面都是执行了一个相同的performUnitOfWork方法，所以后面的逻辑也就没有什么模式的区分了，都是执行的一样的内容。</p>
<h3 id="1-4-3-并发模式下暂停工作与恢复执行"><a href="#1-4-3-并发模式下暂停工作与恢复执行" class="headerlink" title="1.4.3 并发模式下暂停工作与恢复执行"></a>1.4.3 并发模式下暂停工作与恢复执行</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发渲染模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoopConcurrent();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleError(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查tree工作是否完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Still work remaining.</span></span><br><span class="line">    <span class="keyword">return</span> RootInProgress;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>workLoopConcurrent</code> 并发渲染的工作被中断后，就会退出 <code>do while</code> 循环，然后就会检查当前的 <code>workInProgress</code> 是否为 <code>null</code>，很明显被暂停的情况，<code>workInProgress</code> 是一定有值的，它的值为下一个即将处理的 <code>Fiber</code> 节点。</p>
<p>此时 <code>workInProgress</code> 不为 <code>null</code>，就会返回 <code>RootInProgress</code> 的渲染状态，表示还有剩下的工作。</p>
<p>这里 return 之后，就会回到 <code>performConcurrentWorkOnRoot</code> 方法之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params">root, didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回未完成的渲染状态</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据渲染状态 继续执行逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染未完成的情况：</span></span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// 渲染暂停的情况：继续返回performConcurrentWorkOnRoot，下一次宏任务继续处理</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost()) ) &#123;</span><br><span class="line">        <span class="comment">// This currentTask hasn't expired, and we've reached the deadline.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback就是performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">        <span class="comment">// continuationCallback 如果返回也是 performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="comment">// 说明任务还未完成，将任务继续设置未当前任务的callback，等待下次继续执行</span></span><br><span class="line">          <span class="comment">// 这里没有删除这个任务，则下次取出的第一个任务，还是这个任务，</span></span><br><span class="line">          currentTask.callback = continuationCallback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 还有工作，则会生成一个新的宏任务，在下次的宏任务中继续执行剩下的任务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在workLoop方法之中，就会将返回的内容再次赋值给当前任务currentTask的callback属性，表示还有未完成的工作。workLoop方法中的while循环就会被中断，原因同样是shouldYieldToHost方法。</p>
<p>在workLoop方法最后就会判断当前任务currentTask是否为null，很明显被中断的情况，currentTask是有值的，所以就会返回true，这里会一直向上return：</p>
<p>最后会将结果返回performWorkUntilDeadline方法之中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span><br><span class="line">	<span class="comment">// 此时hasMoreWork为true</span></span><br><span class="line">    <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">      <span class="comment">// 如果还有任务,则又触发创建宏任务事件，生成新的宏任务，即在下一个消息事件继续执行任务</span></span><br><span class="line">      schedulePerformWorkUntilDeadline();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时hasMoreWork为true，就会调用schedulePerformWorkUntilDeadline方法，生成一个新的宏任务，在下个宏任务中继续执行剩下的任务。</p>
<p>恢复执行的原理也很简单：在下次的宏任务中继续创建FiberTree的时候，因为workInProgress是一个全局变量，一直保存在内存之中，并且它内容为下一个即将处理的Fiber节点，所以下次再回到这里时，就会自动从这个Fiber节点开始继续执行剩下的创建工作。</p>
<h3 id="1-5-performUnitOfWork"><a href="#1-5-performUnitOfWork" class="headerlink" title="1.5 performUnitOfWork"></a>1.5 performUnitOfWork</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存的上一次的Fiber</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.alternate;</span><br><span class="line">  setCurrentDebugFiberInDEV(unitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始工作</span></span><br><span class="line">  <span class="keyword">let</span> next = beginWork(current, unitOfWork, entangledRenderLanes);</span><br><span class="line"></span><br><span class="line">  resetCurrentDebugFiberInDEV();</span><br><span class="line">  <span class="comment">// ! 把pendingProps更新到memoizedProps</span></span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注意：当遍历到叶子元素，即没有子FiberNode时，performUnitOfWork会进入归的阶段。</span></span><br><span class="line"><span class="comment">   * 这个阶段会调用completeUnitOfWork处理FiberNode，当某个FiberNode阶段执行completeUnitOfWork方法后，</span></span><br><span class="line"><span class="comment">   * 如果存在其他的兄弟节点【FiberNode.sibling !== null】，会进入兄弟节点的归阶段，</span></span><br><span class="line"><span class="comment">   * 如果不存在其他兄弟节点，则进入父节点的归阶段，递阶段和归阶段会交替进行直到HostFiber的归阶段</span></span><br><span class="line"><span class="comment">   * 至此，render工作结束，Fiber树创建完成。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn't spawn new work, complete the current work.</span></span><br><span class="line">    <span class="comment">// 如果不再产生新的work，那么当前work结束</span></span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 Fiber 为null</span></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fiber-树结构"><a href="#Fiber-树结构" class="headerlink" title="Fiber 树结构"></a>Fiber 树结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom/client'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">root.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyFun <span class="keyword">from</span> <span class="string">'./views/MyFun'</span>;</span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'./views/MyClass'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'App组件运行了'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;react源码调试&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyFun name='MyFun'&gt;&lt;/</span>MyFun&gt;</span><br><span class="line">      &lt;MyClass name=<span class="string">'MyClass'</span>&gt;&lt;<span class="regexp">/MyClass&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MyFun.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyFun</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MyFun组件运行了'</span>)</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'MyFun'</span>&gt;</span><br><span class="line">      &lt;div&gt;MyFun组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;state: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;name: &#123;props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件运行了'</span>)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件mount完成'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'MyClass'</span>&gt;</span><br><span class="line">        &lt;div&gt;MyClass组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;state: &#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;name: &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-4.png" alt="alt text"></p>
<h4 id="1-5-1-beginWork"><a href="#1-5-1-beginWork" class="headerlink" title="1.5.1 beginWork"></a>1.5.1 beginWork</h4><p>简单来说，就是生成 fiber 树。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> didReceiveUpdate: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update更新流程</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged() ||</span><br><span class="line">      <span class="comment">// Force a re-render if the implementation changed due to hot reload:</span></span><br><span class="line">      (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// If props or context changed, mark the fiber as having performed work.</span></span><br><span class="line">      <span class="comment">// This may be unset if the props are determined to be equal later (memo).</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither props nor legacy context changes. Check if there's a pending</span></span><br><span class="line">      <span class="comment">// update or context change.</span></span><br><span class="line">      <span class="keyword">const</span> hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span><br><span class="line">        current,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !hasScheduledUpdateOrContext &amp;&amp;</span><br><span class="line">        <span class="comment">// If this is the second pass of an error or suspense boundary, there</span></span><br><span class="line">        <span class="comment">// may not be work scheduled on `current`, so we check for this flag.</span></span><br><span class="line">        (workInProgress.flags &amp; DidCapture) === NoFlags</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No pending updates or context. Bail out now.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> attemptEarlyBailoutIfNoScheduledUpdate(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// This is a special case that only exists for legacy mode.</span></span><br><span class="line">        <span class="comment">// See https://github.com/facebook/react/pull/19216.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// An update was scheduled on this fiber, but there are no new props</span></span><br><span class="line">        <span class="comment">// nor legacy context. Set this to false. If an update queue or context</span></span><br><span class="line">        <span class="comment">// consumer produces a changed value, it will set this to true. Otherwise,</span></span><br><span class="line">        <span class="comment">// the component will assume the children have not changed and bail out.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating() &amp;&amp; isForkedChild(workInProgress)) &#123;</span><br><span class="line">      <span class="comment">// Check if this child belongs to a list of muliple children in</span></span><br><span class="line">      <span class="comment">// its parent.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In a true multi-threaded implementation, we would render children on</span></span><br><span class="line">      <span class="comment">// parallel threads. This would represent the beginning of a new render</span></span><br><span class="line">      <span class="comment">// thread for this subtree.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We only use this for id generation during hydration, which is why the</span></span><br><span class="line">      <span class="comment">// logic is located in this special branch.</span></span><br><span class="line">      <span class="keyword">const</span> slotIndex = workInProgress.index;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = getForksAtLevel(workInProgress);</span><br><span class="line">      pushTreeId(workInProgress, numberOfForks, slotIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear pending update priority.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This assumes that we're about to evaluate the component and process</span></span><br><span class="line">  <span class="comment">// the update queue. However, there's an exception: SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// sometimes bails out later in the begin phase. This indicates that we should</span></span><br><span class="line">  <span class="comment">// move this assignment out of the common path and into each branch.</span></span><br><span class="line">  <span class="comment">// 在进入开始阶段之前，清除待处理的更新优先级。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 这假设我们即将评估组件并处理更新队列。然而，有一个例外情况：SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// 有时会在开始阶段后退出。这表明我们应该将这个赋值移出常规路径，放到每个分支中。</span></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountLazyComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类组件</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根Fiber（第一次都会走这里）</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostHoistable:</span><br><span class="line">      <span class="keyword">if</span> (enableFloat &amp;&amp; supportsResources) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostHoistable(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> HostSingleton:</span><br><span class="line">      <span class="keyword">if</span> (supportsSingletons) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostSingleton(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 原生标签，div span等标签</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      <span class="keyword">return</span> updatePortalComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === type</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateForwardRef(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">return</span> updateFragment(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">return</span> updateMode(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">return</span> updateProfiler(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="keyword">return</span> updateContextProvider(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">return</span> updateContextConsumer(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// Resolve outer props first, then resolve inner props.</span></span><br><span class="line">      <span class="keyword">let</span> resolvedProps = resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      resolvedProps = resolveDefaultProps(type.type, resolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSimpleMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        workInProgress.pendingProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> mountIncompleteClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseListComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseListComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ScopeComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableScopeAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateScopeComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> OffscreenComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateOffscreenComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LegacyHiddenComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableLegacyHidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateLegacyHiddenComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CacheComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateCacheComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TracingMarkerComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableTransitionTracing) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateTracingMarkerComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">`Unknown unit of work tag (<span class="subst">$&#123;workInProgress.tag&#125;</span>). This error is likely caused by a bug in `</span> +</span><br><span class="line">      <span class="string">'React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-1-updateHostRoot"><a href="#1-5-1-1-updateHostRoot" class="headerlink" title="1.5.1.1 updateHostRoot"></a>1.5.1.1 updateHostRoot</h5><ol>
<li>更新当前 fiber，比如 props/state 更新，生命周期函数执行、Hooks 函数执行等。</li>
<li>返回一个下一个 fiber。</li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// current是根fiber，current的的stateNode是FiberRoot</span></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should have a current fiber. This is a bug in React.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. 更新props、state、updateQuue、transition</span></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState.element;</span><br><span class="line">  <span class="comment">// 把current上的updateQueue复用到 workInProgress 上一份。</span></span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextState: RootState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  pushRootTransition(workInProgress, root, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 2. bailout or 协调子节点，如果新旧children相同，则会进入优化的逻辑，跳过本次reconcile协调流程，复用原来的节点内容</span></span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 3. 返回子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-2-updateHostComponent"><a href="#1-5-1-2-updateHostComponent" class="headerlink" title="1.5.1.2 updateHostComponent"></a>1.5.1.2 updateHostComponent</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    <span class="comment">// We special case a direct text child of a host node. This is a common</span></span><br><span class="line">    <span class="comment">// case. We won't handle it as a reified child. We will instead handle</span></span><br><span class="line">    <span class="comment">// this in the host environment that also has access to this prop. That</span></span><br><span class="line">    <span class="comment">// avoids allocating another HostText fiber and traversing it.</span></span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    <span class="comment">// If we're switching from a direct text child to a normal child, or to</span></span><br><span class="line">    <span class="comment">// empty, we need to schedule the text content to be reset.</span></span><br><span class="line">    workInProgress.flags |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableFormActions &amp;&amp; enableAsyncActions) &#123;</span><br><span class="line">    <span class="keyword">const</span> memoizedState = workInProgress.memoizedState;</span><br><span class="line">    <span class="keyword">if</span> (memoizedState !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This fiber has been upgraded to a stateful component. The only way</span></span><br><span class="line">      <span class="comment">// happens currently is for form actions. We use hooks to track the</span></span><br><span class="line">      <span class="comment">// pending and error state of the form.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Once a fiber is upgraded to be stateful, it remains stateful for the</span></span><br><span class="line">      <span class="comment">// rest of its lifetime.</span></span><br><span class="line">      <span class="keyword">const</span> newState = renderTransitionAwareHostComponentWithHooks(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the transition state changed, propagate the change to all the</span></span><br><span class="line">      <span class="comment">// descendents. We use Context as an implementation detail for this.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This is intentionally set here instead of pushHostContext because</span></span><br><span class="line">      <span class="comment">// pushHostContext gets called before we process the state hook, to avoid</span></span><br><span class="line">      <span class="comment">// a state mismatch in the event that something suspends.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> This assumes that there cannot be nested transition providers,</span></span><br><span class="line">      <span class="comment">// because the only renderer that implements this feature is React DOM,</span></span><br><span class="line">      <span class="comment">// and forms cannot be nested. If we did support nested providers, then</span></span><br><span class="line">      <span class="comment">// we would need to push a context value even for host fibers that</span></span><br><span class="line">      <span class="comment">// haven't been upgraded yet.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrimaryRenderer) &#123;</span><br><span class="line">        HostTransitionContext._currentValue = newState;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HostTransitionContext._currentValue2 = newState;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableLazyContextPropagation) &#123;</span><br><span class="line">        <span class="comment">// In the lazy propagation implementation, we don't scan for matching</span></span><br><span class="line">        <span class="comment">// consumers until something bails out.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (didReceiveUpdate) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldStateHook: Hook = current.memoizedState;</span><br><span class="line">            <span class="keyword">const</span> oldState: TransitionStatus = oldStateHook.memoizedState;</span><br><span class="line">            <span class="comment">// This uses regular equality instead of Object.is because we assume</span></span><br><span class="line">            <span class="comment">// that host transition state doesn't include NaN as a valid type.</span></span><br><span class="line">            <span class="keyword">if</span> (oldState !== newState) &#123;</span><br><span class="line">              propagateContextChange(</span><br><span class="line">                workInProgress,</span><br><span class="line">                HostTransitionContext,</span><br><span class="line">                renderLanes,</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-3-bailout"><a href="#1-5-1-3-bailout" class="headerlink" title="1.5.1.3 bailout"></a>1.5.1.3 bailout</h5><p>bailout阶段，返回null。</p>
<p>不会发生在组件初次渲染阶段，仅仅发生在组件更新阶段。当组件⼦节点没有发⽣变化，或者是被⼿动挡住（如类组件的 shouldComponentUpdate、memo 等），组件⼦节点不需要协调的时候。</p>
<h5 id="1-5-1-4-协调子节点-reconcileChildren"><a href="#1-5-1-4-协调子节点-reconcileChildren" class="headerlink" title="1.5.1.4 协调子节点 reconcileChildren"></a>1.5.1.4 协调子节点 reconcileChildren</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 组件初次挂载</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress, <span class="comment">// 父节点</span></span><br><span class="line">      current.child, <span class="comment">// 旧的child</span></span><br><span class="line">      nextChildren, <span class="comment">// 新的child</span></span><br><span class="line">      renderLanes, <span class="comment">// 本次更新的lanes</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最终执行的函数是同一个，都是 <code>createChildReconciler</code>，而 <code>createChildReconciler</code> 是一个 wrapper function。最终会返回内部的 <code>reconcileChildFibers</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers: ChildReconciler =</span><br><span class="line">  createChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers: ChildReconciler = createChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-5-reconcileChildFibers"><a href="#1-5-1-5-reconcileChildFibers" class="headerlink" title="1.5.1.5 reconcileChildFibers"></a>1.5.1.5 reconcileChildFibers</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 协调子节点，构建新的子fiber结构，并且返回新的子fiber</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null, <span class="regexp">//</span> 老fiber的第一个子节点</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> firstChildFiber = reconcileChildFibersImpl(</span><br><span class="line">      returnFiber,</span><br><span class="line">      currentFirstChild,</span><br><span class="line">      newChild,</span><br><span class="line">      lanes,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// debugInfo</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> firstChildFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-5-1-6-reconcileChildFibersImpl"><a href="#1-5-1-6-reconcileChildFibersImpl" class="headerlink" title="1.5.1.6 reconcileChildFibersImpl"></a>1.5.1.6 reconcileChildFibersImpl</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibersImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果newChild是Fragment类型，且没有key，则直接协调其子节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新的child类型，进行不同的处理</span></span><br><span class="line">    <span class="comment">// 单个节点、数组、迭代器、promise、context处理，最常见的react-element元素类型：react中类组件，函数组件，普通dom组件都属于此类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              debugInfo,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_LAZY_TYPE:</span><br><span class="line">          <span class="keyword">const</span> payload = newChild._payload;</span><br><span class="line">          <span class="keyword">const</span> init = newChild._init;</span><br><span class="line">          <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            init(payload),</span><br><span class="line">            lanes,</span><br><span class="line">            mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2，数组节点的处理，即多个子节点，比如div.App下面有三个子节点</span></span><br><span class="line">      <span class="comment">// 循环创建多个子节点，最后返回第一个子节点，firstChild</span></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Usables are a valid React node type. When React encounters a Usable in</span></span><br><span class="line">      <span class="comment">// a child position, it unwraps it using the same algorithm as `use`. For</span></span><br><span class="line">      <span class="comment">// example, for promises, React will throw an exception to unwind the</span></span><br><span class="line">      <span class="comment">// stack, then replay the component once the promise resolves.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A difference from `use` is that React will keep unwrapping the value</span></span><br><span class="line">      <span class="comment">// until it reaches a non-Usable type.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// e.g. Usable&lt;Usable&lt;Usable&lt;T&gt;&gt;&gt; should resolve to T</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The structure is a bit unfortunate. Ideally, we shouldn't need to</span></span><br><span class="line">      <span class="comment">// replay the entire begin phase of the parent fiber in order to reconcile</span></span><br><span class="line">      <span class="comment">// the children again. This would require a somewhat significant refactor,</span></span><br><span class="line">      <span class="comment">// because reconcilation happens deep within the begin phase, and</span></span><br><span class="line">      <span class="comment">// depending on the type of work, not always at the end. We should</span></span><br><span class="line">      <span class="comment">// consider as an future improvement.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> thenable: Thenable&lt;any&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          unwrapThenable(thenable),</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, thenable._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newChild.$$<span class="keyword">typeof</span> === REACT_CONTEXT_TYPE) &#123;</span><br><span class="line">        <span class="keyword">const</span> context: ReactContext&lt;mixed&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          readContextDuringReconcilation(returnFiber, context, lanes),</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，处理文本子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (<span class="keyword">typeof</span> newChild === <span class="string">'string'</span> &amp;&amp; newChild !== <span class="string">''</span>) ||</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'number'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          <span class="string">''</span> + newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-6-reconcileSingleElement"><a href="#1-5-1-6-reconcileSingleElement" class="headerlink" title="1.5.1.6 reconcileSingleElement"></a>1.5.1.6 reconcileSingleElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查老的fiber单链表中是否有可以复用的节点</span></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">        <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">            <span class="comment">// 新老都是Fragment</span></span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props.children);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            child.elementType === elementType ||</span><br><span class="line">            <span class="comment">// Keep this check inline so it only runs on the false path:</span></span><br><span class="line">            (__DEV__</span><br><span class="line">              ? isCompatibleFamilyForHotReloading(child, element)</span><br><span class="line">              : <span class="literal">false</span>) ||</span><br><span class="line">            <span class="comment">// Lazy types should reconcile their resolved type.</span></span><br><span class="line">            <span class="comment">// We need to do this after the Hot Reloading check above,</span></span><br><span class="line">            <span class="comment">// because hot reloading has different semantics than prod because</span></span><br><span class="line">            <span class="comment">// it doesn't resuspend. So we can't let the call below suspend.</span></span><br><span class="line">            (<span class="keyword">typeof</span> elementType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">              elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              elementType.$$<span class="keyword">typeof</span> === REACT_LAZY_TYPE &amp;&amp;</span><br><span class="line">              resolveLazy(elementType) === child.type)</span><br><span class="line">          ) &#123;</span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">            coerceRef(returnFiber, child, existing, element);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果key相同，类型不相同。不再查找</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个老节点没法复用</span></span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初次挂载 2. 没有找到可以复用的老节点</span></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        element.props.children,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        lanes,</span><br><span class="line">        element.key,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据React-element元素对象，创建FiberNode节点</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line">      coerceRef(returnFiber, currentFirstChild, created, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-7-createFiberFromElement"><a href="#1-5-1-7-createFiberFromElement" class="headerlink" title="1.5.1.7 createFiberFromElement"></a>1.5.1.7 createFiberFromElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> owner = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = element.type; <span class="comment">// 存储原始的组件内容，比如function，class</span></span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">const</span> pendingProps = element.props; <span class="comment">// 等待处理的，最新的props</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber节点： 根据元素的type ，针对组件来说：type值一般为class类 或者Function函数</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiberFromTypeAndProps(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    pendingProps,</span><br><span class="line">    owner,</span><br><span class="line">    mode,</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createFiberFromElement</code> 方法很重要，<code>react</code> 所有 <code>reactElement</code> 元素都是通过这个方法来创建对应的 <code>Fiber</code> 节点。比如常见的 class组件，function组件，原生dom元素等。我们在项目中定义的组件和元素在被编译之后，最终在加载时都会通过jsxRuntime.jsx方法转换为一个reactElement元素对象。</p>
<h5 id="1-5-1-8-createFiberFromTypeAndProps"><a href="#1-5-1-8-createFiberFromTypeAndProps" class="headerlink" title="1.5.1.8 createFiberFromTypeAndProps"></a>1.5.1.8 createFiberFromTypeAndProps</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromTypeAndProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: any, <span class="regexp">//</span> React$ElementType</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  owner: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberTag = IndeterminateComponent;</span><br><span class="line">  <span class="keyword">let</span> resolvedType = type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据元素的type进行不同的逻辑处理，class也是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 针对类组件的特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (shouldConstruct(type)) &#123;</span><br><span class="line">      <span class="comment">// 根据type 设置fiberTag 为class组件</span></span><br><span class="line">      fiberTag = ClassComponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通函数组件，没有更新tag【重要，伏笔】</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 原生dom的处理</span></span><br><span class="line">    fiberTag = HostComponent;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他type类型的处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiber(fiberTag, pendingProps, key, mode);</span><br><span class="line">  fiber.elementType = type;</span><br><span class="line">  fiber.type = resolvedType;</span><br><span class="line">  fiber.lanes = lanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在react应用中我们定义的class组件，都是通过继承react的内部组件Component来定义的，所以通过它原型上的isReactComponent属性可以来区分当前组件是不是类组件，返回true则是类组件，返回false则是函数组件。</p>
<p>如果是类组件就会更新fiberTag为ClassComponent的值。</p>
<p>如果是函数组件，这里并没有更新fiberTag，所以函数组件的fiberTag还是为待定的IndeterminateComponent的值。</p>
<p>最后是针对普通的dom元素的处理，更新为HostComponent的值。</p>
<h5 id="1-5-1-9-多子节点的创建-reconcileChildrenArray"><a href="#1-5-1-9-多子节点的创建-reconcileChildrenArray" class="headerlink" title="1.5.1.9 多子节点的创建 - reconcileChildrenArray"></a>1.5.1.9 多子节点的创建 - reconcileChildrenArray</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: Array&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 存储新生成的child</span></span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 上一个新建的child</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild; <span class="comment">// 旧的Fiber节点</span></span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ! 1. 从左边往右遍历，比较新老节点，如果节点可以复用，继续往右，否则就停止</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That's</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn't reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we're not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don't want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.1 新节点没了，（老节点还有）。则删除剩余的老节点即可</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We've reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 2.2 (新节点还有)，老节点没了</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don't have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.3 新老节点都还有节点，但是因为老fiber是链表，不方便快速get与delete，</span></span><br><span class="line">    <span class="comment">// !   因此把老fiber链表中的节点放入Map中，后续操作这个Map的get与delete</span></span><br><span class="line">    <span class="comment">// 0 1|   4 5</span></span><br><span class="line">    <span class="comment">// 0 1| 7 8 2 3</span></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don't add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !3. 如果是组件更新阶段，此时新节点已经遍历完了，能复用的老节点都用完了，</span></span><br><span class="line">    <span class="comment">// ! 则最后查找Map里是否还有元素，如果有，则证明是新节点里不能复用的，也就是要被删除的元素，此时删除这些元素就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren't consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">      pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从 hostFiber 根节点开始，react 的深度优先遍历算法，会一直创建到再无 Child 子节点。</p>
<p>此时叶子结点所对应的Fiber节点创建完成后，它会继续开启属于它的 beginWork 工作，来创建它的子节点，但是因为它已经没有子节点了，所以它最终会返回一个null。</p>
<p>然后一直向上return，直到回到performUnitOfWork方法中：将进入此 Fiber 节点的 completeWork 工作，也就是归的阶段</p>
<h4 id="1-5-2-completeUnitOfWork"><a href="#1-5-2-completeUnitOfWork" class="headerlink" title="1.5.2 completeUnitOfWork"></a>1.5.2 completeUnitOfWork</h4><p>completeWork 代表一个 Fiber 节点的结束工作，completeUnitOfWork 是 completeWork 阶段的入口函数。简单来说，就是生成 dom 树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 取出当前的Fiber节点</span></span><br><span class="line">  <span class="keyword">let</span> completedWork: Fiber = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 取出节点对应的current</span></span><br><span class="line">    <span class="keyword">const</span> current = completedWork.alternate;</span><br><span class="line">    <span class="comment">// 取出节点的父级节点</span></span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!enableProfilerTimer || (completedWork.mode &amp; ProfileMode) === NoMode) &#123;</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startProfilerTimer(completedWork);</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">      <span class="comment">// Update render duration assuming we didn't error.</span></span><br><span class="line">      stopProfilerTimerIfRunningAndRecordDelta(completedWork, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">      workInProgress = next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个节点的completeWork工作完成后，寻找是否存在兄弟节点</span></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.sibling;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果兄弟节点存在，则设置为新的workInProgress，跳出当前函数，回到performUnitOfWork方法中</span></span><br><span class="line">      <span class="comment">// 这将开始sibling兄弟节点的beginWork工作【自上而下】</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【自下而上的处理】</span></span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则将父级节点设置为completedWork，开始父级节点的completedWork工作</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    <span class="comment">// 更新workInProgress，可能会开启新的beginWork工作</span></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We've reached the root.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === RootInProgress) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>completeUnitOfWork方法中重点就是一个do while循环：<code>completedWork !== null</code>。这个循环的条件是completedWork不等于null，即它是一个有效的Fiber节点。</p>
<h5 id="1-5-2-1-completeWork"><a href="#1-5-2-1-completeWork" class="headerlink" title="1.5.2.1 completeWork"></a>1.5.2.1 completeWork</h5><p>根据tag值区别不同fiber<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-2.png" alt="alt text"></p>
<h5 id="1-5-2-2-bubbleProperties"><a href="#1-5-2-2-bubbleProperties" class="headerlink" title="1.5.2.2 bubbleProperties"></a>1.5.2.2 bubbleProperties</h5><p>向上冒泡 subtreeFlags 和 childLanes</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleProperties</span>(<span class="params">completedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.alternate.child === completedWork.child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = NoLanes;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="comment">// “向上冒泡”最早的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// ! 2. 将他们的subtreeFlags和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 子树的flags</span></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “静态”标志（Static flags）与它们所属的 Fiber 或 Hook 共享生命周期，因此即使在放弃（bailout）时，也应该将这些flags向上冒泡。</span></span><br><span class="line">        <span class="comment">// 而其他所有flags仅在单次render + commit 的生命周期内存在，因此我们应该忽略它们。</span></span><br><span class="line">        <span class="comment">// ! 2. 将他们的（subtreeFlags&amp;StaticMask)和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新return pointer以保持树的一致性。这被描述为一种代码异味（code smell），因为它假设commit阶段永远不会与 render 阶段并发。</span></span><br><span class="line">        <span class="comment">// 在重构为交替模型（alternate model）时将会解决这个问题。</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 后代节点的lanes</span></span><br><span class="line">  completedWork.childLanes = newChildLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中"><a href="#1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中" class="headerlink" title="1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中"></a>1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中</h5><p>如果组件是HostComponent，即原生标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = createInstance(</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext,</span><br><span class="line">    workInProgress,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 把DOM子节点添加到父DOM节点中去</span></span><br><span class="line">appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 当节点是原生标签，比如div、span等，会在这里添加到fiber属性stateNode上</span></span><br><span class="line">workInProgress.stateNode = instance;</span><br></pre></td></tr></table></figure>

<h5 id="总结执行流程图"><a href="#总结执行流程图" class="headerlink" title="总结执行流程图"></a>总结执行流程图</h5><p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-3.png" alt="alt text"></p>
<h3 id="1-6-重置-workInProgressX"><a href="#1-6-重置-workInProgressX" class="headerlink" title="1.6 重置 workInProgressX"></a>1.6 重置 workInProgressX</h3><p>这里没有重置 workInProgress，因为 workInProgress 已经在 performUnitOfWork 阶段更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-再遍历一遍更新队列"><a href="#1-7-再遍历一遍更新队列" class="headerlink" title="1.7 再遍历一遍更新队列"></a>1.7 再遍历一遍更新队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishQueueingConcurrentUpdates()</span><br></pre></td></tr></table></figure>

<h3 id="管理更新队列-finishQueueingConcurrentUpdates"><a href="#管理更新队列-finishQueueingConcurrentUpdates" class="headerlink" title="管理更新队列 finishQueueingConcurrentUpdates"></a>管理更新队列 finishQueueingConcurrentUpdates</h3><p><code>finishQueueingConcurrentUpdates</code> 把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中，后续才是根据 <code>VDOM</code> 更新 <code>DOM</code></p>
<p>在 <code>render</code> 阶段，有两处调⽤ <code>finishQueueingConcurrentUpdates</code> ，分别是</p>
<ol>
<li><code>render</code> 开始的时候，在 <code>prepareFreshStack</code> 函数中；<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image.png" alt="alt text"></li>
<li>在 <code>render</code> 结束的时候，最后再调⽤⼀遍。<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-1.png" alt="alt text"></li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">finishQueueingConcurrentUpdates</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> endIndex = concurrentQueuesIndex;</span><br><span class="line">  concurrentQueuesIndex = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  concurrentlyUpdatedLanes = NoLanes; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; endIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber: Fiber = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> queue: ConcurrentQueue = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> update: ConcurrentUpdate = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> lane: Lane = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里构建完之后的fiber.updateQueue.shared.pending数据类型是Update，但是其实这里构建成了一个单向循环链表。</span></span><br><span class="line">    <span class="comment">// 所以fiber.updateQueue.shared.pending其实是指最后一个update，它的next指向的是第一个update</span></span><br><span class="line">    <span class="keyword">if</span> (queue !== <span class="literal">null</span> &amp;&amp; update !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">      <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">        update.next = update;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update.next = pending.next;</span><br><span class="line">        pending.next = update;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.pending = update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// 更新fiber.lanes</span></span><br><span class="line">    <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">      markUpdateLaneFromFiberToRoot(fiber, update, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="markUpdateLaneFromFiberToRoot"><a href="#markUpdateLaneFromFiberToRoot" class="headerlink" title="markUpdateLaneFromFiberToRoot"></a>markUpdateLaneFromFiberToRoot</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  sourceFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: ConcurrentUpdate | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update the source fiber's lanes</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="keyword">let</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Walk the parent path to the root and update the child lanes.</span></span><br><span class="line">  <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">  <span class="keyword">let</span> isHidden = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);</span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent.tag === OffscreenComponent) &#123;</span><br><span class="line">      <span class="keyword">const</span> offscreenInstance: OffscreenInstance | <span class="literal">null</span> = parent.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        offscreenInstance !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(offscreenInstance._visibility &amp; OffscreenVisible)</span><br><span class="line">      ) &#123;</span><br><span class="line">        isHidden = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理更新队列-processUpdateQueue"><a href="#处理更新队列-processUpdateQueue" class="headerlink" title="处理更新队列 processUpdateQueue"></a>处理更新队列 processUpdateQueue</h3><p>这个函数⽤来处理更新队列。</p>
<p><code>processUpdateQueue</code> 在 <code>beginWork</code> 阶段会被两个地⽅调⽤：</p>
<ol>
<li><p>updateHostRoot <font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br></pre></td></tr></table></figure></li>
<li><p>updateClassInstance <font color=gray><em>packages\react-reconciler\src\ReactFiberClassComponent.js</em></font></p>
<p>在类组件的 mount、resumeMount、更新阶段，均会调⽤。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="processUpdateQueue-流程"><a href="#processUpdateQueue-流程" class="headerlink" title="processUpdateQueue 流程"></a>processUpdateQueue 流程</h4><ol>
<li><p>检查是否有 pending update。</p>
<ol>
<li>如果有，将它们转移到 baseQueue。</li>
<li>pending update 是个单向循环链表，转移到 单链表 firstBaseUpdate-&gt;…-&gt;lastBaseUpdate 中去。</li>
</ol>
</li>
<li><p>遍历 queue，根据这些 update 计算出最后的结果</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理这个更新</span></span><br><span class="line">newState = getStateFromUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    queue,</span><br><span class="line">    update,</span><br><span class="line">    newState,</span><br><span class="line">    props,</span><br><span class="line">    instance,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>更新到 fiber 上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.lanes = newLanes;</span><br><span class="line">workInProgress.memoizedState = newState; <span class="comment">// 更新状态</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89scheduleUpdateOnFiber%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89scheduleUpdateOnFiber%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0.html" class="post-title-link" itemprop="url">react18.2源码分析（二）scheduleUpdateOnFiber调度更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2024-06-10T00:00:00+08:00">2024-06-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react源码分析（二）scheduleUpdateOnFiber调度更新"><a href="#react源码分析（二）scheduleUpdateOnFiber调度更新" class="headerlink" title="react源码分析（二）scheduleUpdateOnFiber调度更新"></a>react源码分析（二）scheduleUpdateOnFiber调度更新</h1><p><code>scheduleUpdateOnFiber</code> 函数主要是触发一个在 <code>Fiber</code> 节点上的调度更新任务，⻚⾯初次渲染、类组件 <code>setState/forceUpdate</code>、函数组件 <code>setState</code> 都会⾛到更新，都会调⽤ <code>scheduleUpdateOnFiber</code> 函数。</p>
<p>如果以下源码没有特殊标记路径，那么路径都和 <code>scheduleUpdateOnFiber</code> ⼀样，即 <font color=gray><em>packages/react-reconciler/src/ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 标记根节点有一个 pending update，即待处理的更新。</span></span><br><span class="line">  markRootUpdated(root, lane);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoLanes &amp;&amp;</span><br><span class="line">    root === workInProgressRoot</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 这个更新是在渲染阶段期间发送的。</span></span><br><span class="line">    <span class="comment">// 如果更新源自用户空间（除了本地hook update之外，hook update会被单独处理，不会到达这个函数），那么这是一个错误。</span></span><br><span class="line">    <span class="comment">// 但是，有一些内部的 React 功能将这个作为实现细节，比如选择性hydration。</span></span><br><span class="line">    warnAboutRenderPhaseUpdatesInDEV(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track lanes that were updated during the render phase</span></span><br><span class="line">    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(</span><br><span class="line">      workInProgressRootRenderPhaseUpdatedLanes,</span><br><span class="line">      lane,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面初次渲染时候，此时workInProgressRoot还是null</span></span><br><span class="line">    <span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">      <span class="comment">// Received an update to a tree that's in the middle of rendering. Mark</span></span><br><span class="line">      <span class="comment">// that there was an interleaved update work on this root.</span></span><br><span class="line">      <span class="keyword">if</span> ((executionContext &amp; RenderContext) === NoContext) &#123;</span><br><span class="line">        workInProgressRootInterleavedUpdatedLanes = mergeLanes(</span><br><span class="line">          workInProgressRootInterleavedUpdatedLanes,</span><br><span class="line">          lane,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123;</span><br><span class="line">        <span class="comment">// The root already suspended with a delay, which means this render</span></span><br><span class="line">        <span class="comment">// definitely won't finish. Since we have a new update, let's mark it as</span></span><br><span class="line">        <span class="comment">// suspended now, right before marking the incoming update. This has the</span></span><br><span class="line">        <span class="comment">// effect of interrupting the current render and switching to the update.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Make sure this doesn't override pings that happen while we've</span></span><br><span class="line">        <span class="comment">// already started rendering.</span></span><br><span class="line">        markRootSuspended(</span><br><span class="line">          root,</span><br><span class="line">          workInProgressRootRenderLanes,</span><br><span class="line">          workInProgressDeferredLane,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 开始调度</span></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      lane === SyncLane &amp;&amp;</span><br><span class="line">      executionContext === NoContext &amp;&amp;</span><br><span class="line">      (fiber.mode &amp; ConcurrentMode) === NoMode</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactCurrentActQueue.isBatchingLegacy) &#123;</span><br><span class="line">        <span class="comment">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Flush the synchronous work now, unless we're already working or inside</span></span><br><span class="line">        <span class="comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span></span><br><span class="line">        <span class="comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span></span><br><span class="line">        <span class="comment">// without immediately flushing it. We only do this for user-initiated</span></span><br><span class="line">        <span class="comment">// updates, to preserve historical behavior of legacy mode.</span></span><br><span class="line">        resetRenderTimer();</span><br><span class="line">        flushSyncWorkOnLegacyRootsOnly();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-markRootUpdated"><a href="#1-markRootUpdated" class="headerlink" title="1. markRootUpdated"></a>1. markRootUpdated</h2><p>标记根节点有一个 pending update，即待处理的更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markRootUpdated(root, lane);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root: FiberRoot, updatedLanes: Lanes</span>) </span>&#123;</span><br><span class="line">  _markRootUpdated(root, updatedLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableInfiniteRenderLoopDetection) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Check for recursive updates</span></span><br><span class="line">    <span class="keyword">if</span> (executionContext &amp; RenderContext) &#123;</span><br><span class="line">      workInProgressRootDidIncludeRecursiveRenderUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (executionContext &amp; CommitContext) &#123;</span><br><span class="line">      didIncludeCommitPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getRootForUpdatedFiber中也有这个检测</span></span><br><span class="line">    <span class="comment">// 如果循环超过限制次数(50次)，抛出错误。比如在类组件的render函数里执行setState</span></span><br><span class="line">    throwIfInfiniteUpdateLoopDetected();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>_markRootUpdated</code> 来自 packages\react-reconciler\src\ReactFiberLane.js 的 <code>markRootUpdated</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root: FiberRoot, updateLane: Lane</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置本次更新的优先级, 标记其有正在等待更新的任务,此时挂载的优先级将会后在后续被转换为调度优先级，方便调度程序的使用。</span></span><br><span class="line">  root.pendingLanes |= updateLane;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果update是idle的，将不会处理它，因为我们直到所有常规update完成后才会处理idle更新；</span></span><br><span class="line">  <span class="keyword">if</span> (updateLane !== IdleLane) &#123;</span><br><span class="line">    root.suspendedLanes = NoLanes; <span class="comment">//【由于Suspense而挂起的update对应的lane集合】</span></span><br><span class="line">    root.pingedLanes = NoLanes; <span class="comment">// 【由于请求成功，Suspense取消挂起的update对应的Lane集合】</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>markRootUpdated</code> 主要做的就是设置本次更新的优先级，标记其有正在等待更新的任务，此时挂载的优先级将会后在后续被转换为调度优先级，方便调度程序的使用。</p>
<h2 id="2-ensureRootIsScheduled-root"><a href="#2-ensureRootIsScheduled-root" class="headerlink" title="2. ensureRootIsScheduled(root)"></a>2. ensureRootIsScheduled(root)</h2><p>每次 root: FiberRoot 接收 update 的时候，这个函数都会被调⽤。</p>
<ol>
<li>确保 root 在 root 调度中</li>
<li>确保有⼀个待处理的微任务来处理根调度</li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="comment">// 一般应用中，只有一个根节点，但是React支持多个根节点。</span></span><br><span class="line"><span class="keyword">let</span> firstScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 用于没有同步work的时候，快速退出flushSync</span></span><br><span class="line"><span class="keyword">let</span> mightHavePendingSyncWork: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把root添加到调度中</span></span><br><span class="line">  <span class="keyword">if</span> (root === lastScheduledRoot || root.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ? 后两次</span></span><br><span class="line">    <span class="comment">// Fast path. This root is already scheduled.</span></span><br><span class="line">    <span class="comment">// 已经添加到了调度中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ? sy 前一次</span></span><br><span class="line">    <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 多个根节点</span></span><br><span class="line">      lastScheduledRoot.next = root;</span><br><span class="line">      lastScheduledRoot = root;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每当root接收到update，我们将其设置为true，直到下次处理调度为止。如果为false，那么我们可以在不查看调度的情况下快速退出 flushSync。</span></span><br><span class="line">  mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前事件结束时，逐个检查每个root，并确保为每个root安排了正确优先级的任务。</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactCurrentActQueue.current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!enableDeferRootSchedulingToMicrotask) &#123;</span><br><span class="line">    <span class="comment">// While this flag is disabled, we schedule the render task immediately</span></span><br><span class="line">    <span class="comment">// instead of waiting a microtask.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We need to land enableDeferRootSchedulingToMicrotask ASAP to</span></span><br><span class="line">    <span class="comment">// unblock additional features we have planned.</span></span><br><span class="line">    scheduleTaskForRootDuringMicrotask(root, now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-scheduleImmediateTask"><a href="#2-1-scheduleImmediateTask" class="headerlink" title="2.1 scheduleImmediateTask"></a>2.1 scheduleImmediateTask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleImmediateTask</span>(<span class="params">cb: (</span>) =&gt; <span class="title">mixed</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Can we land supportsMicrotasks? Which environments don't support it?</span></span><br><span class="line">  <span class="comment">// Alternatively, can we move this check to the host config?</span></span><br><span class="line">  <span class="keyword">if</span> (supportsMicrotasks) &#123;</span><br><span class="line">    <span class="comment">// sy-</span></span><br><span class="line">    scheduleMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// In Safari, appending an iframe forces microtasks to run.</span></span><br><span class="line">       <span class="comment">// 在Safari中，附加一个iframe会强制微任务运行。</span></span><br><span class="line">      <span class="comment">// https://github.com/facebook/react/issues/22459</span></span><br><span class="line">      <span class="comment">// We don't support running callbacks in the middle of render</span></span><br><span class="line">      <span class="comment">// or commit so we need to check against that.</span></span><br><span class="line">      <span class="comment">// 在渲染或提交过程中我们不支持运行回调函数，因此我们需要进行检查。</span></span><br><span class="line">      <span class="keyword">const</span> executionContext = getExecutionContext();</span><br><span class="line">      <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">        <span class="comment">// sy-no</span></span><br><span class="line">        <span class="comment">// Note that this would still prematurely flush the callbacks</span></span><br><span class="line">        <span class="comment">// if this happens outside render or commit phase (e.g. in an event).</span></span><br><span class="line">        <span class="comment">// 如果这种情况发生在render或commit阶段之外（例如在事件中），这仍然会过早地刷新回调函数。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intentionally using a macrotask instead of a microtask here. This is</span></span><br><span class="line">        <span class="comment">// wrong semantically but it prevents an infinite loop. The bug is</span></span><br><span class="line">        <span class="comment">// Safari's, not ours, so we just do our best to not crash even though</span></span><br><span class="line">        <span class="comment">// the behavior isn't completely correct.</span></span><br><span class="line">        <span class="comment">// 在这里故意使用宏任务而不是微任务。这在语义上是错误的，但它可以防止无限循环。</span></span><br><span class="line">        <span class="comment">// 这个 bug 是 Safari 的问题，而不是我们的问题，所以我们尽力避免崩溃，即使行为并不完全正确。</span></span><br><span class="line">        Scheduler_scheduleCallback(ImmediateSchedulerPriority, cb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If microtasks are not supported, use Scheduler.</span></span><br><span class="line">    Scheduler_scheduleCallback(ImmediateSchedulerPriority, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-scheduleMicrotask"><a href="#2-1-1-scheduleMicrotask" class="headerlink" title="2.1.1 scheduleMicrotask"></a>2.1.1 scheduleMicrotask</h4><p><font color=gray><em>packages\react-dom-bindings\src\client\ReactFiberConfigDOM.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> scheduleMicrotask: any =</span><br><span class="line">  <span class="keyword">typeof</span> queueMicrotask === <span class="string">'function'</span></span><br><span class="line">    ? queueMicrotask</span><br><span class="line">    : <span class="keyword">typeof</span> localPromise !== <span class="string">'undefined'</span></span><br><span class="line">    ? <span class="function"><span class="params">callback</span> =&gt;</span></span><br><span class="line">        localPromise.resolve(<span class="literal">null</span>).then(callback).catch(handleErrorInNextTick)</span><br><span class="line">    : scheduleTimeout; <span class="comment">// <span class="doctag">TODO:</span> Determine the best fallback here.</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-processRootScheduleInMicrotask"><a href="#2-2-processRootScheduleInMicrotask" class="headerlink" title="2.2 processRootScheduleInMicrotask"></a>2.2 processRootScheduleInMicrotask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，它绝对不应该被同步调用。</span></span><br><span class="line">  didScheduleMicrotask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们将在遍历所有roots并调度它们时重新计算这个</span></span><br><span class="line">  mightHavePendingSyncWork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> root = firstScheduledRoot;</span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> next = root.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      currentEventTransitionLane !== NoLane &amp;&amp;</span><br><span class="line">      shouldAttemptEagerTransition()</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// A transition was scheduled during an event, but we're going to try to</span></span><br><span class="line">      <span class="comment">// render it synchronously anyway. We do this during a popstate event to</span></span><br><span class="line">      <span class="comment">// preserve the scroll position of the previous page.</span></span><br><span class="line">      upgradePendingLaneToSync(root, currentEventTransitionLane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="keyword">if</span> (nextLanes === NoLane) &#123;</span><br><span class="line">      <span class="comment">// ? sy second</span></span><br><span class="line">      <span class="comment">// 页面初次渲染，再执行这里。nextLanes=0</span></span><br><span class="line">      <span class="comment">// This root has no more pending work. Remove it from the schedule. To</span></span><br><span class="line">      <span class="comment">// guard against subtle reentrancy bugs, this microtask is the only place</span></span><br><span class="line">      <span class="comment">// we do this — you can add roots to the schedule whenever, but you can</span></span><br><span class="line">      <span class="comment">// only remove them here.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Null this out so we know it's been removed from the schedule.</span></span><br><span class="line">      <span class="comment">//root 没有更多pending work。从调度中移除它。为了防止微妙的重入bug，这个microtask是我们唯一执行此操作的地方 — 你可以随时将roots添加到调度中，但只能在这里将它们移除。</span></span><br><span class="line">      <span class="comment">// 将其置null，以便我们知道它已从调度中移除</span></span><br><span class="line">      root.next = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (prev === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">        <span class="comment">// This is the new head of the list</span></span><br><span class="line">        firstScheduledRoot = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">        <span class="comment">// This is the new tail of the list</span></span><br><span class="line">        lastScheduledRoot = prev;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ? sy first</span></span><br><span class="line">      <span class="comment">// 页面初次渲染，先执行这里。nextLanes=32</span></span><br><span class="line">      <span class="comment">// This root still has work. Keep it in the list.</span></span><br><span class="line">      prev = root;</span><br><span class="line">      <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">      <span class="comment">// ? sy-no</span></span><br><span class="line">        mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentEventTransitionLane = NoLane;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At the end of the microtask, flush any pending synchronous work. This has</span></span><br><span class="line">  <span class="comment">// to come at the end, because it does actual rendering work that might throw.</span></span><br><span class="line">  <span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line">  <span class="comment">// onClick count</span></span><br><span class="line">  flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-scheduleTaskForRootDuringMicrotask"><a href="#2-3-scheduleTaskForRootDuringMicrotask" class="headerlink" title="2.3 scheduleTaskForRootDuringMicrotask"></a>2.3 scheduleTaskForRootDuringMicrotask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，或者在渲染任务的最后，在我们将控制权交还给主线程之前被调用。它绝对不应该被同步调用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有任何lanes被其他work饿死。如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们。</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">  <span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line">  <span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于root.pendingLanes，计算出本次更新的批次Lanes</span></span><br><span class="line">  <span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// 如果优先级等于0 ，说明根节点没有可处理的回调，则退出任务调度</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Check if there's nothing to work on</span></span><br><span class="line">    nextLanes === NoLanes ||</span><br><span class="line">    <span class="comment">// If this root is currently suspended and waiting for data to resolve, don't</span></span><br><span class="line">    <span class="comment">// schedule a task to render it. We'll either wait for a ping, or wait to</span></span><br><span class="line">    <span class="comment">// receive an update.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Suspended render phase</span></span><br><span class="line">    (root === workInProgressRoot &amp;&amp; isWorkLoopSuspendedOnData()) ||</span><br><span class="line">    <span class="comment">// Suspended commit phase</span></span><br><span class="line">    root.cancelPendingCommit !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There's nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="keyword">return</span> NoLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a new callback in the host environment.</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// sy- setState</span></span><br><span class="line">    <span class="comment">// sy-no 初次渲染</span></span><br><span class="line">    <span class="comment">// Synchronous work is always flushed at the end of the microtask, so we</span></span><br><span class="line">    <span class="comment">// don't need to schedule an additional task.</span></span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        ReactCurrentActQueue.current !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn't changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We'll schedule a new one below.</span></span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个【调度的优先级】，因为react事件优先级和scheduler的优先级不同，需要经过转换【即：事件优先级转换为调度优先级】</span></span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="comment">// lanes转换成事件优先级，匹配符合的优先级，然后赋值对应的scheduler的优先级</span></span><br><span class="line">    <span class="keyword">switch</span> (lanesToEventPriority(nextLanes)) &#123;</span><br><span class="line">      <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">        schedulerPriorityLevel = ImmediateSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">        schedulerPriorityLevel = UserBlockingSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DefaultEventPriority: <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// ? sy 页面初次渲染、transition(128)</span></span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdleEventPriority:</span><br><span class="line">        schedulerPriorityLevel = IdleSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-markStarvedLanesAsExpired"><a href="#2-3-1-markStarvedLanesAsExpired" class="headerlink" title="2.3.1 markStarvedLanesAsExpired"></a>2.3.1 markStarvedLanesAsExpired</h4><p>检查是否有lanes挨饿，如果有，则标记他们过期，以便下次执行。详情参考lanes文章。</p>
<h4 id="2-3-2-getWorkInProgressRoot"><a href="#2-3-2-getWorkInProgressRoot" class="headerlink" title="2.3.2 getWorkInProgressRoot"></a>2.3.2 getWorkInProgressRoot</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> workInProgressRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getWorkInProgressRoot</span>(<span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> workInProgressRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-getWorkInProgressRootRenderLanes"><a href="#2-3-3-getWorkInProgressRootRenderLanes" class="headerlink" title="2.3.3 getWorkInProgressRootRenderLanes"></a>2.3.3 getWorkInProgressRootRenderLanes</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getWorkInProgressRootRenderLanes</span>(<span class="params"></span>): <span class="title">Lanes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> workInProgressRootRenderLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-getNextLanes"><a href="#2-3-4-getNextLanes" class="headerlink" title="2.3.4 getNextLanes"></a>2.3.4 getNextLanes</h4><p>获取本次更新的lanes。详情参考lanes文章。</p>
<h4 id="2-3-5-lanesToEventPriority"><a href="#2-3-5-lanesToEventPriority" class="headerlink" title="2.3.5 lanesToEventPriority"></a>2.3.5 lanesToEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lanesToEventPriority</span>(<span class="params">lanes: Lanes</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据优先级最高的lane，返回对应的 EventPriority。这里对应Scheduler包中的优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = getHighestPriorityLane(lanes);</span><br><span class="line">  <span class="keyword">if</span> (!isHigherEventPriority(DiscreteEventPriority, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isHigherEventPriority(ContinuousEventPriority, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (includesNonIdleWork(lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-scheduleCallback"><a href="#2-3-6-scheduleCallback" class="headerlink" title="2.3.6 scheduleCallback"></a>2.3.6 scheduleCallback</h4><p>进入 schedule 调度器.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  priorityLevel: PriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: RenderTaskFn,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Scheduler_scheduleCallback(priorityLevel, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scheduler_scheduleCallback 最终来自 <font color=gray><em>packages\scheduler\src\forks\Scheduler.js</em></font> 的 unstable_scheduleCallback，在 react调度器scheduler源码分析 会详细讲到。</p>
<h4 id="2-3-7-performConcurrentWorkOnRoot"><a href="#2-3-7-performConcurrentWorkOnRoot" class="headerlink" title="2.3.7 performConcurrentWorkOnRoot"></a>2.3.7 performConcurrentWorkOnRoot</h4><p>具体看 render 阶段文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
