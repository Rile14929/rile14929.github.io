<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E4%BB%A3%E7%A0%81%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E4%BB%A3%E7%A0%81%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2代码打印顺序和流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-05T00:00:00+08:00">2025-02-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 3 4 5 7 6 1(当前调度未超出时间切片)</span></span><br><span class="line"><span class="comment">// 2 3 4 5 6 1 7（当前调度超出时间切片, 在后面加sleep也可以看出来，effect的调度放在了之后的宏任务中执行）</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把setTimeout放在render之前的执行顺序</span></span><br><span class="line"><span class="comment">// 2 3 4 1 5 7 6</span></span><br><span class="line"><span class="comment">// 2 3 4 1 5 6 7</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("log:", 1);</span></span><br><span class="line"><span class="regexp">&#125;, 0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>从源码来看，<code>effect</code> 的 <code>create</code> 函数是在一个被调度的 <code>callback</code> 里面去执行的，为什么它还是会比 <code>Promise.then()</code> 的 <code>callback</code> 函数先执行？</p>
<p><code>useEffect</code> 是在 <code>commit</code> 阶段被 <code>scheduler</code> 加入到 <code>taskQueue</code> 中的，一个时间切片（5ms）内，如果时间允许，可能会执行很多个 <code>task</code>。</p>
<p><code>taskQueue</code> 中的任务又是在宏任务中被执行的，先于微任务。</p>
<p>总之，当前时间切片时间允许就是 <code>effect</code> 在 <code>Promise.then()</code>前，如果时间不够 <code>effect</code> 在 <code>Promise.then()</code> 后。</p>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>如果中间加了个sleep呢？如果不加呢？</p>
<p><code>useEffect</code> 是在 <code>commit</code> 阶段被 <code>scheduler</code> 加入到 <code>taskQueue</code> 中的。</p>
<ul>
<li>加sleep，导致超出时间切片5ms，<code>taskQueue</code>中的调度就要等到下一个宏任务再去调度</li>
<li>不加sleep，可能在5ms之内，<code>useEffect</code>的调度就被执行了，也有可能有各种高优先级的任务在 <code>useEffect</code> 前导致以后得调度再执行 <code>useEffect</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 加：2 3 4 5 6 1 7</span></span><br><span class="line"><span class="comment">// 不加：2 3 4 5 7 6 1 或者 2 3 4 5 6 1 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = performance.now();</span><br><span class="line">  <span class="keyword">while</span> (performance.now() - start &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// block</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sleep();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h2><h3 id="5-1-刷新页面，console-log打印了几次？"><a href="#5-1-刷新页面，console-log打印了几次？" class="headerlink" title="5.1 刷新页面，console.log打印了几次？"></a>5.1 刷新页面，console.log打印了几次？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="number">-100</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount1(<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'x'</span>) <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h3&gt;UseEffectPage &#123;count1&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：3次。</p>
<ul>
<li><p>第一次：函数组件初次渲染，执行log函数，并且此次由于useEffect函数执行，在fiber节点上记录了包含create函数的effect对象；</p>
</li>
<li><p>第二次：源于组件初次渲染完成之后，延迟useEffect的create函数，此时create函数中执行的是setState事件。setState导致函数组件更新，那么再次执行函数组件这个函数，log再次打印。并且此次又记录了create函数的effect对象。</p>
</li>
<li><p>第三次：基本同第二次，不同的地方在于第三次的时候，前后两次状态值相同，函数组件检测到没有更新发生，bailout了。</p>
</li>
<li><p>详细过程：</p>
<ul>
<li>初始化执行UseABC组件函数，flush -&gt; workloop -&gt; performConcurrentWorkOnRoot，进到render阶段，在当前fiber的updateQueue上记录了要更新的effect，打印一次log</li>
<li>初始化到了commit阶段，通过 scheduleCallback 向 taskQueue 加入一个优先级为 NormalPriority 的 flushPassiveEffects 任务<ul>
<li>/* commit的最后还是会ensureRootIsScheduled调度一次微任务<code>scheduleImmediateTask(processRootScheduleInMicrotask);</code>或者performConcurrentWorkOnRoot的最后调度scheduleTaskForRootDuringMicrotask是否要加入高优先级任务，可能涉及到其它高优先级任务插队执行的问题，在flushWork结束的finally里判断如果有任务再次发起宏任务调度 */</li>
</ul>
</li>
<li>不考虑高优先级任务插队或者其他各种情况的话，正常执行完毕后回到 workloop 中，会取出task 或者在下次切片中取出task执行，所以 flushPassiveEffects 任务得以执行，在从root开始遍历，执行各个fiber上的updateQueue的effect</li>
<li>执行到setCount1时候，等于执行dispatchSetState.bind(null,currentlyRenderingFiber,queue)，相当于增加了一个调度更新scheduleUpdateOnFiber，cheduleUpdateOnFiber执行时会标记root上的更新也会把对应的update添加到对应fiber上，最后通过 ensureRootIsScheduled 发起微任务调度，但是commit已经发起过了，就不重复发起了，最终是通过微任务把setCount1加入到了taskQueue中</li>
<li>不管中间发生了什么，当再次执行与setCount1任务相同优先级的调度时候，从root开始遍历，再次执行UseABC组件函数，count1变成了0，且再打印一次log（执行UseABC组件函数的过程中又遇到了useEffect执行setCount1，又添加了调度更新）</li>
<li>当再次执行与此次任务相同优先级的调度时候，那就再次同上执行UseABC组件函数，再打印一次log，但是不同的是，现在count1的值没变化，bailout了</li>
</ul>
</li>
</ul>
<h3 id="5-2-如果useEffect依赖为-，console-log打印了几次？"><a href="#5-2-如果useEffect依赖为-，console-log打印了几次？" class="headerlink" title="5.2 如果useEffect依赖为[]，console.log打印了几次？"></a>5.2 如果useEffect依赖为[]，console.log打印了几次？</h3><p>答案：2次</p>
<ul>
<li>第一次：函数组件初次渲染，执行log函数，并且此次由于useEffect函数执行，在fiber节点上记录了包含create函数的effect对象；</li>
<li>第二次：源于组件初次渲染完成之后，延迟useEffect的create函数，此时create函数中执行的是setState事件。setState导致函数组件更新，那么再次执行函数组件这个函数，log再次打印。但是此次useEffect没有变化，故不再后续执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2合成事件原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-26 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-26T00:00:00+08:00">2025-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><h3 id="注册事件名"><a href="#注册事件名" class="headerlink" title="注册事件名"></a>注册事件名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMEventNames.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> getVendorPrefixedEventName <span class="keyword">from</span> <span class="string">'./getVendorPrefixedEventName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type DOMEventName =</span><br><span class="line">  | <span class="string">'abort'</span></span><br><span class="line">  | <span class="string">'afterblur'</span> <span class="comment">// Not a real event. This is used by event experiments.</span></span><br><span class="line">  <span class="comment">// These are vendor-prefixed so you should use the exported constants instead:</span></span><br><span class="line">  <span class="comment">// 'animationiteration' |</span></span><br><span class="line">  <span class="comment">// 'animationend |</span></span><br><span class="line">  <span class="comment">// 'animationstart' |</span></span><br><span class="line">  | <span class="string">'beforeblur'</span> <span class="comment">// Not a real event. This is used by event experiments.</span></span><br><span class="line">  | <span class="string">'beforeinput'</span></span><br><span class="line">  | <span class="string">'blur'</span></span><br><span class="line">  | <span class="string">'canplay'</span></span><br><span class="line">  | <span class="string">'canplaythrough'</span></span><br><span class="line">  | <span class="string">'cancel'</span></span><br><span class="line">  | <span class="string">'change'</span></span><br><span class="line">  | <span class="string">'click'</span></span><br><span class="line">  | <span class="string">'close'</span></span><br><span class="line">  | <span class="string">'compositionend'</span></span><br><span class="line">  | <span class="string">'compositionstart'</span></span><br><span class="line">  | <span class="string">'compositionupdate'</span></span><br><span class="line">  | <span class="string">'contextmenu'</span></span><br><span class="line">  | <span class="string">'copy'</span></span><br><span class="line">  | <span class="string">'cut'</span></span><br><span class="line">  | <span class="string">'dblclick'</span></span><br><span class="line">  | <span class="string">'auxclick'</span></span><br><span class="line">  | <span class="string">'drag'</span></span><br><span class="line">  | <span class="string">'dragend'</span></span><br><span class="line">  | <span class="string">'dragenter'</span></span><br><span class="line">  | <span class="string">'dragexit'</span></span><br><span class="line">  | <span class="string">'dragleave'</span></span><br><span class="line">  | <span class="string">'dragover'</span></span><br><span class="line">  | <span class="string">'dragstart'</span></span><br><span class="line">  | <span class="string">'drop'</span></span><br><span class="line">  | <span class="string">'durationchange'</span></span><br><span class="line">  | <span class="string">'emptied'</span></span><br><span class="line">  | <span class="string">'encrypted'</span></span><br><span class="line">  | <span class="string">'ended'</span></span><br><span class="line">  | <span class="string">'error'</span></span><br><span class="line">  | <span class="string">'focus'</span></span><br><span class="line">  | <span class="string">'focusin'</span></span><br><span class="line">  | <span class="string">'focusout'</span></span><br><span class="line">  | <span class="string">'fullscreenchange'</span></span><br><span class="line">  | <span class="string">'gotpointercapture'</span></span><br><span class="line">  | <span class="string">'hashchange'</span></span><br><span class="line">  | <span class="string">'input'</span></span><br><span class="line">  | <span class="string">'invalid'</span></span><br><span class="line">  | <span class="string">'keydown'</span></span><br><span class="line">  | <span class="string">'keypress'</span></span><br><span class="line">  | <span class="string">'keyup'</span></span><br><span class="line">  | <span class="string">'load'</span></span><br><span class="line">  | <span class="string">'loadstart'</span></span><br><span class="line">  | <span class="string">'loadeddata'</span></span><br><span class="line">  | <span class="string">'loadedmetadata'</span></span><br><span class="line">  | <span class="string">'lostpointercapture'</span></span><br><span class="line">  | <span class="string">'message'</span></span><br><span class="line">  | <span class="string">'mousedown'</span></span><br><span class="line">  | <span class="string">'mouseenter'</span></span><br><span class="line">  | <span class="string">'mouseleave'</span></span><br><span class="line">  | <span class="string">'mousemove'</span></span><br><span class="line">  | <span class="string">'mouseout'</span></span><br><span class="line">  | <span class="string">'mouseover'</span></span><br><span class="line">  | <span class="string">'mouseup'</span></span><br><span class="line">  | <span class="string">'paste'</span></span><br><span class="line">  | <span class="string">'pause'</span></span><br><span class="line">  | <span class="string">'play'</span></span><br><span class="line">  | <span class="string">'playing'</span></span><br><span class="line">  | <span class="string">'pointercancel'</span></span><br><span class="line">  | <span class="string">'pointerdown'</span></span><br><span class="line">  | <span class="string">'pointerenter'</span></span><br><span class="line">  | <span class="string">'pointerleave'</span></span><br><span class="line">  | <span class="string">'pointermove'</span></span><br><span class="line">  | <span class="string">'pointerout'</span></span><br><span class="line">  | <span class="string">'pointerover'</span></span><br><span class="line">  | <span class="string">'pointerup'</span></span><br><span class="line">  | <span class="string">'popstate'</span></span><br><span class="line">  | <span class="string">'progress'</span></span><br><span class="line">  | <span class="string">'ratechange'</span></span><br><span class="line">  | <span class="string">'reset'</span></span><br><span class="line">  | <span class="string">'resize'</span></span><br><span class="line">  | <span class="string">'scroll'</span></span><br><span class="line">  | <span class="string">'scrollend'</span></span><br><span class="line">  | <span class="string">'seeked'</span></span><br><span class="line">  | <span class="string">'seeking'</span></span><br><span class="line">  | <span class="string">'select'</span></span><br><span class="line">  | <span class="string">'selectstart'</span></span><br><span class="line">  | <span class="string">'selectionchange'</span></span><br><span class="line">  | <span class="string">'stalled'</span></span><br><span class="line">  | <span class="string">'submit'</span></span><br><span class="line">  | <span class="string">'suspend'</span></span><br><span class="line">  | <span class="string">'textInput'</span> <span class="comment">// Intentionally camelCase. Non-standard.</span></span><br><span class="line">  | <span class="string">'timeupdate'</span></span><br><span class="line">  | <span class="string">'toggle'</span></span><br><span class="line">  | <span class="string">'touchcancel'</span></span><br><span class="line">  | <span class="string">'touchend'</span></span><br><span class="line">  | <span class="string">'touchmove'</span></span><br><span class="line">  | <span class="string">'touchstart'</span></span><br><span class="line">  <span class="comment">// These are vendor-prefixed so you should use the exported constants instead:</span></span><br><span class="line">  <span class="comment">// 'transitionend' |</span></span><br><span class="line">  | <span class="string">'volumechange'</span></span><br><span class="line">  | <span class="string">'waiting'</span></span><br><span class="line">  | <span class="string">'wheel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ANIMATION_END: DOMEventName =</span><br><span class="line">  getVendorPrefixedEventName(<span class="string">'animationend'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ANIMATION_ITERATION: DOMEventName =</span><br><span class="line">  getVendorPrefixedEventName(<span class="string">'animationiteration'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ANIMATION_START: DOMEventName =</span><br><span class="line">  getVendorPrefixedEventName(<span class="string">'animationstart'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TRANSITION_END: DOMEventName =</span><br><span class="line">  getVendorPrefixedEventName(<span class="string">'transitionend'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\EventRegistry.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// React中的事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> allNativeEvents: <span class="built_in">Set</span>&lt;DOMEventName&gt; = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> registrationNameDependencies: &#123;</span><br><span class="line">    [registrationName: string]: <span class="built_in">Array</span>&lt;DOMEventName&gt;,</span><br><span class="line">&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件注册</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">registerTwoPhaseEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    registrationName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    dependencies: Array&lt;DOMEventName&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    registerDirectEvent(registrationName, dependencies);</span><br><span class="line">    registerDirectEvent(registrationName + <span class="string">'Capture'</span>, dependencies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">registerDirectEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    registrationName: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    dependencies: Array&lt;DOMEventName&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    registrationNameDependencies[registrationName] = dependencies;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">        allNativeEvents.add(dependencies[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不同类型的事件注册"><a href="#不同类型的事件注册" class="headerlink" title="不同类型的事件注册"></a>不同类型的事件注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> BeforeInputEventPlugin <span class="keyword">from</span> <span class="string">'./plugins/BeforeInputEventPlugin'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ChangeEventPlugin <span class="keyword">from</span> <span class="string">'./plugins/ChangeEventPlugin'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> EnterLeaveEventPlugin <span class="keyword">from</span> <span class="string">'./plugins/EnterLeaveEventPlugin'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> SelectEventPlugin <span class="keyword">from</span> <span class="string">'./plugins/SelectEventPlugin'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> SimpleEventPlugin <span class="keyword">from</span> <span class="string">'./plugins/SimpleEventPlugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 注册事件</span></span><br><span class="line">SimpleEventPlugin.registerEvents();</span><br><span class="line">EnterLeaveEventPlugin.registerEvents();</span><br><span class="line">ChangeEventPlugin.registerEvents();</span><br><span class="line">SelectEventPlugin.registerEvents();</span><br><span class="line">BeforeInputEventPlugin.registerEvents();</span><br></pre></td></tr></table></figure>

<h4 id="SimpleEventPlugin"><a href="#SimpleEventPlugin" class="headerlink" title="SimpleEventPlugin"></a>SimpleEventPlugin</h4><p>普通事件，如 click、drag、drop 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  registerSimpleEvents,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../DOMEventProperties'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMEventProperties.js</span></span><br><span class="line"><span class="keyword">const</span> simpleEventPluginEvents = [</span><br><span class="line">  <span class="string">'abort'</span>,</span><br><span class="line">  <span class="string">'auxClick'</span>,</span><br><span class="line">  <span class="string">'cancel'</span>,</span><br><span class="line">  <span class="string">'canPlay'</span>,</span><br><span class="line">  <span class="string">'canPlayThrough'</span>,</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="string">'close'</span>,</span><br><span class="line">  <span class="string">'contextMenu'</span>,</span><br><span class="line">  <span class="string">'copy'</span>,</span><br><span class="line">  <span class="string">'cut'</span>,</span><br><span class="line">  <span class="string">'drag'</span>,</span><br><span class="line">  <span class="string">'dragEnd'</span>,</span><br><span class="line">  <span class="string">'dragEnter'</span>,</span><br><span class="line">  <span class="string">'dragExit'</span>,</span><br><span class="line">  <span class="string">'dragLeave'</span>,</span><br><span class="line">  <span class="string">'dragOver'</span>,</span><br><span class="line">  <span class="string">'dragStart'</span>,</span><br><span class="line">  <span class="string">'drop'</span>,</span><br><span class="line">  <span class="string">'durationChange'</span>,</span><br><span class="line">  <span class="string">'emptied'</span>,</span><br><span class="line">  <span class="string">'encrypted'</span>,</span><br><span class="line">  <span class="string">'ended'</span>,</span><br><span class="line">  <span class="string">'error'</span>,</span><br><span class="line">  <span class="string">'gotPointerCapture'</span>,</span><br><span class="line">  <span class="string">'input'</span>,</span><br><span class="line">  <span class="string">'invalid'</span>,</span><br><span class="line">  <span class="string">'keyDown'</span>,</span><br><span class="line">  <span class="string">'keyPress'</span>,</span><br><span class="line">  <span class="string">'keyUp'</span>,</span><br><span class="line">  <span class="string">'load'</span>,</span><br><span class="line">  <span class="string">'loadedData'</span>,</span><br><span class="line">  <span class="string">'loadedMetadata'</span>,</span><br><span class="line">  <span class="string">'loadStart'</span>,</span><br><span class="line">  <span class="string">'lostPointerCapture'</span>,</span><br><span class="line">  <span class="string">'mouseDown'</span>,</span><br><span class="line">  <span class="string">'mouseMove'</span>,</span><br><span class="line">  <span class="string">'mouseOut'</span>,</span><br><span class="line">  <span class="string">'mouseOver'</span>,</span><br><span class="line">  <span class="string">'mouseUp'</span>,</span><br><span class="line">  <span class="string">'paste'</span>,</span><br><span class="line">  <span class="string">'pause'</span>,</span><br><span class="line">  <span class="string">'play'</span>,</span><br><span class="line">  <span class="string">'playing'</span>,</span><br><span class="line">  <span class="string">'pointerCancel'</span>,</span><br><span class="line">  <span class="string">'pointerDown'</span>,</span><br><span class="line">  <span class="string">'pointerMove'</span>,</span><br><span class="line">  <span class="string">'pointerOut'</span>,</span><br><span class="line">  <span class="string">'pointerOver'</span>,</span><br><span class="line">  <span class="string">'pointerUp'</span>,</span><br><span class="line">  <span class="string">'progress'</span>,</span><br><span class="line">  <span class="string">'rateChange'</span>,</span><br><span class="line">  <span class="string">'reset'</span>,</span><br><span class="line">  <span class="string">'resize'</span>,</span><br><span class="line">  <span class="string">'seeked'</span>,</span><br><span class="line">  <span class="string">'seeking'</span>,</span><br><span class="line">  <span class="string">'stalled'</span>,</span><br><span class="line">  <span class="string">'submit'</span>,</span><br><span class="line">  <span class="string">'suspend'</span>,</span><br><span class="line">  <span class="string">'timeUpdate'</span>,</span><br><span class="line">  <span class="string">'touchCancel'</span>,</span><br><span class="line">  <span class="string">'touchEnd'</span>,</span><br><span class="line">  <span class="string">'touchStart'</span>,</span><br><span class="line">  <span class="string">'volumeChange'</span>,</span><br><span class="line">  <span class="string">'scroll'</span>,</span><br><span class="line">  <span class="string">'scrollEnd'</span>,</span><br><span class="line">  <span class="string">'toggle'</span>,</span><br><span class="line">  <span class="string">'touchMove'</span>,</span><br><span class="line">  <span class="string">'waiting'</span>,</span><br><span class="line">  <span class="string">'wheel'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerSimpleEvent</span>(<span class="params">domEventName: DOMEventName, reactName: string</span>) </span>&#123;</span><br><span class="line">  topLevelEventsToReactNames.set(domEventName, reactName);</span><br><span class="line">  registerTwoPhaseEvent(reactName, [domEventName]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">registerSimpleEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; simpleEventPluginEvents.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventName = ((simpleEventPluginEvents[i]: any): string);</span><br><span class="line">    <span class="keyword">const</span> domEventName = ((eventName.toLowerCase(): any): DOMEventName);</span><br><span class="line">    <span class="keyword">const</span> capitalizedEvent = eventName[<span class="number">0</span>].toUpperCase() + eventName.slice(<span class="number">1</span>);</span><br><span class="line">    registerSimpleEvent(domEventName, <span class="string">'on'</span> + capitalizedEvent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Special cases where event names don't match.</span></span><br><span class="line">  registerSimpleEvent(ANIMATION_END, <span class="string">'onAnimationEnd'</span>);</span><br><span class="line">  registerSimpleEvent(ANIMATION_ITERATION, <span class="string">'onAnimationIteration'</span>);</span><br><span class="line">  registerSimpleEvent(ANIMATION_START, <span class="string">'onAnimationStart'</span>);</span><br><span class="line">  registerSimpleEvent(<span class="string">'dblclick'</span>, <span class="string">'onDoubleClick'</span>);</span><br><span class="line">  registerSimpleEvent(<span class="string">'focusin'</span>, <span class="string">'onFocus'</span>);</span><br><span class="line">  registerSimpleEvent(<span class="string">'focusout'</span>, <span class="string">'onBlur'</span>);</span><br><span class="line">  registerSimpleEvent(TRANSITION_END, <span class="string">'onTransitionEnd'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnterLeaveEventPlugin"><a href="#EnterLeaveEventPlugin" class="headerlink" title="EnterLeaveEventPlugin"></a>EnterLeaveEventPlugin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\EnterLeaveEventPlugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  registerDirectEvent(<span class="string">'onMouseEnter'</span>, [<span class="string">'mouseout'</span>, <span class="string">'mouseover'</span>]);</span><br><span class="line">  registerDirectEvent(<span class="string">'onMouseLeave'</span>, [<span class="string">'mouseout'</span>, <span class="string">'mouseover'</span>]);</span><br><span class="line">  registerDirectEvent(<span class="string">'onPointerEnter'</span>, [<span class="string">'pointerout'</span>, <span class="string">'pointerover'</span>]);</span><br><span class="line">  registerDirectEvent(<span class="string">'onPointerLeave'</span>, [<span class="string">'pointerout'</span>, <span class="string">'pointerover'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ChangeEventPlugin"><a href="#ChangeEventPlugin" class="headerlink" title="ChangeEventPlugin"></a>ChangeEventPlugin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\ChangeEventPlugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onChange'</span>, [</span><br><span class="line">    <span class="string">'change'</span>,</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    <span class="string">'focusin'</span>,</span><br><span class="line">    <span class="string">'focusout'</span>,</span><br><span class="line">    <span class="string">'input'</span>,</span><br><span class="line">    <span class="string">'keydown'</span>,</span><br><span class="line">    <span class="string">'keyup'</span>,</span><br><span class="line">    <span class="string">'selectionchange'</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SelectEventPlugin"><a href="#SelectEventPlugin" class="headerlink" title="SelectEventPlugin"></a>SelectEventPlugin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\SelectEventPlugin.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onSelect'</span>, [</span><br><span class="line">    <span class="string">'focusout'</span>,</span><br><span class="line">    <span class="string">'contextmenu'</span>,</span><br><span class="line">    <span class="string">'dragend'</span>,</span><br><span class="line">    <span class="string">'focusin'</span>,</span><br><span class="line">    <span class="string">'keydown'</span>,</span><br><span class="line">    <span class="string">'keyup'</span>,</span><br><span class="line">    <span class="string">'mousedown'</span>,</span><br><span class="line">    <span class="string">'mouseup'</span>,</span><br><span class="line">    <span class="string">'selectionchange'</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeforeInputEventPlugin"><a href="#BeforeInputEventPlugin" class="headerlink" title="BeforeInputEventPlugin"></a>BeforeInputEventPlugin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\BeforeInputEventPlugin.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onBeforeInput'</span>, [</span><br><span class="line">    <span class="string">'compositionend'</span>,</span><br><span class="line">    <span class="string">'keypress'</span>,</span><br><span class="line">    <span class="string">'textInput'</span>,</span><br><span class="line">    <span class="string">'paste'</span>,</span><br><span class="line">  ]);</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onCompositionEnd'</span>, [</span><br><span class="line">    <span class="string">'compositionend'</span>,</span><br><span class="line">    <span class="string">'focusout'</span>,</span><br><span class="line">    <span class="string">'keydown'</span>,</span><br><span class="line">    <span class="string">'keypress'</span>,</span><br><span class="line">    <span class="string">'keyup'</span>,</span><br><span class="line">    <span class="string">'mousedown'</span>,</span><br><span class="line">  ]);</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onCompositionStart'</span>, [</span><br><span class="line">    <span class="string">'compositionstart'</span>,</span><br><span class="line">    <span class="string">'focusout'</span>,</span><br><span class="line">    <span class="string">'keydown'</span>,</span><br><span class="line">    <span class="string">'keypress'</span>,</span><br><span class="line">    <span class="string">'keyup'</span>,</span><br><span class="line">    <span class="string">'mousedown'</span>,</span><br><span class="line">  ]);</span><br><span class="line">  registerTwoPhaseEvent(<span class="string">'onCompositionUpdate'</span>, [</span><br><span class="line">    <span class="string">'compositionupdate'</span>,</span><br><span class="line">    <span class="string">'focusout'</span>,</span><br><span class="line">    <span class="string">'keydown'</span>,</span><br><span class="line">    <span class="string">'keypress'</span>,</span><br><span class="line">    <span class="string">'keyup'</span>,</span><br><span class="line">    <span class="string">'mousedown'</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件绑定-listenToAllSupportedEvents"><a href="#事件绑定-listenToAllSupportedEvents" class="headerlink" title="事件绑定 - listenToAllSupportedEvents"></a>事件绑定 - listenToAllSupportedEvents</h3><p>在 <code>React</code> 初始化渲染的时候，会调⽤函数 <code>listenToAllSupportedEvents</code> 来绑定事件。<code>listenAllSupportedEvents</code> 将事件注册在页面的根节点，也就是 <code>div#root</code>。</p>
<p>主要做了两件事情：</p>
<ul>
<li>为避免重复注册事件，在 <code>DOM</code> 上设置一个属性，如果有这个属性说明事件已经被注册了</li>
<li>遍历 <code>allNativeEvents</code>，调用 <code>listenToNativeEvent</code> 进行事件注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Element | Document | DocumentFragment,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CreateRootOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RootType</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// comment nodes 已弃用，这里是为了兼容FB老代码 https://github.com/facebook/react/pull/24110</span></span><br><span class="line">  <span class="keyword">const</span> rootContainerElement: Document | Element | DocumentFragment =</span><br><span class="line">    container.nodeType === COMMENT_NODE</span><br><span class="line">      ? (container.parentNode: any)</span><br><span class="line">      : container;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件绑定</span></span><br><span class="line">  listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMRoot(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenToAllSupportedEvents</span>(<span class="params">rootContainerElement: EventTarget</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(rootContainerElement: any)[listeningMarker]) &#123;</span><br><span class="line">    <span class="comment">// sy 防止重复绑定</span></span><br><span class="line">    (rootContainerElement: any)[listeningMarker] = <span class="literal">true</span>;</span><br><span class="line">    allNativeEvents.forEach(<span class="function"><span class="params">domEventName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// We handle selectionchange separately because it</span></span><br><span class="line">      <span class="comment">// doesn't bubble and needs to be on the document.</span></span><br><span class="line">      <span class="comment">// 单独处理selectionchange事件，因为它不会冒泡，需要在文档上处理。</span></span><br><span class="line">      <span class="keyword">if</span> (domEventName !== <span class="string">'selectionchange'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class="line">          <span class="comment">// ! 这些事件都是委托在rootContainerElement上的</span></span><br><span class="line">          <span class="comment">// nonDelegatedEvents中都是不需要委托的事件，也就是不需要冒泡的，如cancel、close、invalid、load、scroll、scrollend、toggle等</span></span><br><span class="line">          listenToNativeEvent(domEventName, <span class="literal">false</span>, rootContainerElement);</span><br><span class="line">        &#125;</span><br><span class="line">        listenToNativeEvent(domEventName, <span class="literal">true</span>, rootContainerElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单独处理selectionchange事件</span></span><br><span class="line">    <span class="keyword">const</span> ownerDocument =</span><br><span class="line">      (rootContainerElement: any).nodeType === DOCUMENT_NODE</span><br><span class="line">        ? rootContainerElement</span><br><span class="line">        : (rootContainerElement: any).ownerDocument;</span><br><span class="line">    <span class="keyword">if</span> (ownerDocument !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The selectionchange event also needs deduplication</span></span><br><span class="line">      <span class="comment">// but it is attached to the document.</span></span><br><span class="line">      <span class="comment">// selectionchange事件也需要去重，但它附加在document上。</span></span><br><span class="line">      <span class="keyword">if</span> (!(ownerDocument: any)[listeningMarker]) &#123;</span><br><span class="line">        (ownerDocument: any)[listeningMarker] = <span class="literal">true</span>;</span><br><span class="line">        listenToNativeEvent(<span class="string">'selectionchange'</span>, <span class="literal">false</span>, ownerDocument);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"><span class="comment">// We should not delegate these events to the container, but rather</span></span><br><span class="line"><span class="comment">// set them on the actual target element itself. This is primarily</span></span><br><span class="line"><span class="comment">// because these events do not consistently bubble in the DOM.</span></span><br><span class="line"><span class="comment">// 我们不应该将这些事件委托给容器，而是应该直接在实际的目标元素上设置它们。这主要是因为这些事件在DOM中的冒泡行为并不一致。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nonDelegatedEvents: <span class="built_in">Set</span>&lt;DOMEventName&gt; = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">  <span class="string">'cancel'</span>,</span><br><span class="line">  <span class="string">'close'</span>,</span><br><span class="line">  <span class="string">'invalid'</span>,</span><br><span class="line">  <span class="string">'load'</span>,</span><br><span class="line">  <span class="string">'scroll'</span>,</span><br><span class="line">  <span class="string">'scrollend'</span>,</span><br><span class="line">  <span class="string">'toggle'</span>,</span><br><span class="line">  <span class="comment">// In order to reduce bytes, we insert the above array of media events</span></span><br><span class="line">  <span class="comment">// into this Set. Note: the "error" event isn't an exclusive media event,</span></span><br><span class="line">  <span class="comment">// and can occur on other elements too. Rather than duplicate that event,</span></span><br><span class="line">  <span class="comment">// we just take it from the media events array.</span></span><br><span class="line">  <span class="comment">// 为了减少字节数，我们将上述媒体事件数组插入到这个 Set 中。</span></span><br><span class="line">  <span class="comment">// 注意："error" 事件并不是一个独占的媒体事件，也可能发生在其他元素上。我们不会重复这个事件，而是直接从媒体事件数组中取出。</span></span><br><span class="line">  ...mediaEventTypes,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// List of events that need to be individually attached to media elements.</span></span><br><span class="line"><span class="comment">// 需要分别附加到媒体元素的事件列表。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mediaEventTypes: <span class="built_in">Array</span>&lt;DOMEventName&gt; = [</span><br><span class="line">  <span class="string">'abort'</span>,</span><br><span class="line">  <span class="string">'canplay'</span>,</span><br><span class="line">  <span class="string">'canplaythrough'</span>,</span><br><span class="line">  <span class="string">'durationchange'</span>,</span><br><span class="line">  <span class="string">'emptied'</span>,</span><br><span class="line">  <span class="string">'encrypted'</span>,</span><br><span class="line">  <span class="string">'ended'</span>,</span><br><span class="line">  <span class="string">'error'</span>,</span><br><span class="line">  <span class="string">'loadeddata'</span>,</span><br><span class="line">  <span class="string">'loadedmetadata'</span>,</span><br><span class="line">  <span class="string">'loadstart'</span>,</span><br><span class="line">  <span class="string">'pause'</span>,</span><br><span class="line">  <span class="string">'play'</span>,</span><br><span class="line">  <span class="string">'playing'</span>,</span><br><span class="line">  <span class="string">'progress'</span>,</span><br><span class="line">  <span class="string">'ratechange'</span>,</span><br><span class="line">  <span class="string">'resize'</span>,</span><br><span class="line">  <span class="string">'seeked'</span>,</span><br><span class="line">  <span class="string">'seeking'</span>,</span><br><span class="line">  <span class="string">'stalled'</span>,</span><br><span class="line">  <span class="string">'suspend'</span>,</span><br><span class="line">  <span class="string">'timeupdate'</span>,</span><br><span class="line">  <span class="string">'volumechange'</span>,</span><br><span class="line">  <span class="string">'waiting'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="listenToNativeEvent"><a href="#listenToNativeEvent" class="headerlink" title="listenToNativeEvent"></a>listenToNativeEvent</h4><p>这个函数只做一件事情：定义一个 <code>flags</code> 变量表示当前是冒泡还是捕获，然后调用 <code>addTrappedEventListener</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenToNativeEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName, <span class="regexp">//</span> 原生事件名</span></span></span><br><span class="line"><span class="function"><span class="params">  isCapturePhaseListener: boolean, <span class="regexp">//</span> 是否是捕获阶段</span></span></span><br><span class="line"><span class="function"><span class="params">  target: EventTarget, <span class="regexp">//</span> 事件绑定的目标节点，也就是 div#root</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 冒泡用 0 表示，捕获用 4 表示</span></span><br><span class="line">  <span class="keyword">let</span> eventSystemFlags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isCapturePhaseListener) &#123;</span><br><span class="line">    eventSystemFlags |= IS_CAPTURE_PHASE;</span><br><span class="line">  &#125;</span><br><span class="line">  addTrappedEventListener(</span><br><span class="line">    target,</span><br><span class="line">    domEventName,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    isCapturePhaseListener,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addTrappedEventListener"><a href="#addTrappedEventListener" class="headerlink" title="addTrappedEventListener"></a>addTrappedEventListener</h4><p>这个函数主要做了两件事：</p>
<ol>
<li>创建一个监听器，用于事件挂载，具体查看 <code>createEventListenerWrapperWithPriority</code></li>
<li>事件挂载，将事件挂载到目标节点上，也就是将事件绑定到 <code>div#root</code> 上</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTrappedEventListener</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget, <span class="regexp">//</span> 事件挂载节点，也就是 div#root</span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName, <span class="regexp">//</span> 原生事件名，比如 click</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags, <span class="regexp">//</span> <span class="number">4</span> 表示捕获，<span class="number">0</span> 表示冒泡</span></span></span><br><span class="line"><span class="function"><span class="params">  isCapturePhaseListener: boolean, <span class="regexp">//</span> true 表示捕获阶段，false 表示冒泡阶段</span></span></span><br><span class="line"><span class="function"><span class="params">  isDeferredListenerForLegacyFBSupport?: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取对应事件，事件定义在ReactDOMEventListener.js中</span></span><br><span class="line">  <span class="comment">// 如DiscreteEventPriority对应dispatchDiscreteEvent，ContinuousEventPriority对应dispatchContinuousEvent</span></span><br><span class="line">  <span class="comment">// 创建一个事件监听器</span></span><br><span class="line">  <span class="keyword">let</span> listener = createEventListenerWrapperWithPriority(</span><br><span class="line">    targetContainer,</span><br><span class="line">    domEventName,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// If passive option is not supported, then the event will be</span></span><br><span class="line">  <span class="comment">// active and not passive.</span></span><br><span class="line">  <span class="keyword">let</span> isPassiveListener: <span class="keyword">void</span> | boolean = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (passiveBrowserEventsSupported) &#123;</span><br><span class="line">    <span class="comment">// sy</span></span><br><span class="line">    <span class="comment">// Browsers introduced an intervention, making these events</span></span><br><span class="line">    <span class="comment">// passive by default on document. React doesn't bind them</span></span><br><span class="line">    <span class="comment">// to document anymore, but changing this now would undo</span></span><br><span class="line">    <span class="comment">// the performance wins from the change. So we emulate</span></span><br><span class="line">    <span class="comment">// the existing behavior manually on the roots now.</span></span><br><span class="line">    <span class="comment">// 浏览器引入了一种干预措施，使这些事件在document上默认为passive状态。</span></span><br><span class="line">    <span class="comment">// React不再将它们绑定到document上，但是现在改变这一点将会撤销之前的性能优势。</span></span><br><span class="line">    <span class="comment">// 因此，我们现在在根节点上手动模拟现有的行为。</span></span><br><span class="line">    <span class="comment">// https://github.com/facebook/react/issues/19651</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      domEventName === <span class="string">'touchstart'</span> ||</span><br><span class="line">      domEventName === <span class="string">'touchmove'</span> ||</span><br><span class="line">      domEventName === <span class="string">'wheel'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      isPassiveListener = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React17之后，事件委托在targetContainer，但是兼容之前的版本委托在document</span></span><br><span class="line">  targetContainer =</span><br><span class="line">    enableLegacyFBSupport &amp;&amp; isDeferredListenerForLegacyFBSupport</span><br><span class="line">      ? (targetContainer: any).ownerDocument</span><br><span class="line">      : targetContainer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> unsubscribeListener;</span><br><span class="line">  <span class="comment">// When legacyFBSupport is enabled, it's for when we</span></span><br><span class="line">  <span class="comment">// want to add a one time event listener to a container.</span></span><br><span class="line">  <span class="comment">// This should only be used with enableLegacyFBSupport</span></span><br><span class="line">  <span class="comment">// due to requirement to provide compatibility with</span></span><br><span class="line">  <span class="comment">// internal FB www event tooling. This works by removing</span></span><br><span class="line">  <span class="comment">// the event listener as soon as it is invoked. We could</span></span><br><span class="line">  <span class="comment">// also attempt to use the &#123;once: true&#125; param on</span></span><br><span class="line">  <span class="comment">// addEventListener, but that requires support and some</span></span><br><span class="line">  <span class="comment">// browsers do not support this today, and given this is</span></span><br><span class="line">  <span class="comment">// to support legacy code patterns, it's likely they'll</span></span><br><span class="line">  <span class="comment">// need support for such browsers.</span></span><br><span class="line">  <span class="comment">// 当启用legacyFBSupport时，是为了当我们想要向container添加一次性事件监听器时使用。</span></span><br><span class="line">  <span class="comment">// 这应该只与enableLegacyFBSupport一起使用，因为需要与内部FB www事件工具提供的兼容性。</span></span><br><span class="line">  <span class="comment">// 这通过在调用后立即移除事件监听器来实现。我们也可以尝试在addEventListener上使用&#123;once: true&#125;参数，但这需要支持，</span></span><br><span class="line">  <span class="comment">// 一些浏览器今天不支持这一点，考虑到这是为了支持传统代码模式，它们可能需要支持这些浏览器。</span></span><br><span class="line">  <span class="keyword">if</span> (enableLegacyFBSupport &amp;&amp; isDeferredListenerForLegacyFBSupport) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalListener = listener;</span><br><span class="line">    listener = <span class="function"><span class="keyword">function</span> (<span class="params">...p</span>) </span>&#123;</span><br><span class="line">      removeEventListener(</span><br><span class="line">        targetContainer,</span><br><span class="line">        domEventName,</span><br><span class="line">        unsubscribeListener,</span><br><span class="line">        isCapturePhaseListener,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> originalListener.apply(<span class="keyword">this</span>, p);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> There are too many combinations here. Consolidate them.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCapturePhaseListener) &#123;</span><br><span class="line">    <span class="comment">// ! 捕获阶段</span></span><br><span class="line">    <span class="comment">// sy</span></span><br><span class="line">    <span class="keyword">if</span> (isPassiveListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// touchstart、touchmove、wheel</span></span><br><span class="line">      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(</span><br><span class="line">        targetContainer,</span><br><span class="line">        domEventName,</span><br><span class="line">        listener,</span><br><span class="line">        isPassiveListener,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// sy</span></span><br><span class="line">      <span class="comment">// click、contextmenu、drag、drop、input、mousedown、change等事件</span></span><br><span class="line">      unsubscribeListener = addEventCaptureListener(</span><br><span class="line">        targetContainer,</span><br><span class="line">        domEventName,</span><br><span class="line">        listener,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ! 冒泡阶段</span></span><br><span class="line">    <span class="keyword">if</span> (isPassiveListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// touchstart、touchmove、wheel</span></span><br><span class="line">      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(</span><br><span class="line">        targetContainer,</span><br><span class="line">        domEventName,</span><br><span class="line">        listener,</span><br><span class="line">        isPassiveListener,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// click、contextmenu、drag、drop、input、mousedown、change等事件</span></span><br><span class="line">      <span class="comment">// sy</span></span><br><span class="line">      unsubscribeListener = addEventBubbleListener(</span><br><span class="line">        targetContainer,</span><br><span class="line">        domEventName,</span><br><span class="line">        listener,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createEventListenerWrapperWithPriority"><a href="#createEventListenerWrapperWithPriority" class="headerlink" title="createEventListenerWrapperWithPriority"></a>createEventListenerWrapperWithPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\ReactDOMEventListener.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createEventListenerWrapperWithPriority</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据事件名称，获取优先级。比如click、input、drop等对应DiscreteEventPriority，drag、scroll等对应ContinuousEventPriority，</span></span><br><span class="line">  <span class="comment">// message也许处于Scheduler中，根据getCurrentSchedulerPriorityLevel()获取优先级。其它是DefaultEventPriority。</span></span><br><span class="line">  <span class="keyword">const</span> eventPriority = getEventPriority(domEventName);</span><br><span class="line">  <span class="keyword">let</span> listenerWrapper;</span><br><span class="line">  <span class="keyword">switch</span> (eventPriority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">      listenerWrapper = dispatchDiscreteEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">      listenerWrapper = dispatchContinuousEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DefaultEventPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      listenerWrapper = dispatchEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> listenerWrapper.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    domEventName,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    targetContainer,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getEventPriority"><a href="#getEventPriority" class="headerlink" title="getEventPriority"></a>getEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="comment">// Used by SimpleEventPlugin:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'contextmenu'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cut'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'auxclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dblclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'invalid'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keypress'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousedown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'paste'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'play'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointercancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerdown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ratechange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'resize'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'seeked'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'volumechange'</span>:</span><br><span class="line">    <span class="comment">// Used by polyfills: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectionchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionupdate'</span>:</span><br><span class="line">    <span class="comment">// Only enableCreateEventHandleAPI: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeblur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'afterblur'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeinput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'fullscreenchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'hashchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'popstate'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectstart'</span>:</span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragexit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointermove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'toggle'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerleave'</span>:</span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'message'</span>: &#123;</span><br><span class="line">      <span class="comment">// We might be in the Scheduler callback.</span></span><br><span class="line">      <span class="comment">// Eventually this mechanism will be replaced by a check</span></span><br><span class="line">      <span class="comment">// of the current priority on the native scheduler.</span></span><br><span class="line">      <span class="keyword">const</span> schedulerPriority = getCurrentSchedulerPriorityLevel();</span><br><span class="line">      <span class="keyword">switch</span> (schedulerPriority) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediateSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">        <span class="keyword">case</span> UserBlockingSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">        <span class="keyword">case</span> NormalSchedulerPriority:</span><br><span class="line">        <span class="keyword">case</span> LowSchedulerPriority:</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</span></span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">        <span class="keyword">case</span> IdleSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件挂载-捕获阶段"><a href="#事件挂载-捕获阶段" class="headerlink" title="事件挂载 - 捕获阶段"></a>事件挂载 - 捕获阶段</h4><h5 id="支持passive-addEventCaptureListenerWithPassiveFlag"><a href="#支持passive-addEventCaptureListenerWithPassiveFlag" class="headerlink" title="支持passive - addEventCaptureListenerWithPassiveFlag"></a>支持passive - addEventCaptureListenerWithPassiveFlag</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\EventListener.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventCaptureListenerWithPassiveFlag</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventType: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  listener: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  passive: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  target.addEventListener(eventType, listener, &#123;</span><br><span class="line">    capture: <span class="literal">true</span>,</span><br><span class="line">    passive,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addEventCaptureListener"><a href="#addEventCaptureListener" class="headerlink" title="addEventCaptureListener"></a>addEventCaptureListener</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\EventListener.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventCaptureListener</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventType: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  listener: Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  target.addEventListener(eventType, listener, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件挂载-冒泡阶段"><a href="#事件挂载-冒泡阶段" class="headerlink" title="事件挂载 - 冒泡阶段"></a>事件挂载 - 冒泡阶段</h4><h5 id="支持passive-addEventBubbleListenerWithPassiveFlag"><a href="#支持passive-addEventBubbleListenerWithPassiveFlag" class="headerlink" title="支持passive - addEventBubbleListenerWithPassiveFlag"></a>支持passive - addEventBubbleListenerWithPassiveFlag</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\EventListener.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventCaptureListenerWithPassiveFlag</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventType: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  listener: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  passive: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  target.addEventListener(eventType, listener, &#123;</span><br><span class="line">    capture: <span class="literal">true</span>,</span><br><span class="line">    passive,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addEventBubbleListener"><a href="#addEventBubbleListener" class="headerlink" title="addEventBubbleListener"></a>addEventBubbleListener</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-dom-bindings\src\events\EventListener.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventBubbleListener</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventType: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  listener: Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  target.addEventListener(eventType, listener, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件派发"><a href="#事件派发" class="headerlink" title="事件派发"></a>事件派发</h2><h3 id="dispatchDiscreteEvent"><a href="#dispatchDiscreteEvent" class="headerlink" title="dispatchDiscreteEvent"></a>dispatchDiscreteEvent</h3><p>适用事件：click、drop、input、drop 等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 1. 记录上一次的事件优先级</span></span><br><span class="line">  <span class="keyword">const</span> previousPriority = getCurrentUpdatePriority();</span><br><span class="line">  <span class="comment">// ! 2. 记录上一次的transition</span></span><br><span class="line">  <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line">  <span class="comment">// !3. 清空transition，transition为非紧急更新，这里不处理</span></span><br><span class="line">  ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// !4. 设置当前事件优先级为DiscreteEventPriority</span></span><br><span class="line">    setCurrentUpdatePriority(DiscreteEventPriority);</span><br><span class="line">    <span class="comment">// !5. 调用dispatchEvent，执行事件</span></span><br><span class="line">    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// !6. 恢复</span></span><br><span class="line">    setCurrentUpdatePriority(previousPriority);</span><br><span class="line">    ReactCurrentBatchConfig.transition = prevTransition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件优先级记录"><a href="#事件优先级记录" class="headerlink" title="事件优先级记录"></a>事件优先级记录</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-reconciler\src\ReactEventPriorities.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> opaque type EventPriority = Lane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级从上往下，越来越小</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DiscreteEventPriority: EventPriority = SyncLane; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContinuousEventPriority: EventPriority = InputContinuousLane; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultEventPriority: EventPriority = DefaultLane; <span class="comment">// 页面初次渲染的lane 32, transition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleEventPriority: EventPriority = IdleLane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentUpdatePriority: EventPriority = NoLane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentUpdatePriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentUpdatePriority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setCurrentUpdatePriority</span>(<span class="params">newPriority: EventPriority</span>) </span>&#123;</span><br><span class="line">  currentUpdatePriority = newPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchContinuousEvent"><a href="#dispatchContinuousEvent" class="headerlink" title="dispatchContinuousEvent"></a>dispatchContinuousEvent</h3><p>适用事件：drag、mouse的各种事件等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchContinuousEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> previousPriority = getCurrentUpdatePriority();</span><br><span class="line">  <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line">  ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    setCurrentUpdatePriority(ContinuousEventPriority);</span><br><span class="line">    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    setCurrentUpdatePriority(previousPriority);</span><br><span class="line">    ReactCurrentBatchConfig.transition = prevTransition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\ReactDOMEventListener.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 派发事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 有些场景下是禁止事件的，比如在commit阶段</span></span><br><span class="line">  <span class="keyword">if</span> (!_enabled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> blockedOn = findInstanceBlockingEvent(nativeEvent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (blockedOn === <span class="literal">null</span>) &#123;</span><br><span class="line">    dispatchEventForPluginEventSystem(</span><br><span class="line">      domEventName,</span><br><span class="line">      eventSystemFlags,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      return_targetInst,</span><br><span class="line">      targetContainer,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    clearIfContinuousEvent(domEventName, nativeEvent);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    queueIfContinuousEvent(</span><br><span class="line">      blockedOn,</span><br><span class="line">      domEventName,</span><br><span class="line">      eventSystemFlags,</span><br><span class="line">      targetContainer,</span><br><span class="line">      nativeEvent,</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    nativeEvent.stopPropagation();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We need to clear only if we didn't queue because</span></span><br><span class="line">  <span class="comment">// queueing is accumulative.</span></span><br><span class="line">  clearIfContinuousEvent(domEventName, nativeEvent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    eventSystemFlags &amp; IS_CAPTURE_PHASE &amp;&amp;</span><br><span class="line">    isDiscreteEventThatRequiresHydration(domEventName)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">while</span> (blockedOn !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> fiber = getInstanceFromNode(blockedOn);</span><br><span class="line">      <span class="keyword">if</span> (fiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        attemptSynchronousHydration(fiber);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> nextBlockedOn = findInstanceBlockingEvent(nativeEvent);</span><br><span class="line">      <span class="keyword">if</span> (nextBlockedOn === <span class="literal">null</span>) &#123;</span><br><span class="line">        dispatchEventForPluginEventSystem(</span><br><span class="line">          domEventName,</span><br><span class="line">          eventSystemFlags,</span><br><span class="line">          nativeEvent,</span><br><span class="line">          return_targetInst,</span><br><span class="line">          targetContainer,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (nextBlockedOn === blockedOn) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      blockedOn = nextBlockedOn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockedOn !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nativeEvent.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is not replayable so we'll invoke it but without a target,</span></span><br><span class="line">  <span class="comment">// in case the event system needs to trace it.</span></span><br><span class="line">  dispatchEventForPluginEventSystem(</span><br><span class="line">    domEventName,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    targetContainer,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findInstanceBlockingEvent"><a href="#findInstanceBlockingEvent" class="headerlink" title="findInstanceBlockingEvent"></a>findInstanceBlockingEvent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\ReactDOMEventListener.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">findInstanceBlockingEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> | <span class="title">Container</span> | <span class="title">SuspenseInstance</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="keyword">return</span> findInstanceBlockingTarget(nativeEventTarget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> return_targetInst: <span class="literal">null</span> | Fiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a SuspenseInstance or Container if it's blocked.</span></span><br><span class="line"><span class="comment">// The return_targetInst field above is conceptually part of the return value.</span></span><br><span class="line"><span class="comment">// 如果被阻塞，返回一个 SuspenseInstance 或 Container。</span></span><br><span class="line"><span class="comment">// 上面的 return_targetInst 字段在概念上是返回值的一部分。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">findInstanceBlockingTarget</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  targetNode: Node,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> | <span class="title">Container</span> | <span class="title">SuspenseInstance</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Warn if _enabled is false.</span></span><br><span class="line"></span><br><span class="line">  return_targetInst = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 targetNode 获取最近的 Fiber 实例</span></span><br><span class="line">  <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(targetNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (targetInst !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 寻找最近的已挂载的 Fiber 实例</span></span><br><span class="line">    <span class="keyword">const</span> nearestMounted = getNearestMountedFiber(targetInst);</span><br><span class="line">    <span class="keyword">if</span> (nearestMounted === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This tree has been unmounted already. Dispatch without a target.</span></span><br><span class="line">      <span class="comment">// 这棵树已经被卸载了。在没有目标的情况下进行派发。</span></span><br><span class="line">      targetInst = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tag = nearestMounted.tag;</span><br><span class="line">      <span class="keyword">if</span> (tag === SuspenseComponent) &#123;</span><br><span class="line">        <span class="comment">// 寻找最近的已挂载的 Suspense 实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = getSuspenseInstanceFromFiber(nearestMounted);</span><br><span class="line">        <span class="keyword">if</span> (instance !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Queue the event to be replayed later. Abort dispatching since we</span></span><br><span class="line">          <span class="comment">// don't want this event dispatched twice through the event system.</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> If this is the first discrete event in the queue. Schedule an increased</span></span><br><span class="line">          <span class="comment">// priority for this boundary.</span></span><br><span class="line">          <span class="comment">// 将事件排队以便稍后重播。中止事件分发，因为我们不希望通过事件系统将此事件分发两次。</span></span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This shouldn't happen, something went wrong but to avoid blocking</span></span><br><span class="line">        <span class="comment">// the whole system, dispatch the event without a target.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Warn.</span></span><br><span class="line">        <span class="comment">// 这不应该发生，出了点问题，但为了避免阻塞整个系统，以没有目标的方式分发事件。</span></span><br><span class="line">        targetInst = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === HostRoot) &#123;</span><br><span class="line">        <span class="keyword">const</span> root: FiberRoot = nearestMounted.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (isRootDehydrated(root)) &#123;</span><br><span class="line">          <span class="comment">// If this happens during a replay something went wrong and it might block</span></span><br><span class="line">          <span class="comment">// the whole system.</span></span><br><span class="line">          <span class="keyword">return</span> getContainerFromFiber(nearestMounted);</span><br><span class="line">        &#125;</span><br><span class="line">        targetInst = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nearestMounted !== targetInst) &#123;</span><br><span class="line">        <span class="comment">// If we get an event (ex: img onload) before committing that</span></span><br><span class="line">        <span class="comment">// component's mount, ignore it for now (that is, treat it as if it was an</span></span><br><span class="line">        <span class="comment">// event on a non-React tree). We might also consider queueing events and</span></span><br><span class="line">        <span class="comment">// dispatching them after the mount.</span></span><br><span class="line">        <span class="comment">// 如果在提交该组件的挂载之前收到事件（例如：图片加载完成），暂时忽略它（也就是，将其视为在非React树上的事件）。</span></span><br><span class="line">        <span class="comment">// 我们也可以考虑将事件排队，并在挂载后分发它们。</span></span><br><span class="line">        targetInst = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return_targetInst = targetInst;</span><br><span class="line">  <span class="comment">// We're not blocked on anything.</span></span><br><span class="line">   <span class="comment">// 没有阻塞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchEventForPluginEventSystem"><a href="#dispatchEventForPluginEventSystem" class="headerlink" title="dispatchEventForPluginEventSystem"></a>dispatchEventForPluginEventSystem</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\DOMPluginEventSystem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ancestorInst = targetInst;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (eventSystemFlags &amp; IS_EVENT_HANDLE_NON_MANAGED_NODE) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (eventSystemFlags &amp; IS_NON_DELEGATED) === <span class="number">0</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetContainerNode = ((targetContainer: any): Node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are using the legacy FB support flag, we</span></span><br><span class="line">    <span class="comment">// defer the event to the null with a one</span></span><br><span class="line">    <span class="comment">// time event listener so we can defer the event.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      enableLegacyFBSupport &amp;&amp;</span><br><span class="line">      <span class="comment">// If our event flags match the required flags for entering</span></span><br><span class="line">      <span class="comment">// FB legacy mode and we are processing the "click" event,</span></span><br><span class="line">      <span class="comment">// then we can defer the event to the "document", to allow</span></span><br><span class="line">      <span class="comment">// for legacy FB support, where the expected behavior was to</span></span><br><span class="line">      <span class="comment">// match React &lt; 16 behavior of delegated clicks to the doc.</span></span><br><span class="line">      domEventName === <span class="string">'click'</span> &amp;&amp;</span><br><span class="line">      (eventSystemFlags &amp; SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !isReplayingEvent(nativeEvent)</span><br><span class="line">    ) &#123;</span><br><span class="line">      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetInst !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The below logic attempts to work out if we need to change</span></span><br><span class="line">      <span class="comment">// the target fiber to a different ancestor. We had similar logic</span></span><br><span class="line">      <span class="comment">// in the legacy event system, except the big difference between</span></span><br><span class="line">      <span class="comment">// systems is that the modern event system now has an event listener</span></span><br><span class="line">      <span class="comment">// attached to each React Root and React Portal Root. Together,</span></span><br><span class="line">      <span class="comment">// the DOM nodes representing these roots are the "rootContainer".</span></span><br><span class="line">      <span class="comment">// To figure out which ancestor instance we should use, we traverse</span></span><br><span class="line">      <span class="comment">// up the fiber tree from the target instance and attempt to find</span></span><br><span class="line">      <span class="comment">// root boundaries that match that of our current "rootContainer".</span></span><br><span class="line">      <span class="comment">// If we find that "rootContainer", we find the parent fiber</span></span><br><span class="line">      <span class="comment">// sub-tree for that root and make that our ancestor instance.</span></span><br><span class="line">      <span class="keyword">let</span> node: <span class="literal">null</span> | Fiber = targetInst;</span><br><span class="line"></span><br><span class="line">      mainLoop: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 事件没有对应的fiber，没法执行事件，退出</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> nodeTag = node.tag;</span><br><span class="line">        <span class="keyword">if</span> (nodeTag === HostRoot || nodeTag === HostPortal) &#123;</span><br><span class="line">          <span class="keyword">let</span> container = node.stateNode.containerInfo;</span><br><span class="line">          <span class="keyword">if</span> (isMatchingRootContainer(container, targetContainerNode)) &#123;</span><br><span class="line">            <span class="comment">// container和targetContainerNode相等，说明找到了对应的rootContainer</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (nodeTag === HostPortal) &#123;</span><br><span class="line">            <span class="comment">// The target is a portal, but it's not the rootContainer we're looking for.</span></span><br><span class="line">            <span class="comment">// Normally portals handle their own events all the way down to the root.</span></span><br><span class="line">            <span class="comment">// So we should be able to stop now. However, we don't know if this portal</span></span><br><span class="line">            <span class="comment">// was part of *our* root.</span></span><br><span class="line">            <span class="keyword">let</span> grandNode = node.return;</span><br><span class="line">            <span class="keyword">while</span> (grandNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">const</span> grandTag = grandNode.tag;</span><br><span class="line">              <span class="keyword">if</span> (grandTag === HostRoot || grandTag === HostPortal) &#123;</span><br><span class="line">                <span class="keyword">const</span> grandContainer = grandNode.stateNode.containerInfo;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                  isMatchingRootContainer(grandContainer, targetContainerNode)</span><br><span class="line">                ) &#123;</span><br><span class="line">                  <span class="comment">// This is the rootContainer we're looking for and we found it as</span></span><br><span class="line">                  <span class="comment">// a parent of the Portal. That means we can ignore it because the</span></span><br><span class="line">                  <span class="comment">// Portal will bubble through to us.</span></span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              grandNode = grandNode.return;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Now we need to find it's corresponding host fiber in the other</span></span><br><span class="line">          <span class="comment">// tree. To do this we can use getClosestInstanceFromNode, but we</span></span><br><span class="line">          <span class="comment">// need to validate that the fiber is a host instance, otherwise</span></span><br><span class="line">          <span class="comment">// we need to traverse up through the DOM till we find the correct</span></span><br><span class="line">          <span class="comment">// node that is from the other tree.</span></span><br><span class="line">          <span class="keyword">while</span> (container !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> parentNode = getClosestInstanceFromNode(container);</span><br><span class="line">            <span class="keyword">if</span> (parentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> parentTag = parentNode.tag;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              parentTag === HostComponent ||</span><br><span class="line">              parentTag === HostText ||</span><br><span class="line">              (enableFloat ? parentTag === HostHoistable : <span class="literal">false</span>) ||</span><br><span class="line">              parentTag === HostSingleton</span><br><span class="line">            ) &#123;</span><br><span class="line">              node = ancestorInst = parentNode;</span><br><span class="line">              <span class="keyword">continue</span> mainLoop;</span><br><span class="line">            &#125;</span><br><span class="line">            container = container.parentNode;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批量更新</span></span><br><span class="line">  batchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    dispatchEventsForPlugins(</span><br><span class="line">      domEventName,</span><br><span class="line">      eventSystemFlags,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      ancestorInst,</span><br><span class="line">      targetContainer,</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\ReactDOMUpdateBatching.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">batchedUpdates</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isInsideEventHandler) &#123;</span><br><span class="line">    <span class="comment">// If we are currently inside another batch, we need to wait until it</span></span><br><span class="line">    <span class="comment">// fully completes before restoring state.</span></span><br><span class="line">    <span class="comment">// 如果我们当前正在另一个批处理中，需要等待其完全完成后再恢复状态。</span></span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line">  isInsideEventHandler = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> batchedUpdatesImpl(fn, a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isInsideEventHandler = <span class="literal">false</span>;</span><br><span class="line">    finishEventHandler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \packages\react-reconciler\src\ReactFiberWorkLoop.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">batchedUpdates</span>&lt;<span class="title">A</span>, <span class="title">R</span>&gt;(<span class="params">fn: A =&gt; R, a: A</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= BatchedContext;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    <span class="comment">// If there were legacy sync updates, flush them at the end of the outer</span></span><br><span class="line">    <span class="comment">// most batchedUpdates-like method.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      executionContext === NoContext &amp;&amp;</span><br><span class="line">      <span class="comment">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span></span><br><span class="line">      !(__DEV__ &amp;&amp; ReactCurrentActQueue.isBatchingLegacy)</span><br><span class="line">    ) &#123;</span><br><span class="line">      resetRenderTimer();</span><br><span class="line">      flushSyncWorkOnLegacyRootsOnly();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchEventsForPlugins"><a href="#dispatchEventsForPlugins" class="headerlink" title="dispatchEventsForPlugins"></a>dispatchEventsForPlugins</h3><p>这个函数主要做了两件事：</p>
<ol>
<li><code>extractEvents</code> - 提取事件，将事件函数放到 <code>dispatchQueue</code> 队列中</li>
<li><code>processDispatchQueue</code> - 执行事件，将 <code>dispatchQueue</code> 队列中的事件函数依次执行</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchEventsForPlugins</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// nativeEvent.target</span></span><br><span class="line">  <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent);</span><br><span class="line">  <span class="keyword">const</span> dispatchQueue: DispatchQueue = [];</span><br><span class="line">  extractEvents(</span><br><span class="line">    dispatchQueue,</span><br><span class="line">    domEventName,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    targetContainer,</span><br><span class="line">  );</span><br><span class="line">  processDispatchQueue(dispatchQueue, eventSystemFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="extractEvents"><a href="#extractEvents" class="headerlink" title="extractEvents"></a>extractEvents</h3><p>在一开始事件注册时，不同类型的事件由不同的事件插件进行注册，它们的特征可能不一样，但是不同类型的事件底层处理的逻辑是相同的，所以 <code>extractEvents</code> 函数调用了 <code>SimpleEventPlugin.extractEvents</code> 函数，用来提取事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractEvents</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchQueue: DispatchQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: null | EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用插件的 extractEvents 函数，用来提取事件函数</span></span><br><span class="line">  SimpleEventPlugin.extractEvents(</span><br><span class="line">    dispatchQueue,</span><br><span class="line">    domEventName,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">    eventSystemFlags,</span><br><span class="line">    targetContainer,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractEvents</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchQueue: DispatchQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  domEventName: DOMEventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  nativeEventTarget: null | EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetContainer: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.根据原生事件名拿到 react 事件名</span></span><br><span class="line">  <span class="keyword">const</span> reactName = topLevelEventsToReactNames.get(domEventName);</span><br><span class="line">  <span class="keyword">if</span> (reactName === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.定义一个合成事件</span></span><br><span class="line">  <span class="keyword">let</span> SyntheticEventCtor = SyntheticEvent;</span><br><span class="line">  <span class="keyword">let</span> reactEventType: string = domEventName;</span><br><span class="line">  <span class="comment">// 3.根据原生事件名调用不同的合成事件</span></span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keypress'</span>:</span><br><span class="line">      <span class="comment">// Firefox creates a keypress event for function keys too. This removes</span></span><br><span class="line">      <span class="comment">// the unwanted keypress events. Enter is however both printable and</span></span><br><span class="line">      <span class="comment">// non-printable. One would expect Tab to be as well (but it isn't).</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Fixed in https://bugzilla.mozilla.org/show_bug.cgi?id=968056. Can</span></span><br><span class="line">      <span class="comment">// probably remove.</span></span><br><span class="line">      <span class="keyword">if</span> (getEventCharCode(((nativeEvent: any): KeyboardEvent)) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* falls through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticKeyboardEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">      reactEventType = <span class="string">'focus'</span>;</span><br><span class="line">      SyntheticEventCtor = SyntheticFocusEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">      reactEventType = <span class="string">'blur'</span>;</span><br><span class="line">      SyntheticEventCtor = SyntheticFocusEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeblur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'afterblur'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticFocusEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">      <span class="comment">// Firefox creates a click event on right mouse clicks. This removes the</span></span><br><span class="line">      <span class="comment">// unwanted click events.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Fixed in https://phabricator.services.mozilla.com/D26793. Can</span></span><br><span class="line">      <span class="comment">// probably remove.</span></span><br><span class="line">      <span class="keyword">if</span> (nativeEvent.button === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* falls through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'auxclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dblclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousedown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseup'</span>:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Disabled elements should not respond to mouse events</span></span><br><span class="line">    <span class="comment">/* falls through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'contextmenu'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticMouseEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragexit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticDragEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticTouchEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ANIMATION_END:</span><br><span class="line">    <span class="keyword">case</span> ANIMATION_ITERATION:</span><br><span class="line">    <span class="keyword">case</span> ANIMATION_START:</span><br><span class="line">      SyntheticEventCtor = SyntheticAnimationEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRANSITION_END:</span><br><span class="line">      SyntheticEventCtor = SyntheticTransitionEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scrollend'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticUIEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticWheelEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cut'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'paste'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticClipboardEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'gotpointercapture'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'lostpointercapture'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointercancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerdown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointermove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerup'</span>:</span><br><span class="line">      SyntheticEventCtor = SyntheticPointerEvent;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Unknown event. This is used by createEventHandle.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否是捕获阶段</span></span><br><span class="line">  <span class="keyword">const</span> inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> accumulateTargetOnly =</span><br><span class="line">    !inCapturePhase &amp;&amp;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ideally, we'd eventually add all events from</span></span><br><span class="line">    <span class="comment">// nonDelegatedEvents list in DOMPluginEventSystem.</span></span><br><span class="line">    <span class="comment">// Then we can remove this special list.</span></span><br><span class="line">    <span class="comment">// This is a breaking change that can wait until React 18.</span></span><br><span class="line">    <span class="comment">// TODO：理想情况下，我们最终会将nonDelegatedEvents列表中的所有事件添加到DOMPluginEventSystem中。</span></span><br><span class="line">    <span class="comment">// 然后我们可以移除这个特殊列表。这是一个破坏性的变更，可以等到React 18再处理。</span></span><br><span class="line">    (domEventName === <span class="string">'scroll'</span> || domEventName === <span class="string">'scrollend'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.收集从事件源到事件绑定的地方所有的事件函数</span></span><br><span class="line">  <span class="keyword">const</span> listeners = accumulateSinglePhaseListeners(</span><br><span class="line">    targetInst,</span><br><span class="line">    reactName,</span><br><span class="line">    nativeEvent.type,</span><br><span class="line">    inCapturePhase,</span><br><span class="line">    accumulateTargetOnly,</span><br><span class="line">    nativeEvent,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 5.将事件函数保存到事件函数队列中</span></span><br><span class="line">  <span class="keyword">if</span> (listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Intentionally create event lazily.</span></span><br><span class="line">    <span class="keyword">const</span> event: ReactSyntheticEvent = <span class="keyword">new</span> SyntheticEventCtor(</span><br><span class="line">    reactName,</span><br><span class="line">    reactEventType,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeEventTarget,</span><br><span class="line">    );</span><br><span class="line">    dispatchQueue.push(&#123;event, listeners&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processDispatchQueue"><a href="#processDispatchQueue" class="headerlink" title="processDispatchQueue"></a>processDispatchQueue</h3><p><code>processDispatchQueue</code> 函数主要功能是执行事件函数队列中的事件函数</p>
<p><code>dispatchQueue</code> 队列的数据结构如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    event, <span class="comment">// 合成事件对象</span></span><br><span class="line">    listeners: [事件源对应的事件函数, 事件源父节点对应的事件函数, ..., div#root 对应的事件函数], // 事件函数队列</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processDispatchQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchQueue: DispatchQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchQueue.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;event, listeners&#125; = dispatchQueue[i];</span><br><span class="line">    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);</span><br><span class="line">    <span class="comment">//  event system doesn't use pooling.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// This would be a good time to rethrow if any of the event handlers threw.</span></span><br><span class="line">  rethrowCaughtError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体执行是由 <code>processDispatchQueueItemsInOrder</code> 执行</p>
<ol>
<li>判断是不是捕获阶段<ol>
<li>如果是捕获阶段，就从后往前执行</li>
<li>如果是冒泡阶段，就从前往后执行</li>
<li>在执行事件函数之前，如果事件被阻止了，则不在继续执行事件函数</li>
</ol>
</li>
<li>事件函数执行由 <code>executeDispatch</code> 函数完成</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processDispatchQueueItemsInOrder</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactSyntheticEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  dispatchListeners: Array&lt;DispatchListener&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  inCapturePhase: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previousInstance;</span><br><span class="line">  <span class="keyword">if</span> (inCapturePhase) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = dispatchListeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;instance, currentTarget, listener&#125; = dispatchListeners[i];</span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executeDispatch(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;instance, currentTarget, listener&#125; = dispatchListeners[i];</span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.isPropagationStopped()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executeDispatch(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行事件-executeDispatch"><a href="#执行事件-executeDispatch" class="headerlink" title="执行事件 - executeDispatch"></a>执行事件 - executeDispatch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeDispatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  event: ReactSyntheticEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">  listener: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = event.type || <span class="string">'unknown-event'</span>;</span><br><span class="line">  event.currentTarget = currentTarget;</span><br><span class="line">  invokeGuardedCallbackAndCatchFirstError(type, listener, <span class="literal">undefined</span>, event);</span><br><span class="line">  event.currentTarget = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invokeGuardedCallbackAndCatchFirstError"><a href="#invokeGuardedCallbackAndCatchFirstError" class="headerlink" title="invokeGuardedCallbackAndCatchFirstError"></a>invokeGuardedCallbackAndCatchFirstError</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallbackAndCatchFirstError</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">A</span>,</span></span><br><span class="line"><span class="function">  <span class="title">B</span>,</span></span><br><span class="line"><span class="function">  <span class="title">C</span>,</span></span><br><span class="line"><span class="function">  <span class="title">D</span>,</span></span><br><span class="line"><span class="function">  <span class="title">E</span>,</span></span><br><span class="line"><span class="function">  <span class="title">F</span>,</span></span><br><span class="line"><span class="function">  <span class="title">Context</span>,</span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  this: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  func: (a: A, b: B, c: C, d: D, e: E, f: F</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">context</span>: <span class="title">Context</span>,</span></span><br><span class="line"><span class="function">  <span class="title">a</span>: <span class="title">A</span>,</span></span><br><span class="line"><span class="function">  <span class="title">b</span>: <span class="title">B</span>,</span></span><br><span class="line"><span class="function">  <span class="title">c</span>: <span class="title">C</span>,</span></span><br><span class="line"><span class="function">  <span class="title">d</span>: <span class="title">D</span>,</span></span><br><span class="line"><span class="function">  <span class="title">e</span>: <span class="title">E</span>,</span></span><br><span class="line"><span class="function">  <span class="title">f</span>: <span class="title">F</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  invokeGuardedCallback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = clearCaughtError();</span><br><span class="line">    <span class="keyword">if</span> (!hasRethrowError) &#123;</span><br><span class="line">      hasRethrowError = <span class="literal">true</span>;</span><br><span class="line">      rethrowError = error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallback</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>, <span class="title">F</span>, <span class="title">Context</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  func: (a: A, b: B, c: C, d: D, e: E, f: F</span>) =&gt; <span class="title">mixed</span>,</span></span><br><span class="line"><span class="function">  <span class="title">context</span>: <span class="title">Context</span>,</span></span><br><span class="line"><span class="function">  <span class="title">a</span>: <span class="title">A</span>,</span></span><br><span class="line"><span class="function">  <span class="title">b</span>: <span class="title">B</span>,</span></span><br><span class="line"><span class="function">  <span class="title">c</span>: <span class="title">C</span>,</span></span><br><span class="line"><span class="function">  <span class="title">d</span>: <span class="title">D</span>,</span></span><br><span class="line"><span class="function">  <span class="title">e</span>: <span class="title">E</span>,</span></span><br><span class="line"><span class="function">  <span class="title">f</span>: <span class="title">F</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  hasError = <span class="literal">false</span>;</span><br><span class="line">  caughtError = <span class="literal">null</span>;</span><br><span class="line">  invokeGuardedCallbackImpl.apply(reporter, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallbackImpl</span>&lt;<span class="title">Args</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt;, <span class="title">Context</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  this: &#123;onError: (error: mixed</span>) =&gt; <span class="title">void</span>&#125;,</span></span><br><span class="line"><span class="function">  <span class="title">name</span>: <span class="title">string</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">func</span>: (<span class="params">...Args</span>) =&gt; <span class="title">mixed</span>,</span></span><br><span class="line"><span class="function">  <span class="title">context</span>: <span class="title">Context</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> funcArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      func.apply(context, funcArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件系统核心原理比较简单，主要的作用是抹平各浏览器之间的差异。</p>
<p>通过 react 合成事件的学习，学习 react 对于事件系统的分层设计，它将不同类型的事件做成了插件，每个插件提供注册事件和提取事件两个接口，插件自身去实现事件的注册和事件提取。</p>
<p>这样做的好处是，当我们需要扩展新的事件时，只需要实现这两个接口就可以了，不需要修改原有的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%20Diff%E7%AE%97%E6%B3%95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%20Diff%E7%AE%97%E6%B3%95.html" class="post-title-link" itemprop="url">react18.2 Diff算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-16 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-16T00:00:00+08:00">2025-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h2><h3 id="单节点diff-reconcileSingleElement"><a href="#单节点diff-reconcileSingleElement" class="headerlink" title="单节点diff - reconcileSingleElement"></a>单节点diff - reconcileSingleElement</h3><p>单节点diff的为什么做成一个循环:</p>
<ul>
<li>因为新的内容只有一个节点，不代表旧的内容只有一个节点，这里可以分为两种情况：<ul>
<li>新旧都只有一个节点，只执行一次循环的比较</li>
<li>旧的有多个节点，新的只有一个节点，就会循环旧的节点，依次和这个新节点进行key的比较，如果key相等，再比较type类型，比如是否都是div类型</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取出最新的react元素对象的key</span></span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild; <span class="comment">// 旧的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查老的fiber单链表中是否有可以复用的节点</span></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 1.key相等的情况下</span></span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="comment">// 取出最新的节点type：比如组件的type或者DOM节点的type</span></span><br><span class="line">        <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">        <span class="comment">// 2.组件type为Fragment</span></span><br><span class="line">        <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">          <span class="comment">// 新老都是Fragment</span></span><br><span class="line">          <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">            <span class="comment">// 在相等的情况下，给剩下的旧节点打上删除标记</span></span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="comment">// 复用当前旧的节点，生成新的fiber节点</span></span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props.children);</span><br><span class="line">            <span class="comment">// 设置父级节点</span></span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 3，组件type也相等的情况下</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            child.elementType === elementType ||</span><br><span class="line">            <span class="comment">// Keep this check inline so it only runs on the false path:</span></span><br><span class="line">            (__DEV__</span><br><span class="line">              ? isCompatibleFamilyForHotReloading(child, element)</span><br><span class="line">              : <span class="literal">false</span>) ||</span><br><span class="line">            <span class="comment">// Lazy types should reconcile their resolved type.</span></span><br><span class="line">            <span class="comment">// We need to do this after the Hot Reloading check above,</span></span><br><span class="line">            <span class="comment">// because hot reloading has different semantics than prod because</span></span><br><span class="line">            <span class="comment">// it doesn't resuspend. So we can't let the call below suspend.</span></span><br><span class="line">            (<span class="keyword">typeof</span> elementType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">              elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              elementType.$$<span class="keyword">typeof</span> === REACT_LAZY_TYPE &amp;&amp;</span><br><span class="line">              resolveLazy(elementType) === child.type)</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// 在相等的情况下，给剩下的旧节点打上删除标记</span></span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="comment">// 复用当前旧的节点，生成新的fiber节点（生成的existing的pendingProps就是新的了）</span></span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">            <span class="comment">// 设置初始的ref</span></span><br><span class="line">            coerceRef(returnFiber, child, existing, element);</span><br><span class="line">            <span class="comment">// 设置父级节点</span></span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key相等但是type不等的情况下，给所有旧节点打上删除标记【比如组件由div变成span了】</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4，key不相等的情况下，给当前旧的节点打上删除标记</span></span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取出旧的节点的兄弟节点，继续与新的节点进行比较【旧节点可能存在多个】</span></span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初次挂载 2. 没有找到可以服用的老节点</span></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        element.props.children,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        lanes,</span><br><span class="line">        element.key,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line">      coerceRef(returnFiber, currentFirstChild, created, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多节点diff-reconcileChildrenArray"><a href="#多节点diff-reconcileChildrenArray" class="headerlink" title="多节点diff - reconcileChildrenArray"></a>多节点diff - reconcileChildrenArray</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: Array&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 存储新生成的child</span></span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ! 1. 从左边往右遍历，比较新老节点，如果节点可以复用，继续往右，否则就停止</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That's</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn't reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we're not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don't want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.1 新节点没了，（老节点还有）。则删除剩余的老节点即可</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We've reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 2.2 (新节点还有)，老节点没了</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don't have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.3 新老节点都还有节点，但是因为老fiber是链表，不方便快速get与delete，</span></span><br><span class="line">    <span class="comment">// !   因此把老fiber链表中的节点放入Map中，后续操作这个Map的get与delete</span></span><br><span class="line">    <span class="comment">// 0 1|   4 5</span></span><br><span class="line">    <span class="comment">// 0 1| 7 8 2 3</span></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don't add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// !3. 如果是组件更新阶段，此时新节点已经遍历完了，能复用的老节点都用完了，</span></span><br><span class="line">    <span class="comment">// ! 则最后查找Map里是否还有元素，如果有，则证明是新节点里不能复用的，也就是要被删除的元素，此时删除这些元素就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren't consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">      pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><h4 id="updateSlot"><a href="#updateSlot" class="headerlink" title="updateSlot"></a>updateSlot</h4><p><code>updateSlot</code> 函数的主要作用是：调用 <code>updateTextNode</code> 或者 <code>updateElement</code> 函数，如果 <code>Fiber</code> 能够复用就复用，不能够复用就创建一个新的 <code>Fiber</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSlot</span>(<span class="params">returnFiber, oldFiber, newChild</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = oldFiber !== <span class="literal">null</span> ? oldFiber.key : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> newChild === <span class="string">"string"</span> &amp;&amp; newChild !== <span class="string">""</span>) || <span class="keyword">typeof</span> newChild === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> updateTextNode(returnFiber, oldFiber, <span class="string">""</span> + newChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newChild !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> newChild === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">        <span class="keyword">if</span> (newChild.key === key) &#123;</span><br><span class="line">          <span class="keyword">return</span> updateElement(returnFiber, oldFiber, newChild);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="placeChild"><a href="#placeChild" class="headerlink" title="placeChild"></a>placeChild</h4><p><code>placeChild</code> 函数主要作用是：判断当前的 <code>newFiber</code> 是否是复用的节点，如果是复用的节点，就返回这个节点的 <code>index</code> 作为 <code>lastPlacedIndex</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 fiber 都有一个 index 属性，表示当前 fiber 在父节点中的位置</span></span><br><span class="line"><span class="comment">// 如果是个复用的 fiber，current 存在，且 current.index &gt; lastPlacedIndex，否则表示这个节点需要新创建，也可能是移动（移动也是创建）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params">newFiber, lastPlacedIndex, newIdx</span>) </span>&#123;</span><br><span class="line">  newFiber.index = newIdx;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> current = newFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldIndex = current.index;</span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">      newFiber.flags |= Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 复用节点，返回复用节点的 index</span></span><br><span class="line">      <span class="keyword">return</span> oldIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newFiber.flags |= Placement;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="updateFromMap"><a href="#updateFromMap" class="headerlink" title="updateFromMap"></a>updateFromMap</h4><p><code>updateFromMap</code> 函数的主要作用是：和 <code>updateSlot</code> 函数功能差不多，从 <code>existingChildren</code> 中找到相应的 <code>Fiber</code>，然后调用 <code>updateTextNode</code> 或者 <code>updateElement</code> 函数，如果 <code>Fiber</code> 能够复用就复用，不能够复用就创建一个新的 <code>Fiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFromMap</span>(<span class="params">existingChildren, returnFiber, newIdx, newChild</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 文本 Fiber</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> newChild === <span class="string">"string"</span> &amp;&amp; newChild !== <span class="string">""</span>) || <span class="keyword">typeof</span> newChild === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> matchedFiber = existingChildren.get(newIdx) || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> updateTextNode(returnFiber, matchedFiber, <span class="string">`<span class="subst">$&#123;newChild&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// div/span Fiber</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">"object"</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">        <span class="keyword">const</span> matchedFiber = existingChildren.get(newChild.key === <span class="literal">null</span> ? newIdx : newChild.key) || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> updateElement(returnFiber, matchedFiber, newChild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="updateTextNode"><a href="#updateTextNode" class="headerlink" title="updateTextNode"></a>updateTextNode</h4><p><code>updateTextNode</code> 函数的主要作用是：如果 <code>current</code> 存在，就复用 <code>Fiber</code>，否则就创建一个新的 <code>Fiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTextNode</span>(<span class="params">returnFiber, current, textContent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span> || current.tag !== HostText) &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromText(textContent);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> existing = useFiber(current, textContent);</span><br><span class="line">    existing.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> existing;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="updateElement"><a href="#updateElement" class="headerlink" title="updateElement"></a>updateElement</h4><p><code>updateElement</code> 函数的主要作用是：如果 <code>current</code> 存在，且 <code>current.type</code> === <code>element.type</code>，就复用 <code>Fiber</code>，否则就创建一个新的 <code>Fiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateElement</span>(<span class="params">returnFiber, current, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.type === elementType) &#123;</span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(current, element.props);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> created = createFiberFromElement(element);</span><br><span class="line">  created.return = returnFiber;</span><br><span class="line">  <span class="keyword">return</span> created;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>主要功能是对不同 fiber.tag 进行不同的处理。HostRoot容器节点document.getElementById(‘root’)，HostComponent常规节点div/span，HostText文本节点</li>
<li>updateHostComponent</li>
<li>reconcileChildren 函数负责协调子节点，接收三个参数：current：构建完成的 fiber 树；workInProgress：构建中的 fiber 树；nextChildren：要处理的子节点。<ol>
<li>标注子节点是否要移动，如果没有old子节点。直接标注 Placement（新增或者移动位置），如果有old子节点，如果oldIndex &lt; lastPlacedIndex(上一次新增或者移动的点的index)，证明可以移动，否则就保持原位置</li>
<li>01234 -&gt; 2134 移动的是1</li>
<li>2134 -&gt; 01234 移动的是2</li>
<li>1 3 2 5 -&gt; 0 1 2 3 4 移动的是3</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">newFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">lastPlacedIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params">newIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">newFiber.index = newIndex;</span><br><span class="line"><span class="keyword">const</span> current = newFiber.alternate;</span><br><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldIndex = current.index;</span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">    <span class="comment">// This is a move.</span></span><br><span class="line">    newFiber.flags |= Placement | PlacementDEV;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This item can stay in place.</span></span><br><span class="line">    <span class="keyword">return</span> oldIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This is an insertion.</span></span><br><span class="line">    newFiber.flags |= Placement | PlacementDEV;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="completeWork-总结"><a href="#completeWork-总结" class="headerlink" title="completeWork-总结"></a>completeWork-总结</h2><ol>
<li>没有老节点<ol>
<li>创建真实的 DOM 节点</li>
<li>将当前子节点下子节点挂载到当前节点上</li>
</ol>
</li>
<li>有老节点<ol>
<li>updateHostComponent，对比workInProgress.pendingProps 和  current.memoizedProps，如果不同，就markUpdate标记更新</li>
</ol>
</li>
<li>bubbleProperties - 收集当前节点下子节点的 flags 和 subtreeFlags</li>
</ol>
<h2 id="commitWork"><a href="#commitWork" class="headerlink" title="commitWork"></a>commitWork</h2><p>commitWork 在处理单节点时落脚点也是在 HostComponent 中，主要分为三种处理方式：</p>
<ul>
<li>DOM 节点是新增，也就是 Placement，协调是标记哪些节点要移动（包括新增的节点和复用需要移动的节点）下面代码分析了一下要插入到哪个节点前面</li>
<li>DOM 节点中的文本内容变成空，也就是 ContentReset, ContentReset会调用 resetTextContnt 将文本节点设置为空</li>
<li>DOM 节点是更新，也就是 Update，会调用 commitUpdate 更新 DOM 节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; Placement) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      commitPlacement(finishedWork);</span><br><span class="line">    &#125;</span><br><span class="line">    finishedWork.flags &amp;= ~Placement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostSingleton: &#123;</span><br><span class="line">      <span class="keyword">if</span> (supportsSingletons) &#123;</span><br><span class="line">        <span class="keyword">const</span> parent: Instance = parentFiber.stateNode;</span><br><span class="line">        <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">        <span class="comment">// We only have the top Fiber that was inserted but we need to recurse down its</span></span><br><span class="line">        <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">        insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Fall through</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> parent: Instance = parentFiber.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (parentFiber.flags &amp; ContentReset) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c [  ]-1832'</span>, <span class="string">'font-size:13px; background:pink; color:#bf2c9f;'</span>, )</span><br><span class="line">        <span class="comment">// Reset the text content of the parent before doing any insertions</span></span><br><span class="line">        resetTextContent(parent);</span><br><span class="line">        <span class="comment">// Clear ContentReset from the effect tag</span></span><br><span class="line">        parentFiber.flags &amp;= ~ContentReset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      <span class="comment">// We only have the top Fiber that was inserted but we need to recurse down its</span></span><br><span class="line">      <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">      insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="keyword">case</span> HostPortal: &#123;</span><br><span class="line">      <span class="keyword">const</span> parent: Container = parentFiber.stateNode.containerInfo;</span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid host parent fiber. This error is likely caused by a bug '</span> +</span><br><span class="line">          <span class="string">'in React. Please file an issue.'</span>,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHostSibling</span>(<span class="params">fiber: Fiber</span>): ?<span class="title">Instance</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We're going to search forward into the tree until we find a sibling host</span></span><br><span class="line">  <span class="comment">// node. Unfortunately, if multiple insertions are done in a row we have to</span></span><br><span class="line">  <span class="comment">// search past them. This leads to exponential search for the next sibling.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Find a more efficient way to do this.</span></span><br><span class="line">  <span class="keyword">let</span> node: Fiber = fiber;</span><br><span class="line">  siblings: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// If we didn't find anything, let's try the next sibling.</span></span><br><span class="line">    <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.return === <span class="literal">null</span> || isHostParent(node.return)) &#123;</span><br><span class="line">        <span class="comment">// If we pop out of the root or hit the parent the fiber we are the</span></span><br><span class="line">        <span class="comment">// last sibling.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.return;</span><br><span class="line">    &#125;</span><br><span class="line">    node.sibling.return = node.return;</span><br><span class="line">    node = node.sibling; <span class="comment">// 找到下一个兄弟节点</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      node.tag !== HostComponent &amp;&amp;</span><br><span class="line">      node.tag !== HostText &amp;&amp;</span><br><span class="line">      (!supportsSingletons ? <span class="literal">true</span> : node.tag !== HostSingleton) &amp;&amp;</span><br><span class="line">      node.tag !== DehydratedFragment</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// If it is not host node and, we might have a host node inside it.</span></span><br><span class="line">      <span class="comment">// Try to search down until we find one.</span></span><br><span class="line">      <span class="keyword">if</span> (node.flags &amp; Placement) &#123;</span><br><span class="line">        <span class="comment">// If we don't have a child, try the siblings instead.</span></span><br><span class="line">        <span class="keyword">continue</span> siblings;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If we don't have a child, try the siblings instead.</span></span><br><span class="line">      <span class="comment">// We also skip portals because they are not part of this host tree.</span></span><br><span class="line">      <span class="keyword">if</span> (node.child === <span class="literal">null</span> || node.tag === HostPortal) &#123;</span><br><span class="line">        <span class="keyword">continue</span> siblings;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.child.return = node;</span><br><span class="line">        node = node.child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check if this host node is stable or about to be placed.</span></span><br><span class="line">    <span class="comment">// 判断节点是稳定的，即不需要移动或是新增的</span></span><br><span class="line">    <span class="keyword">if</span> (!(node.flags &amp; Placement)) &#123;</span><br><span class="line">      <span class="comment">// Found it!</span></span><br><span class="line">      <span class="comment">// 就找到了这个节点了</span></span><br><span class="line">      <span class="keyword">return</span> node.stateNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2hook%E4%B9%8BuseCallback%E5%92%8CuseMemo%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2hook%E4%B9%8BuseCallback%E5%92%8CuseMemo%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2hook之useCallback和useMemo原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-12T00:00:00+08:00">2025-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>useCallback</code> 和 <code>useMemo</code> 是一样的东西，只是入参有所不同。</p>
<p><code>useCallback</code> 缓存的是回调函数，如果依赖项没有更新，就会使用缓存的回调函数</p>
<p><code>useMemo</code> 缓存的是回调函数的 <code>return</code>，如果依赖项没有更新，就会使用缓存的 <code>return</code></p>
<p>官网有这样一段描述，换言之 <code>useCallback(fn, dependencies)</code> 相当于 <code>useMemo(() =&gt; fn, dependencies)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simplified implementation (inside React)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">fn, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> fn, dependencies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><strong><code>useCallback</code> 允许你在组件渲染之间保存 函数定义。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedFn = useCallback(fn, dependencies)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li><code>fn</code> ：想要缓存的函数。此函数可以接受任何参数并且返回任何值。<ol>
<li>React 将会在初次渲染⽽⾮调⽤时返回该函数。</li>
<li>当进⾏下⼀次渲染时，如果 <code>dependencies</code> 相⽐于上⼀次渲染时没有改变，那么 React 将会返回相同的函数。</li>
<li>否则，React 将返回在最新⼀次渲染中传⼊的函数，并且将其缓存以便之后使⽤。</li>
<li>React 不会调⽤此函数，⽽是返回此函数。你可以⾃⼰决定何时调⽤以及是否调⽤。</li>
</ol>
</li>
<li><code>dependencies</code> ：有关是否更新 <code>fn</code> 的所有响应式值的⼀个列表。<ol>
<li>响应式值包括 <code>props</code>、<code>state</code>，和所有在你组件内部直接声明的变量和函数。</li>
<li>依赖列表必须具有确切数量的项，并且必须像 <code>[dep1, dep2, dep3]</code> 这样编写。</li>
<li>React 使⽤ <code>Object.is</code> ⽐较每⼀个依赖和它的之前的值。</li>
</ol>
</li>
</ol>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在初次渲染时， <code>useCallback</code> 返回你已经传⼊的 <code>fn</code> 函数</p>
<p>在之后的渲染中, 如果依赖没有改变， <code>useCallback</code> 返回上⼀次渲染中缓存的 <code>fn</code> 函数；否则返回这⼀次渲染传⼊的 <code>fn</code> 。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateCallback</code> 代码意图也很简单，如果依赖数组 <code>deps</code> 没有变化，或者 <code>deps=[]</code> 的情况下，会返回之前缓存的回调函数，否则就更新对应 <code>fiber.memoizedState.hook.memoizedState</code> 并返回新的回调函数。</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p><code>useMemo</code> 是每次重新渲染的时候能够缓存计算结果的Hook。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedValue = useMemo(calculateValue, dependencies)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="comment">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span></span><br><span class="line">  <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h2><ol>
<li><code>useCallBack</code> 不要每个函数都包一下，否则就会变成反向优化。<ol>
<li><code>useCallBack</code> 本身就是需要一定性能的</li>
<li>其次 <code>useCallBack</code> 并不能阻止函数重新创建, 由于使用 <code>useCallback</code> 时，函数会作为实参传给 <code>useCallback</code>，所以无论怎样 <code>useCallback</code> 包裹的函数都是会重新创建的，只是当 <code>useCallback</code> 的依赖没有改变时返回的是缓存中的函数而已</li>
</ol>
</li>
<li><code>useMemo</code> 的关键是权衡。其目的是避免不必要的计算，但也要注意不要滥用，因为维持这些缓存值也是有开销的。最佳的做法是先写出清晰和可读的代码，然后在性能瓶颈出现时，再考虑优化。<ol>
<li>如果函数组件中某个值需要大量的计算才能得出，或者渲染某个组件时有昂贵的计算，都可以考虑使用 <code>useMemo</code> 进行包裹</li>
<li>当值作为别的 hooks 的依赖时，可以考虑使用</li>
</ol>
</li>
<li>如果某个函数或者值是传递给子组件的 <code>props</code>，可以考虑使用 <code>useCallback</code> 或者 <code>useMemo</code> 进行包裹（配合 <code>React.memo</code> 使用）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2hook之useEffect和useLayoutEffect原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-06T00:00:00+08:00">2025-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先来解读下几个参数:</p>
<ul>
<li><code>fiberFlags</code>：有副作用的更新标记，用来标记hook所在的fiber；</li>
<li><code>hookFlags</code>：副作用标记；</li>
<li><code>create</code>：使用者传入的回调函数；</li>
<li><code>deps</code>：使用者传入的数组依赖；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiberFlags: Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  hookFlags: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 判断是否有传入deps，如果有会作为下次更新的deps</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 给hook所在的fiber打上有副作用的更新的标记</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 将副作用操作存放到fiber.memoizedState.hook.memoizedState中</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    createEffectInstance(),</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEffectInstance</span>(<span class="params"></span>): <span class="title">EffectInstance</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">destroy</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">inst</span>: <span class="title">EffectInstance</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">Effect</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化副作用结构</span></span><br><span class="line">  <span class="keyword">const</span> effect: Effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    inst,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向fiber的updateQueue上添加effect，并形成环形链表</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue: <span class="literal">null</span> | FunctionComponentUpdateQueue =</span><br><span class="line">    (currentlyRenderingFiber.updateQueue: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码除了初始化副作用的结构代码外，还有就是操作闭环链表，向链表末尾添加新的 <code>effect</code>，该 <code>effect.next</code> 指向 <code>fisrtEffect</code>，并且链表当前的指针指向最新添加的 <code>effect</code>。</p>
<p>简单总结一下：给 <code>hook</code> 所在的 <code>fiber</code> 打上副作用更新标记，并且 <code>fiber.memoizedState.hook.memoizedState</code> 和 <code>fiber.updateQueue</code> 存储了相关的副作用，这些副作用通过闭环链表的结构存储。</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image.png" alt="alt text"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>主要功能就是创建一个带有回调函数的 <code>newHook</code> 去覆盖之前的 <code>hook</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiberFlags: Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  hookFlags: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> effect: Effect = hook.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> inst = effect.inst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// currentHook is null on initial mount when rerendering after a render phase</span></span><br><span class="line">  <span class="comment">// state update or for strict mode.</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevEffect: Effect = currentHook.memoizedState;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="comment">// 比较两次依赖数组中的值是否有变化</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    inst,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-1.png" alt="alt text"></p>
<h3 id="create-和-destroy-函数是怎样被调用？"><a href="#create-和-destroy-函数是怎样被调用？" class="headerlink" title="create 和 destroy 函数是怎样被调用？"></a>create 和 destroy 函数是怎样被调用？</h3><p>在弄清楚怎样被调用之前，我们先来看 <code>destroy</code> 函数的存在性问题。即：在 <code>hook</code> 的 <code>mount</code> 阶段，我们创建 <code>effect</code> 对象的时候，<code>destroy</code> 函数是不存在的。因为，<code>destroy</code> 函数本来就是 <code>create</code> 函数的返回值。而此时 <code>create</code> 函数还没有被调用。</p>
<p>而我们知道，组件 <code>mount</code> 阶段过后， <code>create</code> 函数是一定会被调用的。所以，我们也可以推理得出，在组件的 <code>update</code> 阶段，<code>effect</code> 对象的 <code>create</code> 函数和 <code>destroy</code> 函数肯定是存在的（现在我们假设用户一定定义 <code>destroy</code> 函数 ）。</p>
<p><code>react</code> 会在 <code>commit</code> 阶段去调用我们的 <code>create</code> 函数和 <code>destroy</code> 函数。<code>commit</code> 阶段又可以分为三个子阶段:</p>
<ul>
<li>beforeMutation</li>
<li>mutation</li>
<li>layout</li>
</ul>
<p>回到源码的视角，<code>create</code> 函数和 <code>destroy</code> 函数调用具体是发生在 <code>commit</code> 阶段的入口函数 <code>commitRootImpl</code> 内部，而真正的调用入口函数为 <code>flushPassiveEffects</code>。</p>
<h4 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h4><p>该函数在 <code>commitRootImpl</code> 出现了三次。也就是说 <code>create</code> 函数和 <code>destroy</code> 函数调用存在三个入口：</p>
<ol>
<li>处理由于调用 <code>flushSyncUpdateQueue()</code> 所衍生的 <code>effect</code></li>
<li>在 <code>beforeMutation</code> 子阶段之前的对执行 <code>effect</code> 进行调度</li>
<li>在 <code>layout</code> 子阶段完成之后的同步调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: EventPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">  &#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||</span><br><span class="line">    (finishedWork.flags &amp; PassiveMask) !== NoFlags</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">      rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">      pendingPassiveEffectsRemainingLanes = remainingLanes;</span><br><span class="line">      <span class="comment">// workInProgressTransitions might be overwritten, so we want</span></span><br><span class="line">      <span class="comment">// to store it in pendingPassiveTransitions until they get processed</span></span><br><span class="line">      <span class="comment">// We need to pass this through as an argument to commitRoot</span></span><br><span class="line">      <span class="comment">// because workInProgressTransitions might have changed between</span></span><br><span class="line">      <span class="comment">// the previous render and commit if we throttle the commit</span></span><br><span class="line">      <span class="comment">// with setTimeout</span></span><br><span class="line">      pendingPassiveTransitions = transitions;</span><br><span class="line">      scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ! 1. 异步执行 passive effects</span></span><br><span class="line">        flushPassiveEffects();</span><br><span class="line">        <span class="comment">// This render triggered passive effects: release the root cache pool</span></span><br><span class="line">        <span class="comment">// *after* passive effects fire to avoid freeing a cache pool that may</span></span><br><span class="line">        <span class="comment">// be referenced by a node in the tree (HostRoot, Cache boundary etc)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subtreeHasEffects =</span><br><span class="line">    (finishedWork.subtreeFlags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line">  <span class="keyword">const</span> rootHasEffect =</span><br><span class="line">    (finishedWork.flags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subtreeHasEffects || rootHasEffect) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 进入commit阶段</span></span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 3. mutation阶段 (包括DOM变更)</span></span><br><span class="line">    commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 4. layout阶段</span></span><br><span class="line">    commitLayoutEffects(finishedWork, root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(pendingPassiveEffectsLanes) &amp;&amp; root.tag !== LegacyRoot) &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过简单的 <code>react</code> 应用来测试得到的结果是：1）在组件的 <code>mount</code> 阶段，<code>react</code> 会走第二个入口；2）在组件的 <code>update</code> 阶段，<code>react</code> 会走第三个入口</p>
</blockquote>
<p><strong>不管是从哪个入口进入，create 函数和 destroy 函数调用都是发生了 DOM 更新之后</strong></p>
<p>不管是从哪个入口进入，它们都是走同一个函数 <code>flushPassiveEffects</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushPassiveEffectsImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">  commitPassiveUnmountEffects(root.current); <span class="comment">// cleanup</span></span><br><span class="line">  commitPassiveMountEffects(root, root.current, lanes, transitions); <span class="comment">//setup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且有相同的调用栈：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-2.png" alt="alt text"></p>
<p>因为调用 <code>destroy</code> 和 调用 <code>create</code> 函数是分开的。所以，我们需要将两者分开来讨论。但是由于两者的调用逻辑几乎是一样的。所以，在这里，我们以调用 <code>destroy</code> 函数为例即可，<code>create</code> 函数的调用原理跟这个是一样的。<br>通过源码的阅读和调试，我将「调用 <code>destroy</code> 函数的过程」划分为两个步骤：</p>
<ol>
<li>遍历 <code>fiber</code> 树 - 深度优先遍历 <code>fiber</code> 树，找到身上有 <code>effect</code> 的 <code>fiber</code> 节点</li>
<li>遍历 <code>effect</code> 链表 - 遍历当前的 <code>effect</code> 链表，根据当前 <code>effect</code> 是否满足特定的条件（是否包含特定标签）来确定是否要调用 <code>destroy</code> 函数。</li>
</ol>
<h4 id="1-遍历-fiber-树"><a href="#1-遍历-fiber-树" class="headerlink" title="1. 遍历 fiber 树"></a>1. 遍历 fiber 树</h4><p>我们也知道，所有的 <code>useEffect hook</code> 函数只能用 <code>function component</code> 里面使用。</p>
<p>而 <code>fiber</code> 上可能存在多个 <code>function component</code> 类型的 <code>fiber</code> 节点使用了 <code>hook</code> 函数。所以，这一步中，遍历 <code>fiber</code> 树的目的就是要找到消费了 <code>hook</code> 函数的 <code>fiber</code> 节点。</p>
<p>在这一步之前，<code>react</code> 其实是有做一些前置工作的。那就是：因为遍历 <code>fiber</code> 都是深度优先，在 <code>render</code> 阶段，<code>performUnitOfWork</code> 中的 <code>beginWork</code> 执行到叶子节点后会进入到 <code>completeUnitOfWork</code> 中，会执行 <code>bubbleProperties</code>，也就是 <code>react</code> 会逐步向上追溯当前消费了 <code>hook</code> 函数的 <code>fiber</code> 节点的所有的祖先 <code>fiber</code> 节点，一一给它们的 <code>subtreeFlags</code> 属性值加入一个 <code>Passive</code> 标签。这种机制类似于浏览器的事件冒泡。浏览器的事件起源于特定的 <code>DOM</code> 节点，但是它会在冒泡阶段向上传播到 <code>document</code> 这个根节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberCompleteWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">  popTreeContext(workInProgress);</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleProperties</span>(<span class="params">completedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.alternate.child === completedWork.child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = NoLanes;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="comment">// “向上冒泡”最早的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// ! 2. 将他们的subtreeFlags和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// $FlowFixMe[unsafe-addition] addition with possible null/undefined value</span></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the return pointer so the tree is consistent. This is a code</span></span><br><span class="line">        <span class="comment">// smell because it assumes the commit phase is never concurrent with</span></span><br><span class="line">        <span class="comment">// the render phase. Will address during refactor to alternate model.</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line"></span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 子树的flags</span></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "Static" flags share the lifetime of the fiber/hook they belong to,</span></span><br><span class="line">        <span class="comment">// so we should bubble those up even during a bailout. All the other</span></span><br><span class="line">        <span class="comment">// flags have a lifetime only of a single render + commit, so we should</span></span><br><span class="line">        <span class="comment">// ignore them.</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// $FlowFixMe[unsafe-addition] addition with possible null/undefined value</span></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "Static" flags share the lifetime of the fiber/hook they belong to,</span></span><br><span class="line">        <span class="comment">// so we should bubble those up even during a bailout. All the other</span></span><br><span class="line">        <span class="comment">// flags have a lifetime only of a single render + commit, so we should</span></span><br><span class="line">        <span class="comment">// ignore them.</span></span><br><span class="line">        <span class="comment">// “静态”标志（Static flags）与它们所属的 Fiber 或 Hook 共享生命周期，因此即使在放弃（bailout）时，也应该将这些flags向上冒泡。</span></span><br><span class="line">        <span class="comment">// 而其他所有flags仅在单次render + commit 的生命周期内存在，因此我们应该忽略它们。</span></span><br><span class="line">        <span class="comment">// ! 2. 将他们的（subtreeFlags&amp;StaticMask)和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the return pointer so the tree is consistent. This is a code</span></span><br><span class="line">        <span class="comment">// smell because it assumes the commit phase is never concurrent with</span></span><br><span class="line">        <span class="comment">// the render phase. Will address during refactor to alternate model.</span></span><br><span class="line">        <span class="comment">// 更新return pointer以保持树的一致性。这被描述为一种代码异味（code smell），因为它假设commit阶段永远不会与 render 阶段并发。</span></span><br><span class="line">        <span class="comment">// 在重构为交替模型（alternate model）时将会解决这个问题。</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line"></span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 后代节点的lanes</span></span><br><span class="line">  completedWork.childLanes = newChildLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>useEffect</code> 这个主题。上面所提到的前置工作中，有一点特别需要注意的点是：如果「消费了 <code>hook</code> 函数的那个 <code>fiber</code> 节点」的子树之下没有其他消费了 <code>hook</code> 函数的 <code>fiber</code> 节点，它自己的 <code>subtreeFlags</code> 属性值是不会被贴上一个 <code>Passive</code> 标签的。这也不难理解，因为这恰恰是符合 <code>subtreeFlags</code> 属性名的语义的。</p>
<p>假设只有我们的 <code>&lt;Counter /&gt;</code> 组件里面消费到 <code>useEffect</code> 这个 <code>hook</code> 函数。那么，在 <code>render</code> 阶段，经过上面所提到的前置工作后，我们会得到这样的一颗 <code>fiber</code> 树：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-3.png" alt="alt text"></p>
<p>好了，做完上面的前置工作后，<code>react</code> 会在 <code>commit</code> 阶段发起对 <code>flushPassiveEffects</code> 的调度，将任务加入 <code>taskQueue</code> 中，在适当的时间切片内会执行到此调度。</p>
<p>这个遍历工作是从 <code>fiber</code> 树的根节点 - <code>hostRootFiber</code> 开始的。</p>
<p>源码中的 <code>commitPassiveUnmountOnFiber()</code> ， <code>recursivelyTraversePassiveUnmountEffects()</code> 和 <code>commitHookPassiveUnmountEffects()</code> 这三个函数共同完成了这个过程。而这三个函数是有分工的：</p>
<ul>
<li>commitPassiveUnmountOnFiber() - 是遍历流程的入口</li>
<li>recursivelyTraversePassiveUnmountEffects() - 负责实现了以深度优先的算法的「递」与「归」</li>
<li>commitHookPassiveUnmountEffects() - 在「归」之前，尝试去调用当前 fiber 节点 effect 链表上的所有的 destroy 函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_commitPassiveUnmountOnFiber</span>(<span class="params">parentFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentFiber.subtreeFlags &amp; PassiveMask) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = parentFiber.child;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            my_commitPassiveUnmountOnFiber(child);</span><br><span class="line">            child = child.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isfunctionComponentKind = [FunctionComponent, ForwardRef, SimpleMemoComponent].includes(parentFiber.tag);</span><br><span class="line">    <span class="keyword">const</span> hasPassiveEffect = parentFiber.flags &amp; Passive</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isfunctionComponentKind &amp;&amp; hasPassiveEffect)&#123;</span><br><span class="line">        commitHookPassiveUnmountEffects(</span><br><span class="line">            parentFiber,</span><br><span class="line">            parentFiber.return,</span><br><span class="line">            Passive | HasEffect</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实看完 <code>react</code> 源码，熟悉 <code>react</code> 内部的原理后，这种深优先遍历算法跟 <code>render</code> 阶段的 「work-loop」的遍历算法是一模一样的。唯一的一个区别点有两点：</p>
<ol>
<li>它深度优先遍历不一定会遍历到当前子树路径的叶子节点。它会因为不满足「以当前 parentFiber 为根节点的子树上是否有身上贴有 Passive 标签的 fiber 节点？」这个条件提前终止了；</li>
<li>跟 <code>render</code> 阶段的 「work-loop」的遍历算法中，归去之前必定会执行 <code>complete work</code> 不同，当前的遍历算法会先检查是否满足条件，如果不满足，则不执行 “complete work” 。显然，这里的 “complete work” 是指 <code>commitHookPassiveUnmountEffects()</code> 的调用。</li>
</ol>
<h4 id="2-遍历-effect-链表"><a href="#2-遍历-effect-链表" class="headerlink" title="2. 遍历 effect 链表"></a>2. 遍历 effect 链表</h4><p>上面，我们已经介绍了 <code>react</code> 是如何了遍历整棵 <code>fiber</code> 树，找到那些所有需要执行 <code>effect</code> 的 <code>fiber</code> 节点。上一步骤末尾，我们也指出了，执行 <code>effect</code> 的 <code>fiber</code> 节点的函数是 <code>commitHookPassiveUnmountEffects()</code>。而 <code>commitHookPassiveUnmountEffects()</code> 会直接调用 <code>commitHookEffectListUnmount()</code>。顾名思义，该函数就是 <code>react</code> 遍历 <code>effect</code> 链表去调用 <code>destroy</code> 函数的所在。</p>
<p><strong>effect 链表并不是只存储 useEffect hook 函数的 effect 对象</strong></p>
<p>那这里所提到的 「effect 类型的」hook 函数有哪些呢？从 <a href="mailto:react@18.2.0">react@18.2.0</a> 的源码来看，它包括了5 种类型的 <code>hook</code> 函数：</p>
<ul>
<li>useEffect()</li>
<li>useLayoutEffect()</li>
<li>useInsertionEffect()</li>
<li>useSyncExternalStore()</li>
<li>useImperativeHandle()</li>
</ul>
<p>提出这个结论的依据是: 这些 hook 函数的调用栈最终都是指向了 pushEffect() 函数。如下图：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-4.png" alt="alt text"></p>
<p>而 <code>pushEffect()</code> 函数就是负责创建新的 <code>effect</code> 对象，把它追加到当前 <code>fiber</code> 节点 <code>effect</code> 链表的尾部。可见，如果一个 <code>function component</code> 都消费了上面这些 <code>hook</code> 函数的话，那么它所对应的 <code>fiber</code> 节点的 <code>effect</code> 链表上并不是单纯包含 <code>useEffect hook</code> 函数所产生的 <code>effect</code>。<br>回到正题。上面我们指出了 <code>commitHookEffectListUnmount</code> 函数就是 <code>react</code> 遍历 <code>effect</code> 链表去调用 <code>destroy</code> 函数的所在，下面来看看它的源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListUnmount</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    finishedWork,</span></span></span><br><span class="line"><span class="function"><span class="params">    nearestMountedAncestor</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">    <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">          <span class="comment">// Unmount</span></span><br><span class="line">          <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">          effect.destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effect = effect.next;</span><br><span class="line">      &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyCallDestroy</span>(<span class="params">current, nearestMountedAncestor, destroy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      destroy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(current, nearestMountedAncestor, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的铺垫，我们很快就能看明白这段代码的意思。<code>react</code> 通过 <code>do{...}while()</code> 循环来遍历 <code>effect</code> 链表。我们在上面也提到过，<code>effect</code> 链表其实是单向的循环链表。所以，当前即将需要遍历的 <code>effect</code> 对象又指会了第一个 <code>effect</code> 的时候，意味着我们已经遍历完了整条链表，可以退出循环了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-5.png" alt="alt text"></p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">childEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Child effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sibling</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">siblingEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sibling effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">appEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'App effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">             &lt;Child /&gt;</span><br><span class="line">             &lt;Sibling /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>相信看完上面的分析，也不难得出答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child effect been called</span><br><span class="line">Sibling effect been called</span><br><span class="line">App effect been called</span><br></pre></td></tr></table></figure>

<p>react 采用的递归遍历算法是深度优先算法。示例 react 应用所对应的 fiber 树如下：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-6.png" alt="alt text"></p>
<p>用文字描述整个递归遍历过程是这样的：<br><code>&lt;App&gt;</code> 的递；<br><code>&lt;div&gt;</code> 的递；<br><code>&lt;Child&gt;</code> 的递；<br><code>&lt;Child&gt;</code> 的归；<br><code>&lt;Sibling&gt;</code> 的递；<br><Sibling><code>的归；
``&lt;App&gt;</code> 的归。</p>
<p>在归时候，react 会在当前 fiber 节点上调用 commitHookEffectListMount() 函数，所以，调用结果是：</p>
<p>在 <code>&lt;Child&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>；<br>在 <code>&lt;Sibling&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>；<br>在 <code>&lt;App&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p><code>useLayoutEffect</code> 函数跟 <code>useEffect</code> hook 函数 的不同。两者的不同之处在于两点：</p>
<ol>
<li>它们给「自己所创建的 effect 对象」所贴的 <code>effect flag</code> 是不同的；</li>
<li>它们给「自己所关联的 fiber 节点」所追加的 <code>fiber flag</code> 的不同的。</li>
</ol>
<h3 id="所贴的-hook-flag-不同"><a href="#所贴的-hook-flag-不同" class="headerlink" title="所贴的 hook flag 不同"></a>所贴的 hook flag 不同</h3><ul>
<li>对于 <code>useLayoutEffect() hook</code> 函数而言，它给自己所创建的 <code>effect</code> 对象所贴的 <code>effect flag</code> 是 <code>Layout</code></li>
<li>而 <code>useEffect() hook</code> 函数给自己所创建的 <code>effect</code> 对象所贴的 <code>effect flag</code> 是 <code>Passive</code>；</li>
</ul>
<h3 id="所追加的-fiber-flag-不同"><a href="#所追加的-fiber-flag-不同" class="headerlink" title="所追加的 fiber flag 不同"></a>所追加的 fiber flag 不同</h3><p>对于 <code>useEffect() hook</code> 函数而言，它给自己所关联的 <code>fiber</code> 节点所追加的 <code>fiber flag</code> 是：</p>
<ul>
<li><code>mount</code> 阶段是 <code>Passive | PassiveStatic</code></li>
<li><code>update</code> 阶段是 <code>Passive</code></li>
</ul>
<p>而 <code>useLayoutEffect() hook</code> 函数给自己所关联的 <code>fiber</code> 节点所追加的 <code>fiber flag</code> 是：</p>
<ul>
<li><code>mount</code> 阶段是 <code>Update | LayoutStatic</code></li>
<li><code>update</code> 阶段是 <code>Update</code></li>
</ul>
<h3 id="useLayoutEffect-mutation-子阶段调用-destroy-函数"><a href="#useLayoutEffect-mutation-子阶段调用-destroy-函数" class="headerlink" title="useLayoutEffect - mutation 子阶段调用 destroy 函数"></a>useLayoutEffect - mutation 子阶段调用 destroy 函数</h3><p>它的 <code>destroy</code> 函数的调用是发生在 <code>mutation</code> 子阶段。具体来讲，就是发生在 <code>commitMutationEffectsOnFiber()</code> 这个函数里面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffectsOnFiber</span>(<span class="params">finishedWork, root, lanes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">    <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        recursivelyTraverseMutationEffects(root, finishedWork);</span><br><span class="line">        commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          <span class="comment">// ......</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              commitHookEffectListUnmount(</span><br><span class="line">                Layout | HasEffect,</span><br><span class="line">                finishedWork,</span><br><span class="line">                finishedWork.return</span><br><span class="line">              );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useLayoutEffect-layout-子阶段调用-create-函数"><a href="#useLayoutEffect-layout-子阶段调用-create-函数" class="headerlink" title="useLayoutEffect - layout 子阶段调用 create 函数"></a>useLayoutEffect - layout 子阶段调用 create 函数</h3><ul>
<li>hook 类型 - 这里就是指 useLayoutEffect() hook 的 create 函数；</li>
<li>class 类型 - 这里是指 class component 的两个生命周期函数：<ul>
<li>componentDidMount()</li>
<li>componentDidUpdate()</li>
</ul>
</li>
</ul>
<p><code>useLayoutEffect() hook</code> 的 <code>create</code> 函数的真正调用入口为 <code>commitHookLayoutEffects()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    finishedRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    current,</span></span></span><br><span class="line"><span class="function"><span class="params">    finishedWork,</span></span></span><br><span class="line"><span class="function"><span class="params">    committedLanes</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        recursivelyTraverseLayoutEffects(</span><br><span class="line">          finishedRoot,</span><br><span class="line">          finishedWork,</span><br><span class="line">          committedLanes</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          commitHookLayoutEffects(finishedWork, Layout | HasEffect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>关于这个问题，react 官方文档给出了一个使用用例： <a href="https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen" target="_blank" rel="noopener">在浏览器重绘之前测量 DOM 的布局信息</a>。</p>
<p>「界面更新时候的闪烁问题」。为什么使用 <code>useLayoutEffect()</code> 能解决这类的问题呢？</p>
<p>首先，我们要知道为什么会造成闪烁。造成闪烁的原因是 <code>react</code> 在短时间更新了多帧显示内容不一样的界面。而 <code>useLayoutEffect() hook</code> 的 <code>create</code> 函数是在 <code>layout</code> 子阶段以同步的，批量的方式去执行的。也就是说，<code>create</code> 函数里面的所发起的多次状态更新请求只会产生一次的实质性的界面重绘。 通过抹除代表着中间状态的过渡帧，将多帧压缩为一帧来更新界面，这就是 <code>useLayoutEffect()</code> 能解决「界面更新时候的闪烁问题」原因之所在。</p>
<p>上面所提到的 「界面更新时候的闪烁问题」只是 <code>useLayoutEffect()</code> 能解决问题中的一个垂类。useLayoutEffect() 应该还能解决更多不同业务场景下的问题，我们得通过现象看本质。</p>
<p>那 <code>useLayoutEffect()</code> 的本质能力是什么？</p>
<ul>
<li>访问更新后的 <code>DOM</code> 树 - 因为 <code>useLayoutEffect() hook</code> 的 <code>create</code> 函数是在 <code>mutation</code> 子阶段之后的 <code>layout</code> 子阶段执行的。所以，这就意味着我们可以去访问更新后的 <code>DOM</code> 树和做一些布局信息的测量。</li>
<li>同步/批量执行状态更新，阻塞浏览器重绘 - <code>react</code> 将会以「同步阻塞，批量更新」的方式去对待 <code>create</code> 函数体里面所发起的过个状态更新请求。也就说，在 <code>create</code> 函数体里面所发起的过个状态更新请求只会产生一次界面重绘。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从源码的角度来看， 这两者其实都是在同一个架构里面，拥有很多相同点：</p>
<ul>
<li>每一个 <code>effect</code> 类型 <code>hook</code> 都会关联一个 <code>hook</code> 对象 和 <code>effect</code> 对象；</li>
<li>同一个 <code>function component</code> 内，所有的 <code>hook</code> 对象都共用同一条 <code>hook</code> 链表；</li>
<li>同一个 <code>function component</code> 内，所有的 <code>effect</code> 对象都共用同一条 <code>effect</code> 链表；</li>
<li>同一个调用机制 - 在 <code>render</code> 阶段创建 <code>hook</code> 对象和 <code>effect</code> 对象，在 <code>commit</code> 阶段去调用 <code>hook</code> 的 <code>create</code> 和 <code>destroy</code> 函数。</li>
</ul>
<p>这两者的不同点在于：</p>
<ul>
<li><code>useEffect()</code> 的 <code>destroy</code> 和 <code>create</code> 函数是在同一个子阶段(<code>layout</code> 子阶段后的 <code>passive</code> 子阶段)调用的（调用入口要么是调度后的 <code>flushPassiveEffectImpl()</code>,要么是同步的<code>flushPassiveEffectImpl()</code>）；</li>
<li><code>useLayoutEffect()</code> 的这两个函数却是在不同的子阶段执行。<code>destroy</code> 是在 <code>mutation</code> 子阶段执行的，而 <code>create</code> 是在 <code>layout</code> 子阶段。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2高优先级任务插队和饥饿任务问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>时间切片是 <code>Concurrent Mode</code> 的核心机制之一。它的主要目的是将长任务分解为小的任务单元,每个单元只执行一小段时间,然后让出控制权,避免长时间阻塞主线程。</p>
<p>react 的并发模式在 render 阶段 <strong>每处理一个 fiber 就会根据以下两点判断一次是否应该打断并把控制权交换给主线程：</strong></p>
<ol>
<li>是否超过分片时间（5ms）</li>
<li>根据 <code>isInputPending</code> 判断是否有用户输入</li>
</ol>
<p>但是并不会根据优先级来打断，优先级只会影响任务队列的任务排序，所以按照按优先级排序好的任务顺序来执行，也就能让高优先级任务得到及时处理。</p>
<p>当一个任务开始执行时, <code>Scheduler</code> 会为其分配一个时间片 (通常为 5ms)。在这个时间片内,任务可以连续执行。</p>
<ul>
<li>如果任务在时间片内完成，则直接结束</li>
<li>如果任务执行时间超过了时间片，则 <code>Scheduler</code> 会中断任务的执行，保存当前的进度，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
<li>如果任务执行中，遇到用户输入等需要浏览器及时反馈的操作，会通过判断 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduling/isInputPending" target="_blank" rel="noopener"><code>isInputPending</code></a>，会中断当前任务，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>shouldYield</code> 判断，具体方法就详细说明了，可以去看<a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react调度器scheduler源码分析》</a></p>
<h2 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h2><p><code>scheduleTaskForRootDuringMicrotask</code> 每次执行都会判断上一次中断任务优先级和root下的最高优先级是否一样。</p>
<ul>
<li>如果一样，说明没有更高优先级的更新产生，可以继续上次未完成的协调；</li>
<li>如果不一样，说明有更高优先级的更新进来，要清空之前已开始的协调过程，从根节点开始重新协调。等高优先级更新处理完成以后，再次从根节点开始处理低优先级更新。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberRootScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，或者在渲染任务的最后，在我们将控制权交还给主线程之前被调用。它绝对不应该被同步调用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有任何lanes被其他work饿死。如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们。</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">  <span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line">  <span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line">  <span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Check if there's nothing to work on</span></span><br><span class="line">    nextLanes === NoLanes ||</span><br><span class="line">    <span class="comment">// If this root is currently suspended and waiting for data to resolve, don't</span></span><br><span class="line">    <span class="comment">// schedule a task to render it. We'll either wait for a ping, or wait to</span></span><br><span class="line">    <span class="comment">// receive an update.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Suspended render phase</span></span><br><span class="line">    (root === workInProgressRoot &amp;&amp; isWorkLoopSuspendedOnData()) ||</span><br><span class="line">    <span class="comment">// Suspended commit phase</span></span><br><span class="line">    root.cancelPendingCommit !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There's nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="keyword">return</span> NoLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a new callback in the host environment.</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// sy- setState</span></span><br><span class="line">    <span class="comment">// sy-no 初次渲染</span></span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        ReactCurrentActQueue.current !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn't changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We'll schedule a new one below.</span></span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="keyword">switch</span> (lanesToEventPriority(nextLanes)) &#123;</span><br><span class="line">      <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">        schedulerPriorityLevel = ImmediateSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">        schedulerPriorityLevel = UserBlockingSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DefaultEventPriority: <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// ? sy 页面初次渲染、transition(128)</span></span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdleEventPriority:</span><br><span class="line">        schedulerPriorityLevel = IdleSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-高优先级打断低优先级"><a href="#1-高优先级打断低优先级" class="headerlink" title="1. 高优先级打断低优先级"></a>1. 高优先级打断低优先级</h2><h3 id="cancelCallback"><a href="#cancelCallback" class="headerlink" title="cancelCallback"></a>cancelCallback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cancelCallback(existingCallbackNode)</code>，<code>cancelCallback</code> 函数就是将 <code>root.callbackNode</code> 赋值为 <code>null</code></p>
<h3 id="performConcurrentWorkOnRoot"><a href="#performConcurrentWorkOnRoot" class="headerlink" title="performConcurrentWorkOnRoot"></a>performConcurrentWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是commit，要么是，如果有什么被暂停了，就等待一段时间后再commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getContinuationForRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  originalCallbackNode: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is called at the end of `performConcurrentWorkOnRoot` to determine</span></span><br><span class="line">  <span class="comment">// if we need to schedule a continuation task.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;</span></span><br><span class="line">  <span class="comment">// however, since most of the logic for determining if we need a continuation</span></span><br><span class="line">  <span class="comment">// versus a new task is the same, we cheat a bit and call it here. This is</span></span><br><span class="line">  <span class="comment">// only safe to do because we know we're at the end of the browser task.</span></span><br><span class="line">  <span class="comment">// So although it's not an actual microtask, it might as well be.</span></span><br><span class="line">  scheduleTaskForRootDuringMicrotask(root, now());</span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// The task node scheduled for this root is the same one that's</span></span><br><span class="line">    <span class="comment">// currently executed. Need to return a continuation.</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performConcurrentWorkOnRoot</code> 函数是每个并发任务的入口，下面简要分析以下它的运行流程：</p>
<ol>
<li>会先把 <code>root.callbackNode</code> 缓存起来，存在 <code>originalCallbackNode</code> 变量中</li>
<li>并发模式下会使用 <code>renderRootConcurrent</code> 执行<ol>
<li>在 <code>render</code> 阶段中也有可能在代码执行中，触发更高优先级事件，例如点击事件，高优先级事件又触发了 <code>setState</code> 就是相对高优先级的</li>
<li><code>setState</code> 执行 <code>scheduleUpdateOnFiber</code> 的 <code>prepareFreshStack</code>和 <code>markRootUpdated</code> 函数，就已经把 <code>update</code> 添加到 <code>fiber</code> 上并且将更新优先级标记到 <code>root</code> 的 <code>pendingLanes</code> 上了</li>
</ol>
</li>
<li>如果render阶段结束，做一些检查，commit阶段，如果render阶段中断，会直接跳过上述操作，走到函数的末尾</li>
<li>在函数末尾会调用 <code>getContinuationForRoot</code> 函数，先执行 <code>scheduleTaskForRootDuringMicrotask</code> 就是把 <code>render</code> 中目前最高优先级事件和当前任务优先级作对比，进行 <code>cancelCallback</code> 或者 <code>scheduleCallback</code>，同时 <code>root.callbackNode</code> 也可能被改掉了</li>
<li>再判断 <code>root.callbackNode</code> 和开始缓存起来的值  <code>originalCallbackNode</code>  是否一样，如果不一样，就代表 <code>root.callbackNode</code> 被赋值为 <code>null</code> 或者其他的<code>task</code> 值，代表有更高优先级任务进来。</li>
<li>此时 <code>performConcurrentWorkOnRoot</code> 返回值为 <code>null</code></li>
</ol>
<h3 id="pop-taskQueue"><a href="#pop-taskQueue" class="headerlink" title="pop(taskQueue)"></a>pop(taskQueue)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">    <span class="comment">// 返回值continuationCallback是函数，也就是performConcurrentWorkOnRoot执行后的返回值performConcurrentWorkOnRoot.bind(null, root)或null，如果是函数就继续，不是的话，如果判断如果currentTask === peek(taskQueue)，currentTask 出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// If a continuation is returned, immediately yield to the main thread</span></span><br><span class="line">        <span class="comment">// regardless of how much time is left in the current time slice.</span></span><br><span class="line">        <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskYield(currentTask, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskCompleted(currentTask, currentTime);</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">          currentTask.isQueued = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pop(taskQueue);</span><br><span class="line">&#125;</span><br><span class="line">currentTask = peek(taskQueue);</span><br></pre></td></tr></table></figure>

<p>上面是 <code>Scheduler</code> 模块里面 <code>workLoop</code> 函数的代码片段，<code>currentTask.callback</code> 就是 <code>scheduleCallback</code> 的第二个参数，也就是<code>performConcurrentWorkOnRoot</code> 函数。</p>
<p>承接上个主题，如果 <code>performConcurrentWorkOnRoot</code> 函数返回了 <code>null</code>，<code>workLoop</code> 内部就会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出。</p>
<h3 id="低优先级任务重启"><a href="#低优先级任务重启" class="headerlink" title="低优先级任务重启"></a>低优先级任务重启</h3><p>上一步中说道一个低优先级任务从 <code>taskQueue</code> 中被弹出。那高优先级任务执行完毕之后，如何重启回之前的低优先级任务呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span><br><span class="line">markRootFinished(root, remainingLanes, spawnedLane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Always call this before exiting `commitRoot`, to ensure that any</span></span><br><span class="line"><span class="comment">// additional work on this root is scheduled.</span></span><br><span class="line">ensureRootIsScheduled(root, now());</span><br></pre></td></tr></table></figure>

<p><code>markRootFinished</code> 函数刚刚上面说了是释放已完成任务的 <code>Lane</code>，那也就是说未完成任务依然会存在 <code>lanes</code> 中，所以我们可以重新调用 <code>ensureRootIsScheduled</code> 发起一次新的调度，去重启低优先级任务的执行。我们可以看下重启部分的判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line"><span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 如果 nextLanes 为 NoLanes，就证明所有任务都执行完毕了</span></span><br><span class="line"><span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="comment">// 只要 nextLanes 为 NoLanes，就可以结束调度了</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 nextLanes 不为 NoLanes，就代表还有任务未执行完，也就是那些被打断的低优先级任务</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>commit</code> 的最后还是会 <code>ensureRootIsScheduled</code>，高优先级插队后低优先级任务能重启的原因：<code>taskQueue</code>中被打断的低优先级的任务已经 <code>pop</code>了，但是 <code>root</code> 上还有 <code>pendingLanes</code>，通过 <code>ensureRootIsScheduled</code> 重新把低优先级的任务加入 <code>taskQueue</code> 中。</p>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol>
<li>任务通过 <code>unstable_scheduleCallback</code> 进行调度，将任务添加到 <code>taskQueue</code> 中，如果是首次加载通过 <code>requestHostCallback</code> 调度宏任务</li>
<li><code>Scheduler</code> 里执行 <code>flush</code> 后执行 <code>workLoop</code> 方法，在 <code>workLoop</code> 方法中取出第一个任务，判断是否超出切片时间或者有更需要及时反馈的用户操作，如果没有，那当执行任务的 <code>callback</code> 时，也就是 <code>performConcurrentWorkOnRoot</code> 方法，执行流程可以看上面。所以我们知道 <code>performConcurrentWorkOnRoot</code> 方法可能会返回null，也可能会返回 <code>performConcurrentWorkOnRoot</code></li>
<li>当返回 <code>null</code> 时候，<code>Scheduler</code> 会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出</li>
<li>低优先级任务重启，<code>commitRootImpl</code> 最后会再次调用 <code>ensureRootIsScheduled(root, now())</code>，判断如果 <code>nextLanes</code> 为 <code>NoLanes</code>，就证明所有任务都执行完毕了，如果 <code>nextLanes</code> 不为 <code>NoLanes</code>，就代表还有任务未执行完，也就是那些被打断的低优先级任务，会重新进行调度</li>
</ol>
<h2 id="任务插队情况具体总结分析"><a href="#任务插队情况具体总结分析" class="headerlink" title="任务插队情况具体总结分析"></a>任务插队情况具体总结分析</h2><p>结合 <code>eventLoop</code>， 用户 <code>click</code> 是一个宏任务，会把回调 <code>push</code> 到宏任务队列，等待下一次执行。<code>react</code> 的并发，也是分成了 <code>5ms</code> 的宏任务来执行。</p>
<h3 id="情况1-用户手动触发高优先级任务"><a href="#情况1-用户手动触发高优先级任务" class="headerlink" title="情况1 - 用户手动触发高优先级任务"></a>情况1 - 用户手动触发高优先级任务</h3><p>例如正在执行一个并发任务的时候，用户点击了按钮准备触发 <code>setState</code>（可能是一个 <code>lane</code> 为 <code>2</code> 的同步任务，也可能是比现在优先级高的其它任务），会把这个回调加入到宏任务队列，等到并发任务执行结束，（ <code>flushWork</code> 的返回值如果是 <code>true</code>，也会 <code>schedulePerformWorkUntilDeadline</code> 再次 <code>push</code> 一个任务到宏任务队列，<code>click</code> 的回调在这个任务的前面）</p>
<p>下次进入宏任务队列，取出一个任务也就是 <code>click</code> 的回调，执行 <code>dispatchSetState</code>，<code>isRenderPhaseUpdate</code> 为 <code>false</code>（还没进入到 <code>render</code> 阶段），<code>scheduleUpdateOnFiber</code> 也会向 <code>root</code> 上标记待执行任务的优先级，<code>ensureRootIsScheduled</code> 调度了微任务<code>scheduleImmediateTask</code>，宏任务执行完毕</p>
<p>进入微任务执行 <code>processRootScheduleInMicrotask</code>，执行 <code>scheduleTaskForRootDuringMicrotask</code>：</p>
<ol>
<li>这里会进行高优先级打断低优先级的 <code>cancelCallback</code> 操作、通过 <code>scheduleCallback</code> 将任务加入到 <code>taskQueue</code> 中（<code>taskQueue</code> 是最小堆，也会根据 <code>lane</code> 排序）</li>
<li>上面如果是同步任务，就不会执行 <code>scheduleCallback</code>，会在 <code>microtask</code> 结束时，<code>flushSyncWorkOnAllRoots()</code>;（ <code>flush</code> 任何<code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。）</li>
<li>最后执行完微任务，等到下次执行宏任务的时候，高优先级的就会先执行，以后再执行到低优先级时，其实低优先级没有 <code>callback</code> 了，就会跳过，后面<code>commit</code> 最后再重新发起调度低优先级任务</li>
</ol>
<h3 id="情况2-代码里触发了高优先级任务"><a href="#情况2-代码里触发了高优先级任务" class="headerlink" title="情况2 - 代码里触发了高优先级任务"></a>情况2 - 代码里触发了高优先级任务</h3><p>还有另一种情况是在某个并发任务的 <code>performConcurrentWorkOnRoot</code> 里的 <code>render</code> 过程中加入了可能是一个 <code>lane</code> 为 <code>2</code> 的同步任务，也可能是比现在优先级高的其它任务，会在此次任务切片<code>（5ms）</code>结束后，来进行判断（切片结束是通过 <code>workLoopConcurrent</code> 里面判断）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 <code>markRootUpdated</code> 在 <code>root</code> 上标记要执行任务的优先级, 再去对比当前任务和 <code>root</code> 上的最高优先级的任务是否一致，如果是比现在优先级高的任务但又不是同步任务，<code>getContinuationForRoot</code> 的 <code>scheduleTaskForRootDuringMicrotask</code> 会进行打断低优先级任务并对新的且不是同步任务的发起 <code>scheduleCallback</code> 调度加入到 <code>taskQueue</code> 中，最终 <code>performConcurrentWorkOnRoot</code> 的返回值 <code>return null</code>，在 <code>workLoop</code> 的 <code>continuationCallback</code> 为 <code>null</code>, 会把当前的低优先级任务移除。取出 <code>taskQueue</code> 中的目前最高优先级的任务进行新的调度。</li>
<li>如果是添加同步任务是在 <code>dispatchSetState</code> 里的 <code>ensureRootIsScheduled</code> 发起的微任务调度，或者在 <code>performConcurrentWorkOnRoot</code> 的最后 <code>ensureRootIsScheduled</code> 发起的调度，执行完本次任务切片的宏任务接着执行微任务的时候同步任务就会被执行了</li>
</ol>
<p>所以所有同步任务也都是在 <code>microtask</code> 结束时执行的，已保证最高的优先级且尽可能早的执行</p>
<h2 id="2-饥饿任务问题"><a href="#2-饥饿任务问题" class="headerlink" title="2. 饥饿任务问题"></a>2. 饥饿任务问题</h2><p>上面说到，在高优先级任务执行完毕之后，低优先级任务就会被重启，但假设如果持续有高优先级任务持续进来，那低优先级任务岂不是没有重启之日？</p>
<p>所以 <code>react</code> 为了处理解决饥饿任务问题，在 <code>scheduleTaskForRootDuringMicrotask</code> 函数开始的时候做了以下处理：（参考markStarvedLanesAsExpired函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 调度更新的过程中会被调用</span></span><br><span class="line"><span class="comment">// 检查是有lanes挨饿，如果有，则标记他们过期，即提升优先级（以便下次执行）。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This gets called every time we yield. We can optimize by storing</span></span><br><span class="line">  <span class="comment">// the earliest expiration time on the root. Then use that to quickly bail out</span></span><br><span class="line">  <span class="comment">// of this function.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">const</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">const</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">const</span> expirationTimes = root.expirationTimes; <span class="comment">// 数组，初始化的时候，值都是-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate through the pending lanes and check if we've reached their</span></span><br><span class="line">  <span class="comment">// expiration time. If so, we'll assume the update is being starved and mark</span></span><br><span class="line">  <span class="comment">// it as expired to force it to finish.</span></span><br><span class="line">  <span class="comment">// 遍历pending lanes，并检查是否已经达到它们的过期时间。</span></span><br><span class="line">  <span class="comment">// 如果是，我们就认为这个update挨饿了，并将其标记为已过期，以强制其完成。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should be able to replace this with upgradePendingLanesToSync</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We exclude retry lanes because those must always be time sliced, in order</span></span><br><span class="line">  <span class="comment">// to unwrap uncached promises.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write a test for this</span></span><br><span class="line">  <span class="keyword">let</span> lanes = enableRetryLaneExpiration</span><br><span class="line">    ? pendingLanes <span class="comment">//  ? sy</span></span><br><span class="line">    : pendingLanes &amp; ~RetryLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面两行代码的作用是找到lanes中最低位的1，即优先级最</span></span><br><span class="line">    <span class="keyword">const</span> index = pickArbitraryLaneIndex(lanes);</span><br><span class="line">    <span class="comment">// 把1左移index位，即得到一个只有第index位为1的子掩码</span></span><br><span class="line">    <span class="keyword">const</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expirationTime = expirationTimes[index];</span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">      <span class="comment">// sy- console.log('%c [  ]-1469', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">      <span class="comment">// Found a pending lane with no expiration time. If it's not suspended, or</span></span><br><span class="line">      <span class="comment">// if it's pinged, assume it's CPU-bound. Compute a new expiration time</span></span><br><span class="line">      <span class="comment">// using the current time.</span></span><br><span class="line">      <span class="comment">// 如果这个 pending lane 没有过期时间</span></span><br><span class="line">      <span class="comment">// 如果它没有被挂起且需要更新，我们就认为它是CPU密集型操作。</span></span><br><span class="line">      <span class="comment">// 用当前时间计算出一个新的过期时间给它。</span></span><br><span class="line">      <span class="comment">// CPU bound  / IO Bound</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (lane &amp; suspendedLanes) === NoLanes ||</span><br><span class="line">        (lane &amp; pingedLanes) !== NoLanes</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// sy- console.log('%c [ 饿死 ]-482', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">        <span class="comment">// Assumes timestamps are monotonically increasing.</span></span><br><span class="line">        <span class="comment">// 假设timestamps(时间戳)是单调递增的</span></span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 这个 pending lane 已经过期了</span></span><br><span class="line">      <span class="comment">// This lane expired</span></span><br><span class="line">      root.expiredLanes |= lane;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把lane从lanes中移除，计算下一个lane</span></span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>render</code> 阶段执行的函数 <code>performConcurrentWorkOnRoot</code> 中的代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 1. render</span></span><br><span class="line"><span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes)</span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// 不用时间切片</span></span><br></pre></td></tr></table></figure>

<p>可以看到只要 <code>shouldTimeSlice</code> 只要返回 <code>false</code>，就会执行 <code>renderRootSync</code>，也就是以同步优先级进入 <code>render</code> 阶段。而 <code>shouldTimeSlice</code> 的逻辑也就是刚刚的 <code>expiredLanes</code> 属性相关</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp;</span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查root是否包含过期的lane</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">includesExpiredLane</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a separate check from includesBlockingLane because a lane can</span></span><br><span class="line">  <span class="comment">// expire after a render has already started.</span></span><br><span class="line">  <span class="keyword">return</span> (lanes &amp; root.expiredLanes) !== NoLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2并发模式（Concurrent Mode）分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-10T00:00:00+08:00">2024-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li>并发指的是：多个任务，在同一时间段内同时发生，多个任务会有互相抢占资源的情况。</li>
<li>并行指的是：多个任务，在同一时间点上同时发生，多个任务之间不会互相抢占资源。</li>
</ul>
<p>在这里，我们千万不要理解 <code>Concurrent Mode</code> 是在同时执行多个任务，相信很多人包括我在内都理解混淆，在看源码后，才恍然大悟。</p>
<p>它是同一段时间内，可以执行多个任务：</p>
<ul>
<li>因为高优先级任务可以插队并打断低优先级任务</li>
<li>或当时间切片的某一条任务执行超时后，将执行权交给主线程，当主线程执行完成，又继续执行之前的切片任务</li>
</ul>
<h2 id="为什么需要并发模式"><a href="#为什么需要并发模式" class="headerlink" title="为什么需要并发模式"></a>为什么需要并发模式</h2><p>我们知道在同步模式下，从 <code>setState</code> 到 <code>虚拟DOM遍历</code>，再到 <code>真实DOM</code> 更新，整个过程都是同步执行且无法被中断的，这样可能就会出现一个问题 —— 用户事件触发的更新被阻塞。</p>
<p>因为我们期望一些不重要的更新不会影响一些重要的更新，比如长列表渲染不会阻塞用户 <code>input</code> 输入，从而提升用户体验。</p>
<h2 id="并发模式特点"><a href="#并发模式特点" class="headerlink" title="并发模式特点"></a>并发模式特点</h2><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>对于 <code>React</code> 来说，任务可能很多，如果不区分优先级，那就是先来后到的顺序。如果高优先级任务来了，但是低优先级任务还没有处理完毕，就会造成高优先级任务等待的局面。</p>
<p>由此可见，对于复杂项目来说，任务可中断这件事情很重要。那么问题来了，<code>React</code> 是如何做到的呢，其实基础还是 <code>fiber</code>，<code>fiber</code> 本身链表结构，就是指针，想指向别的地方加个属性值就行了。</p>
<h3 id="可遗弃"><a href="#可遗弃" class="headerlink" title="可遗弃"></a>可遗弃</h3><p>在 <code>Concurrent 模式</code>下，有些update可能会被遗弃掉。</p>
<p>比如我想在淘宝搜索“老人与海”，那么我在输入框输入“老人与海”的过程中，“老人”会有对应的模糊查询结果，但是不一定是我想要的结果，所以这个时候的模糊查询框的update就是低优先级，“老人”对应UI的update相对input的update，优先级就会低一些。在现在React18中，这个模糊查询相关的UI可以被当做transition。</p>
<h3 id="状态复用"><a href="#状态复用" class="headerlink" title="状态复用"></a>状态复用</h3><p>在 <code>Concurrent 模式</code> 下，还支持状态的复用。某些情况下，比如用户走了，又回来，那么上一次的页面状态应当被保存下来，而不是完全从头再来。当然实际情况下不能缓存所有的页面，不然内存不得爆炸，所以还得做成可选的。</p>
<p>目前， <code>React</code> 正在用 <code>Offscreen</code> 组件来实现这个功能。</p>
<p>另外，使用 <code>OffScreen</code>，除了可以复用原先的状态，我们也可以使用它来当做新UI的缓存准备，就是虽然新UI还没登场，但是可以先在后台准备着，这样一旦轮到它，就可以立马快速地渲染出来。</p>
<h2 id="如何实现并发模式（Concurrent-Mode）"><a href="#如何实现并发模式（Concurrent-Mode）" class="headerlink" title="如何实现并发模式（Concurrent Mode）"></a>如何实现并发模式（Concurrent Mode）</h2><p><code>Concurrent Mode</code> 这种中断渲染的行为，带来了几个关键问题：</p>
<ul>
<li>怎样做到中断渲染？</li>
<li>怎样定义任务的重要程度和执行顺序？</li>
<li>何时中断任务，怎样划分时间片？</li>
</ul>
<p>个人总结主要通过三个方面完成：</p>
<ul>
<li>颗粒化更新节点来解决递归不可中断问题；</li>
<li>任务增加优先级来解决任务执行顺序；</li>
<li>创建任务调度机制来解决时间分片和任务中断，任务恢复；</li>
</ul>
<p>对应到React的实现就是：<code>Fiber架构</code>，<code>lane模型</code>，<code>scheduler任务调度</code></p>
<h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><p>在重构 <code>Fiber</code> 架构之前，<code>React</code> 是没办法解决这些问题的。因为在此之前，<code>React</code> 的渲染更新主要是通过对比更新前后的 <code>虚拟DOM</code>，找出不同进行更新，而对比的过程因为 <code>虚拟DOM</code> 树结构的限制，只能采用递归更新，我们知道递归一旦开始，中途就无法中断。</p>
<p>那 <code>Fiber</code> 架构为什么能解决这个问题呢？</p>
<ul>
<li>每个 <code>Fiber</code> 节点对应一个 <code>React Element</code>，保存有该组件的所有基本状态信息；</li>
<li>每个 <code>Fiber</code> 节点保存有该组件的更新信息；</li>
</ul>
<p>因为 <code>Fiber</code> 节点承载了基本状态和更新信息，这样 <code>React</code> 就可以将 <code>Fiber</code> 节点视为最小的工作单元，可以实现 <code>Fiber</code> 节点这种粒度的更新，因为粒度的细化也就使得异步可中断更新成为了可能。</p>
<p><code>Fiber</code> 节点的基本状态保存了它的父节点，子节点，兄弟节点信息，这样可以将之前的递归遍历改变为循环遍历，使渲染中断成为可能。</p>
<h3 id="Lane模型"><a href="#Lane模型" class="headerlink" title="Lane模型"></a>Lane模型</h3><p><code>lane模型</code> 主要解决的是任务优先级问题。</p>
<p>我们想中断渲染的本质是想让有更高优先级的任务可以中断低优先级任务来插队执行。</p>
<p>那怎么定义任务优先级呢，<code>lane模型</code> 通过31位的位运算符来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * lane 值越小，优先级越高</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TotalLanes = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有优先级</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLanes: Lanes = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步优先级，表示同步的任务一次只能执行一个，例如：用户的交互事件产生的更新任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续触发优先级，例如：滚动事件，拖动事件等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousHydrationLane: Lane = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lanes = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认优先级，例如使用setTimeout，请求数据返回等造成的更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultHydrationLane: Lane = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lanes = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡优先级，例如: Suspense、useTransition、useDeferredValue等拥有的优先级</span></span><br><span class="line"><span class="keyword">const</span> TransitionHydrationLane: Lane = <span class="comment">/*                */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLanes: Lanes = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111111111111000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane1: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000001000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane2: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000010000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane3: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane4: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000010000000000</span>; <span class="comment">// 1024</span></span><br><span class="line"><span class="keyword">const</span> TransitionLane5: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000100000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane6: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane7: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000010000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane8: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000100000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane9: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000001000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane10: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000010000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane11: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000100000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane12: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000001000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane13: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000010000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane14: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000100000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane15: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000001000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RetryLanes: Lanes = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane1: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000010000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane2: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000100000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane3: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000001000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane4: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SelectiveHydrationLane: Lane = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleHydrationLane: Lane = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> OffscreenLane: Lane = <span class="comment">/*                   */</span> <span class="number">0b0100000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DeferredLane: Lane = <span class="comment">/*                    */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>React</code> 定义的优先级：</p>
<p>同步任务 &gt; 连续触发事件任务 &gt; setTimeout，请求更新任务 &gt; 过渡任务（React18新特性）</p>
<h4 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): * </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">      <span class="comment">// 同步优先级</span></span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">      <span class="comment">// 连续触发优先级</span></span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>EventPriority</th>
<th></th>
<th>Lane</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>DiscreteEventPriority</td>
<td>离散事件。click、keydown、focusin等，事件的触发不是连续，可以做到快速响应</td>
<td>SyncLane</td>
<td>1</td>
</tr>
<tr>
<td>ContinuousEventPriority</td>
<td>连续事件。drag、scroll、mouseover等，事件的是连续触发的，快速响应可能会阻塞渲染，优先级较离散事件低</td>
<td>InputContinuousLane</td>
<td>4</td>
</tr>
<tr>
<td>DefaultEventPriority</td>
<td>默认的事件优先级</td>
<td>DefaultLane</td>
<td>16</td>
</tr>
<tr>
<td>IdleEventPriority</td>
<td>空闲的优先级</td>
<td>IdleLane</td>
<td>536870912</td>
</tr>
</tbody></table>
<h4 id="调度优先级"><a href="#调度优先级" class="headerlink" title="调度优先级"></a>调度优先级</h4><table>
<thead>
<tr>
<th>SchedulerPriority</th>
<th>EventPriority</th>
<th>大于&gt;17.0.2</th>
<th>小于&gt;17.0.2</th>
</tr>
</thead>
<tbody><tr>
<td>ImmediatePriority</td>
<td>DiscreteEventPriority</td>
<td>1</td>
<td>99</td>
</tr>
<tr>
<td>UserblockingPriority</td>
<td>Userblocking</td>
<td>2</td>
<td>98</td>
</tr>
<tr>
<td>NormalPriority</td>
<td>DefaultEventPriority</td>
<td>3</td>
<td>97</td>
</tr>
<tr>
<td>LowPriority</td>
<td>DefaultEventPriority</td>
<td>4</td>
<td>96</td>
</tr>
<tr>
<td>IdlePriority</td>
<td>IdleEventPriority</td>
<td>5</td>
<td>95</td>
</tr>
<tr>
<td>NoPriority</td>
<td></td>
<td>0</td>
<td>90</td>
</tr>
</tbody></table>
<h4 id="优先级间的转换"><a href="#优先级间的转换" class="headerlink" title="优先级间的转换"></a>优先级间的转换</h4><ul>
<li><p>lane优先级 转 event优先级（参考 lanesToEventPriority 函数）</p>
<ul>
<li>转换规则：以区间的形式根据传入的lane返回对应的 event 优先级。比如传入的优先级不大于 Discrete 优先级，就返回 Discrete 优先级，以此类推</li>
</ul>
</li>
<li><p>event优先级 转 scheduler优先级（参考 ensureRootIsScheduled 函数下的 lanesToEventPriority）</p>
<ul>
<li>转换规则：可以参考上面调度优先级表</li>
</ul>
</li>
<li><p>event优先级 转 lane优先级（参考 getEventPriority 函数）</p>
<ul>
<li>转换规则：对于非离散、连续的事件，会根据一定规则作转换，具体课参考上面 event 优先级表</li>
</ul>
</li>
</ul>
<h4 id="任务饥饿"><a href="#任务饥饿" class="headerlink" title="任务饥饿"></a>任务饥饿</h4><p>任务饥饿是讲一个低优先级的任务一直被高优先级的任务插队，导致这个任务已经过了执行期限依然没有得到执行，在这种情况下，<code>React</code> 会将该任务置为同步渲染任务，在下次更新时立即执行。</p>
<h4 id="任务插队"><a href="#任务插队" class="headerlink" title="任务插队"></a>任务插队</h4><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">《react18.2批处理场景原理并结合优先级进行的分析》</a></p>
<h3 id="scheduler任务调度"><a href="#scheduler任务调度" class="headerlink" title="scheduler任务调度"></a>scheduler任务调度</h3><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react18.2调度器scheduler源码分析》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E5%8E%9F%E7%90%86%E5%B9%B6%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E5%8E%9F%E7%90%86%E5%B9%B6%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2批处理场景原理并结合优先级进行的分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactEventPriorities.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级从上往下，越来越小</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DiscreteEventPriority: EventPriority = SyncLane; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContinuousEventPriority: EventPriority = InputContinuousLane; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultEventPriority: EventPriority = DefaultLane; <span class="comment">// 页面初次渲染的lane 32, transition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleEventPriority: EventPriority = IdleLane;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberLane.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000010</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lane = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000001000</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lane = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000100000</span>; <span class="comment">// 32</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="各种批处理操作场景和结果"><a href="#各种批处理操作场景和结果" class="headerlink" title="各种批处理操作场景和结果"></a>各种批处理操作场景和结果</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onPerform = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !setCount嵌套场景1  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   document.getElementById('onTest').click() // renderWithHooks时候执行这里，fiber和currentlyRenderingFiber相等，所以isRenderPhaseUpdate为true，这里最终走的renderWithHooksAgain</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// !setCount嵌套场景2  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(1000)</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// !setCount嵌套场景3  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     document.getElementById('onTest').click()</span></span><br><span class="line">    <span class="comment">//     return prev + 10</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !插入一个click场景  点击：页面变成1100 + render 1次，划入：页面变成1100 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// document.getElementById('onTest').click() // 这里相当于在点击阶段就已经加入到pending中了，而且执行到这里的时候，isRenderPhaseUpdate为false，因为点击的时候没有还没有currentlyRenderingFiber</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !情况1 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 点击：页面变成3 + render 1次，划入：页面变成3 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 两个不同的state 点击：页面count变成1，page变成-1 + render 1次，划入：页面变成count变成1，page变成-1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setPage(page - 1)</span></span><br><span class="line">    <span class="comment">// !情况4 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 点击：页面变成1 + render 2次，划入：页面变成1 + render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况6 点击：页面变成2 + render 1次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况7 点击：页面变成1 + render 2次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况8 点击：页面变成4 + render 2次，划入：页面变成4 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 3') // hook update 3</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 4') // hook update 4</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况9 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况10 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况11 点击：页面变成2 + render 2次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// !情况12 页面变成1 + render 1次</span></span><br><span class="line">  <span class="comment">//   const changeValue = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     console.log(count) // react18 输出的是更新前的值 --&gt; 0</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   document.body.addEventListener('click', changeValue, false)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; milliseconds) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onPerform&#125; onMouseEnter=&#123;onPerform&#125;&gt;</span><br><span class="line">        Hello CodeSandbox &#123;count&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程和原理"><a href="#执行流程和原理" class="headerlink" title="执行流程和原理"></a>执行流程和原理</h2><p><code>dispatchSetState</code> 的源码在 setState文章中 展示过一次。这里只是重复什么是批-更新的说法，通过点击事件或者鼠标划入事件触发setState，其实就是调用 <code>dispatchSetState</code> 方法。<code>dispatchSetState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react更新</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// ! 1. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 把update暂存到concurrentQueues数组中</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 3. 调度更新</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不纠结 <code>fiber</code> 和 <code>queue</code> 的细节的话，就批处理而言，这就是 <code>setState</code>的全部了。</p>
<h3 id="步骤1：获取本次更新的优先级-requestUpdateLane"><a href="#步骤1：获取本次更新的优先级-requestUpdateLane" class="headerlink" title="步骤1：获取本次更新的优先级 - requestUpdateLane"></a>步骤1：获取本次更新的优先级 - requestUpdateLane</h3><p><code>dispatchSetState</code> 方法在 <code>创建update</code> 前，会通过 <code>requestUpdateLane</code> 方法取到 <code>update</code> 的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber: Fiber</span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special cases</span></span><br><span class="line">  <span class="keyword">const</span> mode = fiber.mode;</span><br><span class="line">  <span class="comment">// 1. 非ConcurrentMode模式 2. 目前不支持</span></span><br><span class="line">  <span class="keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">    <span class="keyword">return</span> (SyncLane: Lane);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoContext &amp;&amp;</span><br><span class="line">    workInProgressRootRenderLanes !== NoLanes</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. These are not officially supported. The</span></span><br><span class="line">    <span class="comment">// old behavior is to give this the same "thread" (lanes) as</span></span><br><span class="line">    <span class="comment">// whatever is currently rendering. So if you call `setState` on a component</span></span><br><span class="line">    <span class="comment">// that happens later in the same render, it will flush. Ideally, we want to</span></span><br><span class="line">    <span class="comment">// remove the special case and treat them as if they came from an</span></span><br><span class="line">    <span class="comment">// interleaved event. Regardless, this pattern is not officially supported.</span></span><br><span class="line">    <span class="comment">// This behavior is only a fallback. The flag only exists until we can roll</span></span><br><span class="line">    <span class="comment">// out the setState warning, since existing code might accidentally rely on</span></span><br><span class="line">    <span class="comment">// the current behavior.</span></span><br><span class="line">    <span class="keyword">return</span> pickArbitraryLane(workInProgressRootRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通更新与非紧急更新(18)</span></span><br><span class="line">  <span class="keyword">const</span> transition = requestCurrentTransition();</span><br><span class="line">  <span class="comment">// 如果有transition</span></span><br><span class="line">  <span class="keyword">if</span> (transition !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionScopeLane = peekEntangledActionLane();</span><br><span class="line">    <span class="keyword">return</span> actionScopeLane !== NoLane</span><br><span class="line">      ? <span class="comment">// We're inside an async action scope. Reuse the same lane.</span></span><br><span class="line">        actionScopeLane</span><br><span class="line">      : <span class="comment">// We may or may not be inside an async action scope. If we are, this</span></span><br><span class="line">        <span class="comment">// is the first update in that scope. Either way, we need to get a</span></span><br><span class="line">        <span class="comment">// fresh transition lane.</span></span><br><span class="line">        requestTransitionLane(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React内部的一些update，比如flushSync，会通过上下文变量来跟踪其优先级</span></span><br><span class="line">  <span class="keyword">const</span> updateLane: Lane = (getCurrentUpdatePriority(): any);</span><br><span class="line">  <span class="keyword">if</span> (updateLane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// ? sy setState click 2</span></span><br><span class="line">    <span class="keyword">return</span> updateLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React外部的update，根据事件类型，向当前环境获取对应的优先级。</span></span><br><span class="line">  <span class="keyword">const</span> eventLane: Lane = (getCurrentEventPriority(): any);</span><br><span class="line">  <span class="keyword">return</span> eventLane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getCurrentEventPriority"><a href="#getCurrentEventPriority" class="headerlink" title="getCurrentEventPriority"></a>getCurrentEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentEventPriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentEvent = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (currentEvent === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getEventPriority(currentEvent.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getEventPriority"><a href="#getEventPriority" class="headerlink" title="getEventPriority"></a>getEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="comment">// Used by SimpleEventPlugin:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'contextmenu'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cut'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'auxclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dblclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'invalid'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keypress'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousedown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'paste'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'play'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointercancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerdown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ratechange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'resize'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'seeked'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'volumechange'</span>:</span><br><span class="line">    <span class="comment">// Used by polyfills: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectionchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionupdate'</span>:</span><br><span class="line">    <span class="comment">// Only enableCreateEventHandleAPI: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeblur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'afterblur'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeinput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'fullscreenchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'hashchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'popstate'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectstart'</span>:</span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragexit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointermove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'toggle'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerleave'</span>:</span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'message'</span>: &#123;</span><br><span class="line">      <span class="comment">// We might be in the Scheduler callback.</span></span><br><span class="line">      <span class="comment">// Eventually this mechanism will be replaced by a check</span></span><br><span class="line">      <span class="comment">// of the current priority on the native scheduler.</span></span><br><span class="line">      <span class="keyword">const</span> schedulerPriority = getCurrentSchedulerPriorityLevel();</span><br><span class="line">      <span class="keyword">switch</span> (schedulerPriority) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediateSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">        <span class="keyword">case</span> UserBlockingSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">        <span class="keyword">case</span> NormalSchedulerPriority:</span><br><span class="line">        <span class="keyword">case</span> LowSchedulerPriority:</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</span></span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">        <span class="keyword">case</span> IdleSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过一系列操作：</p>
<ul>
<li><code>click</code> 事件对应的优先级是 <code>DiscreteEventPriority</code>，优先级值也就是 <code>2</code></li>
<li><code>mouseenter</code> 对应的优先级是 <code>ContinuousEventPriority</code>，优先级值也就是 <code>8</code></li>
<li><code>setTimeout</code> 对应的优先级的值是默认优先级 <code>32</code></li>
</ul>
<blockquote>
<p>一般在合成事件创建之初，就会通过 <code>createEventListenerWrapperWithPriority</code> 各个事件的设置优先级，所以一般 <code>click</code>、<code>mouseenter</code> 等react内部的事件，都会通过 <code>getCurrentUpdatePriority</code> 拿到 <code>updateLane</code>。<br>类似 <code>setTimeout</code>，会走到 <code>getCurrentEventPriority</code> 返回 <code>DefaultEventPriority</code><br>如果是通过 <code>document.body.addEventListener(&#39;click&#39;, changeValue, false)</code> 触发的事件，也会走到 <code>getCurrentEventPriority</code>，通过<code>getEventPriority</code> 拿到 <code>window.event</code> 所对应的优先级</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>requestUpdateLane</code> 中获取优先级：</p>
<ol>
<li>先通过requestCurrentTransition请求并判断是否有非紧急更新</li>
<li>再通过getCurrentUpdatePriority</li>
<li>最后通过getCurrentEventPriority根据事件类型，项当前环境获取对应的优先级。</li>
</ol>
<h3 id="步骤2：创建-update-对象"><a href="#步骤2：创建-update-对象" class="headerlink" title="步骤2：创建 update 对象"></a>步骤2：创建 update 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ! 1. 创建update</span></span><br><span class="line"><span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤3：scheduleUpdateOnFiber"><a href="#步骤3：scheduleUpdateOnFiber" class="headerlink" title="步骤3：scheduleUpdateOnFiber"></a>步骤3：scheduleUpdateOnFiber</h3><p>忽略一些琐碎的细节后，你可以发现这个函数的核心逻辑甚至更简单：</p>
<ul>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ensureRootIsScheduled"><a href="#ensureRootIsScheduled" class="headerlink" title="ensureRootIsScheduled"></a>ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processRootScheduleInMicrotask"><a href="#processRootScheduleInMicrotask" class="headerlink" title="processRootScheduleInMicrotask"></a>processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行流程小结"><a href="#执行流程小结" class="headerlink" title="执行流程小结"></a>执行流程小结</h4><p>通过微任务调度 <code>processRootScheduleInMicrotask</code> 方法，此方法核心就是调用 <code>scheduleTaskForRootDuringMicrotask</code>，而在 <code>microtask</code> 结束时，调用 <code>flushSyncWorkOnAllRoots</code> 方法 <code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>在 <code>scheduleTaskForRootDuringMicrotask</code> 中：</p>
<ol>
<li>先是检查是否有饿死的任务，如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们</li>
<li>获取当前所有优先级中最高的优先级 <code>nextLanes</code></li>
<li>先判断是否包含同步优先级，如果包含，取消其它任务并返回，不包含就继续执行</li>
<li>再判断现存的任务优先级和新任务的优先级，如果相等，就合并执行且 <code>return</code></li>
<li>如果不相等，就取消现存任务</li>
<li>继续根据 <code>nextLanes</code>，通过 <code>lanesToEventPriority</code> 方法，获取 <code>schedulerPriorityLevel</code> 调度的优先级，最后通过 <code>scheduleCallback</code> 进行调度</li>
</ol>
<h2 id="调用-scheduleTaskForRootDuringMicrotask-中的两大问题"><a href="#调用-scheduleTaskForRootDuringMicrotask-中的两大问题" class="headerlink" title="调用 scheduleTaskForRootDuringMicrotask 中的两大问题"></a>调用 scheduleTaskForRootDuringMicrotask 中的两大问题</h2><p>请看<a href="https://rile14929.github.io/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html">《react18.2高优先级任务插队和饥饿任务问题分析》</a></p>
<h2 id="updateReducerImpl"><a href="#updateReducerImpl" class="headerlink" title="updateReducerImpl"></a>updateReducerImpl</h2><p>我们以函数式组件的处理 <code>setState</code> 时的实际执行函数 <code>updateReducerImpl</code> 为例，来看一下相关处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducerImpl</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  hook: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录reducer</span></span><br><span class="line">  queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = hook.baseQueue; <span class="comment">// ! 单向循环链表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有 pendingQueue，说明有未处理的更新</span></span><br><span class="line">    <span class="comment">// 把pendingQueue添加到baseQueue中</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// pending queue合并到base queue中。</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseQueue 被设置为 pendingQueue，也就是待更新的 update 对象队列</span></span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    <span class="comment">// 需要清空 pending 队列，这样本次执行 hook 的 pending 队列不会影响到下一次</span></span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseState = hook.baseState;</span><br><span class="line">  <span class="comment">// 如果基础更新队列中有 update 对象，说明需要执行更新，就按照优先级依次处理每一个 update 对象（下面会进行批量更新）</span></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有pendingQueue，那么memoizedState应该等于baseState</span></span><br><span class="line">    hook.memoizedState = baseState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有待处理的queue，接下来遍历即可</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast: Update&lt;S, A&gt; | <span class="literal">null</span> = <span class="literal">null</span>;  <span class="comment">// 跳过的这些更新（低优先级任务）会被保存在这个循环链表中</span></span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="keyword">let</span> didReadFromEntangledAsyncAction = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前任务的优先级不够，也就是说当前的 renderLanes 比该 update 对象的优先级高。需要先跳过，之后再处理。</span></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          revertLane: update.revertLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果在当前被跳过的 update 对象之前没有其他的 update 被跳过，该对象就是作为新的基础更新对象。并把最初跳过任务时候的 baseState 存储起来</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果之前有更新被跳过，那么将这个更新对象添加到队列最后</span></span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前正在工作的 Fiber 节点（workInProgress）的优先级，标记这个更新对象的优先级由于不匹配当前的 renderLane，因此已经被跳过。</span></span><br><span class="line">        <span class="comment">// 在同文件的 renderWithHook() 方法中可以知道 currentlyRenderingFiber 对应了 workInProgress，表示当前正在工作的 fiber 树</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 优先级足够</span></span><br><span class="line">        <span class="comment">// 优先级足够的时候理论上可以考虑对哪些 update 对象进行收集更新，但是此时还需要考虑一个 revertLane（还原的优先级），以保证组件状态的正确。</span></span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this is an optimistic update.</span></span><br><span class="line">        <span class="keyword">const</span> revertLane = update.revertLane;</span><br><span class="line">        <span class="keyword">if</span> (!enableAsyncActions || revertLane === NoLane) &#123;</span><br><span class="line">          <span class="comment">// ? sy</span></span><br><span class="line">          <span class="comment">// This is not an optimistic update, and we're going to apply it now.</span></span><br><span class="line">          <span class="comment">// But, if there were earlier updates that were skipped, we need to</span></span><br><span class="line">          <span class="comment">// leave this update in the queue so it can be rebased later.</span></span><br><span class="line">          <span class="comment">// 如果 newBaseQueueLast 不为 null，证明有跳过的更新，要把当前的update也加入newBaseQueueLast只是到其 lane 会赋值为 0，后面进行低优先级的更新时，这些已经被处理过的更新也仍旧会被处理，保证最后计算的数据是正确的</span></span><br><span class="line">          <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">              <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">              <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              revertLane: NoLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">          <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">          <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">          <span class="keyword">if</span> (updateLane === peekEntangledActionLane()) &#123;</span><br><span class="line">            <span class="comment">// ? sy-no</span></span><br><span class="line">            didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// This is an optimistic update. If the "revert" priority is</span></span><br><span class="line">          <span class="comment">// sufficient, don't apply the update. Otherwise, apply the update,</span></span><br><span class="line">          <span class="comment">// but leave it in the queue so it can be either reverted or</span></span><br><span class="line">          <span class="comment">// rebased in a subsequent render.</span></span><br><span class="line">          <span class="keyword">if</span> (isSubsetOfLanes(renderLanes, revertLane)) &#123;</span><br><span class="line">            <span class="comment">// The transition that this optimistic update is associated with</span></span><br><span class="line">            <span class="comment">// has finished. Pretend the update doesn't exist by skipping</span></span><br><span class="line">            <span class="comment">// over it.</span></span><br><span class="line">            update = update.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">            <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">            <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">            <span class="keyword">if</span> (revertLane === peekEntangledActionLane()) &#123;</span><br><span class="line">              didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// Once we commit an optimistic update, we shouldn't uncommit it</span></span><br><span class="line">              <span class="comment">// until the transition it is associated with has finished</span></span><br><span class="line">              <span class="comment">// (represented by revertLane). Using NoLane here works because 0</span></span><br><span class="line">              <span class="comment">// is a subset of all bitmasks, so this will never be skipped by</span></span><br><span class="line">              <span class="comment">// the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              <span class="comment">// Reuse the same revertLane so we know when the transition</span></span><br><span class="line">              <span class="comment">// has finished.</span></span><br><span class="line">              revertLane: update.revertLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">              newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">              newBaseState = newState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">            <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">            currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">              currentlyRenderingFiber.lanes,</span><br><span class="line">              revertLane,</span><br><span class="line">            );</span><br><span class="line">            markSkippedUpdateLanes(revertLane);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 update 对象的优先级足够，因此开始处理它的 action，收集新的 state 状态</span></span><br><span class="line">        <span class="keyword">const</span> action = update.action;</span><br><span class="line">        <span class="keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;</span><br><span class="line">          reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ! 计算useReducer的新的state</span></span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 循环 baseQueue（实际上就是 pendingQueue），处理该队列中的每个 update 对象，</span></span><br><span class="line">      <span class="comment">// 并把对应的 action 操作得到的结果更新到 newState 中（即收集新状态）</span></span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState; <span class="comment">// 如果没有跳过的任务，那就把最终计算后的结果存到newBaseState，最终赋值给baseState，否则baseState就还是第一个被跳过的任务时可以拿到的baseState，也是保证最后执行低优先级任务计算的数据是正确的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark that the fiber performed work, but only if the new state is</span></span><br><span class="line">    <span class="comment">// different from the current state.</span></span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (didReadFromEntangledAsyncAction) &#123;</span><br><span class="line">        <span class="keyword">const</span> entangledActionThenable = peekEntangledActionThenable();</span><br><span class="line">        <span class="keyword">if</span> (entangledActionThenable !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> entangledActionThenable;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新到hook上</span></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line"></span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    <span class="comment">// 如果一直没有跳过的，newBaseQueueLast就为null，如果有跳过的就不为null也就赋值给了baseQueue，之后低优先级任务重启后可以执行baseQueue上的任务，当执行最后一批低优先级任务时newBaseQueueLast为null，baseQueue也就为null了，不会影响以后再次触发任务</span></span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// `queue.lanes` is used for entangling transitions. We can set it back to</span></span><br><span class="line">    <span class="comment">// zero once the queue is empty.</span></span><br><span class="line">    queue.lanes = NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看到，<code>updateReducerImpl</code> 方法核心内容分为四个部分：</p>
<ul>
<li>获取 <code>Hook</code> 对象中的更新队列、基础更新队列、基础状态、<code>reduce</code> 函数等信息。</li>
<li>如果更新队列中有待处理的更新对象，就将其加入到基础更新队列中。</li>
<li>按照优先级高低区分是否跳过该更新或者依次处理基础更新队列中的更新对象，计算新的状态。</li>
<li>判断新的状态和旧的状态是否相同，如果相同就不做重新渲染，反之需要重新渲染。</li>
<li>返回更新后的状态和 <code>dispatch</code> 方法。</li>
</ul>
<h2 id="针对setState嵌套场景的分析"><a href="#针对setState嵌套场景的分析" class="headerlink" title="针对setState嵌套场景的分析"></a>针对setState嵌套场景的分析</h2><p>当执行嵌套的 <code>setState</code> 时候，会执行 <code>dispatchSetState</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// ! 1. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// setState嵌套setState的情况，是同一个fiber</span></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是同一个fiber，如果发生嵌套的情况，是一个fiber，会返回true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRenderPhaseUpdate</span>(<span class="params">fiber: Fiber</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>update</code> 加入到队列中，并将 <code>didScheduleRenderPhaseUpdateDuringThisPass</code> 置为 <code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRenderPhaseUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a render phase update. Stash it in a lazily-created map of</span></span><br><span class="line">  <span class="comment">// queue -&gt; linked list of updates. After this render pass, we'll restart</span></span><br><span class="line">  <span class="comment">// and apply the stashed updates on top of the work-in-progress hook.</span></span><br><span class="line">  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =</span><br><span class="line">    <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有 <code>setState</code> 嵌套发生，是发生在 <code>render</code> 阶段的 <code>renderWithHooks</code> 中。执行完函数组件 <code>Component()</code> 会进行判断， 当<code>didScheduleRenderPhaseUpdateDuringThisPass</code>为 <code>true</code> 会执行 <code>renderWithHooksAgain</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if there was a render phase update</span></span><br><span class="line">    <span class="comment">// enqueueRenderPhaseUpdate会给didScheduleRenderPhaseUpdateDuringThisPass设置为true，所以下面还会render一次，这也就是setState嵌套setState的情况下render连续 2次</span></span><br><span class="line">    <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">        <span class="comment">// Keep rendering until the component stabilizes (there are no more render</span></span><br><span class="line">        <span class="comment">// phase updates).</span></span><br><span class="line">        children = renderWithHooksAgain(</span><br><span class="line">            workInProgress,</span><br><span class="line">            Component,</span><br><span class="line">            props,</span><br><span class="line">            secondArg,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>所以通过对执行流程和原理的分析，对于以上提到的这么多批处理的场景，也就能通过源码并结合eventLoop的知识解释的通了。</p>
<p>关于批处理的逻辑，主要有三点：</p>
<ul>
<li>通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>对比上次等待的更新和本次更新的优先级，即 <code>newCallbackPriority === existingCallbackPriority</code>，如果相等，则提前 <code>return</code></li>
<li>在更新阶段，以 <code>setState</code> 为例，会根据优先级来判断是否要同一批次执行</li>
</ul>
<p>在 <code>scheduleUpdateOnFiber</code> 中已经对 <code>setState</code> 对应的优先级做了标记，所以那个优先级在这里是可以被读取到的。如果两次更新的优先级相同，批处理就会起作用。</p>
<blockquote>
<p>批处理的发生当然意味着代码进入上述的 <code>newCallbackPriority === existingCallbackPriority</code> 分支内。但是即使是其他情形也有可能进入这个分支。<br>例如，当连续的两次 <code>setState</code> 被调用，前者优先级高于后者，那么当第二次 <code>setState</code> 被调用，从而进入 <code>ensureRootIsScheduled</code> 时，<code>existingCallbackPriority与newCallbackPriority</code> 都是第一次调用时的优先级（每次所取的都是最高优先级），导致函数提前返回。这并不意味着低优先级的更新被忽略，在高优先级的更新即将完成时，<code>ensureRootIsScheduled</code> 会被再次调用，确保所有更新会被执行。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html" class="post-title-link" itemprop="url">react18.2和react16批处理实现和对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-09T00:00:00+08:00">2024-11-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="react16-半自动批处理"><a href="#react16-半自动批处理" class="headerlink" title="react16 - 半自动批处理"></a>react16 - 半自动批处理</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：同步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中的this.setState或者setState：会批量处理</li>
<li>合成事件和钩子函数中的this.setState或者setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中任何情况：不会批量处理</li>
</ul>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-this-updater"><a href="#2-this-updater" class="headerlink" title="2. this.updater"></a>2. this.updater</h4><p><code>this.updater</code> 是在哪个地方进行赋值暂时不用关心，只需要知道他被赋值为 <code>classComponentUpdater</code>。</p>
<p><code>classComponentUpdater</code> 和 <code>render</code> 流程里面的 <code>ReactDOM.render</code>中 <code>scheduleRootUpdate</code> 非常的相似，其实他们就是同一个更新原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">    <span class="comment">// inst 就是我们调用this.setState的this，也就是classComponent实例</span></span><br><span class="line">    <span class="comment">// 获取到当前实例上的fiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = ReactInstanceMap.get(inst);</span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="comment">// 计算当前fiber的到期时间（优先级）</span></span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建更新一个更新update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload是setState传进来的要更新的对象</span></span><br><span class="line">    update.payload = payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//callback就是setState(&#123;&#125;,()=&gt;&#123;&#125;)的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把更新放到队列UpdateQueue</span></span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进入React异步渲染的核心：React Scheduler</span></span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态更新都会创建一个保存更新状态相关内容的对象 <code>Update</code>。在 <code>render</code> 阶段的 <code>beginWork</code> 中会根据 <code>Update</code> 计算新的 <code>state</code>。</p>
<p>这里讲这个 <code>Update</code> 通过 <code>enqueueUpdate</code> 放到队列 <code>UpdateQueue</code>。</p>
<h4 id="3-requestWork"><a href="#3-requestWork" class="headerlink" title="3. requestWork"></a>3. requestWork</h4><p><code>scheduleWork</code> 里会执行 <code>requestWork</code> 方法。</p>
<p><code>requestWork</code> 中可以看到有多个 <code>if</code> 判断，这里就是 <code>setState</code> <strong>在不同的场景使用会出现同步和异步的根本原因</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将根节点添加到调度任务中</span></span><br><span class="line">  addRootToSchedule(root, expirationTime)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isRendering是全局变量，在后面生命周期函数我们会具体分析到</span></span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isBatchingUpdates、isUnbatchingUpdates是全局变量</span></span><br><span class="line">  <span class="comment">// react事件时有对他们进行重新赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      ....</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景1-合成事件"><a href="#场景1-合成事件" class="headerlink" title="场景1 - 合成事件"></a>场景1 - 合成事件</h3><p>React有着一套自己的合成事件机制，在一个事件调用的时候会经过一些处理，这里不详细描述，最重要的一个函数就是 <code>interactiveUpdates$1</code>，在执行一个事件的时候会先调用这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: <span class="string">'吴彦祖'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name) <span class="comment">// 狗蛋</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        age: <span class="string">'18'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.age) <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interactiveUpdates-1方法"><a href="#interactiveUpdates-1方法" class="headerlink" title="interactiveUpdates$1方法"></a>interactiveUpdates$1方法</h4><ul>
<li>isBatchingUpdates = true;让setState不马上更新</li>
<li>try finally 语句;先执行一个事件里的代码最后才更新</li>
<li>isBatchingUpdates = previousIsBatchingUpdates;合成事件里setTimeout能马上更新的原因</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interactiveUpdates$1</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// Synchronously flush pending interactive updates.</span></span><br><span class="line">    performWork(lowestPendingInteractiveExpirationTime, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    lowestPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingInteractiveUpdates = <span class="literal">true</span>;</span><br><span class="line">  isBatchingUpdates = <span class="literal">true</span>;  <span class="comment">// 把requestWork中的isBatchingUpdates标识改为true</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isBatchingUpdates变量"><a href="#isBatchingUpdates变量" class="headerlink" title="isBatchingUpdates变量"></a>isBatchingUpdates变量</h4><p><code>interactiveUpdates$1</code> 这个方法中把 <code>isBatchingUpdates</code> 设为了 <code>true</code>, 导致在 <code>requestWork</code> 方法中， <code>isBatchingUpdates</code> 为 <code>true</code> ，但是 <code>isUnbatchingUpdates</code> 是 <code>false</code> ，而被直接 <code>return</code> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requestWork</span></span><br><span class="line"><span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就导致了 <code>requestWork</code> 根本没有执行到任何更新的函数，比如 <code>performSyncWork</code>，但在最开始的 <code>enqueueSetState</code> 这个方法里还是已经将每一次更新都存到了一个 <code>update</code> 队列里。</p>
<p>所以合成事件里的 <code>setState</code> 不会马上更新，而是存入了一个更新队列里（enqueueUpdate）</p>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try finally"></a>try finally</h4><p><code>interactiveUpdates$1</code> 最后执行了一个 <code>try finally</code> 语法，会先执行 <code>try</code> 代码块中的语句，然后再执行 <code>finally</code> 中的代码，而 <code>fn(a, b)</code> 是在 <code>try</code> 代码块中执行相关的事件回调，而在 <code>finally</code> 里才有 <code>performSyncWork()</code>;</p>
<p>也就是说我们写的事件监听函数在 <code>try</code> 中执行，但更新在 <code>finally</code> 里，这就导致了所谓的”异步”，<code>state</code> 并没有马上更新并渲染到UI上，而是等到事件执行完之后才更新的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">        performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景2-setTimeout"><a href="#场景2-setTimeout" class="headerlink" title="场景2 - setTimeout"></a>场景2 - setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出更新后的值 --&gt; 1</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>try</code> 代码块执行到 <code>setTimeout</code> 的时候，这是一个宏任务，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块。</p>
<p>等 <code>finally</code> 执行的时候会执行 <code>isBatchingUpdates = previousIsBatchingUpdates</code>; 将 <code>isBatchingUpdates</code> 重置为了 <code>false</code>。</p>
<p>导致最后下次事件循环的时候去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync if</code>分支， 可以同步拿到最新的 <code>state</code> 值。</p>
<h3 id="场景3-生命周期函数中的setState"><a href="#场景3-生命周期函数中的setState" class="headerlink" title="场景3 - 生命周期函数中的setState"></a>场景3 - 生命周期函数中的setState</h3><p>三个全局变量：isRendering、isWorking、isCommitting</p>
<ul>
<li>isRendering：开始react更新就为true</li>
<li>isWorking：进入reconciler阶段就为true、进入commit阶段就为true</li>
<li>isCommitting：进入commit阶段就为true</li>
</ul>
<p>render前生命周期属于reconciler阶段：isRendering = true、isWorking = true Fiber Reconciler 的执行阶段：</p>
<ul>
<li>阶段一是生成 Fiber 树的渐进阶段，可以被打断。</li>
<li>阶段二是批量更新节点的阶段，不可被打断。</li>
</ul>
<p><img src="../images/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94/image.png" alt="alt text"></p>
<p>现在回过头来看 <code>requestWork</code> 里的第一个if判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和合成事件一样，当 <code>componentDidmount</code> 执行的时候，<code>isRendering</code> 为 <code>true</code>，react内部并没有更新就先 <code>return</code> 了，执行完 <code>componentDidmount</code> 后才去 <code>commitUpdateQueue</code> 更新。这就导致你在 <code>componentDidmount</code> 中 <code>setState</code> 完去 <code>console.log</code> 拿的结果还是更新前的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的还是更新前的值 --&gt; 0</span></span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="场景4-原生事件"><a href="#场景4-原生事件" class="headerlink" title="场景4 - 原生事件"></a>场景4 - 原生事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的是更新后的值 --&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发 <code>click</code> 事件，到 <code>requestWork</code> ,在 <code>requestWork</code> 里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被 <code>return</code>，所以当你在原生事件中 <code>setState</code>后，能同步拿到更新后的 <code>state</code> 值。</p>
<h3 id="场景5-setState批量更新的情况"><a href="#场景5-setState批量更新的情况" class="headerlink" title="场景5 - setState批量更新的情况"></a>场景5 - setState批量更新的情况</h3><h5 id="简单分析源码"><a href="#简单分析源码" class="headerlink" title="简单分析源码"></a>简单分析源码</h5><p><code>React</code> 加入 <code>fiber</code> 架构后，调度之前通过 <code>enqueueUpdate</code> 函数维护的 <code>UpdateQueue</code> 就是挂载在组件对应的 <code>fiber</code> 节点上，我们更新的通过调度最后会进入到 <code>updateClassComponent</code> 方法，里面最终会调用一个<code>getStateFromUpdate</code> 来获取最终的 <code>state</code> 状态。</p>
<p><code>getStateFromUpdate</code> 函数外面是对 <code>UpdateQueue</code> 队列的一个 <code>while</code> 循环，比如我们连续 <code>setState</code> 三次，那每次都会创建一个 <code>update</code> 实例通过 <code>enqueueUpdate</code> 放入 <code>fiber</code> 的 <code>UpdateQueue</code> 中，这里就是把这三次的<code>state</code> 合并计算出一个最终的值以提高性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resultState作为参数prevState传入getStateFromUpdate，然后getStateFromUpdate会合并生成</span></span><br><span class="line"><span class="comment">     * 新的状态再次赋值给resultState。完成整个循环遍历，resultState即为最终要更新的state。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resultState = getStateFromUpdate(</span><br><span class="line">        workInProgress,</span><br><span class="line">        queue,</span><br><span class="line">        update,</span><br><span class="line">        resultState,</span><br><span class="line">        props,</span><br><span class="line">        instance,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历下一个update对象</span></span><br><span class="line">    update = update.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getStateFromUpdate</code> 函数主要功能是将存储在更新对象 <code>update</code> 上的 <code>partialState</code> 与上一次的 <code>prevState</code> 进行对象合并，生成一个全新的状态 <code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevState: State,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setState会创建update对象，其属性tag当时被标记为UpdateState</span></span><br><span class="line">    <span class="keyword">case</span> UpdateState: &#123;</span><br><span class="line">      <span class="comment">// payload 存放的是要更新的状态state</span></span><br><span class="line">      <span class="keyword">const</span> payload = update.payload;</span><br><span class="line">      <span class="keyword">let</span> partialState;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取要更新的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> payload === <span class="string">'function'</span>) &#123;</span><br><span class="line">        partialState = payload.call(instance, prevState, nextProps);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        partialState = payload;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// partialState 为null 或者 undefined，则视为未操作，返回上次状态</span></span><br><span class="line">      <span class="keyword">if</span> (partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意：此处通过Object.assign生成一个全新的状态state， state的引用地址发生了变化。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prevState, partialState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="setState传入对象会合并对象"><a href="#setState传入对象会合并对象" class="headerlink" title="setState传入对象会合并对象"></a>setState传入对象会合并对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementByObject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.increment = <span class="keyword">this</span>.increment.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        <span class="comment">// 会批量更新，只会render一次，结果是 1</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;IncrementByObject&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;span&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果是一个 <code>Object</code> ，直接看最后的 <code>Object.assign({}, prevState, partialState);</code></p>
<p><code>Object.assign</code> 的作用： 主要是将所有可枚举属性的值从一个或多个源对象复制到目标对象，同时返回目标对象。如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性。</p>
<p>之前提过在合成事件中或者在生命周期了 <code>state</code> 是不会马上刷新的，是在事件执行完后也就是 <code>try finally</code> 的 <code>finally</code> 里才真正刷新，这就导致了每次 <code>Object.assign</code> 的 <code>partialState</code> 都是 <code>this.state.count + 1</code>，而 <code>state</code> 的 <code>count</code> 在三次 <code>setState</code> 的时候都不会改变都是0，所以计算过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>很明显最终的 <code>state</code> 的 <code>count</code> 只会增加 1。</p>
<h5 id="setState传入函数"><a href="#setState传入函数" class="headerlink" title="setState传入函数"></a>setState传入函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">increment() &#123;</span><br><span class="line">    <span class="comment">// 采用传入函数的方式来更新 state，会批量，只会render一次，更新但结果是 3</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是一个回调函数function 可以发现 <code>if (typeof payload === &#39;function&#39;)</code> 这里对传入的是否是方法做了判断，如果是方法，就执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partialState = payload.call(instance, prevState, nextProps);</span><br></pre></td></tr></table></figure>

<p><code>instance</code> 对于类组件来说，这里保存类组件的实例在外层的 <code>updateClassInstance</code>函数中 <code>const instance = workInProgress.stateNode;</code> 赋值的。</p>
<p>这里其实只看 <code>payload</code> 和 <code>prevState</code> 就行了，<code>payload</code> 是我们通过 <code>setState</code> 传入的回调函数，返回最新的 <code>state</code>，<code>while</code> 循环调用 <code>getStateFromUpdate</code> 每次传入的是 <code>resultState</code>，也就是说接受的 <code>state</code> 都是上一轮计算之后的新值，因此循环计算的过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到最终的 <code>state</code> 的 <code>count</code> 为增加 3。</p>
<h2 id="react18-自动批处理"><a href="#react18-自动批处理" class="headerlink" title="react18 - 自动批处理"></a>react18 - 自动批处理</h2><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：异步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中：会批量处理</li>
<li>setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中：会批量处理</li>
</ul>
</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>具体解析可以看 <a href="https://rile14929.github.io/zh-CN/react18.2%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E5%8E%9F%E7%90%86%E5%B9%B6%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%9E%90.html">《react18.2批处理场景原理并结合优先级进行的分析》</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !情况1 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 页面变成3，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况4 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 页面变成2，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况6 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况7 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况8 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况9 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onClick&#125;&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>批处理：React 会尝试将同一上下文中触发的更新合并为一个更新。</p>
<p>就 React18 而言当说到批处理的时候，需同时具备以下三者：</p>
<ul>
<li>包括了多个react<strong>更新</strong></li>
<li>每个更新具有相同的<strong>优先级</strong></li>
<li>每个更新都是<strong>待执行</strong>的</li>
</ul>
<p>这样做的好处也显而易见：</p>
<ul>
<li>合并不必要的更新，减少更新流程调用次数</li>
<li>状态按顺序保存下来，更新时不会出现「竞争问题」</li>
<li>最终触发的更新是异步流程，减少浏览器掉帧可能性</li>
</ul>
<h4 id="1-更新"><a href="#1-更新" class="headerlink" title="1. 更新"></a>1. 更新</h4><p>对于 <code>hook</code> 有更新队列，对于 <code>react</code> 也有相应的更新（通常伴随着组件render），当然对浏览器还存在页面视图的更新。</p>
<p>当我们调用dispatch或者setState时，上述三种更新都是有涉及的。但是要特别指出的是，批处理中的更新就是指 <code>react</code> 的更新，包含了render，commit阶段等。在后续的批处理部分你将看到三者的差异。</p>
<p>如果我们看 <code>dispatchSetState</code> 的源码，会发现它们主要做了两件事：</p>
<ul>
<li>记录一次 <code>hook</code> 更新（<code>enqueueConcurrentHookUpdate</code>）</li>
<li>调度一次 <code>react</code> 更新（<code>scheduleUpdateOnFiber</code>）</li>
</ul>
<p>批中的更新就是指调度一次 <code>react</code> 更新 <code>scheduleUpdateOnFiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 dispatchReducerAction 中同样包含的逻辑</span></span><br><span class="line"><span class="comment">// 这个函数中 fiber 和 queue 都是通过 dispatchSetState.bind 提前绑定好的，我们调用 setState 时传入的参数是 action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...异常情形</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><p>在更新部分的相关源码示例中，可以看到 <code>lane</code> 字段，它表示的就是这次更新的优先级。只有优先级相同的多个更新才在一个批中，与之相应的就是这些更新被批处理，反之则不然。</p>
<p>一般而言，如果优先级没有被手动改变，那么相同场景下多次调用 <code>setState</code> 或者 <code>dispatch</code> 对应的更新优先级是相同的。</p>
<p>例外的情况是具有一整个序列而非单一的优先级，像 <code>TransitionLanes</code> 和 <code>RetryLanes</code>。以 <code>TransitionLanes</code> 为例，它们包含了许多个优先级并不相同并且依次排列的 <code>lane</code>，但是在 <code>render</code> 场景下，这些 <code>lane</code> 是一起被处理的。</p>
<p>像下面这样的示例中的更新是不会被视为同一批的，<code>startTransition</code> 改变了第二个更新的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">2</span>)) <span class="comment">// startTransition引自react</span></span><br></pre></td></tr></table></figure>

<h4 id="3-待执行"><a href="#3-待执行" class="headerlink" title="3. 待执行"></a>3. 待执行</h4><p>待执行指的是已经调度但还未被执行。通常执行相对于调度而言是异步的。假如两个更新具有相同的优先级，那么：</p>
<ul>
<li>只要一个已执行，另一个未执行，无法批处理</li>
<li>只要都未执行，就能批处理（一些异步场景可能带来迷惑性）</li>
</ul>
<p>对于第一点，当我们手动调用同步执行更新的api时，后续的更新就无法与同步的更新成批，在下面的示例中，你会发现点击将带来两次render。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    flushSync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    setCount(count + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然而，这样做是可以批处理的</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;点击数字&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>flushSync</code> 可以使更新同步地被执行，这样一来，第二个 <code>setCount</code> 带来的更新与第一个 <code>setCount</code> 的更新无法被批处理，因为 <code>setCount(count + 2)</code> 调用时，第一个更新已经执行完了。</p>
<p>对于第二点，考虑到js事件循环带来的复杂异步特性，在一些让人意想不到的场景也能批处理，下面是一个有趣的示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;划入render一次，点击render两次&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>click事件对应的更新优先级是被调度在微任务中的，而mouseEnter事件则是另一类。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState-1"><a href="#1-setState-1" class="headerlink" title="1. setState"></a>1. setState</h4><p><code>setState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react</code> 更新</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-scheduleUpdateOnFiber"><a href="#2-scheduleUpdateOnFiber" class="headerlink" title="2. scheduleUpdateOnFiber"></a>2. scheduleUpdateOnFiber</h4><p>忽略一些琐碎的细节后，可以发现这个函数的核心逻辑甚至更简单：</p>
<ol>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ensureRootIsScheduled"><a href="#3-ensureRootIsScheduled" class="headerlink" title="3. ensureRootIsScheduled"></a>3. ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-processRootScheduleInMicrotask"><a href="#4-processRootScheduleInMicrotask" class="headerlink" title="4. processRootScheduleInMicrotask"></a>4. processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="5-scheduleTaskForRootDuringMicrotask"><a href="#5-scheduleTaskForRootDuringMicrotask" class="headerlink" title="5. scheduleTaskForRootDuringMicrotask"></a>5. scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">      root.callbackPriority = newCallbackPriority;</span><br><span class="line">      root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于批处理有三点：</p>
<ol>
<li>多次调用 <code>setState</code> 时候，在 <code>ensureRootIsScheduled</code> 中通过 <code>didScheduleMicrotask</code> 标记，第一次进入标记为 <code>true</code>，再次进入便不再调度微任务触发 <code>processRootScheduleInMicrotask</code></li>
<li>当触发后续微任务触发 <code>processRootScheduleInMicrotask</code> 方法，通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>如果是同步优先级，直接return，因为<code>processRootScheduleInMicrotask</code> 方法最后会调用 <code>flushSyncWorkOnAllRoots</code> 执行一遍同步任务， 否则对比上次等待的更新和本次更新的优先级，即 <code>existingCallbackPriority === newCallbackPriority</code>，如果相等，则提前return，否则通过 <code>scheduleCallback</code> 调度更新流程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2函数组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-26T00:00:00+08:00">2024-10-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h2><p>执行函数组件 <code>Fiber</code> 节点的 <code>beginWork</code> 工作，根据 <code>tag</code> 类型，进入 <code>IndeterminateComponent</code> 待定组件的逻辑处理【case IndeterminateComponent】：</p>
<p>每个函数组件的首次加载都是走的 <code>IndeterminateComponent</code> 分支逻辑，这是因为在创建函数组件 <code>Fiber</code> 的时候，<code>react</code> 没有更新它的 <code>tag</code> 值，所以它的首次 <code>beginWork</code> 工作就会进入 <code>IndeterminateComponent</code> 分支，在<code>mountIndeterminateComponent</code> 方法中才会更新它的 <code>tag</code>，使函数组件的Fiber在更新阶段执行 <code>beginWork</code> 时，能够进入正确的 <code>FunctionComponent</code> 分支。</p>
<h3 id="1-1-mountIndeterminateComponent"><a href="#1-1-mountIndeterminateComponent" class="headerlink" title="1.1 mountIndeterminateComponent"></a>1.1 mountIndeterminateComponent</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出函数组件的props</span></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储FirstChild内容</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  # 调用函数组件</span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对类组件和函数组件进行不同的处理</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    value.$$<span class="keyword">typeof</span> === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">	# 类组件的处理逻辑 【只是类组件现在已经不走这里了】</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    # 函数组件处理</span><br><span class="line">    <span class="comment">// 更新tag为函数组件类型的值，下个逻辑就可以直接进入函数组件的处理【节点更新的时候】</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    # 创建子节点</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出当前函数组件FIber节点上的最新的props，方便函数组件加载的使用，然后调用renderWithHooks方法，这个方法会执行我们定义的函数组件，返回值就是函数中return的内容，也就是jsx内容【处理过后的react-element元素对象】。</p>
<h4 id="1-1-1-renderWithHooks"><a href="#1-1-1-renderWithHooks" class="headerlink" title="1.1.1 renderWithHooks"></a>1.1.1 renderWithHooks</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  # 设置为当前渲染中的Fiber</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  # 重置函数组件节点的数据</span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置首次加载的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current = current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  # 调用这个函数，即调用组件，循环生成Element对象，</span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line">  <span class="comment">// 重置一些信息</span></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-1-ReactCurrentDispatcher"><a href="#1-1-1-1-ReactCurrentDispatcher" class="headerlink" title="1.1.1.1 ReactCurrentDispatcher"></a>1.1.1.1 ReactCurrentDispatcher</h5><p><code>ReactCurrentDispatcher</code> 对象是一个全局变量，它是在react源码中的react包定义的：</p>
<p><font color=gray><em>packages\react\src\ReactCurrentDispatcher.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure>

<p>然后将它包装在一个新的对象中：</p>
<p><font color=gray><em>packages\react\src\ReactSharedInternalsClient.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactSharedInternals = &#123;</span><br><span class="line">  ReactCurrentDispatcher,</span><br><span class="line">  ReactCurrentCache,</span><br><span class="line">  ReactCurrentBatchConfig,</span><br><span class="line">  ReactCurrentOwner,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>而shared包【通用工具包】会引入这个对象，然后暴露给全局：</p>
<p><font color=gray><em>packages\shared\ReactSharedInternals.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternalsClient'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>其他资源包就可以通过shared工具包来拿到这个对象，所以我们在函数组件加载时才能使用这个对象：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'shared/ReactSharedInternals'</span>;</span><br><span class="line"><span class="comment">// 拿到ReactCurrentDispatcher对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;ReactCurrentDispatcher, ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>知道了 <code>ReactCurrentDispatcher</code> 对象的由来，我们才能更好地理解它的作用，因为函数组件的每个 <code>hook</code> 实际就是在调用这个对象中的同名方法，比如 <code>useState</code>：</p>
<p><font color=gray><em>packages\react\src\ReactHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>resolveDispatcher</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="comment">// 返回获取到的dispatcher</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 hook 也是一样的原理。</p>
<h5 id="1-1-1-2-函数组件调用"><a href="#1-1-1-2-函数组件调用" class="headerlink" title="1.1.1.2 函数组件调用"></a>1.1.1.2 函数组件调用</h5><p>函数组件的加载核心就是执行一次函数的内容，理解起来也很简单。最后触发 return 关键字，这里的 jsx 内容会在 react 内部通过 <code>jsxRuntime.jsx</code> 方法进行处理，生成 <code>react-element</code> 对象，最后返回值就是创建的 react 元素对象。</p>
<p>最后返回生成的 <code>react-element</code> 对象，<code>renderWithHooks</code> 方法执行完成。</p>
<p>函数组件初始化执行完成后，就会更新函数组件Fiber节点的tag值为正确的类型FunctionComponent【后续逻辑函数组件节点便可以进入Function分支了】。</p>
<p>然后根据新建的value【react元素对象】创建子Fiber节点，最后返回子节点，函数组件的加载过程就基本完成了。</p>
<h3 id="1-2-hooks的加载"><a href="#1-2-hooks的加载" class="headerlink" title="1.2 hooks的加载"></a>1.2 hooks的加载</h3><p>根据上文得知，我们查看先前的 <code>ReactCurrentDispatcher</code> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnMount</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useInsertionEffect: mountInsertionEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState, <span class="comment">// 加载state</span></span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useSyncExternalStore: mountSyncExternalStore,</span><br><span class="line">  useId: mountId,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>例如我们在函数中依次使用useState、useEffect、useLayoutEffect，我们来看一下执行过程：</p>
<h4 id="1-2-1-mountState"><a href="#1-2-1-mountState" class="headerlink" title="1.2.1 mountState"></a>1.2.1 mountState</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  # hook加载工作</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 等待处理的update链表</span></span><br><span class="line">    lanes: NoLanes,</span><br><span class="line">    dispatch: <span class="literal">null</span>, <span class="comment">// dispatchSetState方法</span></span><br><span class="line">    lastRenderedReducer: basicStateReducer, <span class="comment">// 一个函数，通过action和lastRenderedState计算最新的state</span></span><br><span class="line">    lastRenderedState: initialState, <span class="comment">// 上一次的state</span></span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = queue;</span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line">  # 返回值</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-1-mountWorkInProgressHook"><a href="#1-2-1-1-mountWorkInProgressHook" class="headerlink" title="1.2.1.1 mountWorkInProgressHook"></a>1.2.1.1 mountWorkInProgressHook</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  # hook对象</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个hook</span></span><br><span class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 后面的hook对象添加到第一个hook的next属性上，形成一个单向链表</span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>hook</code> 对象，<code>workInProgressHook</code> 默认为 <code>null</code>，它代表当前正在处理中的 <code>hook</code> 对象。</p>
<p>当前 <code>useState</code> 为函数组件中的第一个调用的 <code>hook</code> ，所以这时 <code>workInProgressHook</code> 肯定为 <code>null</code>：</p>
<p>将新建 <code>hook</code> 对象赋值给 <code>workInProgressHook</code>，表示为正在处理中的 <code>hook</code> 对象。</p>
<p>同时也将第一个 <code>hook</code> 对象赋值给当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png" alt="alt text"></p>
<p>继续回到 <code>mountState</code> 方法中:</p>
<p>在 <code>hook</code> 新建完成之后，判断传入的参数 <code>initialState</code> 是否为函数，如果为函数则调用此函数，将结果赋值为新的 <code>initialState</code>。</p>
<p>然后设置 <code>hook</code> 对象的 <code>memoizedState</code> 和 <code>baseState</code> 属性为初始的数据 <code>initialState</code>。</p>
<p>接下来创建一个queue对象，这里要注意两个属性：</p>
<ol>
<li>lastRenderedReducer：它是一个函数，作用是根据action和lastRenderedState计算最新的state。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action就是setCount传入的参数，如果为一个函数，则将state传入进行计算，返回新的state</span></span><br><span class="line">  <span class="comment">// 如果不是函数，则action就是最新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lastRenderedState：代表上一次渲染的state</li>
</ol>
<p>然后更新 <code>hook</code> 对象的 <code>queue</code> 属性，同时设置 <code>queue</code> 对象的 <code>dispatch</code> 属性为一个修改函数 <code>dispatchSetState</code></p>
<p>最后返回一个数组，这就是 <code>useState hook</code> 的返回值：一个初始state和一个修改函数。</p>
<h4 id="1-2-2-mountEffect"><a href="#1-2-2-mountEffect" class="headerlink" title="1.2.2 mountEffect"></a>1.2.2 mountEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进入effect加载</span></span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, # Passive标记对应的是useEffect</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-1-mountEffectImpl"><a href="#1-2-2-1-mountEffectImpl" class="headerlink" title="1.2.2.1 mountEffectImpl"></a>1.2.2.1 mountEffectImpl</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  # 创建的新的hook对象</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 确定当前hook的deps依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 当前渲染中的Fiber节点，即函数组件对应的，打上effect钩子的flags</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 设置hook的memoizedState属性</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是先调用 <code>mountWorkInProgressHook</code> 创建一个 <code>hook</code> 对象，所以这里是先将第一个 <code>hook</code> 对象的 <code>next</code> 属性指向新建的 <code>hook</code>，然后再更新 <code>workInProgressHook</code> 的值为当前的 <code>hook</code> 对象。</p>
<p>此时函数组件Fiber节点的memoizedState属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png" alt="alt text"></p>
<p>在 <code>hook</code> 创建完成之后，确定当前 <code>hook</code> 对象的 <code>deps</code> 依赖，因为我们传递的依赖为[]，所以此时 <code>deps</code> 为一个空数组。然后更新当前 <code>Fiber</code> 节点的 <code>flags</code> 标记，最后设置 <code>hook</code> 对象的 <code>memoizedState</code> 属性内容，这里属性的结果为<code>pushEffect</code> 方法调用的返回值</p>
<h5 id="1-2-2-2-pushEffect"><a href="#1-2-2-2-pushEffect" class="headerlink" title="1.2.2.2 pushEffect"></a>1.2.2.2 pushEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  # 创建副作用对象</span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create, <span class="comment">// 回调函数</span></span><br><span class="line">    destroy, <span class="comment">// 销毁函数</span></span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 取出当前函数组件的UpdateQueue</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null时: 创建当前函数组件的UpdateQueue</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span><br><span class="line">    <span class="comment">// 第一个effect对象: 它的next属性会执行自己,形成一个单向环状链表</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次加载其他的effect时: 将</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      # 上一个effect的next属性指向新建的effect</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      # 新建的next属性指向第一个effect</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了一个effect对象，查看它的内容：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png" alt="alt text"></p>
<ol>
<li><code>create</code> 属性即为我们传入的回调函数。</li>
<li><code>deps</code> 属性是当前 <code>useEffect hook</code>的依赖。</li>
<li><code>destory</code> 属性为 <code>undefined</code>，它存储的是 <code>useEffect hook</code>返回的clean清理函数或者说销毁函数，但是它不是在这里赋值的，并且当前我们也没有返回这个函数。</li>
</ol>
<p>然后取出当前函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性内容赋值给变量 <code>componentUpdateQueue</code>。</p>
<p>然后判断 <code>componentUpdateQueue</code> 是否为 <code>null</code>：</p>
<p>为 <code>null</code> 时，然后调用 <code>createFunctionComponentUpdateQueue</code> 方法更新它的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>): <span class="title">FunctionComponentUpdateQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    stores: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前创建的 <code>effect</code> 对象的 <code>next</code> 属性指向了自身，且同时更新 <code>updateQueue.lastEffect</code> 属性为当前 <code>effect</code> 对象，由此形成一个单向环状链表。</p>
<p>所以此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png" alt="alt text"></p>
<p><code>pushEffect</code> 方法最后，返回当前创建的 <code>effect</code> 对象。</p>
<p>再回到 <code>mountEffectImpl</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect()</span><br></pre></td></tr></table></figure>

<p>所以 <code>hook</code> 对象的 <code>memoizedState</code> 属性值为一个 <code>effect</code> 对象。</p>
<p>从这里我们可以发现，虽然每个hook对象都是相同的属性，但是不同的 <code>hook</code> 类型它存储的内容却完全不同。</p>
<ul>
<li><code>useState</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为数据 <code>state</code>。</li>
<li><code>useEffect</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为一个 <code>effect</code> 对象。</li>
</ul>
<h4 id="1-2-3-mountLayoutEffect"><a href="#1-2-3-mountLayoutEffect" class="headerlink" title="1.2.3 mountLayoutEffect"></a>1.2.3 mountLayoutEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberFlags: Flags = UpdateEffect;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">    fiberFlags |= LayoutStaticEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(fiberFlags, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现useEffect和useLayoutEffect共用了同一个加载方法 <code>mountEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<p><code>hook</code> 对象创建和处理，此时函数组件Fiber节点的memoizedState属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png" alt="alt text"></p>
<p><code>effect</code> 对象创建和处理，依然是 <code>pushEffect</code> 方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # 第二次加载其他的effect时:</span><br><span class="line">  <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="comment">// 上一个effect的next属性指向新建的effect</span></span><br><span class="line">    lastEffect.next = effect;</span><br><span class="line">    <span class="comment">// 新建的next属性指向第一个effect</span></span><br><span class="line">    effect.next = firstEffect;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前为第二个effect相关的 <code>hook</code> 处理，所以此时 <code>Fiber.updateQueue</code>【即componentUpdateQueue】是有值的，进入else分支处理。</p>
<p>更新<code>Fiber.updateQueue.lastEffect</code>属性指向为当前新建的 <code>effect2</code>，将 <code>effect2</code> 的 <code>next</code> 属性指向为之前的 <code>effect</code> 对象。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png" alt="alt text"></p>
<p>到此，函数组件加载阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="1-3-commit阶段"><a href="#1-3-commit阶段" class="headerlink" title="1.3 commit阶段"></a>1.3 commit阶段</h3><p>前面全部的加载逻辑都是在 <code>Fiber Reconciler</code> 协调流程中执行的，即函数组件大部分的加载逻辑都是在 <code>reconciler</code> 协调流程中完成的【更新阶段同理】，还有剩下的一部分逻辑在 <code>commit</code> 阶段之中处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发起调度处理useEffect回调</span></span><br><span class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">	<span class="comment">// 这个回调就是处理useEffect的</span></span><br><span class="line">	flushPassiveEffects();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1，BeforeMutation阶段</span></span><br><span class="line">  commitBeforeMutationEffects()</span><br><span class="line">  <span class="comment">// 2，Mutation阶段，渲染真实DOM加载到页面</span></span><br><span class="line">  commitMutationEffects()</span><br><span class="line">  <span class="comment">// 3，Layout阶段</span></span><br><span class="line">  commitLayoutEffects()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit</code> 阶段的内容都是同步执行，在进入具体的执行之前，都会先调用 <code>scheduleCallback</code> 方法发起一个新的调度，即创建一个新的任务 <code>task</code>，最后会生成一个新的宏任务来异步处理副作用【即执行useEffect的回调钩子】。</p>
<p>上面是 <code>useEffect</code> 的回调处理，我们再查看 <code>useLayoutEffect</code> 的回调处理。</p>
<h3 id="1-4-Layout阶段"><a href="#1-4-Layout阶段" class="headerlink" title="1.4 Layout阶段"></a>1.4 Layout阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 根据组件类型</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">          <span class="comment">// 函数组件的处理</span></span><br><span class="line">          <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">              <span class="comment">// 传入的是layout相关的flag标记</span></span><br><span class="line">              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-commitHookEffectListMount"><a href="#1-4-1-commitHookEffectListMount" class="headerlink" title="1.4.1 commitHookEffectListMount"></a>1.4.1 commitHookEffectListMount</h4><p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListMount</span>(<span class="params">flags: HookFlags, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  # 当前函数组件的updateQueue属性，存储的是副作用链表</span><br><span class="line">  <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">  <span class="comment">// 取出最后一个effect对象</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个effect对象</span></span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 开始循环处理</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">        <span class="comment">// Mount</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.create;</span><br><span class="line">        # 执行回调函数</span><br><span class="line">        effect.destroy = create();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从当前函数组件 <code>Fiber</code> 节点取出它的 <code>updateQueue</code> 属性内容，在前面我们已经知道了 <code>Fiber.updateQueue</code> 存储的是副作用相关的链表，定义一个 <code>lastEffect</code> 变量存储 <code>updateQueue.lastEffect</code> 的内容，即最后一个 <code>effect</code> 对象。</p>
<p>判断 <code>lastEffect</code> 是否为 <code>null</code> ，如果 <code>lastEffect</code> 为 <code>null</code>，代表当前函数组件没有使用过 <code>effect</code> 相关的 <code>hook</code>。</p>
<p>当前肯定是有值的，继续向下执行。从 <code>lastEffect.next</code> 中取出第一个 <code>effect</code> 对象，开始按顺序循环处理副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">	<span class="comment">// Mount</span></span><br><span class="line">	<span class="keyword">const</span> create = effect.create;</span><br><span class="line">	<span class="comment">// 执行回调函数</span></span><br><span class="line">	effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">  effect = effect.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>

<p>注意在执行之前有一个条件判断，只有存在 <code>effect</code> 相关的 <code>flags</code> 标记才会执行对应副作用回调。</p>
<p>而在之前 <code>hook</code> 加载是有进行设置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect(</span><br><span class="line">  HookHasEffect | hookFlags, <span class="comment">// HookHasEffect标记就是表示有需要执行副作用</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在函数组件加载阶段时，每个 <code>useEffect</code> 和 <code>useLayoutEffect</code> 都有打上 <code>HookHasEffect</code> 的标记，表示在加载阶段都会默认执行一次。</p>
<p>需要注意的是：之前 <code>commitHookEffectListMount</code> 传入的是与 <code>Layout</code> 相关的 <code>flags</code> 标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); <span class="comment">// Layout</span></span><br></pre></td></tr></table></figure>

<p>所以这里只有 <code>layout hook</code> 的回调才能执行，第一个 <code>effect</code> 对象对应的是 <code>useEffect</code>，不满足判断条件</p>
<p>从当前 <code>effect</code> 对象的 <code>next</code> 属性取出下一个 <code>effect</code> 对象，开始第二次循环。</p>
<p>第二个 <code>effect</code> 对象对应的是 <code>useLayoutEffect</code>，满足判断条件，执行它的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = effect.create;</span><br><span class="line"><span class="comment">// 执行回调函数</span></span><br><span class="line">effect.destroy = create();</span><br></pre></td></tr></table></figure>

<p>到此 hook 相关的回调处理完成，函数组件加载逻辑全部执行完成。</p>
<h2 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h2><h3 id="2-1-dispatchSetState"><a href="#2-1-dispatchSetState" class="headerlink" title="2.1 dispatchSetState"></a>2.1 dispatchSetState</h3><p>当操作更新触发 <code>setState</code> 时, 就是触发之前 <code>useState</code> 加载返回的 <code>dispatch</code> 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line"># 返回值</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A, <span class="regexp">//</span> state <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求更新优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// 1. 创建update更新对象</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// state 1</span></span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 调度之前的一个优化策略校验: eagerState</span><br><span class="line">    <span class="comment">// 快速计算出本次最新的state，与原来的进行对比，如果没有发生变化，则跳过后续的更新逻辑</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当前的state，即旧的state</span></span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="comment">// 快速计算最新的state</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            # 如果state没变，组件不做更新。此处和useReducer对比下，useReducer还是会让函数组件更新</span><br><span class="line">            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将更新对象入队</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      <span class="comment">// 3. 开启一个新的调度更新任务</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-eagerState"><a href="#2-1-1-eagerState" class="headerlink" title="2.1.1 eagerState"></a>2.1.1 eagerState</h4><p>首先看 <code>dispatchSetState</code> 方法的整个结构和类组件的更新方法 <code>enqueueSetState</code> 基本相同，还有 <code>react</code> 应用的初始加载 <code>updateContainer</code>，其实一个react应用的更新场景就只有这三种，而它们的更新逻辑就是以下几个步骤：</p>
<ol>
<li>获取更新优先级 <code>lane</code>。</li>
<li>创建 <code>update</code> 更新对象 。</li>
<li>将 <code>update</code> 更新对象添加到目标Fiber对象的更新队列中。</li>
<li>开启一个新的调度更新任务。</li>
</ol>
<p>它们的区别主要在于函数组件这里在调度之前有一个eagerState优化策略校验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的state，即旧的state</span></span><br><span class="line"><span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line"><span class="comment">// 快速计算最新的state</span></span><br><span class="line"><span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">update.eagerState = eagerState;</span><br><span class="line"><span class="comment">// 比较新旧state</span></span><br><span class="line"><span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个优化策略的作用是：调用 <code>queue.lastRenderedReducer</code> 方法，通过原来的 <code>state</code> 和当前传入的 <code>action</code> 参数，快速的计算出本次最新的 <code>state</code> 【即eagerState】，通过比较新旧 <code>state</code> 来判断数据是否变化，如果没有变化则可以跳过后续的更新逻辑，即不会开启新的调度更新任务。当前我们的 <code>state</code> 是有变化的，所以不满足优化策略，将继续向下执行更新。</p>
<h4 id="2-1-2-enqueueConcurrentHookUpdate"><a href="#2-1-2-enqueueConcurrentHookUpdate" class="headerlink" title="2.1.2 enqueueConcurrentHookUpdate"></a>2.1.2 enqueueConcurrentHookUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentHookUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: HookQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: HookUpdate&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// 通用的入队方法</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// 找到根节点并返回</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>dispatchSetState</code> 方法中，最后还是会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h4 id="2-1-3-flushSyncWorkOnAllRoots"><a href="#2-1-3-flushSyncWorkOnAllRoots" class="headerlink" title="2.1.3 flushSyncWorkOnAllRoots"></a>2.1.3 flushSyncWorkOnAllRoots</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>microtask</code> 结束时，<code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>直接快进到performSyncWorkOnRoot方法中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用renderRootSync方法，开始FiberTree的创建过程。</p>
<p><strong>在这之前，还有一个处理要注意：把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	prepareFreshStack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	finishQueueingConcurrentUpdates()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png" alt="alt text"></p>
<h4 id="2-1-4-updateFunctionComponent"><a href="#2-1-4-updateFunctionComponent" class="headerlink" title="2.1.4 updateFunctionComponent"></a>2.1.4 updateFunctionComponent</h4><p>下面进入 <code>beginWork</code> 工作的 <code>FunctionComponent</code> 处理分支，开始函数组件的更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  # 调用函数组件</span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  # 函数组件默认的bailout策略，满足条件比较苛刻</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见 <code>updateFunctionComponent</code> 方法主要有两个处理：</p>
<ol>
<li>调用renderWithHooks【函数组件加载也是调用了这个方法】。</li>
<li>判断是否满足Bailout优化策略，满足则进入优化逻辑，跳过本组件的更新。不满足，则执行正常的组件更新逻辑。</li>
</ol>
<h4 id="2-1-5-renderWithHooks"><a href="#2-1-5-renderWithHooks" class="headerlink" title="2.1.5 renderWithHooks"></a>2.1.5 renderWithHooks</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// 设置为当前渲染中的Fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置函数组件节点的数据</span></span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置更新的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current =current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  <span class="comment">// 调用这个函数，即调用组件，循环生成Element对象，</span></span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新阶段时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</span><br></pre></td></tr></table></figure>

<p><code>renderWithHooks</code> 方法的重点依然是组件的调用 <code>Component()</code>，这里的逻辑依然只是重新调用一遍我们定义的函数，最后返回最新的jsx内容【即reactElement对象】</p>
<h4 id="2-1-6-hooks的更新"><a href="#2-1-6-hooks的更新" class="headerlink" title="2.1.6 hooks的更新"></a>2.1.6 hooks的更新</h4><p>首先查看 <code>useState</code> 的更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123;</span><br><span class="line">	useState: updateState, <span class="comment">// 更新state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState:</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init?</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 更新hook工作</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-updateWorkInProgressHook"><a href="#2-1-7-updateWorkInProgressHook" class="headerlink" title="2.1.7 updateWorkInProgressHook"></a>2.1.7 updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即将处理的hook</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 第一此进入更新时，currentHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出当前正在更新的函数组件Fiber的旧节点</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.alternate;</span><br><span class="line">    <span class="comment">// 更新阶段，current都是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将旧节点的memoizedState 设置为下一个处理的Hook</span></span><br><span class="line">      <span class="comment">// 将组件加载时，初始化的hook链表取出，memoizedState指向的是hook1</span></span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个hook更新开始，会走这里</span></span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置下一个工作中的Hook为null</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 组件的第一个Hook更新时，workInProgressHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将当前函数组件Fiber节点的memoizedState 设置为下一个处理的hook【默认是null】</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一个Hook，则取next指向的下一个</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个不为null， 说明当前hook不是最后一个更新的hook，只有最后一个hook更新时，nextWorkInProgressHook才为null</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's already a work-in-progress. Reuse it.</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新currentHook 为第一个hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象，复用原来的内容</span></span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      baseQueue: currentHook.baseQueue,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>, <span class="comment">// 但是清空了next指向</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个hook更新时，workInProgressHook为null，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      <span class="comment">// 更新当前函数的组件的memoizedState为第一个hook对象，同时设置为当前正在工作中的hook</span></span><br><span class="line">      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      <span class="comment">// 非第一个Hook,直接添加到上一个hook对象的next属性中</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回当前正在工作中的hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像函数组件的hook在加载时都会调用一个 <code>mountWorkInProgressHook</code> 方法，生成一个hook链表。</p>
<p>而函数组件的hook在更新时也会调用一个 <code>updateWorkInProgressHook</code> 方法，生成对应的hook链表。</p>
<p>所以 <code>updateWorkInProgressHook</code> 方法的作用是：确定当前函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容，也就是生成它的 <code>hook</code> 链表。</p>
<p>它的做法就是从 <code>current</code> 节点上取出函数组件加载时生成的 <code>hook</code> 链表，按顺序取出原来的 <code>hook</code> 对象，根据原来的对象信息创建生成新的 <code>newHook</code> 对象，最后按顺序一个一个添加到新的 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性上。</p>
<p><strong>注意：</strong>这里是一个重点，如果没有清空 <code>next</code> 属性，那更新当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性，直接拿到第一个 <code>hook</code> 对象，就可以拿到整个 <code>hook</code> 链表，然后后续的 <code>hook</code> 更新就不需要再调用 <code>updateWorkInProgressHook</code> 方法了。</p>
<p>但是函数组件为啥不能如此处理呢？</p>
<p>因为react不能保证开发者是一定按照规范来使用的 <code>hook</code> ，如果开发者将 <code>hook</code> 置于条件语句中，在更新阶段出现了原来 <code>hook</code> 链表中不存在的 <code>hook</code> 对象，则在渲染时就会发生异常，所以react在函数组件更新时需要主动中断 <code>hook</code> 对象的next属性指向，按原来的链表顺序重新一个一个添加，如果出现了不匹配的 <code>hook</code> 对象，就会主动抛出异常，提示用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-计算state"><a href="#2-1-8-计算state" class="headerlink" title="2.1.8 计算state"></a>2.1.8 计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line"><span class="function">  <span class="title">initialArg</span>: <span class="title">I</span>,</span></span><br><span class="line"><span class="function">  <span class="title">init</span>?: <span class="title">I</span> =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 返回新的hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer; <span class="comment">// 还是basicStateReducer，无变化</span></span><br><span class="line">  <span class="keyword">const</span> current = currentHook; <span class="comment">// 旧的hook对象，加载时useState创建的hook对象</span></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.baseQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="comment">// 等待处理的更新链表：默认指向的是最后一个update对象</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// pendingQueue不为null，代表有需要处理的更新对象，然后需要将它们添加到baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Merge the pending queue and the base queue.</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们有一个队列要处理</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = current.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line"></span><br><span class="line">    # 循环处理update更新对象</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">        <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line">            action: update.action,</span><br><span class="line">            hasEagerState: update.hasEagerState,</span><br><span class="line">            eagerState: update.eagerState,</span><br><span class="line">            next: (<span class="literal">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	# 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>updateWorkInProgressHook</code> 方法调用完成之后，返回值就是 <code>useState</code> 对应的hook对象：</p>
<p>取出hook对象的queue队列，如果queue为null，则会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的逻辑看似比较多，但其实比较简单，而且和this.setState计算state的逻辑基本一致。</p>
<p><strong>它的核心逻辑：</strong>按顺序正向循环 <code>update</code> 更新队列，定义一个变量 <code>newState</code> 来存储最新的 <code>state</code>，然后根据原来 <code>state</code> 和 <code>update</code> 对象里面的信息计算最新的数据更新变量 <code>newState</code>，每循环一次就会从 <code>update</code> 对象的 <code>next</code> 属性取出下一个参与计算的 <code>update</code>，直接到所有的 <code>update</code> 处理完成。</p>
<p>当前 <code>pendingQueue</code> 结构【单向环状链表】：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png" alt="alt text"></p>
<p>在类组件中，会根据pendingQueue的内容重构生成一个新的单向链表，不再是环状，有明确的结束。</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png" alt="alt text"></p>
<p>和类组件不同的是，函数组件这里并没有额外处理pendingQueue，而是直接复制给baseQueue，从baseQueue.next取出第一个update对象【即first】开始计算state。</p>
<p>所以函数组件这里的do while循环多了一个结束的判断条件，就是不能等于first，不然就会陷入无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first)</span><br></pre></td></tr></table></figure>

<p>然后就是函数组件计算state的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while循环中，计算state的核心逻辑</span></span><br><span class="line"><span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">  newState = ((update.eagerState: any): S);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action = update.action;</span><br><span class="line">  newState = reducer(newState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果eagerState存在，则直接使用eagerState的值为新的state。</p>
<p>如果不存在，则调用reducer【basicStateReducer】，根据最新的newState和当前update对象的action重新计算state。</p>
<p>循环结束，在更新state之前，还有一个校验需要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line"><span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">  markWorkInProgressReceivedUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对一个状态的批量处理之后，有一个状态变化的校验，针对的是函数组件内部的 <code>Bailout</code> 策略。</p>
<p>即如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量 <code>ReceivedUpdate</code> 为 <code>false</code>，表示改组件没有更新的内容，这样就可以在 <code>renderWithHooks</code> 方法执行完成后，进入 <code>Bailout</code> 策略。</p>
<p>然后更新 <code>hook</code> 对象的 <code>memoizedState</code> 属性为最新的 <code>newState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储最新的state</span></span><br><span class="line">hook.memoizedState = newState;</span><br></pre></td></tr></table></figure>

<p>到此，<code>useState hook</code> 的更新程序执行完成，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆state</span></span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p>同时这里我们也可以明白：函数组件 <code>useState hook</code> 能够缓存变量结果的原因，因为它的 <code>state</code> 存储在 <code>hook</code> 对象的属性之中，并且这个属性可以在函数组件重新渲染过程中得到更新。</p>
<h3 id="2-2-updateEffect"><a href="#2-2-updateEffect" class="headerlink" title="2.2 updateEffect"></a>2.2 updateEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 取出新的依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 重置销毁方法</span></span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的pushEffect方法</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    <span class="comment">// 继承原来的destroy方法</span></span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面校验为true的情况下，这里就不会再执行</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先依然是调用一个 <code>updateWorkInProgressHook</code> 方法，前面已经详细讲解了它的作用。所以这里调用此方法后，就会新建一个 <code>newHook</code> 对象，添加到第一个 <code>hook</code> 对象的 <code>next</code> 属性之上，形成一个链表，后续如果还有新的 <code>newHook</code> 对象则继续执行同样的逻辑。</p>
<p>此时函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png" alt="alt text"></p>
<h3 id="2-2-1-areHookInputsEqual"><a href="#2-2-1-areHookInputsEqual" class="headerlink" title="2.2.1 areHookInputsEqual"></a>2.2.1 areHookInputsEqual</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况1，无依赖参数，每次渲染都会执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况2，有至少一项依赖参数，循环判断每个依赖是否相等，任何一个依赖变化则会重新执行副作用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 情况3，即空数组的情况，重新渲染不执行副作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前我们依赖为一个空数组，所以满足第三种情况，直接返回 <code>true</code>。</p>
<ul>
<li><p>在依赖校验为 <code>true</code> 的情况下，即表示没有变化，此时更新 <code>hook.memoizedState</code> 属性，最后触发 <code>return</code> 关键字，<code>updateEffect</code> 方法执行完成。</p>
</li>
<li><p>在依赖变化时，也会重新设置 <code>hook.memoizedState</code> 属性，依赖校验为true的情况下就是第一个参数不同，会打上 <code>HookHasEffect</code> 的标记。</p>
<ul>
<li>这个值会存储到 <code>effect</code> 对象的tag属性上，表示此effect对象有需要执行的副作用回调。</li>
<li><code>hookFlags</code> 表示副作用的类型标记，比如 <code>HookPassive</code>，<code>HookLayout</code>。</li>
<li>所以依赖发生变化的唯一区别就是：打上了 <code>HookHasEffect</code> 标记。最终会 <code>commit</code> 阶段中执行回调时，判断 <code>effect.tag</code> 的值来判断是否执行回调。</li>
</ul>
</li>
</ul>
<p>到此，函数组件的第二个hook：useEffect更新完成。</p>
<h3 id="2-3-updateLayoutEffect"><a href="#2-3-updateLayoutEffect" class="headerlink" title="2.3 updateLayoutEffect"></a>2.3 updateLayoutEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>useEffect</code> 和 <code>useLayoutEffect</code> 共用了同一个更新方法 <code>updateEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<ul>
<li>调用 <code>updateWorkInProgressHook</code> 方法：创建新 <code>hook</code> 对象，此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向更新为：</li>
</ul>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png" alt="alt text"></p>
<ul>
<li>判断 <code>deps</code> 依赖是否变化，如果变化则为对应的 <code>effect</code> 对象打上 <code>HookHasEffect</code> 的标记。</li>
</ul>
<p>到此，函数组件更新阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>函数组件更新阶段主要有这两个重点逻辑：</p>
<ul>
<li>根据 <code>updateQueue</code> 更新队列，循环计算 <code>state</code>，最后将最新的 <code>state</code> 数据存储到 <code>Fiber.memoizedState</code> 属性上并返回。</li>
<li>更新 <code>Effect</code>类 <code>hook</code> 时，判断依赖是否变化打上 <code>HookHasEffect</code>，最后会根据 <code>effect.tag</code> 值来决定本次更新是否执行回调。</li>
</ul>
<p><code>useEffect</code> 和 <code>useLayoutEffect</code>的区别：<code>useLayoutEffect</code> 是 <code>useEffect</code> 的一个变种，它们都是在 <code>React</code> 组件中处理副作用的方法。两者之间的主要区别在于它们的执行时机。</p>
<ul>
<li><code>useEffect</code> 的回调函数会在每次渲染结束后异步执行，这意味着它不会阻塞浏览器的渲染过程。换句话说，<code>React</code> 会在处理 <code>useEffect</code> 内部的状态更新之前，让浏览器先绘制屏幕。</li>
<li>而 <code>useLayoutEffect</code> 的回调函数会在每次渲染结束后同步执行。这意味着它会阻塞浏览器的渲染过程，直到其执行完毕。因此，<code>useLayoutEffect</code> 可以在浏览器重新绘制屏幕之前触发。</li>
</ul>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 会阻塞浏览器的渲染过程，如果过度使用，可能会导致应用程序变慢，甚至引发性能问题。因此，在大多数情况下，应优先考虑使用 <code>useEffect</code>。只有在某些特定情况下，例如需要在 <code>DOM</code> 更新后立即进行某些操作，或者需要在用户看到渲染结果之前进行某些操作，才考虑使用 <code>useLayoutEffect</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/IMG_2044.jpg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
