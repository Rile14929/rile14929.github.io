<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2函数组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-16T00:00:00+08:00">2024-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h2><p>执行函数组件 <code>Fiber</code> 节点的 <code>beginWork</code> 工作，根据 <code>tag</code> 类型，进入 <code>IndeterminateComponent</code> 待定组件的逻辑处理【case IndeterminateComponent】：</p>
<p>每个函数组件的首次加载都是走的 <code>IndeterminateComponent</code> 分支逻辑，这是因为在创建函数组件 <code>Fiber</code> 的时候，<code>react</code> 没有更新它的 <code>tag</code> 值，所以它的首次 <code>beginWork</code> 工作就会进入 <code>IndeterminateComponent</code> 分支，在<code>mountIndeterminateComponent</code> 方法中才会更新它的 <code>tag</code>，使函数组件的Fiber在更新阶段执行 <code>beginWork</code> 时，能够进入正确的 <code>FunctionComponent</code> 分支。</p>
<h3 id="1-1-mountIndeterminateComponent"><a href="#1-1-mountIndeterminateComponent" class="headerlink" title="1.1 mountIndeterminateComponent"></a>1.1 mountIndeterminateComponent</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出函数组件的props</span></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储FirstChild内容</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  # 调用函数组件</span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对类组件和函数组件进行不同的处理</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    value.$$<span class="keyword">typeof</span> === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">	# 类组件的处理逻辑 【只是类组件现在已经不走这里了】</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    # 函数组件处理</span><br><span class="line">    <span class="comment">// 更新tag为函数组件类型的值，下个逻辑就可以直接进入函数组件的处理【节点更新的时候】</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    # 创建子节点</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出当前函数组件FIber节点上的最新的props，方便函数组件加载的使用，然后调用renderWithHooks方法，这个方法会执行我们定义的函数组件，返回值就是函数中return的内容，也就是jsx内容【处理过后的react-element元素对象】。</p>
<h4 id="1-1-1-renderWithHooks"><a href="#1-1-1-renderWithHooks" class="headerlink" title="1.1.1 renderWithHooks"></a>1.1.1 renderWithHooks</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  # 设置为当前渲染中的Fiber</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  # 重置函数组件节点的数据</span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置首次加载的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current = current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  # 调用这个函数，即调用组件，循环生成Element对象，</span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line">  <span class="comment">// 重置一些信息</span></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-1-ReactCurrentDispatcher"><a href="#1-1-1-1-ReactCurrentDispatcher" class="headerlink" title="1.1.1.1 ReactCurrentDispatcher"></a>1.1.1.1 ReactCurrentDispatcher</h5><p><code>ReactCurrentDispatcher</code> 对象是一个全局变量，它是在react源码中的react包定义的：</p>
<p><font color=gray><em>packages\react\src\ReactCurrentDispatcher.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure>

<p>然后将它包装在一个新的对象中：</p>
<p><font color=gray><em>packages\react\src\ReactSharedInternalsClient.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactSharedInternals = &#123;</span><br><span class="line">  ReactCurrentDispatcher,</span><br><span class="line">  ReactCurrentCache,</span><br><span class="line">  ReactCurrentBatchConfig,</span><br><span class="line">  ReactCurrentOwner,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>而shared包【通用工具包】会引入这个对象，然后暴露给全局：</p>
<p><font color=gray><em>packages\shared\ReactSharedInternals.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternalsClient'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>其他资源包就可以通过shared工具包来拿到这个对象，所以我们在函数组件加载时才能使用这个对象：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'shared/ReactSharedInternals'</span>;</span><br><span class="line"><span class="comment">// 拿到ReactCurrentDispatcher对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;ReactCurrentDispatcher, ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>知道了 <code>ReactCurrentDispatcher</code> 对象的由来，我们才能更好地理解它的作用，因为函数组件的每个 <code>hook</code> 实际就是在调用这个对象中的同名方法，比如 <code>useState</code>：</p>
<p><font color=gray><em>packages\react\src\ReactHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>resolveDispatcher</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="comment">// 返回获取到的dispatcher</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 hook 也是一样的原理。</p>
<h5 id="1-1-1-2-函数组件调用"><a href="#1-1-1-2-函数组件调用" class="headerlink" title="1.1.1.2 函数组件调用"></a>1.1.1.2 函数组件调用</h5><p>函数组件的加载核心就是执行一次函数的内容，理解起来也很简单。最后触发 return 关键字，这里的 jsx 内容会在 react 内部通过 <code>jsxRuntime.jsx</code> 方法进行处理，生成 <code>react-element</code> 对象，最后返回值就是创建的 react 元素对象。</p>
<p>最后返回生成的 <code>react-element</code> 对象，<code>renderWithHooks</code> 方法执行完成。</p>
<p>函数组件初始化执行完成后，就会更新函数组件Fiber节点的tag值为正确的类型FunctionComponent【后续逻辑函数组件节点便可以进入Function分支了】。</p>
<p>然后根据新建的value【react元素对象】创建子Fiber节点，最后返回子节点，函数组件的加载过程就基本完成了。</p>
<h3 id="1-2-hooks的加载"><a href="#1-2-hooks的加载" class="headerlink" title="1.2 hooks的加载"></a>1.2 hooks的加载</h3><p>根据上文得知，我们查看先前的 <code>ReactCurrentDispatcher</code> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnMount</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useInsertionEffect: mountInsertionEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState, <span class="comment">// 加载state</span></span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useSyncExternalStore: mountSyncExternalStore,</span><br><span class="line">  useId: mountId,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>例如我们在函数中依次使用useState、useEffect、useLayoutEffect，我们来看一下执行过程：</p>
<h4 id="1-2-1-mountState"><a href="#1-2-1-mountState" class="headerlink" title="1.2.1 mountState"></a>1.2.1 mountState</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  # hook加载工作</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 等待处理的update链表</span></span><br><span class="line">    lanes: NoLanes,</span><br><span class="line">    dispatch: <span class="literal">null</span>, <span class="comment">// dispatchSetState方法</span></span><br><span class="line">    lastRenderedReducer: basicStateReducer, <span class="comment">// 一个函数，通过action和lastRenderedState计算最新的state</span></span><br><span class="line">    lastRenderedState: initialState, <span class="comment">// 上一次的state</span></span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = queue;</span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line">  # 返回值</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-1-mountWorkInProgressHook"><a href="#1-2-1-1-mountWorkInProgressHook" class="headerlink" title="1.2.1.1 mountWorkInProgressHook"></a>1.2.1.1 mountWorkInProgressHook</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  # hook对象</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个hook</span></span><br><span class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 后面的hook对象添加到第一个hook的next属性上，形成一个单向链表</span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>hook</code> 对象，<code>workInProgressHook</code> 默认为 <code>null</code>，它代表当前正在处理中的 <code>hook</code> 对象。</p>
<p>当前 <code>useState</code> 为函数组件中的第一个调用的 <code>hook</code> ，所以这时 <code>workInProgressHook</code> 肯定为 <code>null</code>：</p>
<p>将新建 <code>hook</code> 对象赋值给 <code>workInProgressHook</code>，表示为正在处理中的 <code>hook</code> 对象。</p>
<p>同时也将第一个 <code>hook</code> 对象赋值给当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向为：</p>
<p><img src="image.png" alt="alt text"></p>
<p>继续回到 <code>mountState</code> 方法中:</p>
<p>在 <code>hook</code> 新建完成之后，判断传入的参数 <code>initialState</code> 是否为函数，如果为函数则调用此函数，将结果赋值为新的 <code>initialState</code>。</p>
<p>然后设置 <code>hook</code> 对象的 <code>memoizedState</code> 和 <code>baseState</code> 属性为初始的数据 <code>initialState</code>。</p>
<p>接下来创建一个queue对象，这里要注意两个属性：</p>
<ol>
<li>lastRenderedReducer：它是一个函数，作用是根据action和lastRenderedState计算最新的state。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action就是setCount传入的参数，如果为一个函数，则将state传入进行计算，返回新的state</span></span><br><span class="line">  <span class="comment">// 如果不是函数，则action就是最新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lastRenderedState：代表上一次渲染的state</li>
</ol>
<p>然后更新 <code>hook</code> 对象的 <code>queue</code> 属性，同时设置 <code>queue</code> 对象的 <code>dispatch</code> 属性为一个修改函数 <code>dispatchSetState</code></p>
<p>最后返回一个数组，这就是 <code>useState hook</code> 的返回值：一个初始state和一个修改函数。</p>
<h4 id="1-2-2-mountEffect"><a href="#1-2-2-mountEffect" class="headerlink" title="1.2.2 mountEffect"></a>1.2.2 mountEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进入effect加载</span></span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, # Passive标记对应的是useEffect</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-1-mountEffectImpl"><a href="#1-2-2-1-mountEffectImpl" class="headerlink" title="1.2.2.1 mountEffectImpl"></a>1.2.2.1 mountEffectImpl</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  # 创建的新的hook对象</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 确定当前hook的deps依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 当前渲染中的Fiber节点，即函数组件对应的，打上effect钩子的flags</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 设置hook的memoizedState属性</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是先调用 <code>mountWorkInProgressHook</code> 创建一个 <code>hook</code> 对象，所以这里是先将第一个 <code>hook</code> 对象的 <code>next</code> 属性指向新建的 <code>hook</code>，然后再更新 <code>workInProgressHook</code> 的值为当前的 <code>hook</code> 对象。</p>
<p>此时函数组件Fiber节点的memoizedState属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png" alt="alt text"></p>
<p>在 <code>hook</code> 创建完成之后，确定当前 <code>hook</code> 对象的 <code>deps</code> 依赖，因为我们传递的依赖为[]，所以此时 <code>deps</code> 为一个空数组。然后更新当前 <code>Fiber</code> 节点的 <code>flags</code> 标记，最后设置 <code>hook</code> 对象的 <code>memoizedState</code> 属性内容，这里属性的结果为<code>pushEffect</code> 方法调用的返回值</p>
<h5 id="1-2-2-2-pushEffect"><a href="#1-2-2-2-pushEffect" class="headerlink" title="1.2.2.2 pushEffect"></a>1.2.2.2 pushEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  # 创建副作用对象</span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create, <span class="comment">// 回调函数</span></span><br><span class="line">    destroy, <span class="comment">// 销毁函数</span></span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 取出当前函数组件的UpdateQueue</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null时: 创建当前函数组件的UpdateQueue</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span><br><span class="line">    <span class="comment">// 第一个effect对象: 它的next属性会执行自己,形成一个单向环状链表</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次加载其他的effect时: 将</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      # 上一个effect的next属性指向新建的effect</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      # 新建的next属性指向第一个effect</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了一个effect对象，查看它的内容：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png" alt="alt text"></p>
<ol>
<li><code>create</code> 属性即为我们传入的回调函数。</li>
<li><code>deps</code> 属性是当前 <code>useEffect hook</code>的依赖。</li>
<li><code>destory</code> 属性为 <code>undefined</code>，它存储的是 <code>useEffect hook</code>返回的clean清理函数或者说销毁函数，但是它不是在这里赋值的，并且当前我们也没有返回这个函数。</li>
</ol>
<p>然后取出当前函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性内容赋值给变量 <code>componentUpdateQueue</code>。</p>
<p>然后判断 <code>componentUpdateQueue</code> 是否为 <code>null</code>：</p>
<p>为 <code>null</code> 时，然后调用 <code>createFunctionComponentUpdateQueue</code> 方法更新它的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>): <span class="title">FunctionComponentUpdateQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    stores: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前创建的 <code>effect</code> 对象的 <code>next</code> 属性指向了自身，且同时更新 <code>updateQueue.lastEffect</code> 属性为当前 <code>effect</code> 对象，由此形成一个单向环状链表。</p>
<p>所以此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png" alt="alt text"></p>
<p><code>pushEffect</code> 方法最后，返回当前创建的 <code>effect</code> 对象。</p>
<p>再回到 <code>mountEffectImpl</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect()</span><br></pre></td></tr></table></figure>

<p>所以 <code>hook</code> 对象的 <code>memoizedState</code> 属性值为一个 <code>effect</code> 对象。</p>
<p>从这里我们可以发现，虽然每个hook对象都是相同的属性，但是不同的 <code>hook</code> 类型它存储的内容却完全不同。</p>
<ul>
<li><code>useState</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为数据 <code>state</code>。</li>
<li><code>useEffect</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为一个 <code>effect</code> 对象。</li>
</ul>
<h4 id="1-2-3-mountLayoutEffect"><a href="#1-2-3-mountLayoutEffect" class="headerlink" title="1.2.3 mountLayoutEffect"></a>1.2.3 mountLayoutEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberFlags: Flags = UpdateEffect;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">    fiberFlags |= LayoutStaticEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(fiberFlags, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现useEffect和useLayoutEffect共用了同一个加载方法 <code>mountEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<p><code>hook</code> 对象创建和处理，此时函数组件Fiber节点的memoizedState属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png" alt="alt text"></p>
<p><code>effect</code> 对象创建和处理，依然是 <code>pushEffect</code> 方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # 第二次加载其他的effect时:</span><br><span class="line">  <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="comment">// 上一个effect的next属性指向新建的effect</span></span><br><span class="line">    lastEffect.next = effect;</span><br><span class="line">    <span class="comment">// 新建的next属性指向第一个effect</span></span><br><span class="line">    effect.next = firstEffect;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前为第二个effect相关的 <code>hook</code> 处理，所以此时 <code>Fiber.updateQueue</code>【即componentUpdateQueue】是有值的，进入else分支处理。</p>
<p>更新<code>Fiber.updateQueue.lastEffect</code>属性指向为当前新建的 <code>effect2</code>，将 <code>effect2</code> 的 <code>next</code> 属性指向为之前的 <code>effect</code> 对象。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png" alt="alt text"></p>
<p>到此，函数组件加载阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="1-3-commit阶段"><a href="#1-3-commit阶段" class="headerlink" title="1.3 commit阶段"></a>1.3 commit阶段</h3><p>前面全部的加载逻辑都是在 <code>Fiber Reconciler</code> 协调流程中执行的，即函数组件大部分的加载逻辑都是在 <code>reconciler</code> 协调流程中完成的【更新阶段同理】，还有剩下的一部分逻辑在 <code>commit</code> 阶段之中处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发起调度处理useEffect回调</span></span><br><span class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">	<span class="comment">// 这个回调就是处理useEffect的</span></span><br><span class="line">	flushPassiveEffects();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1，BeforeMutation阶段</span></span><br><span class="line">  commitBeforeMutationEffects()</span><br><span class="line">  <span class="comment">// 2，Mutation阶段，渲染真实DOM加载到页面</span></span><br><span class="line">  commitMutationEffects()</span><br><span class="line">  <span class="comment">// 3，Layout阶段</span></span><br><span class="line">  commitLayoutEffects()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit</code> 阶段的内容都是同步执行，在进入具体的执行之前，都会先调用 <code>scheduleCallback</code> 方法发起一个新的调度，即创建一个新的任务 <code>task</code>，最后会生成一个新的宏任务来异步处理副作用【即执行useEffect的回调钩子】。</p>
<p>上面是 <code>useEffect</code> 的回调处理，我们再查看 <code>useLayoutEffect</code> 的回调处理。</p>
<h3 id="1-4-Layout阶段"><a href="#1-4-Layout阶段" class="headerlink" title="1.4 Layout阶段"></a>1.4 Layout阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 根据组件类型</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">          <span class="comment">// 函数组件的处理</span></span><br><span class="line">          <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">              <span class="comment">// 传入的是layout相关的flag标记</span></span><br><span class="line">              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-commitHookEffectListMount"><a href="#1-4-1-commitHookEffectListMount" class="headerlink" title="1.4.1 commitHookEffectListMount"></a>1.4.1 commitHookEffectListMount</h4><p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListMount</span>(<span class="params">flags: HookFlags, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  # 当前函数组件的updateQueue属性，存储的是副作用链表</span><br><span class="line">  <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">  <span class="comment">// 取出最后一个effect对象</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个effect对象</span></span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 开始循环处理</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">        <span class="comment">// Mount</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.create;</span><br><span class="line">        # 执行回调函数</span><br><span class="line">        effect.destroy = create();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从当前函数组件 <code>Fiber</code> 节点取出它的 <code>updateQueue</code> 属性内容，在前面我们已经知道了 <code>Fiber.updateQueue</code> 存储的是副作用相关的链表，定义一个 <code>lastEffect</code> 变量存储 <code>updateQueue.lastEffect</code> 的内容，即最后一个 <code>effect</code> 对象。</p>
<p>判断 <code>lastEffect</code> 是否为 <code>null</code> ，如果 <code>lastEffect</code> 为 <code>null</code>，代表当前函数组件没有使用过 <code>effect</code> 相关的 <code>hook</code>。</p>
<p>当前肯定是有值的，继续向下执行。从 <code>lastEffect.next</code> 中取出第一个 <code>effect</code> 对象，开始按顺序循环处理副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">	<span class="comment">// Mount</span></span><br><span class="line">	<span class="keyword">const</span> create = effect.create;</span><br><span class="line">	<span class="comment">// 执行回调函数</span></span><br><span class="line">	effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">  effect = effect.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>

<p>注意在执行之前有一个条件判断，只有存在 <code>effect</code> 相关的 <code>flags</code> 标记才会执行对应副作用回调。</p>
<p>而在之前 <code>hook</code> 加载是有进行设置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect(</span><br><span class="line">  HookHasEffect | hookFlags, <span class="comment">// HookHasEffect标记就是表示有需要执行副作用</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在函数组件加载阶段时，每个 <code>useEffect</code> 和 <code>useLayoutEffect</code> 都有打上 <code>HookHasEffect</code> 的标记，表示在加载阶段都会默认执行一次。</p>
<p>需要注意的是：之前 <code>commitHookEffectListMount</code> 传入的是与 <code>Layout</code> 相关的 <code>flags</code> 标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); <span class="comment">// Layout</span></span><br></pre></td></tr></table></figure>

<p>所以这里只有 <code>layout hook</code> 的回调才能执行，第一个 <code>effect</code> 对象对应的是 <code>useEffect</code>，不满足判断条件</p>
<p>从当前 <code>effect</code> 对象的 <code>next</code> 属性取出下一个 <code>effect</code> 对象，开始第二次循环。</p>
<p>第二个 <code>effect</code> 对象对应的是 <code>useLayoutEffect</code>，满足判断条件，执行它的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = effect.create;</span><br><span class="line"><span class="comment">// 执行回调函数</span></span><br><span class="line">effect.destroy = create();</span><br></pre></td></tr></table></figure>

<p>到此 hook 相关的回调处理完成，函数组件加载逻辑全部执行完成。</p>
<h2 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h2><h3 id="2-1-dispatchSetState"><a href="#2-1-dispatchSetState" class="headerlink" title="2.1 dispatchSetState"></a>2.1 dispatchSetState</h3><p>当操作更新触发 <code>setState</code> 时, 就是触发之前 <code>useState</code> 加载返回的 <code>dispatch</code> 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line"># 返回值</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A, <span class="regexp">//</span> state <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求更新优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// 1. 创建update更新对象</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// state 1</span></span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 调度之前的一个优化策略校验: eagerState</span><br><span class="line">    <span class="comment">// 快速计算出本次最新的state，与原来的进行对比，如果没有发生变化，则跳过后续的更新逻辑</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当前的state，即旧的state</span></span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="comment">// 快速计算最新的state</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            # 如果state没变，组件不做更新。此处和useReducer对比下，useReducer还是会让函数组件更新</span><br><span class="line">            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将更新对象入队</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      <span class="comment">// 3. 开启一个新的调度更新任务</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-eagerState"><a href="#2-1-1-eagerState" class="headerlink" title="2.1.1 eagerState"></a>2.1.1 eagerState</h4><p>首先看 <code>dispatchSetState</code> 方法的整个结构和类组件的更新方法 <code>enqueueSetState</code> 基本相同，还有 <code>react</code> 应用的初始加载 <code>updateContainer</code>，其实一个react应用的更新场景就只有这三种，而它们的更新逻辑就是以下几个步骤：</p>
<ol>
<li>获取更新优先级 <code>lane</code>。</li>
<li>创建 <code>update</code> 更新对象 。</li>
<li>将 <code>update</code> 更新对象添加到目标Fiber对象的更新队列中。</li>
<li>开启一个新的调度更新任务。</li>
</ol>
<p>它们的区别主要在于函数组件这里在调度之前有一个eagerState优化策略校验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的state，即旧的state</span></span><br><span class="line"><span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line"><span class="comment">// 快速计算最新的state</span></span><br><span class="line"><span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">update.eagerState = eagerState;</span><br><span class="line"><span class="comment">// 比较新旧state</span></span><br><span class="line"><span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个优化策略的作用是：调用 <code>queue.lastRenderedReducer</code> 方法，通过原来的 <code>state</code> 和当前传入的 <code>action</code> 参数，快速的计算出本次最新的 <code>state</code> 【即eagerState】，通过比较新旧 <code>state</code> 来判断数据是否变化，如果没有变化则可以跳过后续的更新逻辑，即不会开启新的调度更新任务。当前我们的 <code>state</code> 是有变化的，所以不满足优化策略，将继续向下执行更新。</p>
<h4 id="2-1-2-enqueueConcurrentHookUpdate"><a href="#2-1-2-enqueueConcurrentHookUpdate" class="headerlink" title="2.1.2 enqueueConcurrentHookUpdate"></a>2.1.2 enqueueConcurrentHookUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentHookUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: HookQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: HookUpdate&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// 通用的入队方法</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// 找到根节点并返回</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>dispatchSetState</code> 方法中，最后还是会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h4 id="2-1-3-flushSyncWorkOnAllRoots"><a href="#2-1-3-flushSyncWorkOnAllRoots" class="headerlink" title="2.1.3 flushSyncWorkOnAllRoots"></a>2.1.3 flushSyncWorkOnAllRoots</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>microtask</code> 结束时，<code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>直接快进到performSyncWorkOnRoot方法中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用renderRootSync方法，开始FiberTree的创建过程。</p>
<p><strong>在这之前，还有一个处理要注意：把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	prepareFreshStack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	finishQueueingConcurrentUpdates()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png" alt="alt text"></p>
<h4 id="2-1-4-updateFunctionComponent"><a href="#2-1-4-updateFunctionComponent" class="headerlink" title="2.1.4 updateFunctionComponent"></a>2.1.4 updateFunctionComponent</h4><p>下面进入 <code>beginWork</code> 工作的 <code>FunctionComponent</code> 处理分支，开始函数组件的更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  # 调用函数组件</span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  # 函数组件默认的bailout策略，满足条件比较苛刻</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见 <code>updateFunctionComponent</code> 方法主要有两个处理：</p>
<ol>
<li>调用renderWithHooks【函数组件加载也是调用了这个方法】。</li>
<li>判断是否满足Bailout优化策略，满足则进入优化逻辑，跳过本组件的更新。不满足，则执行正常的组件更新逻辑。</li>
</ol>
<h4 id="2-1-5-renderWithHooks"><a href="#2-1-5-renderWithHooks" class="headerlink" title="2.1.5 renderWithHooks"></a>2.1.5 renderWithHooks</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// 设置为当前渲染中的Fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置函数组件节点的数据</span></span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置更新的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current =current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  <span class="comment">// 调用这个函数，即调用组件，循环生成Element对象，</span></span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新阶段时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</span><br></pre></td></tr></table></figure>

<p><code>renderWithHooks</code> 方法的重点依然是组件的调用 <code>Component()</code>，这里的逻辑依然只是重新调用一遍我们定义的函数，最后返回最新的jsx内容【即reactElement对象】</p>
<h4 id="2-1-6-hooks的更新"><a href="#2-1-6-hooks的更新" class="headerlink" title="2.1.6 hooks的更新"></a>2.1.6 hooks的更新</h4><p>首先查看 <code>useState</code> 的更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123;</span><br><span class="line">	useState: updateState, <span class="comment">// 更新state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState:</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init?</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 更新hook工作</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-updateWorkInProgressHook"><a href="#2-1-7-updateWorkInProgressHook" class="headerlink" title="2.1.7 updateWorkInProgressHook"></a>2.1.7 updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即将处理的hook</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 第一此进入更新时，currentHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出当前正在更新的函数组件Fiber的旧节点</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.alternate;</span><br><span class="line">    <span class="comment">// 更新阶段，current都是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将旧节点的memoizedState 设置为下一个处理的Hook</span></span><br><span class="line">      <span class="comment">// 将组件加载时，初始化的hook链表取出，memoizedState指向的是hook1</span></span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个hook更新开始，会走这里</span></span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置下一个工作中的Hook为null</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 组件的第一个Hook更新时，workInProgressHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将当前函数组件Fiber节点的memoizedState 设置为下一个处理的hook【默认是null】</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一个Hook，则取next指向的下一个</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个不为null， 说明当前hook不是最后一个更新的hook，只有最后一个hook更新时，nextWorkInProgressHook才为null</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's already a work-in-progress. Reuse it.</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新currentHook 为第一个hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象，复用原来的内容</span></span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      baseQueue: currentHook.baseQueue,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>, <span class="comment">// 但是清空了next指向</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个hook更新时，workInProgressHook为null，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      <span class="comment">// 更新当前函数的组件的memoizedState为第一个hook对象，同时设置为当前正在工作中的hook</span></span><br><span class="line">      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      <span class="comment">// 非第一个Hook,直接添加到上一个hook对象的next属性中</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回当前正在工作中的hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像函数组件的hook在加载时都会调用一个 <code>mountWorkInProgressHook</code> 方法，生成一个hook链表。</p>
<p>而函数组件的hook在更新时也会调用一个 <code>updateWorkInProgressHook</code> 方法，生成对应的hook链表。</p>
<p>所以 <code>updateWorkInProgressHook</code> 方法的作用是：确定当前函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容，也就是生成它的 <code>hook</code> 链表。</p>
<p>它的做法就是从 <code>current</code> 节点上取出函数组件加载时生成的 <code>hook</code> 链表，按顺序取出原来的 <code>hook</code> 对象，根据原来的对象信息创建生成新的 <code>newHook</code> 对象，最后按顺序一个一个添加到新的 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性上。</p>
<p><strong>注意：</strong>这里是一个重点，如果没有清空 <code>next</code> 属性，那更新当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性，直接拿到第一个 <code>hook</code> 对象，就可以拿到整个 <code>hook</code> 链表，然后后续的 <code>hook</code> 更新就不需要再调用 <code>updateWorkInProgressHook</code> 方法了。</p>
<p>但是函数组件为啥不能如此处理呢？</p>
<p>因为react不能保证开发者是一定按照规范来使用的 <code>hook</code> ，如果开发者将 <code>hook</code> 置于条件语句中，在更新阶段出现了原来 <code>hook</code> 链表中不存在的 <code>hook</code> 对象，则在渲染时就会发生异常，所以react在函数组件更新时需要主动中断 <code>hook</code> 对象的next属性指向，按原来的链表顺序重新一个一个添加，如果出现了不匹配的 <code>hook</code> 对象，就会主动抛出异常，提示用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-计算state"><a href="#2-1-8-计算state" class="headerlink" title="2.1.8 计算state"></a>2.1.8 计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line"><span class="function">  <span class="title">initialArg</span>: <span class="title">I</span>,</span></span><br><span class="line"><span class="function">  <span class="title">init</span>?: <span class="title">I</span> =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 返回新的hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer; <span class="comment">// 还是basicStateReducer，无变化</span></span><br><span class="line">  <span class="keyword">const</span> current = currentHook; <span class="comment">// 旧的hook对象，加载时useState创建的hook对象</span></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.baseQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="comment">// 等待处理的更新链表：默认指向的是最后一个update对象</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// pendingQueue不为null，代表有需要处理的更新对象，然后需要将它们添加到baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Merge the pending queue and the base queue.</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们有一个队列要处理</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = current.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line"></span><br><span class="line">    # 循环处理update更新对象</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">        <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line">            action: update.action,</span><br><span class="line">            hasEagerState: update.hasEagerState,</span><br><span class="line">            eagerState: update.eagerState,</span><br><span class="line">            next: (<span class="literal">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	# 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>updateWorkInProgressHook</code> 方法调用完成之后，返回值就是 <code>useState</code> 对应的hook对象：</p>
<p>取出hook对象的queue队列，如果queue为null，则会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的逻辑看似比较多，但其实比较简单，而且和this.setState计算state的逻辑基本一致。</p>
<p><strong>它的核心逻辑：</strong>按顺序正向循环 <code>update</code> 更新队列，定义一个变量 <code>newState</code> 来存储最新的 <code>state</code>，然后根据原来 <code>state</code> 和 <code>update</code> 对象里面的信息计算最新的数据更新变量 <code>newState</code>，每循环一次就会从 <code>update</code> 对象的 <code>next</code> 属性取出下一个参与计算的 <code>update</code>，直接到所有的 <code>update</code> 处理完成。</p>
<p>当前 <code>pendingQueue</code> 结构【单向环状链表】：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png" alt="alt text"></p>
<p>在类组件中，会根据pendingQueue的内容重构生成一个新的单向链表，不再是环状，有明确的结束。</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png" alt="alt text"></p>
<p>和类组件不同的是，函数组件这里并没有额外处理pendingQueue，而是直接复制给baseQueue，从baseQueue.next取出第一个update对象【即first】开始计算state。</p>
<p>所以函数组件这里的do while循环多了一个结束的判断条件，就是不能等于first，不然就会陷入无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first)</span><br></pre></td></tr></table></figure>

<p>然后就是函数组件计算state的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while循环中，计算state的核心逻辑</span></span><br><span class="line"><span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">  newState = ((update.eagerState: any): S);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action = update.action;</span><br><span class="line">  newState = reducer(newState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果eagerState存在，则直接使用eagerState的值为新的state。</p>
<p>如果不存在，则调用reducer【basicStateReducer】，根据最新的newState和当前update对象的action重新计算state。</p>
<p>循环结束，在更新state之前，还有一个校验需要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line"><span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">  markWorkInProgressReceivedUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对一个状态的批量处理之后，有一个状态变化的校验，针对的是函数组件内部的 <code>Bailout</code> 策略。</p>
<p>即如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量 <code>ReceivedUpdate</code> 为 <code>false</code>，表示改组件没有更新的内容，这样就可以在 <code>renderWithHooks</code> 方法执行完成后，进入 <code>Bailout</code> 策略。</p>
<p>然后更新 <code>hook</code> 对象的 <code>memoizedState</code> 属性为最新的 <code>newState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储最新的state</span></span><br><span class="line">hook.memoizedState = newState;</span><br></pre></td></tr></table></figure>

<p>到此，<code>useState hook</code> 的更新程序执行完成，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆state</span></span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p>同时这里我们也可以明白：函数组件 <code>useState hook</code> 能够缓存变量结果的原因，因为它的 <code>state</code> 存储在 <code>hook</code> 对象的属性之中，并且这个属性可以在函数组件重新渲染过程中得到更新。</p>
<h3 id="2-2-updateEffect"><a href="#2-2-updateEffect" class="headerlink" title="2.2 updateEffect"></a>2.2 updateEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 取出新的依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 重置销毁方法</span></span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的pushEffect方法</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    <span class="comment">// 继承原来的destroy方法</span></span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面校验为true的情况下，这里就不会再执行</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先依然是调用一个 <code>updateWorkInProgressHook</code> 方法，前面已经详细讲解了它的作用。所以这里调用此方法后，就会新建一个 <code>newHook</code> 对象，添加到第一个 <code>hook</code> 对象的 <code>next</code> 属性之上，形成一个链表，后续如果还有新的 <code>newHook</code> 对象则继续执行同样的逻辑。</p>
<p>此时函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png" alt="alt text"></p>
<h3 id="2-2-1-areHookInputsEqual"><a href="#2-2-1-areHookInputsEqual" class="headerlink" title="2.2.1 areHookInputsEqual"></a>2.2.1 areHookInputsEqual</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况1，无依赖参数，每次渲染都会执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况2，有至少一项依赖参数，循环判断每个依赖是否相等，任何一个依赖变化则会重新执行副作用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 情况3，即空数组的情况，重新渲染不执行副作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前我们依赖为一个空数组，所以满足第三种情况，直接返回 <code>true</code>。</p>
<ul>
<li><p>在依赖校验为 <code>true</code> 的情况下，即表示没有变化，此时更新 <code>hook.memoizedState</code> 属性，最后触发 <code>return</code> 关键字，<code>updateEffect</code> 方法执行完成。</p>
</li>
<li><p>在依赖变化时，也会重新设置 <code>hook.memoizedState</code> 属性，依赖校验为true的情况下就是第一个参数不同，会打上 <code>HookHasEffect</code> 的标记。</p>
<ul>
<li>这个值会存储到 <code>effect</code> 对象的tag属性上，表示此effect对象有需要执行的副作用回调。</li>
<li><code>hookFlags</code> 表示副作用的类型标记，比如 <code>HookPassive</code>，<code>HookLayout</code>。</li>
<li>所以依赖发生变化的唯一区别就是：打上了 <code>HookHasEffect</code> 标记。最终会 <code>commit</code> 阶段中执行回调时，判断 <code>effect.tag</code> 的值来判断是否执行回调。</li>
</ul>
</li>
</ul>
<p>到此，函数组件的第二个hook：useEffect更新完成。</p>
<h3 id="2-3-updateLayoutEffect"><a href="#2-3-updateLayoutEffect" class="headerlink" title="2.3 updateLayoutEffect"></a>2.3 updateLayoutEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>useEffect</code> 和 <code>useLayoutEffect</code> 共用了同一个更新方法 <code>updateEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<ul>
<li>调用 <code>updateWorkInProgressHook</code> 方法：创建新 <code>hook</code> 对象，此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向更新为：</li>
</ul>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png" alt="alt text"></p>
<ul>
<li>判断 <code>deps</code> 依赖是否变化，如果变化则为对应的 <code>effect</code> 对象打上 <code>HookHasEffect</code> 的标记。</li>
</ul>
<p>到此，函数组件更新阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>函数组件更新阶段主要有这两个重点逻辑：</p>
<ul>
<li>根据 <code>updateQueue</code> 更新队列，循环计算 <code>state</code>，最后将最新的 <code>state</code> 数据存储到 <code>Fiber.memoizedState</code> 属性上并返回。</li>
<li>更新 <code>Effect</code>类 <code>hook</code> 时，判断依赖是否变化打上 <code>HookHasEffect</code>，最后会根据 <code>effect.tag</code> 值来决定本次更新是否执行回调。</li>
</ul>
<p><code>useEffect</code> 和 <code>useLayoutEffect</code>的区别：<code>useLayoutEffect</code> 是 <code>useEffect</code> 的一个变种，它们都是在 <code>React</code> 组件中处理副作用的方法。两者之间的主要区别在于它们的执行时机。</p>
<ul>
<li><code>useEffect</code> 的回调函数会在每次渲染结束后异步执行，这意味着它不会阻塞浏览器的渲染过程。换句话说，<code>React</code> 会在处理 <code>useEffect</code> 内部的状态更新之前，让浏览器先绘制屏幕。</li>
<li>而 <code>useLayoutEffect</code> 的回调函数会在每次渲染结束后同步执行。这意味着它会阻塞浏览器的渲染过程，直到其执行完毕。因此，<code>useLayoutEffect</code> 可以在浏览器重新绘制屏幕之前触发。</li>
</ul>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 会阻塞浏览器的渲染过程，如果过度使用，可能会导致应用程序变慢，甚至引发性能问题。因此，在大多数情况下，应优先考虑使用 <code>useEffect</code>。只有在某些特定情况下，例如需要在 <code>DOM</code> 更新后立即进行某些操作，或者需要在用户看到渲染结果之前进行某些操作，才考虑使用 <code>useLayoutEffect</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2类组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-09T00:00:00+08:00">2024-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1. 加载阶段"></a>1. 加载阶段</h2><h3 id="1-1-updateClassComponent"><a href="#1-1-updateClassComponent" class="headerlink" title="1.1 updateClassComponent"></a>1.1 updateClassComponent</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasContext;</span><br><span class="line">  <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = <span class="literal">true</span>;</span><br><span class="line">    pushLegacyContextProvider(workInProgress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hasContext = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line">  <span class="comment">// 类组件节点的stateNode 不是存储dom元素，而是组件实例 【hostComponent的stateNode才是dom元素】</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  # 第一次class组件加载，instance都为null</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化构建组件实例</span></span><br><span class="line">    constructClassInstance(workInProgress, Component, nextProps);</span><br><span class="line">    <span class="comment">// 加载组件实例</span></span><br><span class="line">    mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// In a resume, we'll already have an instance we can reuse.</span></span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update阶段：判断是否更新class组件</span></span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 最后：创建class组件child</span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  # 返回child子节点</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassComponent</code> 方法的内容并不复杂，主要就是两个逻辑的执行：</p>
<ol>
<li>class组件实例的创建或者更新。</li>
<li>创建组件的child子节点，最后返回子节点。</li>
</ol>
<h3 id="1-2-构建class组件实例-constructClassInstance"><a href="#1-2-构建class组件实例-constructClassInstance" class="headerlink" title="1.2 构建class组件实例 - constructClassInstance"></a>1.2 构建class组件实例 - constructClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  # 创建class实例对象，参数为props和context</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将instance实例对象的state数据同步到Fiber节点的memoizedState属性</span></span><br><span class="line">  <span class="keyword">const</span> state = (workInProgress.memoizedState =</span><br><span class="line">    instance.state !== <span class="literal">null</span> &amp;&amp; instance.state !== <span class="literal">undefined</span></span><br><span class="line">      ? instance.state</span><br><span class="line">      : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  # 确定class组件实例：即链接FiberNode与对应的组件实例</span><br><span class="line">  adoptClassInstance(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dev开发环境下的警告：如果class组件使用了过时的生命周期钩子，发出对应的警告</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  # 返回创建完成的实例</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-adoptClassInstance"><a href="#1-2-1-adoptClassInstance" class="headerlink" title="1.2.1 adoptClassInstance"></a>1.2.1 adoptClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adoptClassInstance</span>(<span class="params">workInProgress: Fiber, instance: any</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  instance.updater = classComponentUpdater;</span><br><span class="line">  <span class="comment">// Fiber节点存储instance实例</span></span><br><span class="line">  workInProgress.stateNode = instance;</span><br><span class="line">  <span class="comment">// instance对象定义一个_reactInternal内部属性存储Fiber节点</span></span><br><span class="line">  setInstance(instance, workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-加载组件-mountClassInstance"><a href="#1-3-加载组件-mountClassInstance" class="headerlink" title="1.3 加载组件 - mountClassInstance"></a>1.3 加载组件 - mountClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出class组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="comment">// props</span></span><br><span class="line">  instance.props = newProps;</span><br><span class="line">  <span class="comment">// 同步state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line">  <span class="comment">// ref：默认为空对象</span></span><br><span class="line">  instance.refs = emptyRefsObject;</span><br><span class="line">  <span class="comment">// 初始化一个Fiber节点的更新队列</span></span><br><span class="line">  # 设置更新队列对象：fiber.updateQueue = queue;</span><br><span class="line">  initializeUpdateQueue(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步组件实例的state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">    applyDerivedStateFromProps(</span><br><span class="line">      workInProgress,</span><br><span class="line">      ctor,</span><br><span class="line">      getDerivedStateFromProps,</span><br><span class="line">      newProps,</span><br><span class="line">    );</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to support react-lifecycles-compat polyfilled components,</span></span><br><span class="line">  <span class="comment">// Unsafe lifecycles should not be invoked for components using the new APIs.</span></span><br><span class="line">  <span class="comment">// 不应该使用旧的生命周期钩子</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> ctor.getDerivedStateFromProps !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="string">'function'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> instance.componentWillMount === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    # 触发WillMount生命周期钩子</span><br><span class="line">    callComponentWillMount(workInProgress, instance);</span><br><span class="line">    <span class="comment">// If we had additional state updates during this life-cycle, let's</span></span><br><span class="line">    <span class="comment">// process them now.</span></span><br><span class="line">    processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 如果设置了class组件的componentDidMount生命周期钩子函数，则需要在组件的FiberNode上设置对应的flags</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidMount === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fiberFlags: Flags = Update;</span><br><span class="line">    <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">      fiberFlags |= LayoutStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workInProgress.flags |= fiberFlags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先更新了 <code>instance</code> 组件实例上的一些属性，然后初始化了当前组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个更新队列对象</span></span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState, <span class="comment">// 初始state数据</span></span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>, <span class="comment">// 存储update链表</span></span><br><span class="line">      lanes: NoLanes,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置updateQueue属性</span></span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是针对 <code>componentWillMount</code> 生命周期钩子函数的处理，虽然是过时的API，但是如果定义了还是需要在这里触发。</p>
<p>最后如果定义了 <code>componentDidMount</code> 钩子函数，则需要给该 <code>Fiber</code> 节点的 <code>flags</code> 属性设置对应的副作用标记。</p>
<p><code>flags</code> 标记的作用是在 <code>commit</code> 阶段执行对应的副作用操作，所以 <code>componentDidMount</code> 钩子函数会在 <code>commit</code> 阶段中进行触发调用。</p>
<p>到此，类组件的加载就完成了。</p>
<h2 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># setState原理</span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用updater中的一个方法</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-enqueueSetState"><a href="#2-1-enqueueSetState" class="headerlink" title="2.1 enqueueSetState"></a>2.1 enqueueSetState</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  enqueueSetState(inst: any, <span class="attr">payload</span>: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ! 1. 获取current和lane</span></span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 创建update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(lane);</span><br><span class="line">    update.payload = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 3. update入队fiber.updateQueue中, 并返回应用的root根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueUpdate(fiber, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 4. 调度更新(开启一个从root根节点开始的更新调度)</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      <span class="comment">// ! 5. 处理transitions，非紧急更新</span></span><br><span class="line">      entangleTransitions(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">      markStateUpdateScheduled(fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueReplaceState(inst: any, <span class="attr">payload</span>: any, <span class="attr">callback</span>: <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueForceUpdate(inst: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-enqueueUpdate"><a href="#2-1-1-enqueueUpdate" class="headerlink" title="2.1.1 enqueueUpdate"></a>2.1.1 enqueueUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateQueue = fiber.updateQueue;</span><br><span class="line">  <span class="keyword">const</span> sharedQueue: SharedQueue&lt;State&gt; = (updateQueue: any).shared;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-enqueueConcurrentClassUpdate"><a href="#2-1-2-enqueueConcurrentClassUpdate" class="headerlink" title="2.1.2 enqueueConcurrentClassUpdate"></a>2.1.2 enqueueConcurrentClassUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentClassUpdate</span>(<span class="params">fiber, sharedQueue, update, lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> interleaved = sharedQueue.interleaved;</span><br><span class="line">  <span class="comment">// 第一个update对象入队</span></span><br><span class="line">  <span class="keyword">if</span> (interleaved === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.next = update;</span><br><span class="line">    pushConcurrentUpdateQueue(sharedQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他的update对象入队</span></span><br><span class="line">    update.next = interleaved.next;</span><br><span class="line">    interleaved.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  sharedQueue.interleaved = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>enqueueSetState</code> 方法中，这个方法最后会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h3 id="2-2-performSyncWorkOnRoot"><a href="#2-2-performSyncWorkOnRoot" class="headerlink" title="2.2 performSyncWorkOnRoot"></a>2.2 performSyncWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// If passive effects were flushed, exit to the outer work loop in the root</span></span><br><span class="line">    <span class="comment">// scheduler, so we can recompute the priority.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We don't actually need this `ensureRootIsScheduled` call because</span></span><br><span class="line">    <span class="comment">// this path is only reachable if the root is already part of the schedule.</span></span><br><span class="line">    <span class="comment">// I'm including it only for consistency with the other exit points from</span></span><br><span class="line">    <span class="comment">// this function. Can address in a subsequent refactor.</span></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; enableProfilerNestedUpdatePhase) &#123;</span><br><span class="line">    syncNestedUpdateFlag();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * setState</span></span><br><span class="line">  <span class="comment">// !1. render阶段</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">  <span class="keyword">if</span> (root.tag !== LegacyRoot &amp;&amp; exitStatus === RootErrored) &#123;</span><br><span class="line">    <span class="comment">// If something threw an error, try rendering one more time. We'll render</span></span><br><span class="line">    <span class="comment">// synchronously to block concurrent data mutations, and we'll includes</span></span><br><span class="line">    <span class="comment">// all pending updates are included. If it still fails after the second</span></span><br><span class="line">    <span class="comment">// attempt, we'll give up and commit the resulting tree.</span></span><br><span class="line">    <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">    <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">      root,</span><br><span class="line">      originallyAttemptedLanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">      lanes = errorRetryLanes;</span><br><span class="line">      exitStatus = recoverFromConcurrentError(</span><br><span class="line">        root,</span><br><span class="line">        originallyAttemptedLanes,</span><br><span class="line">        errorRetryLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">    <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">    prepareFreshStack(root, NoLanes);</span><br><span class="line">    markRootSuspended(root, lanes, NoLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">throw</span> fatalError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">    <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">    <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">    <span class="comment">// consistent tree or committing.</span></span><br><span class="line">    markRootSuspended(root, lanes, workInProgressDeferredLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We now have a consistent tree. Because this is a sync render, we</span></span><br><span class="line">  <span class="comment">// will commit it even if something suspended.</span></span><br><span class="line">  <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">  root.finishedWork = finishedWork;</span><br><span class="line">  root.finishedLanes = lanes;</span><br><span class="line">  <span class="comment">// ! 2. commit阶段</span></span><br><span class="line">  commitRoot(</span><br><span class="line">    root,</span><br><span class="line">    workInProgressRootRecoverableErrors,</span><br><span class="line">    workInProgressTransitions,</span><br><span class="line">    workInProgressRootDidIncludeRecursiveRenderUpdate,</span><br><span class="line">    workInProgressDeferredLane,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before exiting, make sure there's a callback scheduled for the next</span></span><br><span class="line">  <span class="comment">// pending level.</span></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-updateClassInstance"><a href="#2-3-updateClassInstance" class="headerlink" title="2.3 updateClassInstance"></a>2.3 updateClassInstance</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassInstance</code> 方法里面的内容比较多，我们分成以下几个部分来分析</p>
<h4 id="2-3-1-根据updateQueue计算state"><a href="#2-3-1-根据updateQueue计算state" class="headerlink" title="2.3.1 根据updateQueue计算state"></a>2.3.1 根据updateQueue计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出组件实例</span></span><br><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"># 从旧节点上克隆updateQueue信息，包含了shared.pending中等待处理的更新操作</span><br><span class="line">cloneUpdateQueue(current, workInProgress);</span><br><span class="line"><span class="comment">// 旧的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedOldProps = workInProgress.memoizedProps;</span><br><span class="line"><span class="keyword">const</span> oldProps =</span><br><span class="line">  workInProgress.type === workInProgress.elementType</span><br><span class="line">    ? unresolvedOldProps</span><br><span class="line">    : resolveDefaultProps(workInProgress.type, unresolvedOldProps);</span><br><span class="line">instance.props = oldProps;</span><br><span class="line"><span class="comment">// 新的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedNewProps = workInProgress.pendingProps;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line"><span class="keyword">const</span> hasNewLifecycles =</span><br><span class="line">  <span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span> ||</span><br><span class="line">  <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出旧的数据</span></span><br><span class="line"><span class="keyword">const</span> oldState = workInProgress.memoizedState;</span><br><span class="line"><span class="keyword">let</span> newState = (instance.state = oldState);</span><br><span class="line"># 更新组件实例的数据</span><br><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">newState = workInProgress.memoizedState;</span><br></pre></td></tr></table></figure>
<p>首先处理之前的 <code>updateQueue</code> 信息：</p>
<p>这里就是将 <code>current</code> 节点中的 <code>updateQueue</code> 信息克隆到 <code>workInProgress</code> 节点中对应的属性中。<br><strong>注意：</strong>react应用每次更新都会执行Fiber Reconciler流程【即FiberTree的创建流程】，在进入此流程之前，current节点会存储本次更新相关的一些信息，但是在进入此流程之后，current就变成了旧的节点，workInProgress代表新建的节点，此时就需要将current节点上的一些信息保存到新的节点之中，也就是对应的workInProgress。</p>
<p>从class类中取出 <code>getDerivedStateFromProps</code> 钩子，判断当前类组件有没有使用此钩子，如果没有使用则设置变量 <code>hasNewLifecycles</code> 为 <code>false</code>，此变量的作用是后续判断其他生命周期钩子的执行与否。</p>
<p>下面开始对state的处理：</p>
<ol>
<li>首先取出旧的state数据：</li>
<li>重点：调用processUpdateQueue方法，根据updateQueue信息，计算生成新的state数据。</li>
</ol>
<h5 id="2-3-1-1-processUpdateQueue"><a href="#2-3-1-1-processUpdateQueue" class="headerlink" title="2.3.1.1 processUpdateQueue"></a>2.3.1.1 processUpdateQueue</h5><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = workInProgress.updateQueue;</span><br><span class="line">  <span class="keyword">let</span> firstBaseUpdate = queue.firstBaseUpdate; <span class="comment">// 第一个处理的update，一个完整指向的队列</span></span><br><span class="line">  <span class="keyword">let</span> lastBaseUpdate = queue.lastBaseUpdate; <span class="comment">// 最后一个处理的update</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if there are pending updates. If so, transfer them to the base queue.</span></span><br><span class="line">  <span class="comment">// pending：等待处理的更新操作</span></span><br><span class="line">  <span class="comment">// 如果pending存在内容，则重置它，将它的内容转移到基础队列 firstBaseUpdate</span></span><br><span class="line">  <span class="keyword">let</span> pendingQueue = queue.shared.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 重置pending：因为workInProgress和current同用一个shared对象，所以current的pengding也重置了</span></span><br><span class="line">    queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    # 重构pendingQueue，将单向环状链表变成普通的单向链表</span><br><span class="line">    <span class="comment">// 最后处理的update对象</span></span><br><span class="line">    <span class="keyword">const</span> lastPendingUpdate = pendingQueue;</span><br><span class="line">    <span class="comment">// 第一个处理的update对象</span></span><br><span class="line">    <span class="keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;</span><br><span class="line">    <span class="comment">// 断开链接：最后一个update不再指向第一个update，形成一个单向链表，不再首尾相连</span></span><br><span class="line">    lastPendingUpdate.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Append pending updates to base queue</span></span><br><span class="line">    <span class="comment">// 将等待处理的更新对象添加到firstBaseUpdate基础更新队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstBaseUpdate = firstPendingUpdate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastBaseUpdate.next = firstPendingUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These values may change as we process the queue.</span></span><br><span class="line">  <span class="comment">// 当我们处理队列时，这些值可能会发生变化。</span></span><br><span class="line">  <span class="keyword">if</span> (firstBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Iterate through the list of updates to compute the result.</span></span><br><span class="line">    <span class="keyword">let</span> newState = queue.baseState;</span><br><span class="line">    <span class="keyword">let</span> newLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newFirstBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newLastBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">    # 第一个更新的update</span><br><span class="line">    <span class="keyword">let</span> update = firstBaseUpdate;</span><br><span class="line"></span><br><span class="line">    # 循环update链表计算state</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Don't need this field anymore</span></span><br><span class="line">      <span class="keyword">const</span> updateEventTime = update.eventTime;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据每个update对象的lane来判断是否更新：</span></span><br><span class="line">      <span class="comment">// 检查此更新update是否是在隐藏树时进行的。如果是，组件在隐藏时不需要更新</span></span><br><span class="line">      <span class="comment">// 跳过更新</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// 不必更新【跳过更新】</span></span><br><span class="line">		...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line">        <span class="comment">// 此更新具有足够的优先级【正常更新】</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newLastBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;State&gt; = &#123;</span><br><span class="line">            eventTime: updateEventTime,</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line"></span><br><span class="line">            tag: update.tag,</span><br><span class="line">            payload: update.payload,</span><br><span class="line">            callback: update.callback,</span><br><span class="line"></span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        # 处理当前update对象</span><br><span class="line">        newState = getStateFromUpdate(</span><br><span class="line">          workInProgress,</span><br><span class="line">          queue,</span><br><span class="line">          update,</span><br><span class="line">          newState,</span><br><span class="line">          props,</span><br><span class="line">          instance,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">const</span> callback = update.callback;</span><br><span class="line">        <span class="comment">// If the update was already committed, we should not queue its</span></span><br><span class="line">        <span class="comment">// callback again.</span></span><br><span class="line">        # 如果存在回调函数，则添加到队列的effects数组中，表示有副作用等待执行</span><br><span class="line">        <span class="keyword">if</span> (callback !== <span class="literal">null</span> &amp;&amp; update.lane !== NoLane) &#123;</span><br><span class="line">          workInProgress.flags |= Callback;</span><br><span class="line">          <span class="keyword">const</span> effects = queue.effects;</span><br><span class="line">          <span class="keyword">if</span> (effects === <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.effects = [update];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effects.push(update);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新update为下一个等待处理的对象</span></span><br><span class="line">      update = update.next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update有值，开启下一次循环</span></span><br><span class="line">      <span class="keyword">if</span> (update === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为null，代表链表执行完成，退出循环，表示本次更新state计算完成</span></span><br><span class="line">        pendingQueue = queue.shared.pending;</span><br><span class="line">        <span class="keyword">if</span> (pendingQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// An update was scheduled from inside a reducer. Add the new</span></span><br><span class="line">          <span class="comment">// pending updates to the end of the list and keep processing.</span></span><br><span class="line">          <span class="keyword">const</span> lastPendingUpdate = pendingQueue;</span><br><span class="line">          <span class="comment">// Intentionally unsound. Pending updates form a circular list, but we</span></span><br><span class="line">          <span class="comment">// unravel them when transferring them to the base queue.</span></span><br><span class="line">          <span class="keyword">const</span> firstPendingUpdate = ((lastPendingUpdate.next: any): Update&lt;State&gt;);</span><br><span class="line">          lastPendingUpdate.next = <span class="literal">null</span>;</span><br><span class="line">          update = firstPendingUpdate;</span><br><span class="line">          queue.lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">          queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.baseState = ((newBaseState: any): State);</span><br><span class="line">    queue.firstBaseUpdate = newFirstBaseUpdate;</span><br><span class="line">    queue.lastBaseUpdate = newLastBaseUpdate;</span><br><span class="line"></span><br><span class="line">    markSkippedUpdateLanes(newLanes);</span><br><span class="line">    workInProgress.lanes = newLanes;</span><br><span class="line">    <span class="comment">// 更新state数据</span></span><br><span class="line">    workInProgress.memoizedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-调用getDerivedStateFromProps钩子"><a href="#2-3-2-调用getDerivedStateFromProps钩子" class="headerlink" title="2.3.2 调用getDerivedStateFromProps钩子"></a>2.3.2 调用getDerivedStateFromProps钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  applyDerivedStateFromProps(</span><br><span class="line">    workInProgress,</span><br><span class="line">    ctor,</span><br><span class="line">    getDerivedStateFromProps,</span><br><span class="line">    newProps,</span><br><span class="line">  );</span><br><span class="line">  newState = workInProgress.memoizedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>getDerivedStateFromProps</code> 钩子函数，则在此触发此回调。</p>
<h4 id="2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新"><a href="#2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新" class="headerlink" title="2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新"></a>2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldUpdate =</span><br><span class="line">    <span class="comment">// 检查是否为强制更新</span></span><br><span class="line">    checkHasForceUpdateAfterProcessing() ||</span><br><span class="line">    <span class="comment">// 调用shouldComponentUpdate钩子，检查是否应该更新</span></span><br><span class="line">    checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)</span><br></pre></td></tr></table></figure>


<h5 id="2-3-3-1-checkHasForceUpdateAfterProcessing"><a href="#2-3-3-1-checkHasForceUpdateAfterProcessing" class="headerlink" title="2.3.3.1 checkHasForceUpdateAfterProcessing"></a>2.3.3.1 checkHasForceUpdateAfterProcessing</h5><p><code>checkHasForceUpdateAfterProcessing</code> 方法返回一个变量的状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">checkHasForceUpdateAfterProcessing</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasForceUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasForceUpdate</code> 是一个全局变量，它默认为 <code>false</code> ，表示非强制更新，它的修改就在之前计算state的逻辑中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newState = getStateFromUpdate(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line">		<span class="keyword">case</span> ReplaceState: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> CaptureUpdate: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> UpdateState: &#123;&#125;</span><br><span class="line">		<span class="comment">// 强制更新 场景</span></span><br><span class="line">		<span class="keyword">case</span> ForceUpdate: &#123;</span><br><span class="line">      		hasForceUpdate = <span class="literal">true</span>;</span><br><span class="line">      		<span class="keyword">return</span> prevState;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为 <code>this.forceUpdate</code> 触发的场景，就会进入 <code>ForceUpdate</code> 分支，更新变量 <code>hasForceUpdate</code> 的值为 <code>true</code>。</p>
<p>这时在校验组件是否应该更新时，就会返回 <code>true</code>，代表组件需要更新。</p>
<p>而我们当前是通过 <code>this.setState</code> 修改数据触发的更新，所以当前 <code>hasForceUpdate</code> 是为 <code>false</code> 的，这也是绝大部分类组件更新的场景。</p>
<h5 id="2-3-3-2-checkShouldComponentUpdate"><a href="#2-3-3-2-checkShouldComponentUpdate" class="headerlink" title="2.3.3.2 checkShouldComponentUpdate"></a>2.3.3.2 checkShouldComponentUpdate</h5><p>查看 <code>checkShouldComponentUpdate</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkShouldComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldState,</span></span></span><br><span class="line"><span class="function"><span class="params">  newState,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.shouldComponentUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      nextContext,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对PureComponent纯组件的 内部校验</span></span><br><span class="line">  <span class="keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkShouldComponentUpdate</code> 方法也比较简单，主要就是调用一次我们定义的 <code>shouldComponentUpdate</code> 钩子，根据调用的返回值来决定类组件是否应该更新，如果我们没有使用 <code>shouldComponentUpdate</code> 钩子，则类组件是默认需要更新的。</p>
<p>同时在这里我们还可以发现有一个针对 <code>PureComponent</code> 纯组件的更新校验，这其实就是 <code>PureComponent</code> 和 <code>Component</code> 唯一的区别，纯组件 <code>PureComponent</code>在react内部自动帮助我们对 <code>props</code> 和 <code>state</code> 进行了浅比较，任何一个变化则返回 <code>true</code>，需要更新组件。</p>
<h4 id="2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"><a href="#2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记" class="headerlink" title="2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"></a>2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 执行componentWillUpdate钩子</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	instance.componentWillUpdate(newProps, newState, nextContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新flags标记</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Update;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Snapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>componentWillUpdate</code> 生命周期钩子函数，则会在此处调用此函数。</p>
<p>然后如果类组件定义了 <code>componentDidUpdate</code> 或者 <code>getSnapshotBeforeUpdate</code> 生命周期钩子函数，就会更新组件 <code>Fiber</code> 的 <code>flags</code> 副作用标记。</p>
<p>这些生命周期钩子会在commit阶段，真实DOM渲染完成之后，被触发执行。</p>
<p>最后同步更新组件实例instance的props和state：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance.props = newProps;</span><br><span class="line">instance.state = newState;</span><br></pre></td></tr></table></figure>

<p>到此，一个类组件的更新程序基本执行完成。</p>
<h3 id="2-4-commit阶段"><a href="#2-4-commit阶段" class="headerlink" title="2.4 commit阶段"></a>2.4 commit阶段</h3><p>前面全部的加载逻辑都是在Fiber Reconciler协调流程中执行的，即类组件大部分的加载或者更新逻辑都是在reconciler协调流程中完成的，还有剩下的一部分逻辑在commit阶段之中处理。</p>
<p>对于类组件的更新来说，在commit阶段主要还有以下两部分逻辑需要处理：</p>
<ol>
<li>执行类组件的 <code>componentDidUpdate</code> 生命周期钩子函数。</li>
<li>执行 <code>this.setState</code> 方法传入的回调函数。</li>
</ol>
<p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">    <span class="comment">// 根据组件类型：进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 类组件的处理</span></span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="comment">// 组件实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">			  <span class="comment">// mount加载阶段</span></span><br><span class="line"></span><br><span class="line">              # 触发componentDidMount 生命周期钩子函数【这类静态方法：是存储在instance对象原型上的】</span><br><span class="line">              instance.componentDidMount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// update更新阶段</span></span><br><span class="line">              <span class="keyword">const</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps</span><br><span class="line">                  : resolveDefaultProps( finishedWork.type, current.memoizedProps);</span><br><span class="line">              <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">			  # 触发componentDidUpdate 生命周期钩子函数</span><br><span class="line">              instance.componentDidUpdate( prevProps,prevState,</span><br><span class="line">                  instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 取出当前组件节点的updateQueue更新对象</span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishedWork代表当前处理的类组件Fiber节点，首先从fiber.stateNode属性中取出组件实例instance。然后根据进行判断，只有存在相关的副作用标记才会继续内部的逻辑：</p>
<p>然后判断current是否为null，current表示旧的虚拟DOM节点，在组件的更新阶段，它肯定是存在的。然后直接调用 <code>componentDidUpdate</code> 生命周期钩子函数即可。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>类组件的更新逻辑主要内容是以下两点：</p>
<ol>
<li><code>reconciler</code> 协调流程中循环 <code>update</code> 链表计算出最新的 <code>state</code>。</li>
<li><code>commit</code> 阶段中触发 <code>componentDidUpdate</code> 生命周期钩子函数以及循环执行 <code>this.setState</code> 的回调。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2调度器scheduler源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-15T00:00:00+08:00">2024-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心算法-最小堆"><a href="#核心算法-最小堆" class="headerlink" title="核心算法 - 最小堆"></a>核心算法 - 最小堆</h2><p><font color=gray><em>packages\scheduler\src\SchedulerMinHeap.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">type Heap&lt;T: Node&gt; = <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">type Node = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = heap.length;</span><br><span class="line">  heap.push(node);</span><br><span class="line">  siftUp(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">peek</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heap.length === <span class="number">0</span> ? <span class="literal">null</span> : heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (heap.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> last = heap.pop();</span><br><span class="line">  <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">    heap[<span class="number">0</span>] = last;</span><br><span class="line">    siftDown(heap, last, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftUp</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> parent = heap[parentIndex];</span><br><span class="line">    <span class="keyword">if</span> (compare(parent, node) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// The parent is larger. Swap positions.</span></span><br><span class="line">      heap[parentIndex] = node;</span><br><span class="line">      heap[index] = parent;</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The parent is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftDown</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">const</span> length = heap.length;</span><br><span class="line">  <span class="keyword">const</span> halfLength = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; halfLength) &#123;</span><br><span class="line">    <span class="keyword">const</span> leftIndex = (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = heap[leftIndex];</span><br><span class="line">    <span class="keyword">const</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> right = heap[rightIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the left or right node is smaller, swap with the smaller of those.</span></span><br><span class="line">    <span class="keyword">if</span> (compare(left, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        heap[index] = right;</span><br><span class="line">        heap[rightIndex] = node;</span><br><span class="line">        index = rightIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap[index] = left;</span><br><span class="line">        heap[leftIndex] = node;</span><br><span class="line">        index = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[index] = right;</span><br><span class="line">      heap[rightIndex] = node;</span><br><span class="line">      index = rightIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a: Node, b: Node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Compare sort index first, then task id.</span></span><br><span class="line">  <span class="keyword">const</span> diff = a.sortIndex - b.sortIndex;</span><br><span class="line">  <span class="keyword">return</span> diff !== <span class="number">0</span> ? diff : a.id - b.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h2><p>通过调用 <code>scheduleCallback</code> 方法进入调度器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从下面开始，我们将深入scheduler的源码：</p>
<h3 id="1-定义全局变量"><a href="#1-定义全局变量" class="headerlink" title="1. 定义全局变量"></a>1. 定义全局变量</h3><p><font color=gray><em>packages\scheduler\src\forks\Scheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;push, pop, peek&#125; <span class="keyword">from</span> <span class="string">'../SchedulerMinHeap'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerPriorities'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  enableIsInputPending,</span><br><span class="line">  enableIsInputPendingContinuous,</span><br><span class="line">  frameYieldMs,</span><br><span class="line">  continuousYieldMs,</span><br><span class="line">  maxYieldMs,</span><br><span class="line">  userBlockingPriorityTimeout,</span><br><span class="line">  lowPriorityTimeout,</span><br><span class="line">  normalPriorityTimeout,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerFeatureFlags'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  markTaskRun,</span><br><span class="line">  markTaskYield,</span><br><span class="line">  markTaskCompleted,</span><br><span class="line">  markTaskCanceled,</span><br><span class="line">  markTaskErrored,</span><br><span class="line">  markSchedulerSuspended,</span><br><span class="line">  markSchedulerUnsuspended,</span><br><span class="line">  markTaskStart,</span><br><span class="line">  stopLoggingProfilingEvents,</span><br><span class="line">  startLoggingProfilingEvents,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerProfiling'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Callback = <span class="function"><span class="params">boolean</span> =&gt;</span> ?Callback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> opaque type Task = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  callback: Callback | <span class="literal">null</span>,</span><br><span class="line">  priorityLevel: PriorityLevel,</span><br><span class="line">  startTime: number,</span><br><span class="line">  expirationTime: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  isQueued?: boolean,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间，通过performance或者Date</span></span><br><span class="line"><span class="keyword">let</span> getCurrentTime: <span class="function"><span class="params">()</span> =&gt;</span> number | DOMHighResTimeStamp;</span><br><span class="line"><span class="keyword">const</span> hasPerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> performance.now === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasPerformanceNow) &#123;</span><br><span class="line">  <span class="keyword">const</span> localPerformance = performance;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localPerformance.now();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> localDate = <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">const</span> initialTime = localDate.now();</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localDate.now() - initialTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tasks are stored on a min heap</span></span><br><span class="line"><span class="keyword">var</span> taskQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 没有延迟的任务</span></span><br><span class="line"><span class="keyword">var</span> timerQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 有延迟的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自增id，标记task唯一性</span></span><br><span class="line"><span class="comment">// Incrementing id counter. Used to maintain insertion order.</span></span><br><span class="line"><span class="keyword">var</span> taskIdCounter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line"><span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentTask = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> currentPriorityLevel = NormalPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="comment">// 是否有work在执行</span></span><br><span class="line"><span class="comment">// This is set while performing work, to prevent re-entrance.</span></span><br><span class="line"><span class="keyword">var</span> isPerformingWork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程是否在调度</span></span><br><span class="line"><span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有任务在倒计时</span></span><br><span class="line"><span class="keyword">var</span> isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taskTimeoutID: TimeoutID = (<span class="number">-1</span>: any);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> needsPaint = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capture local references to native APIs, in case a polyfill overrides them.</span></span><br><span class="line"><span class="keyword">const</span> localSetTimeout = <span class="keyword">typeof</span> setTimeout === <span class="string">'function'</span> ? setTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localClearTimeout =</span><br><span class="line">  <span class="keyword">typeof</span> clearTimeout === <span class="string">'function'</span> ? clearTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localSetImmediate =</span><br><span class="line">  <span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> ? setImmediate : <span class="literal">null</span>; <span class="comment">// IE and Node.js + jsdom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前是否有所有类型的输入事件，包括按键、鼠标、滚轮触控等DOM UI事件</span></span><br><span class="line"><span class="keyword">const</span> isInputPending =</span><br><span class="line">  <span class="keyword">typeof</span> navigator !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[prop-missing]</span></span><br><span class="line">  navigator.scheduling !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[incompatible-type]</span></span><br><span class="line">  navigator.scheduling.isInputPending !== <span class="literal">undefined</span></span><br><span class="line">    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否应该把控制权交换给主线程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldYieldToHost</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前程序运行时间</span></span><br><span class="line">  <span class="keyword">const</span> timeElapsed = getCurrentTime() - startTime;</span><br><span class="line">  <span class="comment">// 如果运行时间小于帧间隔时间5ms</span></span><br><span class="line">  <span class="keyword">if</span> (timeElapsed &lt; frameInterval) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main thread has been blocked for a non-negligible amount of time. We</span></span><br><span class="line">  <span class="comment">// may want to yield control of the main thread, so the browser can perform</span></span><br><span class="line">  <span class="comment">// high priority tasks. The main ones are painting and user input. If there's</span></span><br><span class="line">  <span class="comment">// a pending paint or a pending input, then we should yield. But if there's</span></span><br><span class="line">  <span class="comment">// neither, then we can yield less often while remaining responsive. We'll</span></span><br><span class="line">  <span class="comment">// eventually yield regardless, since there could be a pending paint that</span></span><br><span class="line">  <span class="comment">// wasn't accompanied by a call to `requestPaint`, or other main thread tasks</span></span><br><span class="line">  <span class="comment">// like network events.</span></span><br><span class="line">  <span class="keyword">if</span> (enableIsInputPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needsPaint) &#123;</span><br><span class="line">      <span class="comment">// There's a pending paint (signaled by `requestPaint`). Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeElapsed &lt; continuousInputInterval) &#123;</span><br><span class="line">      <span class="comment">// We haven't blocked the thread for that long. Only yield if there's a</span></span><br><span class="line">      <span class="comment">// pending discrete input (e.g. click). It's OK if there's pending</span></span><br><span class="line">      <span class="comment">// continuous input (e.g. mouseover).</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeElapsed &lt; maxInterval) &#123;</span><br><span class="line">      <span class="comment">// Yield if there's either a pending discrete or continuous input.</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending(continuousOptions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We've blocked the thread for a long time. Even if there's no pending</span></span><br><span class="line">      <span class="comment">// input, there may be some other scheduled work that we don't know about,</span></span><br><span class="line">      <span class="comment">// like a network event. Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `isInputPending` isn't available. Yield now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-根据环境设置生成宏任务调度函数"><a href="#2-根据环境设置生成宏任务调度函数" class="headerlink" title="2. 根据环境设置生成宏任务调度函数"></a>2. 根据环境设置生成宏任务调度函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE.</span></span><br><span class="line">  <span class="comment">// There's a few reasons for why we prefer setImmediate.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span></span><br><span class="line">  <span class="comment">// (Even though this is a DOM fork of the Scheduler, you could get here</span></span><br><span class="line">  <span class="comment">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// But also, it runs earlier which is the semantic we want.</span></span><br><span class="line">  <span class="comment">// If other browsers ever implement it, it's better to use it.</span></span><br><span class="line">  <span class="comment">// Although both of these would be inferior to native scheduling.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetImmediate(performWorkUntilDeadline);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetTimeout(performWorkUntilDeadline, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-任务调度器的入口函数"><a href="#3-任务调度器的入口函数" class="headerlink" title="3. 任务调度器的入口函数"></a>3. 任务调度器的入口函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务调度器的入口函数：并发模式下调度一个回调函数 【这里传入的callback就是performConcurrentWorkOnRoot】</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  priorityLevel: PriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: Callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: &#123;delay: number&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime(); <span class="comment">// 获取当前程序执行时间，performance.now()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime; <span class="comment">// 定义任务开始时间，不是执行时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'object'</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">'number'</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在延期，则开始时间 = 当前时间 + 延期时间</span></span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，开始时间 = 当前时间</span></span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开始时间直接等于currentTime</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义超时时间 【根据优先级，设置不同的超时时间】</span></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      <span class="comment">// Times out immediately，立即超时</span></span><br><span class="line">      timeout = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = userBlockingPriorityTimeout; <span class="comment">// 250</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="comment">// Never times out，永不超时</span></span><br><span class="line">      timeout = maxSigned31BitInt; <span class="comment">// Math.pow(2, 30) - 1， 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = lowPriorityTimeout; <span class="comment">// 10000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = normalPriorityTimeout; <span class="comment">// 5000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过期时间，也是理论上的任务执行时间，值越小，说明优先级越高，需要优先执行</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newTask: Task = &#123;</span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,</span><br><span class="line">    expirationTime,</span><br><span class="line">    sortIndex: <span class="number">-1</span>, <span class="comment">// 调度执行任务的依据</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始时间 大于当前时间：说明是延期任务，先加入到延时队列timerQueue</span></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// 有delay的任务</span></span><br><span class="line">    newTask.sortIndex = startTime; <span class="comment">// sortIndex是把任务从timerQueue中取出来放到taskQueue中的依据</span></span><br><span class="line">    push(timerQueue, newTask); <span class="comment">// 暂时存到timerQueue，等晚点到了执行时间，再放到taskQueue，再执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">      <span class="comment">// 所有任务都延迟了，而这是延迟时间最短的任务。</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">        <span class="comment">// 取消现有的setTimeout</span></span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule a timeout.</span></span><br><span class="line">      <span class="comment">// setTimeout</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有delay的任务，直接加入任务队列</span></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line">    <span class="comment">// Schedule a host callback, if needed. If we're already performing work,</span></span><br><span class="line">    <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">    <span class="comment">// 如果需要的话，调度一个HostCallback。如果我们已经在执行work，就等到下次我们让出控制权的时候。</span></span><br><span class="line">    <span class="comment">// 判断host回调任务是否已经被调度，以及是否正在工作中，只有host回调任务还没有被调度 且 当前并未在工作中；才会开启一个新的host回调任务</span></span><br><span class="line">    <span class="comment">// 【首次加载时，需要调度一个host回调任务】</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 设置host回调任务，触发localSetImmediate、MessageChannel或localSetTimeout，生成新的宏任务，在宏任务中执行工作循环workLoop</span></span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-调度异步执行，创建新的宏任务"><a href="#4-调度异步执行，创建新的宏任务" class="headerlink" title="4. 调度异步执行，创建新的宏任务"></a>4. 调度异步执行，创建新的宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 调度异步执行，创建新的宏任务</span></span><br><span class="line">    schedulePerformWorkUntilDeadline();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-异步执行宏任务"><a href="#5-异步执行宏任务" class="headerlink" title="5. 异步执行宏任务"></a>5. 异步执行宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在有效时间内执行工作</span></span><br><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line">    <span class="comment">// Keep track of the start time so we can measure how long the main thread</span></span><br><span class="line">    <span class="comment">// has been blocked.</span></span><br><span class="line">    <span class="comment">// 记录了一个work的起始时间，其实就是一个时间切片的起始时间，是个时间戳</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a scheduler task throws, exit the current browser task so the</span></span><br><span class="line">    <span class="comment">// error can be observed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Intentionally not using a try-catch, since that makes some debugging</span></span><br><span class="line">    <span class="comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span></span><br><span class="line">    <span class="comment">// remain true, and we'll continue the work loop.</span></span><br><span class="line">    <span class="keyword">let</span> hasMoreWork = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据返回判断是否还有工作</span></span><br><span class="line">      hasMoreWork = flushWork(currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">        <span class="comment">// 如果还有任务,则又触发调度宏任务事件，生成新的宏任务，即在下一个event loop中继续执行任务</span></span><br><span class="line">        schedulePerformWorkUntilDeadline();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Yielding to the browser will give it a chance to paint, so we can</span></span><br><span class="line">  <span class="comment">// reset this.</span></span><br><span class="line">  needsPaint = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We'll need a host callback the next time work is scheduled.</span></span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">    <span class="comment">// We scheduled a timeout but it's no longer needed. Cancel it.</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    cancelHostTimeout();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isPerformingWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> workLoop(initialTime);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有很多task，每个task都有一个callback，callback执行完了，就执行下一个task</span></span><br><span class="line"><span class="comment">// 一个work就是一个时间切片内执行的一些task</span></span><br><span class="line"><span class="comment">// 时间切片要循环，就是work要循环</span></span><br><span class="line"><span class="comment">// 返回为true，表示还有任务没有执行完，需要继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  <span class="comment">// 如果timerQueue中有*有效任务*到达执行时间，就放到taskQueue中</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line">  <span class="comment">// 从任务队列中取出队列第一个任务【注意：taskQueue中是按任务的到期时间expirationTime排序的，越小越先执行】</span></span><br><span class="line">  currentTask = peek(taskQueue);</span><br><span class="line">  <span class="comment">// 循环从taskQueue中取出任务</span></span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【重点判断】</span></span><br><span class="line"><span class="comment">     * 1，如果当前任务到期时间 大于 当前时间，说明任务还未过期</span></span><br><span class="line"><span class="comment">     * 2，shouldYieldToHost为true应该暂停</span></span><br><span class="line"><span class="comment">     * 总结：如果同时满足这两个条件，即任务还没过期，但是没有剩余可执行时间了，就应该跳出本次工作循环，</span></span><br><span class="line"><span class="comment">     * 让出主线程，交给渲染流水线，等待下一个宏任务执行task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      currentTask.callback = <span class="literal">null</span>;</span><br><span class="line">      currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">      <span class="comment">// 是否属于过期的任务，可能存在还没过期的任务。</span></span><br><span class="line">      <span class="keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span><br><span class="line">      <span class="comment">// 执行任务</span></span><br><span class="line">      <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">      currentTime = getCurrentTime();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果执行完后又返回了 function，赋值给当前任务的callback</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话，将当前任务移除。中断在这个位置发生，高优先任务会把低优先任务的callback置空。</span></span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pop(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTask = peek(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Return whether there's additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回是否还有任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 说明 currentTask 执行完了</span></span><br><span class="line">    <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理 timerQueue</span></span><br><span class="line">      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler periodically yields in case there is other work on the main</span></span><br><span class="line"><span class="comment">// thread, like user events. By default, it yields multiple times per frame.</span></span><br><span class="line"><span class="comment">// It does not attempt to align with frame boundaries, since most tasks don't</span></span><br><span class="line"><span class="comment">// need to be frame aligned; for those that do, use requestAnimationFrame.</span></span><br><span class="line"><span class="keyword">let</span> frameInterval = frameYieldMs;</span><br><span class="line"><span class="keyword">const</span> continuousInputInterval = continuousYieldMs;</span><br><span class="line"><span class="keyword">const</span> maxInterval = maxYieldMs;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuousOptions = &#123;<span class="attr">includeContinuous</span>: enableIsInputPendingContinuous&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceTimers</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check for tasks that are no longer delayed and add them to the queue.</span></span><br><span class="line">  <span class="keyword">let</span> timer = peek(timerQueue);</span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 无效的任务</span></span><br><span class="line">      <span class="comment">// Timer was cancelled.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.startTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      <span class="comment">// 任务已到达开始时间，转入taskQueue中</span></span><br><span class="line">      <span class="comment">// Timer fired. Transfer to the task queue.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">      timer.sortIndex = timer.expirationTime;</span><br><span class="line">      push(taskQueue, timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Remaining timers are pending.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = peek(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 把延迟任务从timerQueue中推入taskQueue</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Null out the callback to indicate the task has been canceled. (Can't</span></span><br><span class="line">  <span class="comment">// remove from the queue because you can't remove arbitrary nodes from an</span></span><br><span class="line">  <span class="comment">// array based heap, only the first one.)</span></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentPriorityLevel</span>(<span class="params"></span>): <span class="title">PriorityLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentPriorityLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostTimeout</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  callback: (currentTime: number</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">ms</span>: <span class="title">number</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  taskTimeoutID = localSetTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHostTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  localClearTimeout(taskTimeoutID);</span><br><span class="line">  taskTimeoutID = ((<span class="number">-1</span>: any): TimeoutID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  scheduleCallback,</span><br><span class="line">  cancelCallback,</span><br><span class="line">  getCurrentPriorityLevel,</span><br><span class="line">  shouldYieldToHost <span class="keyword">as</span> unstable_shouldYield,</span><br><span class="line">  getCurrentTime,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="核心流程图"><a href="#核心流程图" class="headerlink" title="核心流程图"></a>核心流程图</h2><h3 id="1-使用了-Scheduler-任务调度的流程图（Concurrent模式）"><a href="#1-使用了-Scheduler-任务调度的流程图（Concurrent模式）" class="headerlink" title="1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）"></a>1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<h3 id="2-没有使用-Scheduler-任务调度的流程图（legacy模式）"><a href="#2-没有使用-Scheduler-任务调度的流程图（legacy模式）" class="headerlink" title="2. 没有使用 Scheduler 任务调度的流程图（legacy模式）"></a>2. 没有使用 Scheduler 任务调度的流程图（legacy模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-1.png" alt="alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个比较泛的流程示例：<br><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-2.png" alt="alt text"></p>
<ul>
<li>在 React 中宏观来看，针对浏览器、Scheduler 、Reconciler 其实是有3层 Loop。浏览器级别的 eventLoop，Scheduler 级别的 workLoop，Reconciler 级别 workLoopConcurrent 。<ul>
<li>浏览器的 eventLoop 与 Scheduler 的关系<ul>
<li>每次 eventLoop 会执行宏任务的队列的宏任务，而 React 中的 Scheduler 就是用宏任务 setImmediate等 触发的。</li>
<li>当 eventLoop 开始执行跟 Scheduler 有关的宏任务时，Scheduler 会启动一次 workLoop，就是在遍历执行 Scheduler 中已存在的 taskQueue 队列的每个 task。</li>
</ul>
</li>
<li>Scheduler 与 Reconciler 的关系<ul>
<li>Scheduler中的 workLoop 中每执行一次 task，是通过调用 Reconciler 中的 performConcurrentWorkOnRoot 方法，即每一个 task 可以理解为是一个 performConcurrentWorkOnRoot 方法的调用。</li>
<li>performConcurrentWorkOnRoot 方法每次调用，其本质是在执行 workLoopConcurrent 方法，这个方法是在循环 performUnitOfWork 这个构建 Fiber 树中每个 Fiber 的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此可以梳理出来，3个大循环，从最开始的 eventLoop 的单个宏任务执行，会逐步触发 Scheduler 和 Reconciler 的任务循环执行。</p>
<ul>
<li>任务的中断与恢复，实现中断与恢复的逻辑分了2个部分，第一个是 Scheduler 中正在执行的 workLoop 的任务中断，第二个是 Reconciler 中正在执行的 workLoopConcurrent 的任务中断<ul>
<li>Reconciler 中的任务中断与恢复：在 workLoopConcurrent 的 while 循环中，通过 shouldYield() 方法来判断当前构建 fiber 树的执行过程是否超时，如果超时，则中断当前的 while 循环。由于每次 while 执行的 fiber 构建方法，即 performUnitOfWork 是按照每个 fiberNode 来遍历的，也就是说每完成一次 fiberNode 的 beginWork + completeWork 树的构建过程，会设置下一次 nextNode 的值 ，可以理解为中断时已经保留了下一次要构建的 fiberNode 指针，以至于不会下一次不知道从哪里继续。</li>
<li>Scheduler 中的任务中断与恢复：当执行任务时间超时后，如果 Reconciler 中的 performConcurrentWorkOnRoot 方法没有执行完成，会返回其自身。在 Scheduler 中，发现当前任务还有下一个任务没有执行完，则不会将当前任务从 taskQueue 中取出，同时会把 reconciler 中返回的待执行的回调函数继续赋值给当前任务，于是下一次继续启动 Scheduler 的任务时，也就连接上了。同时退出这次中断的任务前，会通过 messageChannel 向 eventLoop 的宏任务队列放入一个新的宏任务。</li>
<li>所以任务的恢复，其实就是从下一次 eventLoop 开始执行 Scheduler 相关的宏任务，而执行的宏任务也是 Reconciler 中断前赋值的 fiberNode，也就实现了整体的任务恢复。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89render-commit%E9%98%B6%E6%AE%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89render-commit%E9%98%B6%E6%AE%B5.html" class="post-title-link" itemprop="url">react18.2源码分析（四）render-commit阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-12T00:00:00+08:00">2024-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !3. commit</span></span><br><span class="line"><span class="comment">// 我们现在有了一个一致的树。下一步要么是 commit，要么是，如果有什么被暂停了，就等待一段时间后再 commit。</span></span><br><span class="line">root.finishedWork = finishedWork;</span><br><span class="line">root.finishedLanes = lanes;</span><br><span class="line">finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br></pre></td></tr></table></figure>

<h2 id="2-commit阶段-finishConcurrentRender"><a href="#2-commit阶段-finishConcurrentRender" class="headerlink" title="2. commit阶段 - finishConcurrentRender"></a>2. commit阶段 - finishConcurrentRender</h2><h3 id="2-1-finishConcurrentRender"><a href="#2-1-finishConcurrentRender" class="headerlink" title="2.1 finishConcurrentRender"></a>2.1 finishConcurrentRender</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishConcurrentRender</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  exitStatus: RootExitStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  commitRootWhenReady(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">      workInProgressRootRecoverableErrors,</span><br><span class="line">      workInProgressTransitions,</span><br><span class="line">      workInProgressRootDidIncludeRecursiveRenderUpdate,</span><br><span class="line">      lanes,</span><br><span class="line">      workInProgressDeferredLane,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-commitRootWhenReady"><a href="#2-2-commitRootWhenReady" class="headerlink" title="2.2 commitRootWhenReady"></a>2.2 commitRootWhenReady</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootWhenReady</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: Array&lt;CapturedValue&lt;mixed&gt;&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, commit immediately.</span></span><br><span class="line">  commitRoot(</span><br><span class="line">    root,</span><br><span class="line">    recoverableErrors,</span><br><span class="line">    transitions,</span><br><span class="line">    didIncludeRenderPhaseUpdate,</span><br><span class="line">    spawnedLane,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-commitRoot"><a href="#2-3-commitRoot" class="headerlink" title="2.3 commitRoot"></a>2.3 commitRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This no longer makes any sense. We already wrap the mutation and</span></span><br><span class="line">  <span class="comment">// layout phases. Should be able to remove.</span></span><br><span class="line">  <span class="keyword">const</span> previousUpdateLanePriority = getCurrentUpdatePriority();</span><br><span class="line">  <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">    setCurrentUpdatePriority(DiscreteEventPriority);</span><br><span class="line">    commitRootImpl(</span><br><span class="line">      root,</span><br><span class="line">      recoverableErrors,</span><br><span class="line">      transitions,</span><br><span class="line">      didIncludeRenderPhaseUpdate,</span><br><span class="line">      previousUpdateLanePriority,</span><br><span class="line">      spawnedLane,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ReactCurrentBatchConfig.transition = prevTransition;</span><br><span class="line">    setCurrentUpdatePriority(previousUpdateLanePriority);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-commitRootImpl"><a href="#2-4-commitRootImpl" class="headerlink" title="2.4 commitRootImpl"></a>2.4 commitRootImpl</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: EventPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> finishedWork = root.finishedWork;</span><br><span class="line">  <span class="keyword">const</span> lanes = root.finishedLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||</span><br><span class="line">    (finishedWork.flags &amp; PassiveMask) !== NoFlags</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">      rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">      pendingPassiveEffectsRemainingLanes = remainingLanes;</span><br><span class="line"></span><br><span class="line">      pendingPassiveTransitions = transitions;</span><br><span class="line">      scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ! 1. 异步执行 passive effects</span></span><br><span class="line">        flushPassiveEffects();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查HostFiber的子孙元素是存在副作用</span></span><br><span class="line">  <span class="keyword">const</span> subtreeHasEffects =</span><br><span class="line">    (finishedWork.subtreeFlags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line">  <span class="comment">// 检查HostFiber自身存在副作用</span></span><br><span class="line">  <span class="keyword">const</span> rootHasEffect =</span><br><span class="line">    (finishedWork.flags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何一个有副作用，说明需要更新，进入commit逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (subtreeHasEffects || rootHasEffect) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevTransition = ReactCurrentBatchConfig.transition;</span><br><span class="line">    ReactCurrentBatchConfig.transition = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前更新优先级</span></span><br><span class="line">    <span class="keyword">const</span> previousPriority = getCurrentUpdatePriority();</span><br><span class="line">    <span class="comment">// 设置同步优先级，commit必须同步执行</span></span><br><span class="line">    setCurrentUpdatePriority(DiscreteEventPriority);</span><br><span class="line">    <span class="comment">// 当前上下文</span></span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 进入commit阶段</span></span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在调用生命周期之前将其重置为null</span></span><br><span class="line">    ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 3. BeforeMutation阶段【这个阶段执行与flags相关的副作用】</span></span><br><span class="line">    <span class="keyword">const</span> shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 4. mutation阶段 (完成真实的dom渲染，更新页面)</span></span><br><span class="line">    commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染后，重置container容器信息</span></span><br><span class="line">    resetAfterCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Fiber双缓冲机制，完成Current Fiber Tree的切换</span></span><br><span class="line">    <span class="comment">// 其实也并不一定叫切换，就是将最新work内容存储为当前的内容，下一次的work就可以利用当前的内容</span></span><br><span class="line">    <span class="comment">// 注意：到这里是页面已经完成了更新渲染，这个交互Fiber Tree是为了保留最新的Tree，提供给下次更新使用</span></span><br><span class="line">    <span class="comment">// 同时也方便调用生命周期钩子时是最新的DOM</span></span><br><span class="line">    root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 5. layout阶段</span></span><br><span class="line">    commitLayoutEffects(finishedWork, root, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No effects.</span></span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-异步执行-passive-effects"><a href="#2-4-1-异步执行-passive-effects" class="headerlink" title="2.4.1 异步执行 passive effects"></a>2.4.1 异步执行 passive effects</h4><p>执行 useEffect 的 effects</p>
<h4 id="2-4-2-进入-commit-阶段"><a href="#2-4-2-进入-commit-阶段" class="headerlink" title="2.4.2 进入 commit 阶段"></a>2.4.2 进入 commit 阶段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executionContext |= CommitContext</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-beforeMutation阶段-commitBeforeMutationEffects"><a href="#2-4-3-beforeMutation阶段-commitBeforeMutationEffects" class="headerlink" title="2.4.3 beforeMutation阶段 - commitBeforeMutationEffects"></a>2.4.3 beforeMutation阶段 - commitBeforeMutationEffects</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  firstChild: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  focusedInstanceHandle = prepareForCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置第一个处理的节点为 hostFiber</span></span><br><span class="line">  nextEffect = firstChild;</span><br><span class="line">  <span class="comment">// 提交开始</span></span><br><span class="line">  commitBeforeMutationEffects_begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> shouldFire = shouldFireAfterActiveInstanceBlur;</span><br><span class="line">  shouldFireAfterActiveInstanceBlur = <span class="literal">false</span>;</span><br><span class="line">  focusedInstanceHandle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shouldFire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 <code>nextEffect</code> 变量，这里的 <code>firstChild</code> 代表第一个处理的节点为 <code>hostFiber</code>。</p>
<p>然后调用 <code>commitBeforeMutationEffects_begin</code>，开始递归遍历 <code>FiberTree</code>，处理有副作用的 <code>Fiber</code> 节点。</p>
<h5 id="2-4-3-1-commitBeforeMutationEffects-begin"><a href="#2-4-3-1-commitBeforeMutationEffects-begin" class="headerlink" title="2.4.3.1 commitBeforeMutationEffects_begin"></a>2.4.3.1 commitBeforeMutationEffects_begin</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects_begin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// while循环，处理所有节点</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// 取出子节点， 刚开始是hostFiber节点的child： 即App 组件</span></span><br><span class="line">    <span class="keyword">const</span> child = fiber.child;</span><br><span class="line">    <span class="comment">// 如果该fiber的子节点存在BeforeMutation阶段相关的flgas标记 且 child不为null;  则继续循环，</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (fiber.subtreeFlags &amp; BeforeMutationMask) !== NoFlags &amp;&amp;</span><br><span class="line">      child !== <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      child.return = fiber;</span><br><span class="line">      <span class="comment">// 设置child为下一个处理的节点</span></span><br><span class="line">      nextEffect = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 只有当fiber的子节点不存在BeforeMutation阶段相关的flgas标记 且 child为null; 【叶子节点】</span></span><br><span class="line">      <span class="comment">// 和reconciler流程一样，第一个进入complete工作的都是【div react源码调试】节点</span></span><br><span class="line">      commitBeforeMutationEffects_complete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-2-commitBeforeMutationEffects-complete"><a href="#2-4-3-2-commitBeforeMutationEffects-complete" class="headerlink" title="2.4.3.2 commitBeforeMutationEffects_complete"></a>2.4.3.2 commitBeforeMutationEffects_complete</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects_complete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    setCurrentDebugFiberInDEV(fiber);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理当前节点的副作用</span></span><br><span class="line">      commitBeforeMutationEffectsOnFiber(fiber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(fiber, fiber.return, error);</span><br><span class="line">    &#125;</span><br><span class="line">    resetCurrentDebugFiberInDEV();</span><br><span class="line">    <span class="comment">// 取出兄弟节点</span></span><br><span class="line">    <span class="keyword">const</span> sibling = fiber.sibling;</span><br><span class="line">    <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">      sibling.return = fiber.return;</span><br><span class="line">      <span class="comment">// 将兄弟节点设置为下一个nextEffect 【回到begin工作】</span></span><br><span class="line">      nextEffect = sibling;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = fiber.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitBeforeMutationEffects_complete方法也是一个while循环，对当前Fiber节点执行flags标记对应的操作，即执行commitBeforeMutationEffectsOnFiber方法。执行完成后，如果当前Fiber节点存在sibling兄弟节点，则将兄弟节点设置为最新的nextEffect，退出当前函数，开启兄弟节点的begin工作。如果不存在兄弟节点，则将当前Fiber节点的父级节点设置为最新的nextEffect，执行父级节点的commitBeforeMutationEffects_complete工作。</p>
<p>根据上面可以看出，BeforeMutation阶段逻辑和之前创建FiberTree的逻辑基本相同，都是深度优先遍历的顺序从HostFiber根节点开始【自上而下】遍历处理每一个满足条件的Fiber节点，执行flags对应的副作用操作，即相似的begin和complete工作逻辑。这里主要的执行内容在commitBeforeMutationEffectsOnFiber方法之中。</p>
<blockquote>
<p>注意，其实commit阶段中三个子阶段的逻辑：基本都是以这种逻辑方式来处理相关的副作用内容。</p>
</blockquote>
<h5 id="2-4-3-3-commitBeforeMutationEffectsOnFiber"><a href="#2-4-3-3-commitBeforeMutationEffectsOnFiber" class="headerlink" title="2.4.3.3 commitBeforeMutationEffectsOnFiber"></a>2.4.3.3 commitBeforeMutationEffectsOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffectsOnFiber</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点的类型，进行不同的副作用处理</span></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableUseEffectEventHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Update) !== NoFlags) &#123;</span><br><span class="line">          commitUseEffectEventMount(finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> prevProps = current.memoizedProps;</span><br><span class="line">          <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">          <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">const</span> snapshot = instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType === finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState,</span><br><span class="line">          );</span><br><span class="line">          instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hostFiber节点的处理</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">          <span class="comment">// 应用根节点</span></span><br><span class="line">          <span class="keyword">const</span> root = finishedWork.stateNode;</span><br><span class="line">          <span class="comment">// 设置textContent = ''; 也就是清空#div容器内容， 方便Mutation阶段的渲染</span></span><br><span class="line">          clearContainer(root.containerInfo);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="keyword">case</span> HostHoistable:</span><br><span class="line">    <span class="keyword">case</span> HostSingleton:</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent:</span><br><span class="line">      <span class="comment">// Nothing to do for these component types</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">'This unit of work tag should not have side-effects. This error is '</span> +</span><br><span class="line">            <span class="string">'likely caused by a bug in React. Please file an issue.'</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; Snapshot) !== NoFlags) &#123;</span><br><span class="line">    resetCurrentDebugFiberInDEV();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 <code>commitBeforeMutationEffectsOnFiber</code> 方法后，发现只有 <code>Snapshot</code> 标记的副作用才会执行。</p>
<blockquote>
<p><code>hostFiber</code> 节点的 <code>Snapshot</code> 副作用是在 <code>completeWork</code> 工作中被标记的。</p>
</blockquote>
<h5 id="2-4-3-4-BeforeMutation阶段总结"><a href="#2-4-3-4-BeforeMutation阶段总结" class="headerlink" title="2.4.3.4 BeforeMutation阶段总结"></a>2.4.3.4 BeforeMutation阶段总结</h5><p>所以BeforeMutation阶段最终只会执行这两种副作用：</p>
<ol>
<li>触发类组件的getSnapshotBeforeUpdate钩子。</li>
<li>处理HostRoot类型节点【HostFiber】，清空#root容器内容， 方便下面Mutation阶段的DOM挂载。</li>
</ol>
<h4 id="2-4-4-mutation-阶段-commitMutationEffects"><a href="#2-4-4-mutation-阶段-commitMutationEffects" class="headerlink" title="2.4.4 mutation 阶段 - commitMutationEffects"></a>2.4.4 mutation 阶段 - commitMutationEffects</h4><p>前面我们已经知道了 <code>MutationMask</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;</span><br></pre></td></tr></table></figure>

<p>而 <code>MutationMask</code> 就是代表 <code>Mutation</code> 阶段所需要执行的哪些副作用类型，虽然可以看到 <code>MutationMask</code> 集成了很多的副作用标记，但是 <code>Mutation</code> 阶段的重点内容：还是针对 <code>Fiber</code> 节点上 <code>DOM</code> 内容的处理，然后将最终的 <code>DOM</code> 内容渲染到页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);</span><br><span class="line"></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-1-commitMutationEffectsOnFiber"><a href="#2-4-4-1-commitMutationEffectsOnFiber" class="headerlink" title="2.4.4.1 commitMutationEffectsOnFiber"></a>2.4.4.1 commitMutationEffectsOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffectsOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧hostFiber 节点</span></span><br><span class="line">  <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">  <span class="comment">// 取出dom操作的标识flags</span></span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据节点tag，执行不同的逻辑</span></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数组件处理</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="comment">// recursivelyTraverse：递归遍历</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      <span class="comment">// app组件跳出了循环，向下继续执行</span></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          commitHookEffectListUnmount(</span><br><span class="line">            HookInsertion | HookHasEffect,</span><br><span class="line">            finishedWork,</span><br><span class="line">            finishedWork.return,</span><br><span class="line">          );</span><br><span class="line">          commitHookEffectListMount(</span><br><span class="line">            HookInsertion | HookHasEffect,</span><br><span class="line">            finishedWork,</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          enableProfilerTimer &amp;&amp;</span><br><span class="line">          enableProfilerCommitHooks &amp;&amp;</span><br><span class="line">          finishedWork.mode &amp; ProfileMode</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            startLayoutEffectTimer();</span><br><span class="line">            commitHookEffectListUnmount(</span><br><span class="line">              HookLayout | HookHasEffect,</span><br><span class="line">              finishedWork,</span><br><span class="line">              finishedWork.return,</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">          recordLayoutEffectDuration(finishedWork);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            commitHookEffectListUnmount(</span><br><span class="line">              HookLayout | HookHasEffect,</span><br><span class="line">              finishedWork,</span><br><span class="line">              finishedWork.return,</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类组件处理</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Ref) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          safelyDetachRef(current, current.return);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原生dom元素处理</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="comment">// 递归遍历</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      <span class="comment">// 处理dom</span></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Ref) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          safelyDetachRef(current, current.return);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">        <span class="comment">// 如果flags标记为ContentReset</span></span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; ContentReset) &#123;</span><br><span class="line">          <span class="comment">// dom实例</span></span><br><span class="line">          <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重置dom的内容</span></span><br><span class="line">            resetTextContent(instance);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果flgas标记为Update更新</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          <span class="comment">// 取出当前节点对应的DOM对象</span></span><br><span class="line">          <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">            <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">            <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">            <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">            <span class="comment">// this case.</span></span><br><span class="line">            <span class="keyword">const</span> oldProps =</span><br><span class="line">              current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">            <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">            <span class="keyword">const</span> updatePayload: <span class="literal">null</span> | UpdatePayload = (finishedWork.updateQueue: any);</span><br><span class="line">            finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                commitUpdate(</span><br><span class="line">                  instance,</span><br><span class="line">                  updatePayload,</span><br><span class="line">                  type,</span><br><span class="line">                  oldProps,</span><br><span class="line">                  newProps,</span><br><span class="line">                  finishedWork,</span><br><span class="line">                );</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                captureCommitPhaseError(</span><br><span class="line">                  finishedWork,</span><br><span class="line">                  finishedWork.return,</span><br><span class="line">                  error,</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文本处理</span></span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">          <span class="keyword">if</span> (finishedWork.stateNode === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">'This should have a text node initialized. This error is likely '</span> +</span><br><span class="line">                <span class="string">'caused by a bug in React. Please file an issue.'</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> textInstance: TextInstance = finishedWork.stateNode;</span><br><span class="line">          <span class="keyword">const</span> newText: string = finishedWork.memoizedProps;</span><br><span class="line">          <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">          <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">          <span class="comment">// this case.</span></span><br><span class="line">          <span class="keyword">const</span> oldText: string =</span><br><span class="line">            current !== <span class="literal">null</span> ? current.memoizedProps : newText;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hostFiber根节点处理 【第一次会走根节点， 从根节点向下递归渲染dom】</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="comment">// recursivelyTraverse：递归遍历 【页面显示】</span></span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsMutation &amp;&amp; supportsHydration) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevRootState: RootState = current.memoizedState;</span><br><span class="line">            <span class="keyword">if</span> (prevRootState.isDehydrated) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                commitHydratedContainer(root.containerInfo);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                captureCommitPhaseError(</span><br><span class="line">                  finishedWork,</span><br><span class="line">                  finishedWork.return,</span><br><span class="line">                  error,</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (supportsPersistence) &#123;</span><br><span class="line">          <span class="keyword">const</span> containerInfo = root.containerInfo;</span><br><span class="line">          <span class="keyword">const</span> pendingChildren = root.pendingChildren;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            replaceContainerChildren(containerInfo, pendingChildren);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line">      commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitMutationEffectsOnFiber</code> 方法内容很多，但是它的核心逻辑依然是switch case结构：根据当前Fiber节点tag值，对不同组件类型进行不同的逻辑处理。</p>
<p>要处理的组件类型有很多，我们主要掌握几个常见的组件类型处理逻辑：</p>
<ul>
<li>FunctionComponent：函数组件。</li>
<li>ClassComponent：类组件。</li>
<li>HostComponent：DOM节点。</li>
<li>HostText：文本节点。</li>
<li>HostRoot：HostFiber根节点。</li>
</ul>
<p>从上面几个组件类型的处理逻辑来看，它们都是一套相同的处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1，删除DOM</span></span><br><span class="line">recursivelyTraverseMutationEffects(root, finishedWork, lanes);</span><br><span class="line"><span class="comment">// 2，插入DOM</span></span><br><span class="line">commitReconciliationEffects(finishedWork);</span><br><span class="line"><span class="comment">// 3，更新(DOM内容)</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-2-Mutation阶段执行顺序"><a href="#2-4-4-2-Mutation阶段执行顺序" class="headerlink" title="2.4.4.2 Mutation阶段执行顺序"></a>2.4.4.2 Mutation阶段执行顺序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commitMutationEffectsOnFiber  =&gt; commit()</span><br><span class="line">recursivelyTraverseMutationEffects  这个方法中使用了循环，并且调用了上面的方法=&gt; <span class="keyword">for</span>()</span><br><span class="line"><span class="comment">// 2，插入DOM</span></span><br><span class="line">commitReconciliationEffects(finishedWork);  <span class="comment">// 2，3两部分视为一个内容 =&gt; content()</span></span><br><span class="line"><span class="comment">// 3，更新(DOM内容)</span></span><br><span class="line">commitPlacement(finishedWork);</span><br></pre></td></tr></table></figure>

<p>所以Mutation阶段的执行顺序就可以表示为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fiber顺序: <span class="function"><span class="params">HostFiber</span>  =&gt;</span>    fun App    =&gt; 	 div.App  =&gt;   ...</span><br><span class="line"><span class="comment">// 代码执行顺序</span></span><br><span class="line">commit</span><br><span class="line">	      <span class="keyword">for</span></span><br><span class="line">			      commit</span><br><span class="line">			  		  	    <span class="keyword">for</span></span><br><span class="line">						  		   commit</span><br><span class="line">						  				      <span class="keyword">for</span></span><br><span class="line">						  				  		     commit</span><br><span class="line">						  				  		  		      ...</span><br><span class="line">						  				      content</span><br><span class="line">						    content</span><br><span class="line">	      content</span><br></pre></td></tr></table></figure>

<p>执行顺序为从上往下，通过这种递归遍历方式，可以发现HostFiber虽然是第一个进入commit逻辑的节点，但是它的content内容却是最后一个执行，也就是说在HostFiber的content内容处理完成之后，即代表完整的DOM树已经渲染到页面。实际上最后执行插入到页面的操作是在【fun App】组件节点上执行的，后续会有说明，这部分内容在第三章也有解释。</p>
<p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9Brender-commit%E9%98%B6%E6%AE%B5/image.png" alt="alt text"></p>
<h5 id="2-4-4-3-recursivelyTraverseMutationEffects"><a href="#2-4-4-3-recursivelyTraverseMutationEffects" class="headerlink" title="2.4.4.3 recursivelyTraverseMutationEffects"></a>2.4.4.3 recursivelyTraverseMutationEffects</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyTraverseMutationEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot, <span class="regexp">//</span> root</span></span></span><br><span class="line"><span class="function"><span class="params">  parentFiber: Fiber, <span class="regexp">//</span> HostFiber</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  # 删除标记，是否存在</span><br><span class="line">  <span class="keyword">const</span> deletions = parentFiber.deletions;</span><br><span class="line">  <span class="keyword">if</span> (deletions !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deletions.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> childToDelete = deletions[i];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行删除副作用</span></span><br><span class="line">        commitDeletionEffects(root, parentFiber, childToDelete);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        captureCommitPhaseError(childToDelete, parentFiber, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 如果子节点树有副作用标记</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.subtreeFlags &amp; MutationMask) &#123;</span><br><span class="line">    <span class="comment">// 取出子节点</span></span><br><span class="line">    <span class="keyword">let</span> child = parentFiber.child;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 开始递归渲染</span></span><br><span class="line">      commitMutationEffectsOnFiber(child, root, lanes);</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码可以看出，<code>recursivelyTraverseMutationEffects</code> 方法主要就两个逻辑：</p>
<ul>
<li>判断当前 <code>Fiber</code> 节点是否存在 <code>deletions</code> 删除标记，如果存在则循环 <code>deletions</code>，删除子节点对应DOM元素的内容。</li>
<li>遍历子树，递归调用 <code>commitMutationEffectsOnFiber</code>。</li>
</ul>
<p>这里主要讲解第一点内容删除的逻辑，第二点遍历的内容就是前面 <code>Mutation</code> 阶段执行顺序的内容。<br>具体的删除逻辑就是执行 <code>commitDeletionEffects</code> 方法，真实的删除逻辑比较复杂，删除一个DOM元素要考虑很多东西，这里我们不会展开 <code>commitDeletionEffects</code> 方法，但是还是要了解一下可能会造成的一些副作用影响：</p>
<ul>
<li>执行子树所有组件的 <code>unmount</code> 卸载逻辑。</li>
<li>执行子树某些类组件的 <code>componentWillUnmount</code> 方法。</li>
<li>执行子树某些函数组件的 <code>useEffect</code>，<code>useLayoutEffect</code>等 hooks 的 <code>destory</code> 销毁方法。</li>
<li>执行子树所有 <code>ref</code> 属性的卸载操作。</li>
</ul>
<p>这里将删除DOM的逻辑放在每个组件的第一个执行，也是非常必要的。因为Mutation阶段的核心就是DOM操作，如果对应的DOM都已经被删除了，那么也就没有必要再去执行剩下的修改更新了。</p>
<h5 id="2-4-4-4-commitReconciliationEffects"><a href="#2-4-4-4-commitReconciliationEffects" class="headerlink" title="2.4.4.4 commitReconciliationEffects"></a>2.4.4.4 commitReconciliationEffects</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitReconciliationEffects</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line">  <span class="comment">// 如果是插入/移动标记</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; Placement) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      # 执行dom插入添加操作</span><br><span class="line">      commitPlacement(finishedWork);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">    &#125;</span><br><span class="line">    finishedWork.flags &amp;= ~Placement;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; Hydrating) &#123;</span><br><span class="line">    finishedWork.flags &amp;= ~Hydrating;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>commitReconciliationEffects</code> 方法就是执行 <code>DOM</code> 的插入或者移动操作，判断当前 <code>Fiber</code> 节点是否存在 <code>Placement</code> 标记，存在就会执行 <code>commitPlacement</code> 方法，执行相关的 <code>DOM</code> 的操作。</p>
<h5 id="2-4-4-5-commitPlacement"><a href="#2-4-4-5-commitPlacement" class="headerlink" title="2.4.4.5 commitPlacement"></a>2.4.4.5 commitPlacement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// finishedWork: fun App 它的父级节点为HostFIber</span></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    # 普通DOM节点</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> parent: Instance = parentFiber.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (parentFiber.flags &amp; ContentReset) &#123;</span><br><span class="line">        resetTextContent(parent);</span><br><span class="line">        parentFiber.flags &amp;= ~ContentReset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      <span class="comment">// 插入节点</span></span><br><span class="line">      insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 处理HostFiber节点的插入动作：</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="keyword">case</span> HostPortal: &#123;</span><br><span class="line">      <span class="comment">// #div</span></span><br><span class="line">      <span class="keyword">const</span> parent: Container = parentFiber.stateNode.containerInfo;</span><br><span class="line">      <span class="comment">// 无兄弟节点</span></span><br><span class="line">      <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">      # 将离屏的DOM树插入到#div； 马上页面上显示出DOM内容</span><br><span class="line">      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够执行 <code>Placement</code> 副作用的，只有两种组件节点 <code>HostComponent</code> 和 <code>HostRoot</code>。</p>
<p>对于 <code>HostComponent</code> 来说，就是常规的 <code>DOM</code> 插入和移动，即调用原生的 <code>DOM</code> 方法执行对应的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生DOM操作</span></span><br><span class="line">parentNode.appendChild()</span><br><span class="line">parentNode.insertBefore()</span><br></pre></td></tr></table></figure>

<h5 id="mutation阶段总结"><a href="#mutation阶段总结" class="headerlink" title="mutation阶段总结"></a>mutation阶段总结</h5><p>mutation 阶段的主要工作是：</p>
<ul>
<li>对 <code>DOM</code> 内容的增删改操作，最后将构建完成的离屏 <code>DOM</code> 树渲染到页面。</li>
<li>针对函数组件触发 <code>useInsertionEffect hook</code> 的副作用以及 <code>useLayoutEffect hook</code> 的 <code>destroy</code> 方法。</li>
<li>针对类组件和普通 <code>DOM</code> 组件重置 <code>ref</code> 对象的内容。</li>
</ul>
<h4 id="2-4-5-layout-阶段-commitLayoutEffects"><a href="#2-4-5-layout-阶段-commitLayoutEffects" class="headerlink" title="2.4.5 layout 阶段 - commitLayoutEffects"></a>2.4.5 layout 阶段 - commitLayoutEffects</h4><p>前面我们已经知道了 <code>LayoutMask</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutMask = Update | Callback | Ref | Visibility;</span><br></pre></td></tr></table></figure>

<p>而 <code>LayoutMask</code> 就是代表 <code>Layout</code> 阶段所需要执行的哪些副作用类型：</p>
<ul>
<li>类组件的 <code>componentDidMount/componentDidUpdate</code> 生命周期钩子函数的执行。</li>
<li>类组件调用 <code>this.setState</code> 时传递的 <code>callback</code> 回调函数的会被保存到 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性中在这里执行。</li>
<li>执行函数组件的 <code>useLayoutEffect hook</code> 回调。</li>
</ul>
<p>可以说 Layout 阶段的主要内容：就是在DOM渲染完成后，执行函数组件和类组件定义的一些callback回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  inProgressLanes = committedLanes;</span><br><span class="line">  inProgressRoot = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HostFiber</span></span><br><span class="line">  nextEffect = finishedWork;</span><br><span class="line">  # 又是begin 和complete工作逻辑</span><br><span class="line">  # 相当于递归循环触发每个组件的生命周期钩子函数 以及相关的 hooks 回调</span><br><span class="line">  commitLayoutEffects_begin(finishedWork, root, committedLanes);</span><br><span class="line"></span><br><span class="line">  inProgressLanes = <span class="literal">null</span>;</span><br><span class="line">  inProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-1-commitLayoutEffects-begin"><a href="#2-4-5-1-commitLayoutEffects-begin" class="headerlink" title="2.4.5.1 commitLayoutEffects_begin"></a>2.4.5.1 commitLayoutEffects_begin</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects_begin</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subtreeRoot: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isModernRoot = (subtreeRoot.mode &amp; ConcurrentMode) !== NoMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环触发</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// HostFiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// fun App组件节点</span></span><br><span class="line">    <span class="keyword">const</span> firstChild = fiber.child;</span><br><span class="line"></span><br><span class="line">    # 说明子树存在副作用，需要更新nextEffect为子节点，进入下一级的循环</span><br><span class="line">    <span class="keyword">if</span> ((fiber.subtreeFlags &amp; LayoutMask) !== NoFlags &amp;&amp; firstChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      firstChild.return = fiber;</span><br><span class="line">      nextEffect = firstChild;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      # 说明副作用在自身节点了，进入complete阶段</span><br><span class="line">      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-2-commitLayoutMountEffects-complete"><a href="#2-4-5-2-commitLayoutMountEffects-complete" class="headerlink" title="2.4.5.2 commitLayoutMountEffects_complete"></a>2.4.5.2 commitLayoutMountEffects_complete</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutMountEffects_complete</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subtreeRoot: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// while循环</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = nextEffect;</span><br><span class="line">    <span class="comment">// 存在layout相关的副作用 才会进入</span></span><br><span class="line">    <span class="keyword">if</span> ((fiber.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = fiber.alternate;</span><br><span class="line">      setCurrentDebugFiberInDEV(fiber);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        # 执行副作用</span><br><span class="line">        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        captureCommitPhaseError(fiber, fiber.return, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 当回到HostFiber时，代表循环完成，退出layout工作</span><br><span class="line">    <span class="keyword">if</span> (fiber === subtreeRoot) &#123;</span><br><span class="line">      nextEffect = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 存在兄弟节点，开始兄弟节点的工作</span><br><span class="line">    <span class="keyword">const</span> sibling = fiber.sibling;</span><br><span class="line">    <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">      sibling.return = fiber.return;</span><br><span class="line">      nextEffect = sibling;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	# 不存在兄弟节点，则返回父级节点</span><br><span class="line">    nextEffect = fiber.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-3-commitLayoutEffectOnFiber"><a href="#2-4-5-3-commitLayoutEffectOnFiber" class="headerlink" title="2.4.5.3 commitLayoutEffectOnFiber"></a>2.4.5.3 commitLayoutEffectOnFiber</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">    # 根据组件类型：进行不同的处理</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      # 1，函数组件的处理</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) &#123;</span><br><span class="line">          <span class="comment">// 处理副作用</span></span><br><span class="line">          commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      # 2，类组件的处理</span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="comment">// 组件实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">			  <span class="comment">// mount加载阶段</span></span><br><span class="line"></span><br><span class="line">              # 触发componentDidMount 生命周期钩子函数【这类静态方法：是存储在instance对象原型上的】</span><br><span class="line">              instance.componentDidMount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// update更新阶段</span></span><br><span class="line">              <span class="keyword">const</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps</span><br><span class="line">                  : resolveDefaultProps( finishedWork.type, current.memoizedProps);</span><br><span class="line">              <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">			  # 触发componentDidUpdate 生命周期钩子函数</span><br><span class="line">              instance.componentDidUpdate( prevProps,prevState,</span><br><span class="line">                  instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 取出当前组件节点的updateQueue更新对象</span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> I think this is now always non-null by the time it reaches the</span></span><br><span class="line">        <span class="comment">// commit phase. Consider removing the type check.</span></span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (finishedWork.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (finishedWork.child.tag) &#123;</span><br><span class="line">              <span class="keyword">case</span> HostComponent:</span><br><span class="line">                instance = getPublicInstance(finishedWork.child.stateNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ClassComponent:</span><br><span class="line">                instance = finishedWork.child.stateNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">        <span class="comment">// 取出DOM对象</span></span><br><span class="line">        <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (current === <span class="literal">null</span> &amp;&amp; finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">          <span class="keyword">const</span> props = finishedWork.memoizedProps;</span><br><span class="line">          # 针对一些特殊的DOM元素做加载处理：button,input等做自动聚焦，对Img图片做加载</span><br><span class="line">          commitMount(instance, type, props, finishedWork);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitLayoutEffectOnFiber</code> 方法依然是和前面两个阶段的逻辑一样，根据不同的组件节点进行不同的逻辑处理，这里我们还是理解几个重点组件类型即可。</p>
<ul>
<li><p>函数组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br></pre></td></tr></table></figure>
<p>同步执行当前函数组件节点的useLayoutEffect 回调。</p>
</li>
<li><p>类组件<br>根据当前Fiber节点是否存在current【旧的Fiber】来区分是mount阶段还是update阶段：</p>
<ul>
<li>mount阶段：执行当前类组件的componentDidMount生命周期钩子函数。</li>
<li>update阶段：执行当前类组件的componentDidUpdate生命周期钩子函数。</li>
</ul>
</li>
</ul>
<h5 id="layout阶段总结"><a href="#layout阶段总结" class="headerlink" title="layout阶段总结"></a>layout阶段总结</h5><p>在真实DOM加载完成后：</p>
<ul>
<li>执行函数组件的useLayoutEffect hook的回调。</li>
<li>类组件执⾏ componentDidMount 或者 componentDidUpdate。。</li>
<li>由此可⻅，函数组件的 effects 和类组件中⽣命周期执⾏时机是不同的</li>
</ul>
<h3 id="FiberTree的切换"><a href="#FiberTree的切换" class="headerlink" title="FiberTree的切换"></a>FiberTree的切换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2，Mutation阶段</span></span><br><span class="line">commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"># FiberTree的切换</span><br><span class="line">root.current = finishedWork;</span><br><span class="line"><span class="comment">// 3, Layout阶段</span></span><br><span class="line">commitLayoutEffects(finishedWork, root, lanes);</span><br></pre></td></tr></table></figure>

<p>在 <code>Mutation</code> 阶段和 <code>Layout</code> 阶段之间还有一个重要处理没有说明，那就是 <code>FiberTree</code> 的切换。</p>
<p>通过前面我们已经知道，<code>Mutation</code> 阶段处理完成之后，页面就已经完成了真实的 <code>DOM</code> 渲染。所以此时<code>finishedWork</code> 就是最新的 <code>FiberTree</code> 以及存储着最新的 <code>DOM</code> 内容，在这里更新 <code>current</code> 的内容，主要有两个方面的作用：</p>
<ul>
<li>保留最新的 <code>Fiber</code> 树结构，在下一次更新时就可以利用本次的 <code>FiberTree</code> 来做数据的复用以及差异对比。</li>
<li>对于类组件来说：当在 <code>Layout</code> 阶段执行 <code>componentDidMount</code> 或者 <code>componentDidUpdate</code> 生命周期钩子时就可以获取最新的 <code>DOM</code> 内容。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，react18.2源码解析最重要的内容：即一个react应用的基本加载流程算是解析完成了，虽然其中一些逻辑描述可能不够准确，但整体来说还是比较符合。当然其中也有一些逻辑的细节并没有展开讲解，这是因为本身应用的加载流程就已经比较复杂了，如果在解析过程中每个逻辑都放在一起讲解，那文章的内容可能翻倍不止，阅读效果也会大打折扣。所以关于一些细节方面的逻辑处理会在新的章节里面展开讲解，比如类组件，函数组件的具体加载过程、hooks原理、合成事件等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89render-render%E9%98%B6%E6%AE%B5.html" class="post-title-link" itemprop="url">react18.2源码分析（三）render-render阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-03T00:00:00+08:00">2024-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react源码分析（三）render-render阶段"><a href="#react源码分析（三）render-render阶段" class="headerlink" title="react源码分析（三）render-render阶段"></a>react源码分析（三）render-render阶段</h1><blockquote>
<p>如果以下代码没有特殊标记，路径都是 <font color=gray><em>src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js</em></font></p>
</blockquote>
<p>这个 <code>performConcurrentWorkOnRoot</code> 函数中包含两个重要的阶段，<code>render</code> 和 <code>commit</code> 阶段。这是每个并发任务的入口点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the entry point for every concurrent task, i.e. anything that goes through Scheduler.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ??</span></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// Something in the passive effect phase may have canceled the current task.</span></span><br><span class="line">    <span class="comment">// Check if the task node for this root was changed.</span></span><br><span class="line">    <span class="keyword">if</span> (root.callbackNode !== originalCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The current task was canceled. Exit. We don't need to call</span></span><br><span class="line">      <span class="comment">// `ensureRootIsScheduled` because the check above implies either that</span></span><br><span class="line">      <span class="comment">// there's a new task, or that there's no remaining work on this root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Current task was not canceled. Continue.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, using the fields stored</span></span><br><span class="line">  <span class="comment">// on the root.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This was already computed in the caller. Pass it as an argument.</span></span><br><span class="line">  <span class="keyword">let</span> lanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// Defensive coding. This is never expected to happen.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We disable time-slicing in some cases: if the work has been CPU-bound</span></span><br><span class="line">  <span class="comment">// for too long ("expired" work, to prevent starvation), or we're in</span></span><br><span class="line">  <span class="comment">// sync-updates-by-default mode.</span></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We only check `didTimeout` defensively, to account for a Scheduler</span></span><br><span class="line">  <span class="comment">// bug we're still investigating. Once the bug in Scheduler is fixed,</span></span><br><span class="line">  <span class="comment">// we can remove this, since we track expiration ourselves.</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line">        <span class="comment">// The render completed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this render may have yielded to a concurrent event, and if so,</span></span><br><span class="line">        <span class="comment">// confirm that any newly rendered stores are consistent.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It's possible that even a concurrent render may never have yielded</span></span><br><span class="line">        <span class="comment">// to the main thread, if it was fast enough, or if it expired. We could</span></span><br><span class="line">        <span class="comment">// skip the consistency check in that case, too.</span></span><br><span class="line">        <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          renderWasConcurrent &amp;&amp;</span><br><span class="line">          !isRenderConsistentWithExternalStores(finishedWork)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// A store was mutated in an interleaved event. Render again,</span></span><br><span class="line">          <span class="comment">// synchronously, to block further mutations.</span></span><br><span class="line">          exitStatus = renderRootSync(root, lanes);</span><br><span class="line">          <span class="comment">// We assume the tree is now consistent because we didn't yield to any</span></span><br><span class="line">          <span class="comment">// concurrent events.</span></span><br><span class="line">          renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// Need to check the exit status again.</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if something threw</span></span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">          <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">            root,</span><br><span class="line">            originallyAttemptedLanes,</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">            lanes = errorRetryLanes;</span><br><span class="line">            exitStatus = recoverFromConcurrentError(</span><br><span class="line">              root,</span><br><span class="line">              originallyAttemptedLanes,</span><br><span class="line">              errorRetryLanes,</span><br><span class="line">            );</span><br><span class="line">            renderWasConcurrent = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">          <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">          prepareFreshStack(root, NoLanes);</span><br><span class="line">          markRootSuspended(root, lanes, NoLane);</span><br><span class="line">          ensureRootIsScheduled(root);</span><br><span class="line">          <span class="keyword">throw</span> fatalError;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是 commit，要么是，如果有什么被暂停了，就等待一段时间后再 commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-render阶段-renderRootSync"><a href="#1-render阶段-renderRootSync" class="headerlink" title="1. render阶段 - renderRootSync"></a>1. render阶段 - renderRootSync</h2><p>进入 <code>render</code> 阶段的，同步渲染模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ! 1. 记录 render阶段 开始</span></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= RenderContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevDispatcher = pushDispatcher(root.containerInfo);</span><br><span class="line">  <span class="keyword">const</span> prevCacheDispatcher = pushCacheDispatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the root or lanes have changed, throw out the existing stack</span></span><br><span class="line">  <span class="comment">// and prepare a fresh one. Otherwise we'll continue where we left off.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableUpdaterTracking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDevToolsPresent) &#123;</span><br><span class="line">        <span class="keyword">const</span> memoizedUpdaters = root.memoizedUpdaters;</span><br><span class="line">        <span class="keyword">if</span> (memoizedUpdaters.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          restorePendingUpdaters(root, workInProgressRootRenderLanes);</span><br><span class="line">          memoizedUpdaters.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span></span><br><span class="line">        <span class="comment">// If we bailout on this work, we'll move them back (like above).</span></span><br><span class="line">        <span class="comment">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span></span><br><span class="line">        <span class="comment">// That way we can keep the current update and future updates separate.</span></span><br><span class="line">        movePendingFibersToMemoized(root, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. workInProgressTransitions赋值（用于dev环境）</span></span><br><span class="line">    workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br><span class="line">    <span class="comment">// ! 3. 初始化</span></span><br><span class="line">    prepareFreshStack(root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStarted(lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didSuspendInShell = <span class="literal">false</span>;</span><br><span class="line">  outer: <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        workInProgressSuspendedReason !== NotSuspended &amp;&amp;</span><br><span class="line">        workInProgress !== <span class="literal">null</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// The work loop is suspended. During a synchronous render, we don't</span></span><br><span class="line">        <span class="comment">// yield to the main thread. Immediately unwind the stack. This will</span></span><br><span class="line">        <span class="comment">// trigger either a fallback or an error boundary.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> For discrete and "default" updates (anything that's not</span></span><br><span class="line">        <span class="comment">// flushSync), we want to wait for the microtasks the flush before</span></span><br><span class="line">        <span class="comment">// unwinding. Will probably implement this using renderRootConcurrent,</span></span><br><span class="line">        <span class="comment">// or merge renderRootSync and renderRootConcurrent into the same</span></span><br><span class="line">        <span class="comment">// function and fork the behavior some other way.</span></span><br><span class="line">        <span class="keyword">const</span> unitOfWork = workInProgress;</span><br><span class="line">        <span class="keyword">const</span> thrownValue = workInProgressThrownValue;</span><br><span class="line">        <span class="keyword">switch</span> (workInProgressSuspendedReason) &#123;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnHydration: &#123;</span><br><span class="line">            <span class="comment">// Selective hydration. An update flowed into a dehydrated tree.</span></span><br><span class="line">            <span class="comment">// Interrupt the current render so the work loop can switch to the</span></span><br><span class="line">            <span class="comment">// hydration lane.</span></span><br><span class="line">            resetWorkInProgressStack();</span><br><span class="line">            workInProgressRootExitStatus = RootDidNotComplete;</span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnImmediate:</span><br><span class="line">          <span class="keyword">case</span> SuspendedOnData: &#123;</span><br><span class="line">            <span class="keyword">if</span> (!didSuspendInShell &amp;&amp; getSuspenseHandler() === <span class="literal">null</span>) &#123;</span><br><span class="line">              didSuspendInShell = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intentional fallthrough</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="comment">// Unwind then continue with the normal work loop.</span></span><br><span class="line">            workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">            workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ! 4. workLoopSync</span></span><br><span class="line">      workLoopSync();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleThrow(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Check if something suspended in the shell. We use this to detect an</span></span><br><span class="line">  <span class="comment">// infinite ping loop caused by an uncached promise.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Only increment this counter once per synchronous render attempt across the</span></span><br><span class="line">  <span class="comment">// whole tree. Even if there are many sibling components that suspend, this</span></span><br><span class="line">  <span class="comment">// counter only gets incremented once.</span></span><br><span class="line">  <span class="keyword">if</span> (didSuspendInShell) &#123;</span><br><span class="line">    root.shellSuspendCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  popDispatcher(prevDispatcher);</span><br><span class="line">  popCacheDispatcher(prevCacheDispatcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is a sync render, so we should have finished the whole tree.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Cannot commit an incomplete root. This error is likely caused by a '</span> +</span><br><span class="line">        <span class="string">'bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    markRenderStopped();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 6. 再遍历一遍更新队列</span></span><br><span class="line">  <span class="comment">// It's safe to process the queue now that the render phase is complete.</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressRootExitStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-记录-render-阶段-开始"><a href="#1-1-记录-render-阶段-开始" class="headerlink" title="1.1 记录 render 阶段 开始"></a>1.1 记录 render 阶段 开始</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">executionContext |= RenderContext;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-workInProgressTransitions赋值"><a href="#1-2-workInProgressTransitions赋值" class="headerlink" title="1.2 workInProgressTransitions赋值"></a>1.2 workInProgressTransitions赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-prepareFreshStack-初始化"><a href="#1-3-prepareFreshStack-初始化" class="headerlink" title="1.3 prepareFreshStack 初始化"></a>1.3 prepareFreshStack 初始化</h3><p>初始化 <code>workInProgressRoot</code>、<code>workInProgress</code>、<code>workInProgressRootRenderLanes</code> 等值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  root.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeoutHandle = root.timeoutHandle;</span><br><span class="line">  <span class="keyword">if</span> (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">    <span class="comment">// The root previous suspended and scheduled a timeout to commit a fallback</span></span><br><span class="line">    <span class="comment">// state. Now that we have additional work, cancel the timeout.</span></span><br><span class="line">    root.timeoutHandle = noTimeout;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above</span></span><br><span class="line">    cancelTimeout(timeoutHandle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cancelPendingCommit = root.cancelPendingCommit;</span><br><span class="line">  <span class="keyword">if</span> (cancelPendingCommit !== <span class="literal">null</span>) &#123;</span><br><span class="line">    root.cancelPendingCommit = <span class="literal">null</span>;</span><br><span class="line">    cancelPendingCommit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetWorkInProgressStack();</span><br><span class="line">  workInProgressRoot = root; <span class="comment">// FiberRoot</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rootWorkInProgress = createWorkInProgress(root.current, <span class="literal">null</span>); <span class="comment">// Fiber</span></span><br><span class="line"></span><br><span class="line">  workInProgress = rootWorkInProgress; <span class="comment">// Fiber</span></span><br><span class="line">  workInProgressRootRenderLanes = lanes;</span><br><span class="line">  workInProgressSuspendedReason = NotSuspended;</span><br><span class="line">  workInProgressThrownValue = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidAttachPingListener = <span class="literal">false</span>;</span><br><span class="line">  workInProgressRootExitStatus = RootInProgress;</span><br><span class="line">  workInProgressRootFatalError = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootSkippedLanes = NoLanes;</span><br><span class="line">  workInProgressRootInterleavedUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootPingedLanes = NoLanes;</span><br><span class="line">  workInProgressDeferredLane = NoLane;</span><br><span class="line">  workInProgressRootConcurrentErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRecoverableErrors = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootDidIncludeRecursiveRenderUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the lanes that are entangled with whatever we're about to render. We</span></span><br><span class="line">  <span class="comment">// track these separately so we can distinguish the priority of the render</span></span><br><span class="line">  <span class="comment">// task from the priority of the lanes it is entangled with. For example, a</span></span><br><span class="line">  <span class="comment">// transition may not be allowed to finish unless it includes the Sync lane,</span></span><br><span class="line">  <span class="comment">// which is currently suspended. We should be able to render the Transition</span></span><br><span class="line">  <span class="comment">// and Sync lane in the same batch, but at Transition priority, because the</span></span><br><span class="line">  <span class="comment">// Sync lane already suspended.</span></span><br><span class="line"></span><br><span class="line">  entangledRenderLanes = getEntangledLanes(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把concurrentQueues的内容添加到fiber的queue中，即给fiber的lanes、childLanes赋值</span></span><br><span class="line">  finishQueueingConcurrentUpdates();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rootWorkInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-1-workLoopSync"><a href="#1-4-1-workLoopSync" class="headerlink" title="1.4.1 workLoopSync"></a>1.4.1 workLoopSync</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work without checking if we need to yield between fiber.</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootSync，while循环，只要workInProgress有值，就会一直循环执行performUnitOfWork，直到workInProgress === null。</p>
<p>所以同步渲染模式，一旦开始这个Fiber Reconciler协调流程，就会进入一直循环的逻辑，直到创建出完整的FiberTree，这个过程无法中断。</p>
<p>下面我们来看看并发渲染模式的方法。</p>
<h3 id="1-4-2-workLoopConcurrent"><a href="#1-4-2-workLoopConcurrent" class="headerlink" title="1.4.2 workLoopConcurrent"></a>1.4.2 workLoopConcurrent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 renderRootConcurrent，可以看见和同步渲染模式基本一样，唯一的区别就是while循环的多了一个判断条件：当前程序运行时间是否小于帧间隔时间frameInterval【默认5ms】。</p>
<ul>
<li>如果小于：则返回false，代表还有剩余可执行时间。取反后为true，表示可以继续创建FiberTree的工作循环。</li>
<li>如果大于：则返回true，代表没有剩余可执行时间。取反后为false，则while循环的条件将不再满足，会暂停创建FiberTree的工作，结束本次宏任务，剩下的工作会留待下一次宏任务再处理。</li>
</ul>
<p>所以并发渲染模式和同步渲染模式的主要区别就是在这里：它可以中断FiberTree的创建过程，而同步渲染模式是无法中断这个过程的，它只能从开始到创建完成。</p>
<p>并且在这里我们也可以看出，它们的while循环里面都是执行了一个相同的performUnitOfWork方法，所以后面的逻辑也就没有什么模式的区分了，都是执行的一样的内容。</p>
<h3 id="1-4-3-并发模式下暂停工作与恢复执行"><a href="#1-4-3-并发模式下暂停工作与恢复执行" class="headerlink" title="1.4.3 并发模式下暂停工作与恢复执行"></a>1.4.3 并发模式下暂停工作与恢复执行</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发渲染模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoopConcurrent();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleError(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查tree工作是否完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Still work remaining.</span></span><br><span class="line">    <span class="keyword">return</span> RootInProgress;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>workLoopConcurrent</code> 并发渲染的工作被中断后，就会退出 <code>do while</code> 循环，然后就会检查当前的 <code>workInProgress</code> 是否为 <code>null</code>，很明显被暂停的情况，<code>workInProgress</code> 是一定有值的，它的值为下一个即将处理的 <code>Fiber</code> 节点。</p>
<p>此时 <code>workInProgress</code> 不为 <code>null</code>，就会返回 <code>RootInProgress</code> 的渲染状态，表示还有剩下的工作。</p>
<p>这里 return 之后，就会回到 <code>performConcurrentWorkOnRoot</code> 方法之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params">root, didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回未完成的渲染状态</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据渲染状态 继续执行逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染未完成的情况：</span></span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// 渲染暂停的情况：继续返回performConcurrentWorkOnRoot，下一次宏任务继续处理</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost()) ) &#123;</span><br><span class="line">        <span class="comment">// This currentTask hasn't expired, and we've reached the deadline.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback就是performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">        <span class="comment">// continuationCallback 如果返回也是 performConcurrentWorkOnRoot函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="comment">// 说明任务还未完成，将任务继续设置未当前任务的callback，等待下次继续执行</span></span><br><span class="line">          <span class="comment">// 这里没有删除这个任务，则下次取出的第一个任务，还是这个任务，</span></span><br><span class="line">          currentTask.callback = continuationCallback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 还有工作，则会生成一个新的宏任务，在下次的宏任务中继续执行剩下的任务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在workLoop方法之中，就会将返回的内容再次赋值给当前任务currentTask的callback属性，表示还有未完成的工作。workLoop方法中的while循环就会被中断，原因同样是shouldYieldToHost方法。</p>
<p>在workLoop方法最后就会判断当前任务currentTask是否为null，很明显被中断的情况，currentTask是有值的，所以就会返回true，这里会一直向上return：</p>
<p>最后会将结果返回performWorkUntilDeadline方法之中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span><br><span class="line">	<span class="comment">// 此时hasMoreWork为true</span></span><br><span class="line">    <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">      <span class="comment">// 如果还有任务,则又触发创建宏任务事件，生成新的宏任务，即在下一个消息事件继续执行任务</span></span><br><span class="line">      schedulePerformWorkUntilDeadline();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时hasMoreWork为true，就会调用schedulePerformWorkUntilDeadline方法，生成一个新的宏任务，在下个宏任务中继续执行剩下的任务。</p>
<p>恢复执行的原理也很简单：在下次的宏任务中继续创建FiberTree的时候，因为workInProgress是一个全局变量，一直保存在内存之中，并且它内容为下一个即将处理的Fiber节点，所以下次再回到这里时，就会自动从这个Fiber节点开始继续执行剩下的创建工作。</p>
<h3 id="1-5-performUnitOfWork"><a href="#1-5-performUnitOfWork" class="headerlink" title="1.5 performUnitOfWork"></a>1.5 performUnitOfWork</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存的上一次的Fiber</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.alternate;</span><br><span class="line">  setCurrentDebugFiberInDEV(unitOfWork);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始工作</span></span><br><span class="line">  <span class="keyword">let</span> next = beginWork(current, unitOfWork, entangledRenderLanes);</span><br><span class="line"></span><br><span class="line">  resetCurrentDebugFiberInDEV();</span><br><span class="line">  <span class="comment">// ! 把pendingProps更新到memoizedProps</span></span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注意：当遍历到叶子元素，即没有子FiberNode时，performUnitOfWork会进入归的阶段。</span></span><br><span class="line"><span class="comment">   * 这个阶段会调用completeUnitOfWork处理FiberNode，当某个FiberNode阶段执行completeUnitOfWork方法后，</span></span><br><span class="line"><span class="comment">   * 如果存在其他的兄弟节点【FiberNode.sibling !== null】，会进入兄弟节点的归阶段，</span></span><br><span class="line"><span class="comment">   * 如果不存在其他兄弟节点，则进入父节点的归阶段，递阶段和归阶段会交替进行直到HostFiber的归阶段</span></span><br><span class="line"><span class="comment">   * 至此，render工作结束，Fiber树创建完成。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn't spawn new work, complete the current work.</span></span><br><span class="line">    <span class="comment">// 如果不再产生新的work，那么当前work结束</span></span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 Fiber 为null</span></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fiber-树结构"><a href="#Fiber-树结构" class="headerlink" title="Fiber 树结构"></a>Fiber 树结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom/client'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">root.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyFun <span class="keyword">from</span> <span class="string">'./views/MyFun'</span>;</span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'./views/MyClass'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'App组件运行了'</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;react源码调试&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyFun name='MyFun'&gt;&lt;/</span>MyFun&gt;</span><br><span class="line">      &lt;MyClass name=<span class="string">'MyClass'</span>&gt;&lt;<span class="regexp">/MyClass&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  MyFun.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyFun</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MyFun组件运行了'</span>)</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'MyFun'</span>&gt;</span><br><span class="line">      &lt;div&gt;MyFun组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;state: &#123;count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;name: &#123;props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件运行了'</span>)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MyClass组件mount完成'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'MyClass'</span>&gt;</span><br><span class="line">        &lt;div&gt;MyClass组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;state: &#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;name: &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-4.png" alt="alt text"></p>
<h4 id="1-5-1-beginWork"><a href="#1-5-1-beginWork" class="headerlink" title="1.5.1 beginWork"></a>1.5.1 beginWork</h4><p>简单来说，就是生成 fiber 树。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> didReceiveUpdate: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update更新流程</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged() ||</span><br><span class="line">      <span class="comment">// Force a re-render if the implementation changed due to hot reload:</span></span><br><span class="line">      (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// If props or context changed, mark the fiber as having performed work.</span></span><br><span class="line">      <span class="comment">// This may be unset if the props are determined to be equal later (memo).</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither props nor legacy context changes. Check if there's a pending</span></span><br><span class="line">      <span class="comment">// update or context change.</span></span><br><span class="line">      <span class="keyword">const</span> hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span><br><span class="line">        current,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !hasScheduledUpdateOrContext &amp;&amp;</span><br><span class="line">        <span class="comment">// If this is the second pass of an error or suspense boundary, there</span></span><br><span class="line">        <span class="comment">// may not be work scheduled on `current`, so we check for this flag.</span></span><br><span class="line">        (workInProgress.flags &amp; DidCapture) === NoFlags</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No pending updates or context. Bail out now.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> attemptEarlyBailoutIfNoScheduledUpdate(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// This is a special case that only exists for legacy mode.</span></span><br><span class="line">        <span class="comment">// See https://github.com/facebook/react/pull/19216.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// An update was scheduled on this fiber, but there are no new props</span></span><br><span class="line">        <span class="comment">// nor legacy context. Set this to false. If an update queue or context</span></span><br><span class="line">        <span class="comment">// consumer produces a changed value, it will set this to true. Otherwise,</span></span><br><span class="line">        <span class="comment">// the component will assume the children have not changed and bail out.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating() &amp;&amp; isForkedChild(workInProgress)) &#123;</span><br><span class="line">      <span class="comment">// Check if this child belongs to a list of muliple children in</span></span><br><span class="line">      <span class="comment">// its parent.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// In a true multi-threaded implementation, we would render children on</span></span><br><span class="line">      <span class="comment">// parallel threads. This would represent the beginning of a new render</span></span><br><span class="line">      <span class="comment">// thread for this subtree.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We only use this for id generation during hydration, which is why the</span></span><br><span class="line">      <span class="comment">// logic is located in this special branch.</span></span><br><span class="line">      <span class="keyword">const</span> slotIndex = workInProgress.index;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = getForksAtLevel(workInProgress);</span><br><span class="line">      pushTreeId(workInProgress, numberOfForks, slotIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear pending update priority.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This assumes that we're about to evaluate the component and process</span></span><br><span class="line">  <span class="comment">// the update queue. However, there's an exception: SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// sometimes bails out later in the begin phase. This indicates that we should</span></span><br><span class="line">  <span class="comment">// move this assignment out of the common path and into each branch.</span></span><br><span class="line">  <span class="comment">// 在进入开始阶段之前，清除待处理的更新优先级。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 这假设我们即将评估组件并处理更新队列。然而，有一个例外情况：SimpleMemoComponent</span></span><br><span class="line">  <span class="comment">// 有时会在开始阶段后退出。这表明我们应该将这个赋值移出常规路径，放到每个分支中。</span></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountLazyComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类组件</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根Fiber（第一次都会走这里）</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostHoistable:</span><br><span class="line">      <span class="keyword">if</span> (enableFloat &amp;&amp; supportsResources) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostHoistable(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> HostSingleton:</span><br><span class="line">      <span class="keyword">if</span> (supportsSingletons) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateHostSingleton(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 原生标签，div span等标签</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      <span class="keyword">return</span> updatePortalComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === type</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateForwardRef(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">return</span> updateFragment(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">return</span> updateMode(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">return</span> updateProfiler(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="keyword">return</span> updateContextProvider(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">return</span> updateContextConsumer(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// Resolve outer props first, then resolve inner props.</span></span><br><span class="line">      <span class="keyword">let</span> resolvedProps = resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      resolvedProps = resolveDefaultProps(type.type, resolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSimpleMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        workInProgress.pendingProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> mountIncompleteClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseListComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseListComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ScopeComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableScopeAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateScopeComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> OffscreenComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateOffscreenComponent(current, workInProgress, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LegacyHiddenComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableLegacyHidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateLegacyHiddenComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CacheComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateCacheComponent(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TracingMarkerComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableTransitionTracing) &#123;</span><br><span class="line">        <span class="keyword">return</span> updateTracingMarkerComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">`Unknown unit of work tag (<span class="subst">$&#123;workInProgress.tag&#125;</span>). This error is likely caused by a bug in `</span> +</span><br><span class="line">      <span class="string">'React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-1-updateHostRoot"><a href="#1-5-1-1-updateHostRoot" class="headerlink" title="1.5.1.1 updateHostRoot"></a>1.5.1.1 updateHostRoot</h5><ol>
<li>更新当前 fiber，比如 props/state 更新，生命周期函数执行、Hooks 函数执行等。</li>
<li>返回一个下一个 fiber。</li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// current是根fiber，current的的stateNode是FiberRoot</span></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should have a current fiber. This is a bug in React.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. 更新props、state、updateQuue、transition</span></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState.element;</span><br><span class="line">  <span class="comment">// 把current上的updateQueue复用到 workInProgress 上一份。</span></span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextState: RootState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  pushRootTransition(workInProgress, root, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 2. bailout or 协调子节点，如果新旧children相同，则会进入优化的逻辑，跳过本次reconcile协调流程，复用原来的节点内容</span></span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 3. 返回子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-2-updateHostComponent"><a href="#1-5-1-2-updateHostComponent" class="headerlink" title="1.5.1.2 updateHostComponent"></a>1.5.1.2 updateHostComponent</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    <span class="comment">// We special case a direct text child of a host node. This is a common</span></span><br><span class="line">    <span class="comment">// case. We won't handle it as a reified child. We will instead handle</span></span><br><span class="line">    <span class="comment">// this in the host environment that also has access to this prop. That</span></span><br><span class="line">    <span class="comment">// avoids allocating another HostText fiber and traversing it.</span></span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    <span class="comment">// If we're switching from a direct text child to a normal child, or to</span></span><br><span class="line">    <span class="comment">// empty, we need to schedule the text content to be reset.</span></span><br><span class="line">    workInProgress.flags |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableFormActions &amp;&amp; enableAsyncActions) &#123;</span><br><span class="line">    <span class="keyword">const</span> memoizedState = workInProgress.memoizedState;</span><br><span class="line">    <span class="keyword">if</span> (memoizedState !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This fiber has been upgraded to a stateful component. The only way</span></span><br><span class="line">      <span class="comment">// happens currently is for form actions. We use hooks to track the</span></span><br><span class="line">      <span class="comment">// pending and error state of the form.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Once a fiber is upgraded to be stateful, it remains stateful for the</span></span><br><span class="line">      <span class="comment">// rest of its lifetime.</span></span><br><span class="line">      <span class="keyword">const</span> newState = renderTransitionAwareHostComponentWithHooks(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the transition state changed, propagate the change to all the</span></span><br><span class="line">      <span class="comment">// descendents. We use Context as an implementation detail for this.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This is intentionally set here instead of pushHostContext because</span></span><br><span class="line">      <span class="comment">// pushHostContext gets called before we process the state hook, to avoid</span></span><br><span class="line">      <span class="comment">// a state mismatch in the event that something suspends.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> This assumes that there cannot be nested transition providers,</span></span><br><span class="line">      <span class="comment">// because the only renderer that implements this feature is React DOM,</span></span><br><span class="line">      <span class="comment">// and forms cannot be nested. If we did support nested providers, then</span></span><br><span class="line">      <span class="comment">// we would need to push a context value even for host fibers that</span></span><br><span class="line">      <span class="comment">// haven't been upgraded yet.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrimaryRenderer) &#123;</span><br><span class="line">        HostTransitionContext._currentValue = newState;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HostTransitionContext._currentValue2 = newState;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enableLazyContextPropagation) &#123;</span><br><span class="line">        <span class="comment">// In the lazy propagation implementation, we don't scan for matching</span></span><br><span class="line">        <span class="comment">// consumers until something bails out.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (didReceiveUpdate) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldStateHook: Hook = current.memoizedState;</span><br><span class="line">            <span class="keyword">const</span> oldState: TransitionStatus = oldStateHook.memoizedState;</span><br><span class="line">            <span class="comment">// This uses regular equality instead of Object.is because we assume</span></span><br><span class="line">            <span class="comment">// that host transition state doesn't include NaN as a valid type.</span></span><br><span class="line">            <span class="keyword">if</span> (oldState !== newState) &#123;</span><br><span class="line">              propagateContextChange(</span><br><span class="line">                workInProgress,</span><br><span class="line">                HostTransitionContext,</span><br><span class="line">                renderLanes,</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-5-1-3-bailout"><a href="#1-5-1-3-bailout" class="headerlink" title="1.5.1.3 bailout"></a>1.5.1.3 bailout</h5><p>bailout阶段，返回null。</p>
<p>不会发生在组件初次渲染阶段，仅仅发生在组件更新阶段。当组件⼦节点没有发⽣变化，或者是被⼿动挡住（如类组件的 shouldComponentUpdate、memo 等），组件⼦节点不需要协调的时候。</p>
<h5 id="1-5-1-4-协调子节点-reconcileChildren"><a href="#1-5-1-4-协调子节点-reconcileChildren" class="headerlink" title="1.5.1.4 协调子节点 reconcileChildren"></a>1.5.1.4 协调子节点 reconcileChildren</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 组件初次挂载</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress, <span class="comment">// 父节点</span></span><br><span class="line">      current.child, <span class="comment">// 旧的child</span></span><br><span class="line">      nextChildren, <span class="comment">// 新的child</span></span><br><span class="line">      renderLanes, <span class="comment">// 本次更新的lanes</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最终执行的函数是同一个，都是 <code>createChildReconciler</code>，而 <code>createChildReconciler</code> 是一个 wrapper function。最终会返回内部的 <code>reconcileChildFibers</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers: ChildReconciler =</span><br><span class="line">  createChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers: ChildReconciler = createChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-5-reconcileChildFibers"><a href="#1-5-1-5-reconcileChildFibers" class="headerlink" title="1.5.1.5 reconcileChildFibers"></a>1.5.1.5 reconcileChildFibers</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 协调子节点，构建新的子fiber结构，并且返回新的子fiber</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null, <span class="regexp">//</span> 老fiber的第一个子节点</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> firstChildFiber = reconcileChildFibersImpl(</span><br><span class="line">      returnFiber,</span><br><span class="line">      currentFirstChild,</span><br><span class="line">      newChild,</span><br><span class="line">      lanes,</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// debugInfo</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> firstChildFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-5-1-6-reconcileChildFibersImpl"><a href="#1-5-1-6-reconcileChildFibersImpl" class="headerlink" title="1.5.1.6 reconcileChildFibersImpl"></a>1.5.1.6 reconcileChildFibersImpl</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibersImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果newChild是Fragment类型，且没有key，则直接协调其子节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新的child类型，进行不同的处理</span></span><br><span class="line">    <span class="comment">// 单个节点、数组、迭代器、promise、context处理，最常见的react-element元素类型：react中类组件，函数组件，普通dom组件都属于此类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">              debugInfo,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_LAZY_TYPE:</span><br><span class="line">          <span class="keyword">const</span> payload = newChild._payload;</span><br><span class="line">          <span class="keyword">const</span> init = newChild._init;</span><br><span class="line">          <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            init(payload),</span><br><span class="line">            lanes,</span><br><span class="line">            mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2，数组节点的处理，即多个子节点，比如div.App下面有三个子节点</span></span><br><span class="line">      <span class="comment">// 循环创建多个子节点，最后返回第一个子节点，firstChild</span></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, newChild._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Usables are a valid React node type. When React encounters a Usable in</span></span><br><span class="line">      <span class="comment">// a child position, it unwraps it using the same algorithm as `use`. For</span></span><br><span class="line">      <span class="comment">// example, for promises, React will throw an exception to unwind the</span></span><br><span class="line">      <span class="comment">// stack, then replay the component once the promise resolves.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A difference from `use` is that React will keep unwrapping the value</span></span><br><span class="line">      <span class="comment">// until it reaches a non-Usable type.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// e.g. Usable&lt;Usable&lt;Usable&lt;T&gt;&gt;&gt; should resolve to T</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The structure is a bit unfortunate. Ideally, we shouldn't need to</span></span><br><span class="line">      <span class="comment">// replay the entire begin phase of the parent fiber in order to reconcile</span></span><br><span class="line">      <span class="comment">// the children again. This would require a somewhat significant refactor,</span></span><br><span class="line">      <span class="comment">// because reconcilation happens deep within the begin phase, and</span></span><br><span class="line">      <span class="comment">// depending on the type of work, not always at the end. We should</span></span><br><span class="line">      <span class="comment">// consider as an future improvement.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> thenable: Thenable&lt;any&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          unwrapThenable(thenable),</span><br><span class="line">          lanes,</span><br><span class="line">          mergeDebugInfo(debugInfo, thenable._debugInfo),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newChild.$$<span class="keyword">typeof</span> === REACT_CONTEXT_TYPE) &#123;</span><br><span class="line">        <span class="keyword">const</span> context: ReactContext&lt;mixed&gt; = (newChild: any);</span><br><span class="line">        <span class="keyword">return</span> reconcileChildFibersImpl(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          readContextDuringReconcilation(returnFiber, context, lanes),</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3，处理文本子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (<span class="keyword">typeof</span> newChild === <span class="string">'string'</span> &amp;&amp; newChild !== <span class="string">''</span>) ||</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">'number'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          <span class="string">''</span> + newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-6-reconcileSingleElement"><a href="#1-5-1-6-reconcileSingleElement" class="headerlink" title="1.5.1.6 reconcileSingleElement"></a>1.5.1.6 reconcileSingleElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查老的fiber单链表中是否有可以复用的节点</span></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">        <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">            <span class="comment">// 新老都是Fragment</span></span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props.children);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            child.elementType === elementType ||</span><br><span class="line">            <span class="comment">// Keep this check inline so it only runs on the false path:</span></span><br><span class="line">            (__DEV__</span><br><span class="line">              ? isCompatibleFamilyForHotReloading(child, element)</span><br><span class="line">              : <span class="literal">false</span>) ||</span><br><span class="line">            <span class="comment">// Lazy types should reconcile their resolved type.</span></span><br><span class="line">            <span class="comment">// We need to do this after the Hot Reloading check above,</span></span><br><span class="line">            <span class="comment">// because hot reloading has different semantics than prod because</span></span><br><span class="line">            <span class="comment">// it doesn't resuspend. So we can't let the call below suspend.</span></span><br><span class="line">            (<span class="keyword">typeof</span> elementType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">              elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              elementType.$$<span class="keyword">typeof</span> === REACT_LAZY_TYPE &amp;&amp;</span><br><span class="line">              resolveLazy(elementType) === child.type)</span><br><span class="line">          ) &#123;</span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">            coerceRef(returnFiber, child, existing, element);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果key相同，类型不相同。不再查找</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个老节点没法复用</span></span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初次挂载 2. 没有找到可以复用的老节点</span></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        element.props.children,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        lanes,</span><br><span class="line">        element.key,</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据React-element元素对象，创建FiberNode节点</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line">      coerceRef(returnFiber, currentFirstChild, created, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-1-7-createFiberFromElement"><a href="#1-5-1-7-createFiberFromElement" class="headerlink" title="1.5.1.7 createFiberFromElement"></a>1.5.1.7 createFiberFromElement</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> owner = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = element.type; <span class="comment">// 存储原始的组件内容，比如function，class</span></span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">const</span> pendingProps = element.props; <span class="comment">// 等待处理的，最新的props</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber节点： 根据元素的type ，针对组件来说：type值一般为class类 或者Function函数</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiberFromTypeAndProps(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    pendingProps,</span><br><span class="line">    owner,</span><br><span class="line">    mode,</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createFiberFromElement</code> 方法很重要，<code>react</code> 所有 <code>reactElement</code> 元素都是通过这个方法来创建对应的 <code>Fiber</code> 节点。比如常见的 class组件，function组件，原生dom元素等。我们在项目中定义的组件和元素在被编译之后，最终在加载时都会通过jsxRuntime.jsx方法转换为一个reactElement元素对象。</p>
<h5 id="1-5-1-8-createFiberFromTypeAndProps"><a href="#1-5-1-8-createFiberFromTypeAndProps" class="headerlink" title="1.5.1.8 createFiberFromTypeAndProps"></a>1.5.1.8 createFiberFromTypeAndProps</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberFromTypeAndProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: any, <span class="regexp">//</span> React$ElementType</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  owner: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberTag = IndeterminateComponent;</span><br><span class="line">  <span class="keyword">let</span> resolvedType = type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据元素的type进行不同的逻辑处理，class也是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 针对类组件的特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (shouldConstruct(type)) &#123;</span><br><span class="line">      <span class="comment">// 根据type 设置fiberTag 为class组件</span></span><br><span class="line">      fiberTag = ClassComponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通函数组件，没有更新tag【重要，伏笔】</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 原生dom的处理</span></span><br><span class="line">    fiberTag = HostComponent;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他type类型的处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = createFiber(fiberTag, pendingProps, key, mode);</span><br><span class="line">  fiber.elementType = type;</span><br><span class="line">  fiber.type = resolvedType;</span><br><span class="line">  fiber.lanes = lanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在react应用中我们定义的class组件，都是通过继承react的内部组件Component来定义的，所以通过它原型上的isReactComponent属性可以来区分当前组件是不是类组件，返回true则是类组件，返回false则是函数组件。</p>
<p>如果是类组件就会更新fiberTag为ClassComponent的值。</p>
<p>如果是函数组件，这里并没有更新fiberTag，所以函数组件的fiberTag还是为待定的IndeterminateComponent的值。</p>
<p>最后是针对普通的dom元素的处理，更新为HostComponent的值。</p>
<h5 id="1-5-1-9-多子节点的创建-reconcileChildrenArray"><a href="#1-5-1-9-多子节点的创建-reconcileChildrenArray" class="headerlink" title="1.5.1.9 多子节点的创建 - reconcileChildrenArray"></a>1.5.1.9 多子节点的创建 - reconcileChildrenArray</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: Array&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">    debugInfo: ReactDebugInfo | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 存储新生成的child</span></span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// 上一个新建的child</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild; <span class="comment">// 旧的Fiber节点</span></span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ! 1. 从左边往右遍历，比较新老节点，如果节点可以复用，继续往右，否则就停止</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That's</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn't reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we're not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don't want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.1 新节点没了，（老节点还有）。则删除剩余的老节点即可</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We've reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 2.2 (新节点还有)，老节点没了</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don't have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          lanes,</span><br><span class="line">          debugInfo,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">        <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">        pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !2.3 新老节点都还有节点，但是因为老fiber是链表，不方便快速get与delete，</span></span><br><span class="line">    <span class="comment">// !   因此把老fiber链表中的节点放入Map中，后续操作这个Map的get与delete</span></span><br><span class="line">    <span class="comment">// 0 1|   4 5</span></span><br><span class="line">    <span class="comment">// 0 1| 7 8 2 3</span></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        lanes,</span><br><span class="line">        debugInfo,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don't add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !3. 如果是组件更新阶段，此时新节点已经遍历完了，能复用的老节点都用完了，</span></span><br><span class="line">    <span class="comment">// ! 则最后查找Map里是否还有元素，如果有，则证明是新节点里不能复用的，也就是要被删除的元素，此时删除这些元素就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren't consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIsHydrating()) &#123;</span><br><span class="line">      <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">      pushTreeFork(returnFiber, numberOfForks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从 hostFiber 根节点开始，react 的深度优先遍历算法，会一直创建到再无 Child 子节点。</p>
<p>此时叶子结点所对应的Fiber节点创建完成后，它会继续开启属于它的 beginWork 工作，来创建它的子节点，但是因为它已经没有子节点了，所以它最终会返回一个null。</p>
<p>然后一直向上return，直到回到performUnitOfWork方法中：将进入此 Fiber 节点的 completeWork 工作，也就是归的阶段</p>
<h4 id="1-5-2-completeUnitOfWork"><a href="#1-5-2-completeUnitOfWork" class="headerlink" title="1.5.2 completeUnitOfWork"></a>1.5.2 completeUnitOfWork</h4><p>completeWork 代表一个 Fiber 节点的结束工作，completeUnitOfWork 是 completeWork 阶段的入口函数。简单来说，就是生成 dom 树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 取出当前的Fiber节点</span></span><br><span class="line">  <span class="keyword">let</span> completedWork: Fiber = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 取出节点对应的current</span></span><br><span class="line">    <span class="keyword">const</span> current = completedWork.alternate;</span><br><span class="line">    <span class="comment">// 取出节点的父级节点</span></span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="keyword">if</span> (!enableProfilerTimer || (completedWork.mode &amp; ProfileMode) === NoMode) &#123;</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startProfilerTimer(completedWork);</span><br><span class="line">      next = completeWork(current, completedWork, entangledRenderLanes);</span><br><span class="line">      <span class="comment">// Update render duration assuming we didn't error.</span></span><br><span class="line">      stopProfilerTimerIfRunningAndRecordDelta(completedWork, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">      workInProgress = next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个节点的completeWork工作完成后，寻找是否存在兄弟节点</span></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.sibling;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果兄弟节点存在，则设置为新的workInProgress，跳出当前函数，回到performUnitOfWork方法中</span></span><br><span class="line">      <span class="comment">// 这将开始sibling兄弟节点的beginWork工作【自上而下】</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【自下而上的处理】</span></span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则将父级节点设置为completedWork，开始父级节点的completedWork工作</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    <span class="comment">// 更新workInProgress，可能会开启新的beginWork工作</span></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We've reached the root.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === RootInProgress) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>completeUnitOfWork方法中重点就是一个do while循环：<code>completedWork !== null</code>。这个循环的条件是completedWork不等于null，即它是一个有效的Fiber节点。</p>
<h5 id="1-5-2-1-completeWork"><a href="#1-5-2-1-completeWork" class="headerlink" title="1.5.2.1 completeWork"></a>1.5.2.1 completeWork</h5><p>根据tag值区别不同fiber<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-2.png" alt="alt text"></p>
<h5 id="1-5-2-2-bubbleProperties"><a href="#1-5-2-2-bubbleProperties" class="headerlink" title="1.5.2.2 bubbleProperties"></a>1.5.2.2 bubbleProperties</h5><p>向上冒泡 subtreeFlags 和 childLanes</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleProperties</span>(<span class="params">completedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.alternate.child === completedWork.child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = NoLanes;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="comment">// “向上冒泡”最早的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// ! 2. 将他们的subtreeFlags和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 子树的flags</span></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “静态”标志（Static flags）与它们所属的 Fiber 或 Hook 共享生命周期，因此即使在放弃（bailout）时，也应该将这些flags向上冒泡。</span></span><br><span class="line">        <span class="comment">// 而其他所有flags仅在单次render + commit 的生命周期内存在，因此我们应该忽略它们。</span></span><br><span class="line">        <span class="comment">// ! 2. 将他们的（subtreeFlags&amp;StaticMask)和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新return pointer以保持树的一致性。这被描述为一种代码异味（code smell），因为它假设commit阶段永远不会与 render 阶段并发。</span></span><br><span class="line">        <span class="comment">// 在重构为交替模型（alternate model）时将会解决这个问题。</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 后代节点的lanes</span></span><br><span class="line">  completedWork.childLanes = newChildLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中"><a href="#1-5-2-3-createInstance-创建-DOM-节点，并添加到父节点中" class="headerlink" title="1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中"></a>1.5.2.3 createInstance, 创建 DOM 节点，并添加到父节点中</h5><p>如果组件是HostComponent，即原生标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = createInstance(</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext,</span><br><span class="line">    workInProgress,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 把DOM子节点添加到父DOM节点中去</span></span><br><span class="line">appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 当节点是原生标签，比如div、span等，会在这里添加到fiber属性stateNode上</span></span><br><span class="line">workInProgress.stateNode = instance;</span><br></pre></td></tr></table></figure>

<h5 id="总结执行流程图"><a href="#总结执行流程图" class="headerlink" title="总结执行流程图"></a>总结执行流程图</h5><p><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-3.png" alt="alt text"></p>
<h3 id="1-6-重置-workInProgressX"><a href="#1-6-重置-workInProgressX" class="headerlink" title="1.6 重置 workInProgressX"></a>1.6 重置 workInProgressX</h3><p>这里没有重置 workInProgress，因为 workInProgress 已经在 performUnitOfWork 阶段更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 5. 重置</span></span><br><span class="line">  <span class="comment">// 重置Context的相关值，如currentlyRenderingFiber等</span></span><br><span class="line">  resetContextDependencies();</span><br><span class="line">  <span class="comment">// 重置 executionContext</span></span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set this to null to indicate there's no in-progress render.</span></span><br><span class="line">  <span class="comment">// 设置为null，表示没有进行中的render了</span></span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-再遍历一遍更新队列"><a href="#1-7-再遍历一遍更新队列" class="headerlink" title="1.7 再遍历一遍更新队列"></a>1.7 再遍历一遍更新队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishQueueingConcurrentUpdates()</span><br></pre></td></tr></table></figure>

<h3 id="管理更新队列-finishQueueingConcurrentUpdates"><a href="#管理更新队列-finishQueueingConcurrentUpdates" class="headerlink" title="管理更新队列 finishQueueingConcurrentUpdates"></a>管理更新队列 finishQueueingConcurrentUpdates</h3><p><code>finishQueueingConcurrentUpdates</code> 把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中，后续才是根据 <code>VDOM</code> 更新 <code>DOM</code></p>
<p>在 <code>render</code> 阶段，有两处调⽤ <code>finishQueueingConcurrentUpdates</code> ，分别是</p>
<ol>
<li><code>render</code> 开始的时候，在 <code>prepareFreshStack</code> 函数中；<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image.png" alt="alt text"></li>
<li>在 <code>render</code> 结束的时候，最后再调⽤⼀遍。<br><img src="../images/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89render-render%E9%98%B6%E6%AE%B5/image-1.png" alt="alt text"></li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">finishQueueingConcurrentUpdates</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> endIndex = concurrentQueuesIndex;</span><br><span class="line">  concurrentQueuesIndex = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  concurrentlyUpdatedLanes = NoLanes; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; endIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber: Fiber = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> queue: ConcurrentQueue = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> update: ConcurrentUpdate = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> lane: Lane = concurrentQueues[i];</span><br><span class="line">    concurrentQueues[i++] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这里构建完之后的fiber.updateQueue.shared.pending数据类型是Update，但是其实这里构建成了一个单向循环链表。</span></span><br><span class="line">    <span class="comment">// 所以fiber.updateQueue.shared.pending其实是指最后一个update，它的next指向的是第一个update</span></span><br><span class="line">    <span class="keyword">if</span> (queue !== <span class="literal">null</span> &amp;&amp; update !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">      <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">        update.next = update;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update.next = pending.next;</span><br><span class="line">        pending.next = update;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.pending = update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// 更新fiber.lanes</span></span><br><span class="line">    <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">      markUpdateLaneFromFiberToRoot(fiber, update, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="markUpdateLaneFromFiberToRoot"><a href="#markUpdateLaneFromFiberToRoot" class="headerlink" title="markUpdateLaneFromFiberToRoot"></a>markUpdateLaneFromFiberToRoot</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  sourceFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: ConcurrentUpdate | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update the source fiber's lanes</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="keyword">let</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Walk the parent path to the root and update the child lanes.</span></span><br><span class="line">  <span class="comment">// 从当前节点开始，往上找到根节点，更新childLanes</span></span><br><span class="line">  <span class="keyword">let</span> isHidden = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);</span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent.tag === OffscreenComponent) &#123;</span><br><span class="line">      <span class="keyword">const</span> offscreenInstance: OffscreenInstance | <span class="literal">null</span> = parent.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        offscreenInstance !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(offscreenInstance._visibility &amp; OffscreenVisible)</span><br><span class="line">      ) &#123;</span><br><span class="line">        isHidden = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理更新队列-processUpdateQueue"><a href="#处理更新队列-processUpdateQueue" class="headerlink" title="处理更新队列 processUpdateQueue"></a>处理更新队列 processUpdateQueue</h3><p>这个函数⽤来处理更新队列。</p>
<p><code>processUpdateQueue</code> 在 <code>beginWork</code> 阶段会被两个地⽅调⽤：</p>
<ol>
<li><p>updateHostRoot <font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br></pre></td></tr></table></figure></li>
<li><p>updateClassInstance <font color=gray><em>packages\react-reconciler\src\ReactFiberClassComponent.js</em></font></p>
<p>在类组件的 mount、resumeMount、更新阶段，均会调⽤。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="processUpdateQueue-流程"><a href="#processUpdateQueue-流程" class="headerlink" title="processUpdateQueue 流程"></a>processUpdateQueue 流程</h4><ol>
<li><p>检查是否有 pending update。</p>
<ol>
<li>如果有，将它们转移到 baseQueue。</li>
<li>pending update 是个单向循环链表，转移到 单链表 firstBaseUpdate-&gt;…-&gt;lastBaseUpdate 中去。</li>
</ol>
</li>
<li><p>遍历 queue，根据这些 update 计算出最后的结果</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理这个更新</span></span><br><span class="line">newState = getStateFromUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    queue,</span><br><span class="line">    update,</span><br><span class="line">    newState,</span><br><span class="line">    props,</span><br><span class="line">    instance,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>更新到 fiber 上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.lanes = newLanes;</span><br><span class="line">workInProgress.memoizedState = newState; <span class="comment">// 更新状态</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89scheduleUpdateOnFiber%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89scheduleUpdateOnFiber%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0.html" class="post-title-link" itemprop="url">react18.2源码分析（二）scheduleUpdateOnFiber调度更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2024-06-10T00:00:00+08:00">2024-06-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react源码分析（二）scheduleUpdateOnFiber调度更新"><a href="#react源码分析（二）scheduleUpdateOnFiber调度更新" class="headerlink" title="react源码分析（二）scheduleUpdateOnFiber调度更新"></a>react源码分析（二）scheduleUpdateOnFiber调度更新</h1><p><code>scheduleUpdateOnFiber</code> 函数主要是触发一个在 <code>Fiber</code> 节点上的调度更新任务，⻚⾯初次渲染、类组件 <code>setState/forceUpdate</code>、函数组件 <code>setState</code> 都会⾛到更新，都会调⽤ <code>scheduleUpdateOnFiber</code> 函数。</p>
<p>如果以下源码没有特殊标记路径，那么路径都和 <code>scheduleUpdateOnFiber</code> ⼀样，即 <font color=gray><em>packages/react-reconciler/src/ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 标记根节点有一个 pending update，即待处理的更新。</span></span><br><span class="line">  markRootUpdated(root, lane);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoLanes &amp;&amp;</span><br><span class="line">    root === workInProgressRoot</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 这个更新是在渲染阶段期间发送的。</span></span><br><span class="line">    <span class="comment">// 如果更新源自用户空间（除了本地hook update之外，hook update会被单独处理，不会到达这个函数），那么这是一个错误。</span></span><br><span class="line">    <span class="comment">// 但是，有一些内部的 React 功能将这个作为实现细节，比如选择性hydration。</span></span><br><span class="line">    warnAboutRenderPhaseUpdatesInDEV(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track lanes that were updated during the render phase</span></span><br><span class="line">    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(</span><br><span class="line">      workInProgressRootRenderPhaseUpdatedLanes,</span><br><span class="line">      lane,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面初次渲染时候，此时workInProgressRoot还是null</span></span><br><span class="line">    <span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">      <span class="comment">// Received an update to a tree that's in the middle of rendering. Mark</span></span><br><span class="line">      <span class="comment">// that there was an interleaved update work on this root.</span></span><br><span class="line">      <span class="keyword">if</span> ((executionContext &amp; RenderContext) === NoContext) &#123;</span><br><span class="line">        workInProgressRootInterleavedUpdatedLanes = mergeLanes(</span><br><span class="line">          workInProgressRootInterleavedUpdatedLanes,</span><br><span class="line">          lane,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123;</span><br><span class="line">        <span class="comment">// The root already suspended with a delay, which means this render</span></span><br><span class="line">        <span class="comment">// definitely won't finish. Since we have a new update, let's mark it as</span></span><br><span class="line">        <span class="comment">// suspended now, right before marking the incoming update. This has the</span></span><br><span class="line">        <span class="comment">// effect of interrupting the current render and switching to the update.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Make sure this doesn't override pings that happen while we've</span></span><br><span class="line">        <span class="comment">// already started rendering.</span></span><br><span class="line">        markRootSuspended(</span><br><span class="line">          root,</span><br><span class="line">          workInProgressRootRenderLanes,</span><br><span class="line">          workInProgressDeferredLane,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 开始调度</span></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      lane === SyncLane &amp;&amp;</span><br><span class="line">      executionContext === NoContext &amp;&amp;</span><br><span class="line">      (fiber.mode &amp; ConcurrentMode) === NoMode</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactCurrentActQueue.isBatchingLegacy) &#123;</span><br><span class="line">        <span class="comment">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Flush the synchronous work now, unless we're already working or inside</span></span><br><span class="line">        <span class="comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span></span><br><span class="line">        <span class="comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span></span><br><span class="line">        <span class="comment">// without immediately flushing it. We only do this for user-initiated</span></span><br><span class="line">        <span class="comment">// updates, to preserve historical behavior of legacy mode.</span></span><br><span class="line">        resetRenderTimer();</span><br><span class="line">        flushSyncWorkOnLegacyRootsOnly();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-markRootUpdated"><a href="#1-markRootUpdated" class="headerlink" title="1. markRootUpdated"></a>1. markRootUpdated</h2><p>标记根节点有一个 pending update，即待处理的更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markRootUpdated(root, lane);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root: FiberRoot, updatedLanes: Lanes</span>) </span>&#123;</span><br><span class="line">  _markRootUpdated(root, updatedLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableInfiniteRenderLoopDetection) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Check for recursive updates</span></span><br><span class="line">    <span class="keyword">if</span> (executionContext &amp; RenderContext) &#123;</span><br><span class="line">      workInProgressRootDidIncludeRecursiveRenderUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (executionContext &amp; CommitContext) &#123;</span><br><span class="line">      didIncludeCommitPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getRootForUpdatedFiber中也有这个检测</span></span><br><span class="line">    <span class="comment">// 如果循环超过限制次数(50次)，抛出错误。比如在类组件的render函数里执行setState</span></span><br><span class="line">    throwIfInfiniteUpdateLoopDetected();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>_markRootUpdated</code> 来自 packages\react-reconciler\src\ReactFiberLane.js 的 <code>markRootUpdated</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root: FiberRoot, updateLane: Lane</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置本次更新的优先级, 标记其有正在等待更新的任务,此时挂载的优先级将会后在后续被转换为调度优先级，方便调度程序的使用。</span></span><br><span class="line">  root.pendingLanes |= updateLane;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果update是idle的，将不会处理它，因为我们直到所有常规update完成后才会处理idle更新；</span></span><br><span class="line">  <span class="keyword">if</span> (updateLane !== IdleLane) &#123;</span><br><span class="line">    root.suspendedLanes = NoLanes; <span class="comment">//【由于Suspense而挂起的update对应的lane集合】</span></span><br><span class="line">    root.pingedLanes = NoLanes; <span class="comment">// 【由于请求成功，Suspense取消挂起的update对应的Lane集合】</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>markRootUpdated</code> 主要做的就是设置本次更新的优先级，标记其有正在等待更新的任务，此时挂载的优先级将会后在后续被转换为调度优先级，方便调度程序的使用。</p>
<h2 id="2-ensureRootIsScheduled-root"><a href="#2-ensureRootIsScheduled-root" class="headerlink" title="2. ensureRootIsScheduled(root)"></a>2. ensureRootIsScheduled(root)</h2><p>每次 root: FiberRoot 接收 update 的时候，这个函数都会被调⽤。</p>
<ol>
<li>确保 root 在 root 调度中</li>
<li>确保有⼀个待处理的微任务来处理根调度</li>
</ol>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="comment">// 一般应用中，只有一个根节点，但是React支持多个根节点。</span></span><br><span class="line"><span class="keyword">let</span> firstScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastScheduledRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 用于没有同步work的时候，快速退出flushSync</span></span><br><span class="line"><span class="keyword">let</span> mightHavePendingSyncWork: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 把root添加到调度中</span></span><br><span class="line">  <span class="keyword">if</span> (root === lastScheduledRoot || root.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ? 后两次</span></span><br><span class="line">    <span class="comment">// Fast path. This root is already scheduled.</span></span><br><span class="line">    <span class="comment">// 已经添加到了调度中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ? sy 前一次</span></span><br><span class="line">    <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 多个根节点</span></span><br><span class="line">      lastScheduledRoot.next = root;</span><br><span class="line">      lastScheduledRoot = root;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每当root接收到update，我们将其设置为true，直到下次处理调度为止。如果为false，那么我们可以在不查看调度的情况下快速退出 flushSync。</span></span><br><span class="line">  mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前事件结束时，逐个检查每个root，并确保为每个root安排了正确优先级的任务。</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactCurrentActQueue.current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!enableDeferRootSchedulingToMicrotask) &#123;</span><br><span class="line">    <span class="comment">// While this flag is disabled, we schedule the render task immediately</span></span><br><span class="line">    <span class="comment">// instead of waiting a microtask.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We need to land enableDeferRootSchedulingToMicrotask ASAP to</span></span><br><span class="line">    <span class="comment">// unblock additional features we have planned.</span></span><br><span class="line">    scheduleTaskForRootDuringMicrotask(root, now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-scheduleImmediateTask"><a href="#2-1-scheduleImmediateTask" class="headerlink" title="2.1 scheduleImmediateTask"></a>2.1 scheduleImmediateTask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleImmediateTask</span>(<span class="params">cb: (</span>) =&gt; <span class="title">mixed</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Can we land supportsMicrotasks? Which environments don't support it?</span></span><br><span class="line">  <span class="comment">// Alternatively, can we move this check to the host config?</span></span><br><span class="line">  <span class="keyword">if</span> (supportsMicrotasks) &#123;</span><br><span class="line">    <span class="comment">// sy-</span></span><br><span class="line">    scheduleMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// In Safari, appending an iframe forces microtasks to run.</span></span><br><span class="line">       <span class="comment">// 在Safari中，附加一个iframe会强制微任务运行。</span></span><br><span class="line">      <span class="comment">// https://github.com/facebook/react/issues/22459</span></span><br><span class="line">      <span class="comment">// We don't support running callbacks in the middle of render</span></span><br><span class="line">      <span class="comment">// or commit so we need to check against that.</span></span><br><span class="line">      <span class="comment">// 在渲染或提交过程中我们不支持运行回调函数，因此我们需要进行检查。</span></span><br><span class="line">      <span class="keyword">const</span> executionContext = getExecutionContext();</span><br><span class="line">      <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">        <span class="comment">// sy-no</span></span><br><span class="line">        <span class="comment">// Note that this would still prematurely flush the callbacks</span></span><br><span class="line">        <span class="comment">// if this happens outside render or commit phase (e.g. in an event).</span></span><br><span class="line">        <span class="comment">// 如果这种情况发生在render或commit阶段之外（例如在事件中），这仍然会过早地刷新回调函数。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intentionally using a macrotask instead of a microtask here. This is</span></span><br><span class="line">        <span class="comment">// wrong semantically but it prevents an infinite loop. The bug is</span></span><br><span class="line">        <span class="comment">// Safari's, not ours, so we just do our best to not crash even though</span></span><br><span class="line">        <span class="comment">// the behavior isn't completely correct.</span></span><br><span class="line">        <span class="comment">// 在这里故意使用宏任务而不是微任务。这在语义上是错误的，但它可以防止无限循环。</span></span><br><span class="line">        <span class="comment">// 这个 bug 是 Safari 的问题，而不是我们的问题，所以我们尽力避免崩溃，即使行为并不完全正确。</span></span><br><span class="line">        Scheduler_scheduleCallback(ImmediateSchedulerPriority, cb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If microtasks are not supported, use Scheduler.</span></span><br><span class="line">    Scheduler_scheduleCallback(ImmediateSchedulerPriority, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-scheduleMicrotask"><a href="#2-1-1-scheduleMicrotask" class="headerlink" title="2.1.1 scheduleMicrotask"></a>2.1.1 scheduleMicrotask</h4><p><font color=gray><em>packages\react-dom-bindings\src\client\ReactFiberConfigDOM.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> scheduleMicrotask: any =</span><br><span class="line">  <span class="keyword">typeof</span> queueMicrotask === <span class="string">'function'</span></span><br><span class="line">    ? queueMicrotask</span><br><span class="line">    : <span class="keyword">typeof</span> localPromise !== <span class="string">'undefined'</span></span><br><span class="line">    ? <span class="function"><span class="params">callback</span> =&gt;</span></span><br><span class="line">        localPromise.resolve(<span class="literal">null</span>).then(callback).catch(handleErrorInNextTick)</span><br><span class="line">    : scheduleTimeout; <span class="comment">// <span class="doctag">TODO:</span> Determine the best fallback here.</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-processRootScheduleInMicrotask"><a href="#2-2-processRootScheduleInMicrotask" class="headerlink" title="2.2 processRootScheduleInMicrotask"></a>2.2 processRootScheduleInMicrotask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，它绝对不应该被同步调用。</span></span><br><span class="line">  didScheduleMicrotask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们将在遍历所有roots并调度它们时重新计算这个</span></span><br><span class="line">  mightHavePendingSyncWork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> root = firstScheduledRoot;</span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> next = root.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      currentEventTransitionLane !== NoLane &amp;&amp;</span><br><span class="line">      shouldAttemptEagerTransition()</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// A transition was scheduled during an event, but we're going to try to</span></span><br><span class="line">      <span class="comment">// render it synchronously anyway. We do this during a popstate event to</span></span><br><span class="line">      <span class="comment">// preserve the scroll position of the previous page.</span></span><br><span class="line">      upgradePendingLaneToSync(root, currentEventTransitionLane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="keyword">if</span> (nextLanes === NoLane) &#123;</span><br><span class="line">      <span class="comment">// ? sy second</span></span><br><span class="line">      <span class="comment">// 页面初次渲染，再执行这里。nextLanes=0</span></span><br><span class="line">      <span class="comment">// This root has no more pending work. Remove it from the schedule. To</span></span><br><span class="line">      <span class="comment">// guard against subtle reentrancy bugs, this microtask is the only place</span></span><br><span class="line">      <span class="comment">// we do this — you can add roots to the schedule whenever, but you can</span></span><br><span class="line">      <span class="comment">// only remove them here.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Null this out so we know it's been removed from the schedule.</span></span><br><span class="line">      <span class="comment">//root 没有更多pending work。从调度中移除它。为了防止微妙的重入bug，这个microtask是我们唯一执行此操作的地方 — 你可以随时将roots添加到调度中，但只能在这里将它们移除。</span></span><br><span class="line">      <span class="comment">// 将其置null，以便我们知道它已从调度中移除</span></span><br><span class="line">      root.next = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (prev === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">        <span class="comment">// This is the new head of the list</span></span><br><span class="line">        firstScheduledRoot = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">        <span class="comment">// This is the new tail of the list</span></span><br><span class="line">        lastScheduledRoot = prev;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ? sy first</span></span><br><span class="line">      <span class="comment">// 页面初次渲染，先执行这里。nextLanes=32</span></span><br><span class="line">      <span class="comment">// This root still has work. Keep it in the list.</span></span><br><span class="line">      prev = root;</span><br><span class="line">      <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">      <span class="comment">// ? sy-no</span></span><br><span class="line">        mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentEventTransitionLane = NoLane;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At the end of the microtask, flush any pending synchronous work. This has</span></span><br><span class="line">  <span class="comment">// to come at the end, because it does actual rendering work that might throw.</span></span><br><span class="line">  <span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line">  <span class="comment">// onClick count</span></span><br><span class="line">  flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-scheduleTaskForRootDuringMicrotask"><a href="#2-3-scheduleTaskForRootDuringMicrotask" class="headerlink" title="2.3 scheduleTaskForRootDuringMicrotask"></a>2.3 scheduleTaskForRootDuringMicrotask</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRootScheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，或者在渲染任务的最后，在我们将控制权交还给主线程之前被调用。它绝对不应该被同步调用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有任何lanes被其他work饿死。如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们。</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">  <span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line">  <span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于root.pendingLanes，计算出本次更新的批次Lanes</span></span><br><span class="line">  <span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// 如果优先级等于0 ，说明根节点没有可处理的回调，则退出任务调度</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Check if there's nothing to work on</span></span><br><span class="line">    nextLanes === NoLanes ||</span><br><span class="line">    <span class="comment">// If this root is currently suspended and waiting for data to resolve, don't</span></span><br><span class="line">    <span class="comment">// schedule a task to render it. We'll either wait for a ping, or wait to</span></span><br><span class="line">    <span class="comment">// receive an update.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Suspended render phase</span></span><br><span class="line">    (root === workInProgressRoot &amp;&amp; isWorkLoopSuspendedOnData()) ||</span><br><span class="line">    <span class="comment">// Suspended commit phase</span></span><br><span class="line">    root.cancelPendingCommit !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There's nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="keyword">return</span> NoLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a new callback in the host environment.</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// sy- setState</span></span><br><span class="line">    <span class="comment">// sy-no 初次渲染</span></span><br><span class="line">    <span class="comment">// Synchronous work is always flushed at the end of the microtask, so we</span></span><br><span class="line">    <span class="comment">// don't need to schedule an additional task.</span></span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        ReactCurrentActQueue.current !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn't changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We'll schedule a new one below.</span></span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个【调度的优先级】，因为react事件优先级和scheduler的优先级不同，需要经过转换【即：事件优先级转换为调度优先级】</span></span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="comment">// lanes转换成事件优先级，匹配符合的优先级，然后赋值对应的scheduler的优先级</span></span><br><span class="line">    <span class="keyword">switch</span> (lanesToEventPriority(nextLanes)) &#123;</span><br><span class="line">      <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">        schedulerPriorityLevel = ImmediateSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">        schedulerPriorityLevel = UserBlockingSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DefaultEventPriority: <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// ? sy 页面初次渲染、transition(128)</span></span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdleEventPriority:</span><br><span class="line">        schedulerPriorityLevel = IdleSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-markStarvedLanesAsExpired"><a href="#2-3-1-markStarvedLanesAsExpired" class="headerlink" title="2.3.1 markStarvedLanesAsExpired"></a>2.3.1 markStarvedLanesAsExpired</h4><p>检查是否有lanes挨饿，如果有，则标记他们过期，以便下次执行。详情参考lanes文章。</p>
<h4 id="2-3-2-getWorkInProgressRoot"><a href="#2-3-2-getWorkInProgressRoot" class="headerlink" title="2.3.2 getWorkInProgressRoot"></a>2.3.2 getWorkInProgressRoot</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> workInProgressRoot: FiberRoot | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getWorkInProgressRoot</span>(<span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> workInProgressRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-getWorkInProgressRootRenderLanes"><a href="#2-3-3-getWorkInProgressRootRenderLanes" class="headerlink" title="2.3.3 getWorkInProgressRootRenderLanes"></a>2.3.3 getWorkInProgressRootRenderLanes</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getWorkInProgressRootRenderLanes</span>(<span class="params"></span>): <span class="title">Lanes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> workInProgressRootRenderLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-getNextLanes"><a href="#2-3-4-getNextLanes" class="headerlink" title="2.3.4 getNextLanes"></a>2.3.4 getNextLanes</h4><p>获取本次更新的lanes。详情参考lanes文章。</p>
<h4 id="2-3-5-lanesToEventPriority"><a href="#2-3-5-lanesToEventPriority" class="headerlink" title="2.3.5 lanesToEventPriority"></a>2.3.5 lanesToEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lanesToEventPriority</span>(<span class="params">lanes: Lanes</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据优先级最高的lane，返回对应的 EventPriority。这里对应Scheduler包中的优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = getHighestPriorityLane(lanes);</span><br><span class="line">  <span class="keyword">if</span> (!isHigherEventPriority(DiscreteEventPriority, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isHigherEventPriority(ContinuousEventPriority, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (includesNonIdleWork(lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-scheduleCallback"><a href="#2-3-6-scheduleCallback" class="headerlink" title="2.3.6 scheduleCallback"></a>2.3.6 scheduleCallback</h4><p>进入 schedule 调度器.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  priorityLevel: PriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: RenderTaskFn,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Scheduler_scheduleCallback(priorityLevel, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scheduler_scheduleCallback 最终来自 <font color=gray><em>packages\scheduler\src\forks\Scheduler.js</em></font> 的 unstable_scheduleCallback，在 react调度器scheduler源码分析 会详细讲到。</p>
<h4 id="2-3-7-performConcurrentWorkOnRoot"><a href="#2-3-7-performConcurrentWorkOnRoot" class="headerlink" title="2.3.7 performConcurrentWorkOnRoot"></a>2.3.7 performConcurrentWorkOnRoot</h4><p>具体看 render 阶段文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD.html" class="post-title-link" itemprop="url">react18.2源码分析（一） 应用加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-01T00:00:00+08:00">2024-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-入口-createRoot-API"><a href="#1-入口-createRoot-API" class="headerlink" title="1. 入口 - createRoot API"></a>1. 入口 - createRoot API</h2><p><code>createRoot</code> 允许在浏览器的 DOM 节点创建根节点以显示 React 组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"><span class="keyword">import</span> jsx <span class="keyword">from</span> <span class="string">"./pages/ExamplePage"</span>;</span><br><span class="line"><span class="keyword">const</span> root = createRoot(<span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">root.render(jsx);</span><br></pre></td></tr></table></figure>

<p><code>createRoot</code> 接收两个参数 <code>container</code> 和 <code>options</code>，返回一个 <code>RootType</code> 类型，即 <code>ReactDOMRoot</code> 的实例。</p>
<p><font color=gray><em>packages\react-dom\src\client\ReactDOMRoot.js</em></font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">export type RootType &#x3D; &#123;</span><br><span class="line">  render(children: ReactNodeList): void,</span><br><span class="line">  unmount(): void,</span><br><span class="line">  _internalRoot: FiberRoot | null,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export type CreateRootOptions &#x3D; &#123;</span><br><span class="line">  unstable_strictMode?: boolean,</span><br><span class="line">  unstable_concurrentUpdatesByDefault?: boolean,</span><br><span class="line">  unstable_transitionCallbacks?: TransitionTracingCallbacks,</span><br><span class="line">  identifierPrefix?: string,</span><br><span class="line">  onRecoverableError?: (error: mixed) &#x3D;&gt; void,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export function createRoot(</span><br><span class="line">  container: Element | Document | DocumentFragment,</span><br><span class="line">  options?: CreateRootOptions, &#x2F;&#x2F; 有两个参数可用，其余的属于非稳定值，不要使用</span><br><span class="line">): RootType &#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 检查container是否是DOM</span><br><span class="line">  if (!isValidContainer(container)) &#123;</span><br><span class="line">    throw new Error(&#39;createRoot(...): Target container is not a DOM element.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  warnIfReactDOMContainerInDEV(container);</span><br><span class="line"></span><br><span class="line">  let isStrictMode &#x3D; false;</span><br><span class="line">  let concurrentUpdatesByDefaultOverride &#x3D; false;</span><br><span class="line">  let identifierPrefix &#x3D; &#39;&#39;;</span><br><span class="line">  let onRecoverableError &#x3D; defaultOnRecoverableError;</span><br><span class="line">  let transitionCallbacks &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. 检查options</span><br><span class="line">  if (options !&#x3D;&#x3D; null &amp;&amp; options !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">    if (options.unstable_strictMode &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">      isStrictMode &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (</span><br><span class="line">      allowConcurrentByDefault &amp;&amp;</span><br><span class="line">      options.unstable_concurrentUpdatesByDefault &#x3D;&#x3D;&#x3D; true</span><br><span class="line">    ) &#123;</span><br><span class="line">      concurrentUpdatesByDefaultOverride &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options.identifierPrefix !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      identifierPrefix &#x3D; options.identifierPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options.onRecoverableError !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      onRecoverableError &#x3D; options.onRecoverableError;</span><br><span class="line">    &#125;</span><br><span class="line">    if (options.unstable_transitionCallbacks !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      transitionCallbacks &#x3D; options.unstable_transitionCallbacks;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 创建FiberRoot</span><br><span class="line">  const root: FiberRoot &#x3D; createContainer(</span><br><span class="line">    container,</span><br><span class="line">    ConcurrentRoot,</span><br><span class="line">    null,</span><br><span class="line">    isStrictMode,</span><br><span class="line">    concurrentUpdatesByDefaultOverride,</span><br><span class="line">    identifierPrefix,</span><br><span class="line">    onRecoverableError,</span><br><span class="line">    transitionCallbacks,</span><br><span class="line">  );</span><br><span class="line">  &#x2F;&#x2F; 4. 标记Container是根Fiber</span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  Dispatcher.current &#x3D; ReactDOMClientDispatcher;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; comment nodes 已弃用，这里是为了兼容FB老代码 https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;pull&#x2F;24110</span><br><span class="line">  const rootContainerElement: Document | Element | DocumentFragment &#x3D;</span><br><span class="line">    container.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE</span><br><span class="line">      ? (container.parentNode: any)</span><br><span class="line">      : container;</span><br><span class="line">  &#x2F;&#x2F; 5. 从Container层监听listenToAllSupportedEvents</span><br><span class="line">  listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 6. 返回ReactDOMRoot实例</span><br><span class="line">  return new ReactDOMRoot(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-检查container是否是DOM"><a href="#1-检查container是否是DOM" class="headerlink" title="1. 检查container是否是DOM"></a>1. 检查container是否是DOM</h3><p>如果不是，则抛出错误提示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isValidContainer(container)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'createRoot(...): Target container is not a DOM element.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-检查options"><a href="#2-检查options" class="headerlink" title="2. 检查options"></a>2. 检查options</h3><p>⽬前⽂档中有两个参数可⽤： onRecoverableError 与 identifierPrefix 。</p>
<p>但是源码中实际上还有⼀些 unstable 值，属于⾮稳定值，不要使⽤.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CreateRootOptions = &#123;</span><br><span class="line">  unstable_strictMode?: <span class="built_in">boolean</span>,</span><br><span class="line">  unstable_concurrentUpdatesByDefault?: <span class="built_in">boolean</span>,</span><br><span class="line">  unstable_transitionCallbacks?: TransitionTracingCallbacks,</span><br><span class="line">  identifierPrefix?: <span class="built_in">string</span>,</span><br><span class="line">  onRecoverableError?: <span class="function">(<span class="params">error: mixed</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-createContainer-创建-FiberRoot，-即root"><a href="#3-createContainer-创建-FiberRoot，-即root" class="headerlink" title="3. createContainer 创建 FiberRoot， 即root"></a>3. createContainer 创建 FiberRoot， 即root</h3><p>这⾥的 <code>containerInfo</code> 就是根 <code>dom</code> 节点。(就是那个 id 为 root 的div)。这个变量在 <code>createRoot</code> ⾥叫 <code>container</code> ，到这⾥换名成了 <code>containerInfo</code> 。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberReconciler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">  isStrictMode: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  concurrentUpdatesByDefaultOverride: null | boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  identifierPrefix: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  onRecoverableError: (error: mixed</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">transitionCallbacks</span>: <span class="title">null</span> | <span class="title">TransitionTracingCallbacks</span>,</span></span><br><span class="line"><span class="function">): <span class="title">OpaqueRoot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hydrate = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> initialChildren = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(</span><br><span class="line">    containerInfo,</span><br><span class="line">    tag,</span><br><span class="line">    hydrate,</span><br><span class="line">    initialChildren,</span><br><span class="line">    hydrationCallbacks,</span><br><span class="line">    isStrictMode,</span><br><span class="line">    concurrentUpdatesByDefaultOverride,</span><br><span class="line">    identifierPrefix,</span><br><span class="line">    onRecoverableError,</span><br><span class="line">    transitionCallbacks,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createFiberRoot</code> 创建并返回 <code>FiberRoot</code></p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberRoot.js</em></font></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialChildren: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">  isStrictMode: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  concurrentUpdatesByDefaultOverride: <span class="literal">null</span> | <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// <span class="doctag">TODO:</span> We have several of these arguments that are conceptually part of the</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// host config, but because they are passed in at runtime, we have to thread</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// them through the root constructor. Perhaps we should put them all into a</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// single type, like a DynamicHostConfig that is defined by the renderer.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  identifierPrefix: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  onRecoverableError: <span class="literal">null</span> | ((error: mixed) =&gt; <span class="built_in">void</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">  transitionCallbacks: <span class="literal">null</span> | TransitionTracingCallbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">  formState: ReactFormState&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. fiberRoot 表示Fiber数据结构对象， 是Fiber数据结构中的最外层对象。</span></span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = (<span class="keyword">new</span> FiberRootNode(</span><br><span class="line">    containerInfo,</span><br><span class="line">    tag,</span><br><span class="line">    hydrate,</span><br><span class="line">    identifierPrefix,</span><br><span class="line">    onRecoverableError,</span><br><span class="line">    formState,</span><br><span class="line">  ): <span class="built_in">any</span>);</span><br><span class="line">  <span class="comment">// 2. rootFiber表示组件挂载点对应的Fiber对象，比如React应用中默认的组件挂载点就是id为root的div。</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber: Fiber = createHostRootFiber(</span><br><span class="line">    tag,</span><br><span class="line">    isStrictMode,</span><br><span class="line">    concurrentUpdatesByDefaultOverride,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 3. 循环构造root 和 uninitializedFiber</span></span><br><span class="line">  <span class="comment">// fiberRoot包含rootFiber，在fiberRoot对象中有一个current属性，存储rootFiber。</span></span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  <span class="comment">// rootFiber指向fiberRoot，在rootFiber对象中有一个stateNode属性，指向fiberRoot。</span></span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在React应用中，可支持多个根节点fiberRoot，每一个 fiberRoot 下可以有多个 rootFiber ，因为 render 方法是可以调用多次的。</span></span><br><span class="line">  <span class="comment">// FiberRoot 会记录应用的更新信息，比如协调器在完成工作后，会将工作成果存储在fiberRoot中。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    <span class="comment">// sy</span></span><br><span class="line">    <span class="keyword">const</span> initialCache = createCache();</span><br><span class="line">    retainCache(initialCache);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pooledCache is a fresh cache instance that is used temporarily</span></span><br><span class="line">    <span class="comment">// for newly mounted boundaries during a render. In general, the</span></span><br><span class="line">    <span class="comment">// pooledCache is always cleared from the root at the end of a render:</span></span><br><span class="line">    <span class="comment">// it is either released when render commits, or moved to an Offscreen</span></span><br><span class="line">    <span class="comment">// component if rendering suspends. Because the lifetime of the pooled</span></span><br><span class="line">    <span class="comment">// cache is distinct from the main memoizedState.cache, it must be</span></span><br><span class="line">    <span class="comment">// retained separately.</span></span><br><span class="line">    root.pooledCache = initialCache;</span><br><span class="line">    retainCache(initialCache);</span><br><span class="line">    <span class="keyword">const</span> initialState: RootState = &#123;</span><br><span class="line">      element: initialChildren,</span><br><span class="line">      isDehydrated: hydrate,</span><br><span class="line">      cache: initialCache,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.memoizedState = initialState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState: RootState = &#123;</span><br><span class="line">      element: initialChildren,</span><br><span class="line">      isDehydrated: hydrate,</span><br><span class="line">      cache: (<span class="literal">null</span>: <span class="built_in">any</span>), <span class="comment">// not enabled yet</span></span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.memoizedState = initialState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 初始化 initializeUpdateQueue</span></span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-实例化-FiberRootNode，创建-FiberRoot"><a href="#3-1-实例化-FiberRootNode，创建-FiberRoot" class="headerlink" title="3.1 实例化 FiberRootNode，创建 FiberRoot"></a>3.1 实例化 FiberRootNode，创建 FiberRoot</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberRoot.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  this: $FlowFixMe,</span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  identifierPrefix: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  onRecoverableError: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  formState: ReactFormState&lt;any, any&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="keyword">this</span>.containerInfo = containerInfo;</span><br><span class="line">  <span class="keyword">this</span>.pendingChildren = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.pingCache = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.timeoutHandle = noTimeout;</span><br><span class="line">  <span class="keyword">this</span>.cancelPendingCommit = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.pendingContext = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbackPriority = NoLane;</span><br><span class="line">  <span class="keyword">this</span>.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.pendingLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.suspendedLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.pingedLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.expiredLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.finishedLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.errorRecoveryDisabledLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.shellSuspendCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前更新与其他更新之间的关联性，即它们之间存在依赖或相关性。</span></span><br><span class="line">  <span class="comment">// 当一个更新被触发时，React 会根据其依赖关系计算出 entangledLanes，这些 entangledLanes 表示与当前更新相关联的其他更新的 Lanes。</span></span><br><span class="line">  <span class="keyword">this</span>.entangledLanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.entanglements = createLaneMap(NoLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hiddenUpdates = createLaneMap(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.identifierPrefix = identifierPrefix;</span><br><span class="line">  <span class="keyword">this</span>.onRecoverableError = onRecoverableError;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pooledCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.pooledCacheLanes = NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hydrationCallbacks = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.formState = formState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.incompleteTransitions = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">if</span> (enableTransitionTracing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.transitionCallbacks = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> transitionLanesMap = (<span class="keyword">this</span>.transitionLanes = []);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; TotalLanes; i++) &#123;</span><br><span class="line">      transitionLanesMap.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; enableProfilerCommitHooks) &#123;</span><br><span class="line">    <span class="keyword">this</span>.effectDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.passiveEffectDuration = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableUpdaterTracking) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memoizedUpdaters = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> pendingUpdatersLaneMap = (<span class="keyword">this</span>.pendingUpdatersLaneMap = []);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; TotalLanes; i++) &#123;</span><br><span class="line">      pendingUpdatersLaneMap.push(<span class="keyword">new</span> <span class="built_in">Set</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-createHostRootFiber-创建原生标签的根-Fiber"><a href="#3-2-createHostRootFiber-创建原生标签的根-Fiber" class="headerlink" title="3.2 createHostRootFiber 创建原生标签的根 Fiber"></a>3.2 createHostRootFiber 创建原生标签的根 Fiber</h4><p>注意这⾥创建的是 <code>Fiber</code> 只是属于根部的 <code>Fiber</code> 。和 3.1 的 <code>FiberRoot</code> 不同，<code>FiberRoot</code> 与 <code>Fiber</code> 是两个类型。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiber.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  isStrictMode: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  concurrentUpdatesByDefaultOverride: null | boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class="line">    mode = ConcurrentMode;</span><br><span class="line">    <span class="keyword">if</span> (isStrictMode === <span class="literal">true</span>) &#123;</span><br><span class="line">      mode |= StrictLegacyMode | StrictEffectsMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// We only use this flag for our repo tests to check both behaviors.</span></span><br><span class="line">      forceConcurrentByDefaultForTesting</span><br><span class="line">    ) &#123;</span><br><span class="line">      mode |= ConcurrentUpdatesByDefaultMode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// Only for internal experiments.</span></span><br><span class="line">      allowConcurrentByDefault &amp;&amp;</span><br><span class="line">      concurrentUpdatesByDefaultOverride</span><br><span class="line">    ) &#123;</span><br><span class="line">      mode |= ConcurrentUpdatesByDefaultMode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mode = NoMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    mode |= ProfileMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  this: $FlowFixMe,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag; <span class="comment">// 组件类型</span></span><br><span class="line">  <span class="keyword">this</span>.key = key; <span class="comment">// 组件props上的key</span></span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// ReactElement.type 组件的dom类型， 比如`div, p`</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>; <span class="comment">// 异步组件resolved之后返回的内容</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// 在浏览器环境对应dom节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>; <span class="comment">// 指向父节点</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>; <span class="comment">// 孩子节点</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 兄弟节点， 兄弟节点的return指向同一个父节点</span></span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.refCleanup = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.pendingProps = pendingProps; <span class="comment">// 新的props</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">// 上一次渲染完成的props</span></span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">// 组件产生的update信息会放在这个队列</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>; <span class="comment">// 上一次渲染完成的state</span></span><br><span class="line">  <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="keyword">this</span>.flags = NoFlags; <span class="comment">// 相当于之前的effectTag， 记录side effect类型</span></span><br><span class="line">  <span class="keyword">this</span>.subtreeFlags = NoFlags;</span><br><span class="line">  <span class="keyword">this</span>.deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.lanes = NoLanes;     <span class="comment">// 优先级相关</span></span><br><span class="line">  <span class="keyword">this</span>.childLanes = NoLanes;  <span class="comment">// 优先级相关</span></span><br><span class="line">  <span class="keyword">this</span>.alternate = <span class="literal">null</span>;    <span class="comment">// 对应的是current fiber</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-循环构造-root-和-uninitializedFiber"><a href="#3-3-循环构造-root-和-uninitializedFiber" class="headerlink" title="3.3 循环构造 root 和 uninitializedFiber"></a>3.3 循环构造 root 和 uninitializedFiber</h4><p><code>root.current</code> 是 <code>Fiber</code><br><code>uninitializedFiber.stateNode</code> 是根 <code>FiberRoot</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.current = uninitializedFiber; <span class="comment">// Fiber</span></span><br><span class="line">uninitializedFiber.stateNode = root; <span class="comment">// FiberRoot</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-初始化-initializeUpdateQueue"><a href="#3-4-初始化-initializeUpdateQueue" class="headerlink" title="3.4 初始化 initializeUpdateQueue"></a>3.4 初始化 initializeUpdateQueue</h4><p>类似fiber，update queues也是成对出现的，一个已经完成的即对应目前页面，一个正在工作中的。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Update&lt;State&gt; = &#123;</span><br><span class="line">  lane: Lane,</span><br><span class="line"></span><br><span class="line">  tag: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line">  payload: any,</span><br><span class="line">  callback: <span class="function">(<span class="params">(</span>) =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  next: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type SharedQueue&lt;State&gt; = &#123;</span><br><span class="line">  pending: Update&lt;State&gt; | <span class="literal">null</span>, <span class="comment">// 单向循环链表</span></span><br><span class="line">  lanes: Lanes,</span><br><span class="line">  <span class="comment">// 如果类组件是Activity(以前叫OffScreen)的后代组件，需要延迟执行的其setState的callback。这里是先暂时收集，commit阶段提交</span></span><br><span class="line">  <span class="comment">// Activity目前还是unstable，了解即可~</span></span><br><span class="line">  hiddenCallbacks: <span class="built_in">Array</span>&lt;<span class="function"><span class="params">()</span> =&gt;</span> mixed&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">  baseState: State,</span><br><span class="line">  <span class="comment">// 单链表 firstBaseUpdate-&gt;...-&gt;lastBaseUpdate</span></span><br><span class="line">  firstBaseUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastBaseUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  shared: SharedQueue&lt;State&gt;,</span><br><span class="line">  callbacks: <span class="built_in">Array</span>&lt;<span class="function"><span class="params">()</span> =&gt;</span> mixed&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里初始化fiber.updateQueue</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>,</span><br><span class="line">      lanes: NoLanes,</span><br><span class="line">      hiddenCallbacks: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    callbacks: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-markContainerAsRoot-标记-Container-是根-Fiber"><a href="#4-markContainerAsRoot-标记-Container-是根-Fiber" class="headerlink" title="4. markContainerAsRoot 标记 Container 是根 Fiber"></a>4. markContainerAsRoot 标记 Container 是根 Fiber</h3><p>这个函数给container根DOM节点赋值根Fiber</p>
<p><font color=gray><em>packages\react-dom-bindings\src\client\ReactDOMComponentTree.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomKey = <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).slice(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> internalContainerInstanceKey = <span class="string">'__reactContainer$'</span> + randomKey;</span><br><span class="line"><span class="comment">// 标记根节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markContainerAsRoot</span>(<span class="params">hostRoot: Fiber, node: Container</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  node[internalContainerInstanceKey] = hostRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性值在函数中用于 getClosestInstanceFromNode 和 getInstanceFromNode 中会用于根据根DOM去Fiber值。</p>
<p>对应的还有两个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消标记，在ReactDOMRoot.prototype.unmount函数里调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmarkContainerAsRoot</span>(<span class="params">node: Container</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  node[internalContainerInstanceKey] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查是否被标记为根节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isContainerMarkedAsRoot</span>(<span class="params">node: Container</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!node[internalContainerInstanceKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-从Container层监听listenToAllSupportedEvents"><a href="#5-从Container层监听listenToAllSupportedEvents" class="headerlink" title="5. 从Container层监听listenToAllSupportedEvents"></a>5. 从Container层监听listenToAllSupportedEvents</h3><p>react事件比较复杂，后续事件文章展开写。</p>
<h3 id="6-返回ReactDOMRoot实例"><a href="#6-返回ReactDOMRoot实例" class="headerlink" title="6. 返回ReactDOMRoot实例"></a>6. 返回ReactDOMRoot实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ReactDOMRoot(root);</span><br></pre></td></tr></table></figure>
<p>ReactDOMRoot 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMRoot</span>(<span class="params">internalRoot: FiberRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._internalRoot = internalRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-加载-执行-render-函数"><a href="#2-加载-执行-render-函数" class="headerlink" title="2. 加载 - 执行 render 函数"></a>2. 加载 - 执行 render 函数</h2><p><code>createRoot</code> 会返回 <code>RootType</code> 类型，即 <code>ReactDOMRoot</code> 的实例。</p>
<p><font color=gray><em>packages\react-dom\src\client\ReactDOMRoot.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type RootType = &#123;</span><br><span class="line">  render(children: ReactNodeList): <span class="keyword">void</span>,</span><br><span class="line">  unmount(): <span class="keyword">void</span>,</span><br><span class="line">  _internalRoot: FiberRoot | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMRoot</span>(<span class="params">internalRoot: FiberRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._internalRoot = internalRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">children: ReactNodeList</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">this</span>._internalRoot;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot update an unmounted root.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    updateContainer(children, root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>updateContainer 源码：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberReconciler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ! 1. 获取current和lane</span></span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(current); <span class="comment">// 页面初次渲染，defaultLane 32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 2. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(lane);</span><br><span class="line">  <span class="comment">// Caution: React DevTools currently depends on this property</span></span><br><span class="line">  <span class="comment">// being called "element".</span></span><br><span class="line">  update.payload = &#123;element&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面初次渲染，React18中已取消callback，只有老版本有效</span></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 3. 将update入队管理</span></span><br><span class="line">  <span class="keyword">const</span> root = enqueueUpdate(current, update, lane);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ! 4. 调度更新</span></span><br><span class="line">    scheduleUpdateOnFiber(root, current, lane);</span><br><span class="line">    <span class="comment">// ! 5. 处理transitions，非紧急更新</span></span><br><span class="line">    entangleTransitions(root, current, lane);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-获取-current-和-lane"><a href="#2-1-获取-current-和-lane" class="headerlink" title="2.1 获取 current 和 lane"></a>2.1 获取 current 和 lane</h4><p><code>lane</code> 是用于标识 <code>update</code> 优先级，一种标识 <code>update</code> 优先级的机制。每个 <code>update</code> 都会被分配一个或者多个 <code>lane</code>，以确定其在更新队列中的优先级顺序。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberWorkLoop.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber: Fiber</span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special cases</span></span><br><span class="line">  <span class="keyword">const</span> mode = fiber.mode;</span><br><span class="line">  <span class="comment">// 1. 非ConcurrentMode模式 2. 目前不支持</span></span><br><span class="line">  <span class="keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">    <span class="keyword">return</span> (SyncLane: Lane);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoContext &amp;&amp;</span><br><span class="line">    workInProgressRootRenderLanes !== NoLanes</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. These are not officially supported. The</span></span><br><span class="line">    <span class="comment">// old behavior is to give this the same "thread" (lanes) as</span></span><br><span class="line">    <span class="comment">// whatever is currently rendering. So if you call `setState` on a component</span></span><br><span class="line">    <span class="comment">// that happens later in the same render, it will flush. Ideally, we want to</span></span><br><span class="line">    <span class="comment">// remove the special case and treat them as if they came from an</span></span><br><span class="line">    <span class="comment">// interleaved event. Regardless, this pattern is not officially supported.</span></span><br><span class="line">    <span class="comment">// This behavior is only a fallback. The flag only exists until we can roll</span></span><br><span class="line">    <span class="comment">// out the setState warning, since existing code might accidentally rely on</span></span><br><span class="line">    <span class="comment">// the current behavior.</span></span><br><span class="line">    <span class="keyword">return</span> pickArbitraryLane(workInProgressRootRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通更新与非紧急更新(18)</span></span><br><span class="line">  <span class="keyword">const</span> transition = requestCurrentTransition();</span><br><span class="line">  <span class="comment">// 如果有transition</span></span><br><span class="line">  <span class="keyword">if</span> (transition !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionScopeLane = peekEntangledActionLane();</span><br><span class="line">    <span class="keyword">return</span> actionScopeLane !== NoLane</span><br><span class="line">      ? <span class="comment">// We're inside an async action scope. Reuse the same lane.</span></span><br><span class="line">        actionScopeLane</span><br><span class="line">      : <span class="comment">// We may or may not be inside an async action scope. If we are, this</span></span><br><span class="line">        <span class="comment">// is the first update in that scope. Either way, we need to get a</span></span><br><span class="line">        <span class="comment">// fresh transition lane.</span></span><br><span class="line">        requestTransitionLane(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Move this type conversion to the event priority module.</span></span><br><span class="line">  <span class="comment">// React内部的一些update，比如flushSync，会通过上下文变量来跟踪其优先级</span></span><br><span class="line">  <span class="keyword">const</span> updateLane: Lane = (getCurrentUpdatePriority(): any);</span><br><span class="line">  <span class="keyword">if</span> (updateLane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// ? sy setState click 2</span></span><br><span class="line">    <span class="keyword">return</span> updateLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Move this type conversion to the event priority module.</span></span><br><span class="line">  <span class="comment">// React外部的update，根据事件类型，向当前环境获取对应的优先级。</span></span><br><span class="line">  <span class="keyword">const</span> eventLane: Lane = (getCurrentEventPriority(): any);</span><br><span class="line">  <span class="keyword">return</span> eventLane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-getCurrentEventPriority"><a href="#1-1-1-getCurrentEventPriority" class="headerlink" title="1.1.1 getCurrentEventPriority"></a>1.1.1 getCurrentEventPriority</h5><p><font color=gray><em>packages\react-dom-bindings\src\client\ReactFiberConfigDOM.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentEventPriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentEvent = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (currentEvent === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getEventPriority(currentEvent.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-DefaultEventPriority、getCurrentUpdatePriority"><a href="#1-1-2-DefaultEventPriority、getCurrentUpdatePriority" class="headerlink" title="1.1.2 DefaultEventPriority、getCurrentUpdatePriority"></a>1.1.2 DefaultEventPriority、getCurrentUpdatePriority</h5><p><font color=gray><em>packages\react-reconciler\src\ReactEventPriorities.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> opaque type EventPriority = Lane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级从上往下，越来越低</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DiscreteEventPriority: EventPriority = SyncLane; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContinuousEventPriority: EventPriority = InputContinuousLane; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultEventPriority: EventPriority = DefaultLane; <span class="comment">// 页面初次渲染的lane 32, transition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleEventPriority: EventPriority = IdleLane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentUpdatePriority: EventPriority = NoLane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentUpdatePriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentUpdatePriority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setCurrentUpdatePriority</span>(<span class="params">newPriority: EventPriority</span>) </span>&#123;</span><br><span class="line">  currentUpdatePriority = newPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-创建update-createUpdate"><a href="#2-2-创建update-createUpdate" class="headerlink" title="2.2 创建update(createUpdate)"></a>2.2 创建update(createUpdate)</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Update&lt;State&gt; = &#123;</span><br><span class="line">  lane: Lane,</span><br><span class="line"></span><br><span class="line">  tag: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line">  payload: any,</span><br><span class="line">  callback: <span class="function">(<span class="params">(</span>) =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  next: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params">lane: Lane</span>): <span class="title">Update</span>&lt;<span class="title">mixed</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;mixed&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line"></span><br><span class="line">    tag: UpdateState,</span><br><span class="line">    payload: <span class="literal">null</span>,</span><br><span class="line">    callback: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-update入队"><a href="#2-3-update入队" class="headerlink" title="2.3 update入队"></a>2.3 update入队</h4><p><code>createRoot(root).render()</code> 阶段与类组件的 <code>setState</code> 、<code>forceUpdate</code> 阶段最开始调⽤的是 <code>ReactFiberClassUpdateQueue.js</code> 中的 <code>enqueueUpdate</code>。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateQueue = fiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (updateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Only occurs if the fiber has been unmounted.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sharedQueue: SharedQueue&lt;State&gt; = (updateQueue: any).shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类组件旧的生命周期相关的update</span></span><br><span class="line">  <span class="keyword">if</span> (isUnsafeClassRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// This is an unsafe render phase update. Add directly to the update</span></span><br><span class="line">    <span class="comment">// queue so we can process it immediately during the current render.</span></span><br><span class="line">    <span class="keyword">const</span> pending = sharedQueue.pending;</span><br><span class="line">    <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">      update.next = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update.next = pending.next;</span><br><span class="line">      pending.next = update;</span><br><span class="line">    &#125;</span><br><span class="line">    sharedQueue.pending = update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the childLanes even though we're most likely already rendering</span></span><br><span class="line">    <span class="comment">// this fiber. This is for backwards compatibility in the case where you</span></span><br><span class="line">    <span class="comment">// update a different component during render phase than the one that is</span></span><br><span class="line">    <span class="comment">// currently renderings (a pattern that is accompanied by a warning).</span></span><br><span class="line">    <span class="keyword">return</span> unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// sy</span></span><br><span class="line">    <span class="keyword">return</span> enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-enqueueConcurrentClassUpdate"><a href="#1-3-1-enqueueConcurrentClassUpdate" class="headerlink" title="1.3.1 enqueueConcurrentClassUpdate"></a>1.3.1 enqueueConcurrentClassUpdate</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassUpdate | HookUpdate;</span></span><br><span class="line"><span class="keyword">export</span> type ConcurrentUpdate = &#123;</span><br><span class="line">  next: ConcurrentUpdate,</span><br><span class="line">  lane: Lane,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ClassQueue | HookQueue;</span></span><br><span class="line">type ConcurrentQueue = &#123;</span><br><span class="line">  pending: ConcurrentUpdate | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果渲染正在进行中，并且收到来自并发事件的更新,我们会等到当前的渲染结束（无论是完成还是被中断）之后再将其添加到 fiber 队列中。</span></span><br><span class="line"><span class="comment">// 将其推送到这个数组中，这样我们以后就可以访问queue、fiber、update等。</span></span><br><span class="line"><span class="keyword">const</span> concurrentQueues: <span class="built_in">Array</span>&lt;any&gt; = [];</span><br><span class="line"><span class="keyword">let</span> concurrentQueuesIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> concurrentlyUpdatedLanes: Lanes = NoLanes;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentClassUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: ClassQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: ClassUpdate&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// ! 1. update入队</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// ! 2. 返回FiberRoot</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-1-enqueueUpdate"><a href="#1-3-1-1-enqueueUpdate" class="headerlink" title="1.3.1.1 enqueueUpdate"></a>1.3.1.1 enqueueUpdate</h5><p>把 <code>update</code> 存储到 <code>concurrentQueues</code> 中，虽然这个函数也叫 <code>enqueueUpdate</code> 。</p>
<p>这⾥的 <code>enqueueUpdate</code> 是数字式存储，并且是依次存储 <code>fiber</code>、<code>queue</code>、<code>update</code>、<code>lane</code>，下次依然这个顺序，最后执⾏处理的时候也要按照这个规律取值。</p>
<p>React 源码中其它地⽅这种结构都是对象式写法，这⾥⽐较罕⻅地写了这个结构。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: ConcurrentQueue | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: ConcurrentUpdate | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Don't update the `childLanes` on the return path yet. If we already in</span></span><br><span class="line">  <span class="comment">// the middle of rendering, wait until after it has completed.</span></span><br><span class="line">  concurrentQueues[concurrentQueuesIndex++] = fiber;</span><br><span class="line">  concurrentQueues[concurrentQueuesIndex++] = queue;</span><br><span class="line">  concurrentQueues[concurrentQueuesIndex++] = update;</span><br><span class="line">  concurrentQueues[concurrentQueuesIndex++] = lane;</span><br><span class="line"></span><br><span class="line">  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The fiber's `lane` field is used in some places to check if any work is</span></span><br><span class="line">  <span class="comment">// scheduled, to perform an eager bailout, so we need to update it immediately.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should probably move this to the "shared" queue instead.</span></span><br><span class="line">  fiber.lanes = mergeLanes(fiber.lanes, lane);</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-2-getRootForUpdatedFiber-找到-FiberRoot"><a href="#1-3-1-2-getRootForUpdatedFiber-找到-FiberRoot" class="headerlink" title="1.3.1.2 getRootForUpdatedFiber 找到 FiberRoot"></a>1.3.1.2 getRootForUpdatedFiber 找到 FiberRoot</h5><p>从 sourceFiber 开始，找到根 Fiber，返回其 stateNode，即 FiberRoot。</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberConcurrentUpdates.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRootForUpdatedFiber</span>(<span class="params">sourceFiber: Fiber</span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果循环超过限制次数(50次)，抛出错误。比如在类组件的render函数里执行setState</span></span><br><span class="line">  throwIfInfiniteUpdateLoopDetected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When a setState happens, we must ensure the root is scheduled. Because</span></span><br><span class="line">  <span class="comment">// update queues do not have a backpointer to the root, the only way to do</span></span><br><span class="line">  <span class="comment">// this currently is to walk up the return path. This used to not be a big</span></span><br><span class="line">  <span class="comment">// deal because we would have to walk up the return path to set</span></span><br><span class="line">  <span class="comment">// the `childLanes`, anyway, but now those two traversals happen at</span></span><br><span class="line">  <span class="comment">// different times.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Consider adding a `root` backpointer on the update queue.</span></span><br><span class="line">  <span class="comment">// __DEV__，检查是否有未挂载的Fiber，如Can't perform a React state update on a component that hasn't mounted yet.</span></span><br><span class="line">  detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);</span><br><span class="line">  <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">  <span class="keyword">let</span> parent = node.return;</span><br><span class="line">  <span class="comment">// 循环往上查找，找到根节点</span></span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    detectUpdateOnUnmountedFiber(sourceFiber, node);</span><br><span class="line">    node = parent;</span><br><span class="line">    parent = node.return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根节点一定是HostRoot，返回根节点的stateNode，即FiberRoot</span></span><br><span class="line">  <span class="keyword">return</span> node.tag === HostRoot ? (node.stateNode: FiberRoot) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-scheduleUpdateOnFiber-调度更新"><a href="#2-4-scheduleUpdateOnFiber-调度更新" class="headerlink" title="2.4 scheduleUpdateOnFiber 调度更新"></a>2.4 scheduleUpdateOnFiber 调度更新</h4><p>调度 update。</p>
<p>具体查看 scheduleUpdateOnFiber调度更新 文章。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-entangleTransitions-非紧急更新"><a href="#2-5-entangleTransitions-非紧急更新" class="headerlink" title="2.5 entangleTransitions 非紧急更新"></a>2.5 entangleTransitions 非紧急更新</h4><p>处理非紧急更新 Transitions。查看后续文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html" class="post-title-link" itemprop="url">vue3组件异步更新和NextTick的运行机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-17T00:00:00+08:00">2024-03-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="组件的异步更新"><a href="#组件的异步更新" class="headerlink" title="组件的异步更新"></a>组件的异步更新</h2><h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create reactive effect for rendering</span></span><br><span class="line"><span class="keyword">const</span> effect = (instance.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">  componentUpdateFn, <span class="comment">// fn：组件更新实际执行函数</span></span><br><span class="line">  NOOP,</span><br><span class="line">  () =&gt; queueJob(update), <span class="comment">//scheduler： update: () =&gt; effect.run() ，相当于执行componentUpdateFn</span></span><br><span class="line">  instance.scope, <span class="comment">// track it in component's effect scope</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<h3 id="queueJob"><a href="#queueJob" class="headerlink" title="queueJob"></a>queueJob</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: SchedulerJob[] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvedPromise = <span class="comment">/*#__PURE__*/</span> <span class="built_in">Promise</span>.resolve() <span class="keyword">as</span> <span class="built_in">Promise</span>&lt;any&gt;</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise: <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job: SchedulerJob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !queue.length ||</span><br><span class="line">    !queue.includes( <span class="comment">// queue中是否已经存在相同job</span></span><br><span class="line">      job,</span><br><span class="line">      isFlushing &amp;&amp; job.allowRecurse ? flushIndex + <span class="number">1</span> : flushIndex,</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (job.id == <span class="literal">null</span>) &#123;</span><br><span class="line">      queue.push(job)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue.splice(findInsertionIndex(job.id), <span class="number">0</span>, job)</span><br><span class="line">    &#125;</span><br><span class="line">    queueFlush()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queueJob 执行主要是将 scheduler 添加到 queue 队列中，然后执行 queueFlush 函数。</p>
<h3 id="queueFlush"><a href="#queueFlush" class="headerlink" title="queueFlush"></a>queueFlush</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// isFlushing和isflushPending初始值都是false</span></span><br><span class="line">	<span class="comment">// 说明当前没有flush任务在执行，也没有flush任务在等待执行</span></span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    <span class="comment">// 初次执行queueFlush将isFlushPending设置为true，表示有flush任务在等待执行</span></span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.then(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolvedPromise 就是 promise.resolve()，flushJobs 被放到微任务队列中，等待所有同步任务执行完毕后执行，这样就可以保证flushJobs在一次组件更新中只执行一次。最后，更新 currentFlushPromise 以供 nextTick 使用。</p>
<h3 id="flushJobs"><a href="#flushJobs" class="headerlink" title="flushJobs"></a>flushJobs</h3><p>当所有的同步scheduler执行完毕后，就会去处理微任务队列的任务，就会执行flushJobs回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen?: CountMap</span>) </span>&#123;</span><br><span class="line">  isFlushPending = <span class="literal">false</span></span><br><span class="line">  isFlushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child so its render effect will have smaller</span></span><br><span class="line">  <span class="comment">//    priority number)</span></span><br><span class="line">  <span class="comment">// 2. If a component is unmounted during a parent component's update,</span></span><br><span class="line">  <span class="comment">//    its update can be skipped.</span></span><br><span class="line">  <span class="comment">// 组件更新的顺序是从父到子 因为父组件总是在子组件之前创建 所以它的渲染效果将具有更小的优先级</span></span><br><span class="line">  <span class="comment">// 如果一个组件在父组件更新期间被卸载 则可以跳过它的更新</span></span><br><span class="line">  queue.sort(comparator)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 先执行queue中的job 然后执行pendingPostFlushCbs中的job</span></span><br><span class="line">  <span class="comment">// 这里可以实现watch中的 postFlush</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.length; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job &amp;&amp; job.active !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; check(job)) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        callWithErrorHandling(job, <span class="literal">null</span>, ErrorCodes.SCHEDULER)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// job执行完毕后清空队列</span></span><br><span class="line">    flushIndex = <span class="number">0</span></span><br><span class="line">    queue.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行flushPostFlushCbs 此时组件已经更新完毕</span></span><br><span class="line">    flushPostFlushCbs(seen)</span><br><span class="line"></span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">    currentFlushPromise = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// some postFlushCb queued jobs!</span></span><br><span class="line">    <span class="comment">// keep flushing until it drains.</span></span><br><span class="line">    <span class="keyword">if</span> (queue.length || pendingPostFlushCbs.length) &#123;</span><br><span class="line">      flushJobs(seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NextTick"><a href="#NextTick" class="headerlink" title="NextTick"></a>NextTick</h2><p>vue3中的nextTick实现非常简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>&lt;<span class="title">T</span> = <span class="title">void</span>, <span class="title">R</span> = <span class="title">void</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  this: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn?: (this: T</span>) =&gt; <span class="title">R</span>,</span></span><br><span class="line"><span class="function">): <span class="title">Promise</span>&lt;<span class="title">Awaited</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(<span class="keyword">this</span> ? fn.bind(<span class="keyword">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键就是 currentFlushPromise，我们仔细看其实发现 currentFlushPromise 在 queueFlush 中就被赋值，它正是把执行组件更新函数的任务放入微队列中的promise，所以在此我们拿到 currentFlushPromise 正好把 nextTick 接收到的函数回调fn放到微队列中 flushJobs 的后面，等到 flushJobs 执行完成后组件也已经更新完毕，此时正是我们希望去执行 nextTick 回调的时机。</p>
<p>注意：我们知道在一个eventloop中，执行完微任务后才进行渲染更新，那nextTick能拿到最新的dom吗？答案是可以的，执行nextTick回调时候，dom已经被修改，只是还没渲染。我们运行下面的例子便可得到答案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"count"</span>&gt;&#123;&#123; count &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const count = ref(0);</span></span><br><span class="line"><span class="regexp">count.value++;</span></span><br><span class="line"><span class="regexp">nextTick(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行回调时候，虽然dom还没渲染，但dom已经被修改可以获取最新值</span></span><br><span class="line"><span class="regexp">    console.log('count', document.getElementById('count').innerText); /</span><span class="regexp">/ 1</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组件内当修改响应式数据后，组件更新函数会被放到queue中，然后注册一个微任务，这个微任务负责执行queue中的所有job，所以这时就算我们同步修改多次/多个响应式数据，同一个组件的更新函数只会被放入一次到queue中，nextTick的回调也会放入到微队列中 flushJobs 的后面，等到同步操作结束后才会去执行注册的微任务，组件更新函数才会被执行（nextTick在此后执行也会获取到最新的dom值），组件也会被更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3-computed%E5%92%8Cwatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3-computed%E5%92%8Cwatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">vue3 computed和watch的实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-03T00:00:00+08:00">2024-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-03 00:00:00" itemprop="dateModified" datetime="2023-02-03T00:00:00+08:00">2023-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算属性：computed"><a href="#计算属性：computed" class="headerlink" title="计算属性：computed"></a>计算属性：computed</h2><p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 2</span></span><br><span class="line">plusOne.value++ <span class="comment">// error</span></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。</p>
<p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p>
<p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。</p>
<p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(&#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; count.value + 1,</span><br><span class="line">  <span class="keyword">set</span>: val =&gt; &#123;</span><br><span class="line">    count.value = val - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">plusOne.value = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p>
<p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  debugOptions?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getter 函数</span></span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="comment">// setter 函数</span></span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否只有getter的情况，也就是上面第一种例子情况</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = isFunction(getterOrOptions)</span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          warn(<span class="string">'Write operation failed: computed value is readonly'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成computed实例</span></span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; debugOptions &amp;&amp; !isSSR) &#123;</span><br><span class="line">    cRef.effect.onTrack = debugOptions.onTrack</span><br><span class="line">    cRef.effect.onTrigger = debugOptions.onTrigger</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cRef <span class="keyword">as</span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed接收3个参数，主要看第一个参数，观察其类型，发现可以传两种参数：一种是一个getter函数，一种是个包含get、set的对象。<br>首先从getterOrOptions中确定getter、setter（如果getterOrOptions是个function，说明computed是不可写的，所以会将setter设置为一个空函数），确定好之后，创建ComputedRefImpl的实例，并将其返回。</p>
<h3 id="ComputedRefImpl"><a href="#ComputedRefImpl" class="headerlink" title="ComputedRefImpl"></a>ComputedRefImpl</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputedRefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span> <span class="comment">// 存储effect的集合</span></span><br><span class="line"></span><br><span class="line">  private _value!: T</span><br><span class="line">  public readonly effect: ReactiveEffect&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line">  public readonly [ReactiveFlags.IS_READONLY]: boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  public _cacheable: boolean</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Dev only</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _warnRecursive?: boolean</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private getter: ComputedGetter&lt;T&gt;,</span><br><span class="line">    private readonly _setter: ComputedSetter&lt;T&gt;,</span><br><span class="line">    isReadonly: boolean,</span><br><span class="line">    isSSR: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 创建effect</span></span><br><span class="line">    <span class="keyword">this</span>.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">      () =&gt; getter(<span class="keyword">this</span>._value), <span class="comment">// fn</span></span><br><span class="line">      <span class="comment">// trigger</span></span><br><span class="line">      () =&gt;</span><br><span class="line">        triggerRefValue(</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          <span class="keyword">this</span>.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect</span><br><span class="line">            ? DirtyLevels.MaybeDirty_ComputedSideEffect</span><br><span class="line">            : DirtyLevels.MaybeDirty,</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 用于区分effect是否是computed</span></span><br><span class="line">    <span class="keyword">this</span>.effect.computed = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// this.effect.active与this._cacheable在SSR中为false</span></span><br><span class="line">    <span class="keyword">this</span>.effect.active = <span class="keyword">this</span>._cacheable = !isSSR</span><br><span class="line">    <span class="keyword">this</span>[ReactiveFlags.IS_READONLY] = isReadonly</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="comment">// 计算出的 ref 可能会被其他代理包装，例如 readonly（），所以转成原始类型</span></span><br><span class="line">    <span class="keyword">const</span> self = toRaw(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 当未缓存或者dirty也就是需要更新 并且值发生了改变，触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (!self._cacheable || self.effect.dirty) &amp;&amp;</span><br><span class="line">      hasChanged(self._value, (self._value = self.effect.run()!)) <span class="comment">// 会触发一次run，相当于获取最新的依赖值，如果结果发生改变，触发更新</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      triggerRefValue(self, DirtyLevels.Dirty)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行依赖收集</span></span><br><span class="line">    trackRefValue(self)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 _dirtyLevel 高于 DirtyLevels.MaybeDirty_ComputedSideEffect， 触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (self.effect._dirtyLevel &gt;= DirtyLevels.MaybeDirty_ComputedSideEffect) &#123;</span><br><span class="line">      triggerRefValue(self, DirtyLevels.MaybeDirty_ComputedSideEffect)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> value(newValue: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>._setter(newValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #region polyfill _dirty for backward compatibility third party code for Vue &lt;= 3.3.x</span></span><br><span class="line">  <span class="keyword">get</span> _dirty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.effect.dirty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> _dirty(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.effect.dirty = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="侦听器：watch"><a href="#侦听器：watch" class="headerlink" title="侦听器：watch"></a>侦听器：watch</h2><p>1.watch API 可以侦听一个 getter 函数，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> state.count, (count, prevCount) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 state.count 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.watch API 也可以直接侦听一个响应式对象，当响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, (count, prevCount) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 count.value 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.watch API 还可以直接侦听多个响应式对象，任意一个响应式对象更新后，就会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> count2 = ref(<span class="number">1</span>)</span><br><span class="line">watch([count, count2], ([count, count2], [prevCount, prevCount2]) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 count.value 或者 count2.value 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Immediate</span> <span class="title">extends</span> <span class="title">Readonly</span>&lt;<span class="title">boolean</span>&gt; = <span class="title">false</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: T | WatchSource&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptions&lt;Immediate&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(source <span class="keyword">as</span> any, cb, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到watch内部调用了doWatch：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | object,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    immediate,</span></span></span><br><span class="line"><span class="function"><span class="params">    deep,</span></span></span><br><span class="line"><span class="function"><span class="params">    flush,</span></span></span><br><span class="line"><span class="function"><span class="params">    once,</span></span></span><br><span class="line"><span class="function"><span class="params">    onTrack,</span></span></span><br><span class="line"><span class="function"><span class="params">    onTrigger,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有回调函数，并且只监听一次后移除watch</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; once) &#123;</span><br><span class="line">    <span class="keyword">const</span> _cb = cb</span><br><span class="line">    cb = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      _cb(...args)</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance</span><br><span class="line">  <span class="keyword">const</span> reactiveGetter = <span class="function">(<span class="params">source: object</span>) =&gt;</span></span><br><span class="line">    deep === <span class="literal">true</span></span><br><span class="line">      ? source <span class="comment">// traverse will happen in wrapped getter below</span></span><br><span class="line">      : <span class="comment">// for deep: false, only traverse root-level properties</span></span><br><span class="line">        traverse(source, deep === <span class="literal">false</span> ? <span class="number">1</span> : <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: <span class="function"><span class="params">()</span> =&gt;</span> any</span><br><span class="line">  <span class="keyword">let</span> forceTrigger = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> isMultiSource = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 根据不同source 创建不同的getter函数</span></span><br><span class="line">  <span class="comment">// getter 函数与computed的getter函数作用类似</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(source)) &#123;</span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> source.value</span><br><span class="line">    forceTrigger = isShallow(source)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123;</span><br><span class="line">    <span class="comment">// source是reactive对象时 自动开启deep=true</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> reactiveGetter(source)</span><br><span class="line">    forceTrigger = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(source)) &#123;</span><br><span class="line">    isMultiSource = <span class="literal">true</span></span><br><span class="line">    forceTrigger = source.some(<span class="function"><span class="params">s</span> =&gt;</span> isReactive(s) || isShallow(s))</span><br><span class="line">    <span class="comment">// source是一个数组的时候，getter 遍历通过类型判断</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> s.value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> reactiveGetter(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warnInvalidSource(s)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果有cb，代表source是个getter函数</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// getter with cb</span></span><br><span class="line">      getter = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则代表是watchEffect</span></span><br><span class="line">      <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">      getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">          source,</span><br><span class="line">          instance,</span><br><span class="line">          ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">          [onCleanup],</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = NOOP</span><br><span class="line">    __DEV__ &amp;&amp; warnInvalidSource(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.x array mutation watch compat</span></span><br><span class="line">  <span class="comment">// 兼容vue2</span></span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__ &amp;&amp; cb &amp;&amp; !deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> val = baseGetter()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        isArray(val) &amp;&amp;</span><br><span class="line">        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        traverse(val)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 深度监听</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    <span class="comment">// traverse会递归遍历对象的所有属性 以达到深度监听的目的</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> traverse(baseGetter())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watch回调的第三个参数 可以用此注册一个cleanup函数 会在下一次watch cb调用前执行</span></span><br><span class="line">  <span class="comment">// 常用于竞态问题的处理</span></span><br><span class="line">  <span class="keyword">let</span> cleanup: <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">void</span>) | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> onCleanup: OnCleanup = <span class="function">(<span class="params">fn: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; &#123;</span><br><span class="line">    cleanup = effect.onStop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)</span><br><span class="line">      cleanup = effect.onStop = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// in SSR there is no need to setup an actual effect, and it should be noop</span></span><br><span class="line">  <span class="comment">// unless it's eager or sync flush</span></span><br><span class="line">  <span class="keyword">let</span> ssrCleanup: <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">void</span>)[] | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class="line">    <span class="comment">// we will also not call the invalidate callback (+ runner is not set up)</span></span><br><span class="line">    <span class="comment">// ssr处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// oldValue声明 多个source监听则初始化为数组</span></span><br><span class="line">  <span class="keyword">let</span> oldValue: any = isMultiSource</span><br><span class="line">    ? <span class="keyword">new</span> <span class="built_in">Array</span>((source <span class="keyword">as</span> []).length).fill(INITIAL_WATCHER_VALUE)</span><br><span class="line">    : INITIAL_WATCHER_VALUE</span><br><span class="line">  <span class="comment">// 调度器调用时执行</span></span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active || !effect.dirty) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// watch(source, cb)</span></span><br><span class="line">      <span class="comment">// 获取newValue</span></span><br><span class="line">      <span class="keyword">const</span> newValue = effect.run()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        deep ||</span><br><span class="line">        forceTrigger ||</span><br><span class="line">        (isMultiSource</span><br><span class="line">          ? <span class="function">(<span class="params">newValue <span class="keyword">as</span> any[]</span>).<span class="params">some</span>(<span class="params">(v, i</span>) =&gt;</span> hasChanged(v, oldValue[i]))</span><br><span class="line">          : hasChanged(newValue, oldValue)) ||</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          isArray(newValue) &amp;&amp;</span><br><span class="line">          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// cleanup before running cb again</span></span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用cb 参数为newValue、oldValue、onCleanup</span></span><br><span class="line">        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [</span><br><span class="line">          newValue,</span><br><span class="line">          <span class="comment">// pass undefined as the old value when it's changed for the first time</span></span><br><span class="line">          oldValue === INITIAL_WATCHER_VALUE</span><br><span class="line">            ? <span class="literal">undefined</span></span><br><span class="line">            : isMultiSource &amp;&amp; oldValue[<span class="number">0</span>] === INITIAL_WATCHER_VALUE</span><br><span class="line">              ? []</span><br><span class="line">              : oldValue,</span><br><span class="line">          onCleanup,</span><br><span class="line">        ])</span><br><span class="line">         <span class="comment">// 更新oldValue</span></span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// watchEffect</span></span><br><span class="line">      effect.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// important: mark the job as a watcher callback so that scheduler knows</span></span><br><span class="line">  <span class="comment">// it is allowed to self-trigger (#1727)</span></span><br><span class="line">  job.allowRecurse = !!cb</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建任务队列的调度回调scheduler</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: EffectScheduler</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">'sync'</span>) &#123;</span><br><span class="line">    <span class="comment">// 同步更新 即每次响应式数据改变都会回调一次cb</span></span><br><span class="line">    scheduler = job <span class="keyword">as</span> any <span class="comment">// the scheduler function gets called directly</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">    <span class="comment">// job放入pendingPostFlushCbs队列中</span></span><br><span class="line">    <span class="comment">// pendingPostFlushCbs队列会在queue队列执行完毕后执行 函数更新effect通常会放在queue队列中</span></span><br><span class="line">    <span class="comment">// 所以pendingPostFlushCbs队列执行时组件已经更新完毕</span></span><br><span class="line">    scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: 'pre'</span></span><br><span class="line">    job.pre = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (instance) job.id = instance.uid</span><br><span class="line">    <span class="comment">// 默认更新</span></span><br><span class="line">    <span class="comment">// 原理在这：https://rile14929.github.io/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html</span></span><br><span class="line">    scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queueJob(job)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect effect.run的时候建立effect与getter内响应式数据的关系</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">new</span> ReactiveEffect(getter, NOOP, scheduler)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scope = getCurrentScope()</span><br><span class="line">  <span class="comment">// 取消监听的函数</span></span><br><span class="line">  <span class="keyword">const</span> unwatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    effect.stop()</span><br><span class="line">    <span class="keyword">if</span> (scope) &#123;</span><br><span class="line">      remove(scope.effects, effect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initial run</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">       <span class="comment">// 立即执行一次job</span></span><br><span class="line">      job()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则执行effect.run() 会执行getter 获取oldValue</span></span><br><span class="line">      oldValue = effect.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">    queuePostRenderEffect(</span><br><span class="line">      effect.run.bind(effect),</span><br><span class="line">      instance &amp;&amp; instance.suspense,</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    effect.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.push(unwatch)</span><br><span class="line">  <span class="keyword">return</span> unwatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WatchEffect"><a href="#WatchEffect" class="headerlink" title="WatchEffect"></a>WatchEffect</h3><p>watchEffect API 的作用是注册一个副作用函数，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再立即执行这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line">count.value++</span><br></pre></td></tr></table></figure>

<p>watchEffect 和前面的 watch API 主要有三点不同：</p>
<ol>
<li><p><strong>侦听的源不同</strong> 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。</p>
</li>
<li><p><strong>没有回调函数</strong> 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。</p>
</li>
<li><p><strong>立即执行</strong> 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate 为 true，才会立即执行回调函数。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchPostEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(</span><br><span class="line">    effect,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    __DEV__ ? extend(&#123;&#125;, options <span class="keyword">as</span> any, &#123; <span class="attr">flush</span>: <span class="string">'post'</span> &#125;) : &#123; <span class="attr">flush</span>: <span class="string">'post'</span> &#125;,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchSyncEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(</span><br><span class="line">    effect,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    __DEV__ ? extend(&#123;&#125;, options <span class="keyword">as</span> any, &#123; <span class="attr">flush</span>: <span class="string">'sync'</span> &#125;) : &#123; <span class="attr">flush</span>: <span class="string">'sync'</span> &#125;,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简易版实现原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">        cleanup()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">        source,</span><br><span class="line">        instance,</span><br><span class="line">        ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">        [onCleanup],</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scheduler: EffectScheduler</span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">'sync'</span>) &#123;</span><br><span class="line">  scheduler = job <span class="keyword">as</span> any <span class="comment">// the scheduler function gets called directly</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">  scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: 'pre'</span></span><br><span class="line">  job.pre = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (instance) job.id = instance.uid</span><br><span class="line">  scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queueJob(job)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> ReactiveEffect(getter, NOOP, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// initial run</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">  queuePostRenderEffect(</span><br><span class="line">    effect.run.bind(effect),</span><br><span class="line">    instance &amp;&amp; instance.suspense,</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  effect.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是计算属性computed和侦听器watch的实现原理，总的来说就是侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。</p>
<p>文章里面涉及到<a href="https://rile14929.github.io/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html">任务队列异步更新的原理</a>在这。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">vue3响应式实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-06T00:00:00+08:00">2024-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们分析了 Composition API 的核心 setup 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这次我们就来深入学习和分析响应式内部的实现原理。</p>
<p><strong>响应式它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。响应式是 Vue.js 组件化更新渲染的一个核心机制。</strong></p>
<p>Vue.js 2.x的响应式：在内部通过 Object.defineProperty API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用vue2官网的一张图可以直观地看清这个流程。</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image.png" alt="alt text"></p>
<p>在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。这里有两个流程，首先是依赖收集流程，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；然后是派发通知流程，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。</p>
<p>但是Object.defineProperty API 有一些缺点：包括不能监听对象属性新增和删除；初始化阶段递归执行 Object.defineProperty 带来的性能负担。</p>
<p>Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用 Proxy API 重写了响应式部分，并独立维护和发布整个 reactivity 库，下面就来分析响应式部分的实现原理。</p>
<h2 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span></span><br><span class="line">  <span class="keyword">if</span> (isReadonly(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: Target,</span></span></span><br><span class="line"><span class="function"><span class="params">  isReadonly: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  proxyMap: WeakMap&lt;Target, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标必须是对象或数组类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment">// exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="comment">// target 已经是 Proxy 对象，直接返回</span></span><br><span class="line">  <span class="comment">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// target 已经有对应的 Proxy 了</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// only specific value types can be observed.</span></span><br><span class="line">  <span class="comment">// 只有在白名单里的数据类型才能变成响应式</span></span><br><span class="line">  <span class="keyword">const</span> targetType = getTargetType(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === TargetType.INVALID) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用 Proxy 创建响应式</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,</span><br><span class="line">  )</span><br><span class="line">  proxyMap.set(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，reactive 内部通过 createReactiveObject 函数把 target 变成了一个响应式对象。</p>
<p>在这个过程中，createReactiveObject 函数主要做了以下几件事情。</p>
<ol>
<li>函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以原始数据 target 必须是对象或者数组。</li>
<li>如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象</li>
<li>如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象</li>
<li>只有在白名单里的数据类型才能变成响应式，比如，带有 __v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。</li>
</ol>
<p>接下来，我们继续看 Proxy 处理器对象 mutableHandlers 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它其实就是劫持了我们对 observed 对象的一些操作，比如：</p>
<p>访问对象属性会触发 get 函数；</p>
<p>设置对象属性会触发 set 函数；</p>
<p>删除对象属性会触发 deleteProperty 函数；</p>
<p>in 操作符会触发 has 函数；</p>
<p>通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。</p>
<p>因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。</p>
<h3 id="依赖收集：get-函数"><a href="#依赖收集：get-函数" class="headerlink" title="依赖收集：get 函数"></a>依赖收集：get 函数</h3><p><strong>依赖收集发生在数据访问的阶段</strong>，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 get 函数，我们来看一下 get 函数的实现流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(target: Target, key: string | symbol, receiver: object) &#123;</span><br><span class="line">    <span class="keyword">const</span> isReadonly = <span class="keyword">this</span>._isReadonly,</span><br><span class="line">      shallow = <span class="keyword">this</span>._shallow</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isReactive</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_SHALLOW) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isShallow</span></span><br><span class="line">      <span class="keyword">return</span> shallow</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.RAW) &#123;</span><br><span class="line">      <span class="comment">// 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        receiver ===</span><br><span class="line">          (isReadonly</span><br><span class="line">            ? shallow</span><br><span class="line">              ? shallowReadonlyMap</span><br><span class="line">              : readonlyMap</span><br><span class="line">            : shallow</span><br><span class="line">              ? shallowReactiveMap</span><br><span class="line">              : reactiveMap</span><br><span class="line">          ).get(target) ||</span><br><span class="line">        <span class="comment">// receiver is not the reactive proxy, but has the same prototype</span></span><br><span class="line">        <span class="comment">// this means the reciever is a user proxy of the reactive proxy</span></span><br><span class="line">        <span class="built_in">Object</span>.getPrototypeOf(target) === <span class="built_in">Object</span>.getPrototypeOf(receiver)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// early return undefined</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是数组</span></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = isArray(target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">        <span class="comment">// arrayInstrumentations 包含对数组一些方法修改的函数</span></span><br><span class="line">      <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'hasOwnProperty'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasOwnProperty</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    <span class="comment">// 内置 Symbol key 不需要依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">      <span class="keyword">return</span> targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? readonly(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面代码来看，get 函数主要做了四件事情，首先对特殊的 key 做了代理，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p>
<p>接着通过 Reflect.get 方法求值，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现：</p>
<h4 id="arrayInstrumentations"><a href="#arrayInstrumentations" class="headerlink" title="arrayInstrumentations"></a>arrayInstrumentations</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = <span class="comment">/*#__PURE__*/</span> createArrayInstrumentations()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayInstrumentations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instrumentations: Record&lt;string, <span class="built_in">Function</span>&gt; = &#123;&#125;</span><br><span class="line">  <span class="comment">// instrument identity-sensitive Array methods to account for possible reactive</span></span><br><span class="line">  <span class="comment">// values</span></span><br><span class="line">  ;([<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>] <span class="keyword">as</span> <span class="keyword">const</span>).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">this: unknown[], ...args: unknown[]</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// toRaw 可以把响应式对象转成原始数据，this就是Reflect的receiver</span></span><br><span class="line">      <span class="keyword">const</span> arr = toRaw(<span class="keyword">this</span>) <span class="keyword">as</span> any</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        track(arr, TrackOpTypes.GET, i + <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// we run the method using the original args first (which may be reactive)</span></span><br><span class="line">      <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">      <span class="keyword">if</span> (res === <span class="number">-1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// if that didn't work, run it again using raw values.</span></span><br><span class="line">        <span class="keyword">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class="line">  <span class="comment">// which leads to infinite loops in some cases (#2137)</span></span><br><span class="line">  ;([<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>] <span class="keyword">as</span> <span class="keyword">const</span>).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">this: unknown[], ...args: unknown[]</span>) </span>&#123;</span><br><span class="line">      pauseTracking()</span><br><span class="line">      pauseScheduling()</span><br><span class="line">      <span class="keyword">const</span> res = (toRaw(<span class="keyword">this</span>) <span class="keyword">as</span> any)[key].apply(<span class="keyword">this</span>, args)</span><br><span class="line">      resetScheduling()</span><br><span class="line">      resetTracking()</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当 target 是一个数组的时候，我们去访问 target.includes、target.indexOf、 target.lastIndexOf 就会执行 arrayInstrumentations 代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个 API 的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。</p>
<p>当调用 target.push、target.pop、target.shift、target.unshift、target.splice 时候，由于都会访问.length导致收集了数组的length，在某种场景下造成无限循环，看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/core/pull/2138</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = reactive([])</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  arr.push(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  arr.push(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以为避免此种情况发生，会暂停收集依赖，在执行完毕后，再恢复依赖收集。</p>
<p>回到 get 函数，第三步就是通过 Reflect.get 求值，然后会执行 track 函数收集依赖，我们稍后重点分析这个过程。</p>
<p>函数最后会对计算的值 res 进行判断，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。</p>
<p>整个 get 函数最核心的部分其实是执行 track 函数收集依赖，下面我们重点分析这个过程。</p>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: object, type: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是否应该收集依赖 和 当前激活的 effect</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 每个 target 对应一个 depsMap</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      <span class="comment">// 每个 key 对应一个 dep Map</span></span><br><span class="line">      depsMap.set(key, (dep = createDep(<span class="function"><span class="params">()</span> =&gt;</span> depsMap!.delete(key))))</span><br><span class="line">    &#125;</span><br><span class="line">    trackEffect(</span><br><span class="line">      activeEffect,</span><br><span class="line">      dep,</span><br><span class="line">      __DEV__</span><br><span class="line">        ? &#123;</span><br><span class="line">            target,</span><br><span class="line">            type,</span><br><span class="line">            key,</span><br><span class="line">          &#125;</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trackEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: ReactiveEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  dep: Dep,</span></span></span><br><span class="line"><span class="function"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dep.get(effect) !== effect._trackId) &#123;</span><br><span class="line">    <span class="comment">// 收集当前激活的 effect 作为依赖</span></span><br><span class="line">    dep.set(effect, effect._trackId)</span><br><span class="line">    <span class="keyword">const</span> oldDep = effect.deps[effect._depsLength]</span><br><span class="line">    <span class="keyword">if</span> (oldDep !== dep) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldDep) &#123;</span><br><span class="line">        cleanupDepEffect(oldDep, effect)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当前激活的 effect 收集 dep 集合作为依赖</span></span><br><span class="line">      effect.deps[effect._depsLength++] = dep</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect._depsLength++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      effect.onTrack?.(extend(&#123; effect &#125;, debuggerEventExtraInfo!))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析track函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们收集的依赖就是数据变化后执行的副作用函数。</p>
<p>再来看实现，我们把 target 作为原始的数据，key 作为访问的属性。我们创建了全局的 targetMap 作为原始数据对象的 Map，它的键是 target，值是 depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系：</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-1.png" alt="../images/vue3响应式实现原理/image-20240316133230452"></p>
<p>所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。</p>
<h3 id="派发通知：set-函数"><a href="#派发通知：set-函数" class="headerlink" title="派发通知：set 函数"></a>派发通知：set 函数</h3><p>派发通知发生在数据更新的阶段 ，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性更新的时候就会执行 set 函数。我们来看一下 set 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(</span><br><span class="line">    target: object,</span><br><span class="line">    key: string | symbol,</span><br><span class="line">    value: unknown,</span><br><span class="line">    receiver: object,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._shallow) &#123;</span><br><span class="line">      <span class="keyword">const</span> isOldValueReadonly = isReadonly(oldValue)</span><br><span class="line">      <span class="keyword">if</span> (!isShallow(value) &amp;&amp; !isReadonly(value)) &#123;</span><br><span class="line">        oldValue = toRaw(oldValue)</span><br><span class="line">        value = toRaw(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOldValueReadonly) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          oldValue.value = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数组是否包含index或者对象是否有这个属性</span></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="comment">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上述代码来看，set 函数的实现逻辑很简单，主要就做两件事情， 首先通过 Reflect.set 求值 ， 然后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型，即新增还是修改。</p>
<p>整个 set 函数最核心的部分就是 执行 trigger 函数派发通知 ，下面我们将重点分析这个过程。</p>
<p>我们先来看一下 trigger 函数的实现：</p>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 targetMap 拿到 target 对应的依赖集合</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 没有依赖，直接返回</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建要执行的deps数组</span></span><br><span class="line">  <span class="keyword">let</span> deps: (Dep | <span class="literal">undefined</span>)[] = []</span><br><span class="line">  <span class="keyword">if</span> (type === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    <span class="comment">// 清空数组或者map的时候触发所有key对应的的effect函数</span></span><br><span class="line">    deps = [...depsMap.values()]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    <span class="keyword">const</span> newLength = <span class="built_in">Number</span>(newValue)</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'length'</span> || (!isSymbol(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class="line">        deps.push(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="comment">// set add delete操作 将key对应的effect函数添加到deps数组中</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      deps.push(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="comment">// 根据不同的操作类型push对应的dep</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.ADD:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIntegerKey(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          deps.push(depsMap.get(<span class="string">'length'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.DELETE:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.SET:</span><br><span class="line">        <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pauseScheduling()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">      triggerEffects(</span><br><span class="line">        dep,</span><br><span class="line">        DirtyLevels.Dirty,</span><br><span class="line">        __DEV__</span><br><span class="line">          ? &#123;</span><br><span class="line">              target,</span><br><span class="line">              type,</span><br><span class="line">              key,</span><br><span class="line">              newValue,</span><br><span class="line">              oldValue,</span><br><span class="line">              oldTarget,</span><br><span class="line">            &#125;</span><br><span class="line">          : <span class="keyword">void</span> <span class="number">0</span>,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resetScheduling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">triggerEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dep: Dep,</span></span></span><br><span class="line"><span class="function"><span class="params">  dirtyLevel: DirtyLevels,</span></span></span><br><span class="line"><span class="function"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pauseScheduling()</span><br><span class="line">  <span class="comment">// 执行triggerEffects，执行dep里所有的effect</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> dep.keys()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      effect._dirtyLevel &lt; dirtyLevel &amp;&amp;</span><br><span class="line">      dep.get(effect) === effect._trackId</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastDirtyLevel = effect._dirtyLevel</span><br><span class="line">      effect._dirtyLevel = dirtyLevel</span><br><span class="line">      <span class="keyword">if</span> (lastDirtyLevel === DirtyLevels.NotDirty) &#123;</span><br><span class="line">        effect._shouldSchedule = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          effect.onTrigger?.(extend(&#123; effect &#125;, debuggerEventExtraInfo))</span><br><span class="line">        &#125;</span><br><span class="line">        effect.trigger()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  scheduleEffects(dep)</span><br><span class="line">  resetScheduling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。</p>
<h2 id="ref-API"><a href="#ref-API" class="headerlink" title="ref API"></a>ref API</h2><p>通过前面的分析，我们知道 reactive API 对传入的 target 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。</p>
<p>但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 Vue.js 3.0 设计并实现了 ref API。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createRef(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params">rawValue: unknown, shallow: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果传入的就是一个 ref，那么返回自身即可，处理嵌套 ref 的情况。</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  private _value: T</span><br><span class="line">  private _rawValue: T</span><br><span class="line"></span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    value: T,</span><br><span class="line">    public readonly __v_isShallow: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rawValue = __v_isShallow ? value : toRaw(value)</span><br><span class="line">    <span class="keyword">this</span>._value = __v_isShallow ? value : toReactive(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="comment">// 依赖收集，key 为固定的 value</span></span><br><span class="line">    trackRefValue(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> value(newVal) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue = <span class="keyword">this</span>.__v_isShallow || isShallow(newVal) || isReadonly(newVal)</span><br><span class="line">    newVal = useDirectValue ? newVal : toRaw(newVal)</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newVal, <span class="keyword">this</span>._rawValue)) &#123;</span><br><span class="line">      <span class="comment">// 判断有变化后更新值</span></span><br><span class="line">      <span class="keyword">this</span>._rawValue = newVal</span><br><span class="line">      <span class="keyword">this</span>._value = useDirectValue ? newVal : toReactive(newVal)</span><br><span class="line">      <span class="comment">// 派发通知</span></span><br><span class="line">      triggerRefValue(<span class="keyword">this</span>, DirtyLevels.Dirty, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数首先处理了嵌套 ref 的情况，如果传入的 rawValue 也是 ref，那么直接返回。</p>
<p>接着对 rawValue 做了一层转换，如果 rawValue 是对象或者数组类型，那么把它转换成一个 reactive 对象。</p>
<p>最后定义一个对 value 属性做 getter 和 setter 劫持的对象并返回，get 部分就是执行 track 函数做依赖收集然后返回它的值；set 部分就是设置新值并且执行 trigger 函数派发通知。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后通过一张图来看一下响应式的工作流程。</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-3.png" alt="alt text"></p>
<p>Vue.js 3.0 在响应式的实现思路和 Vue.js 2.x 差别并不大，主要就是 <strong>劫持数据的方式改成用 Proxy 实现 ， 以及收集的依赖由 watcher 实例变成了组件副作用渲染函数</strong> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
