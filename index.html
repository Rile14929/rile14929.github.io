<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E4%BB%A3%E7%A0%81%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E4%BB%A3%E7%A0%81%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2代码打印顺序和流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-03 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-03T00:00:00+08:00">2025-01-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 3 4 5 7 6 1(当前调度未超出时间切片)</span></span><br><span class="line"><span class="comment">// 2 3 4 5 6 1 7（当前调度超出时间切片, 在后面加sleep也可以看出来，effect的调度放在了之后的宏任务中执行）</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把setTimeout放在render之前的执行顺序</span></span><br><span class="line"><span class="comment">// 2 3 4 1 5 7 6</span></span><br><span class="line"><span class="comment">// 2 3 4 1 5 6 7</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("log:", 1);</span></span><br><span class="line"><span class="regexp">&#125;, 0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>从源码来看，<code>effect</code> 的 <code>create</code> 函数是在一个被调度的 <code>callback</code> 里面去执行的，为什么它还是会比 <code>Promise.then()</code> 的 <code>callback</code> 函数先执行？</p>
<p><code>useEffect</code> 是在 <code>commit</code> 阶段被 <code>scheduler</code> 加入到 <code>taskQueue</code> 中的，一个时间切片（5ms）内，如果时间允许，可能会执行很多个 <code>task</code>。</p>
<p><code>taskQueue</code> 中的任务又是在宏任务中被执行的，先于微任务。</p>
<p>总之，当前时间切片时间允许就是 <code>effect</code> 在 <code>Promise.then()</code>前，如果时间不够 <code>effect</code> 在 <code>Promise.then()</code> 后。</p>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>如果中间加了个sleep呢？如果不加呢？</p>
<p><code>useEffect</code> 是在 <code>commit</code> 阶段被 <code>scheduler</code> 加入到 <code>taskQueue</code> 中的。</p>
<ul>
<li>加sleep，导致超出时间切片5ms，<code>taskQueue</code>中的调度就要等到下一个宏任务再去调度</li>
<li>不加sleep，可能在5ms之内，<code>useEffect</code>的调度就被执行了，也有可能有各种高优先级的任务在 <code>useEffect</code> 前导致以后得调度再执行 <code>useEffect</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 加：2 3 4 5 6 1 7</span></span><br><span class="line"><span class="comment">// 不加：2 3 4 5 7 6 1 或者 2 3 4 5 6 1 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = performance.now();</span><br><span class="line">  <span class="keyword">while</span> (performance.now() - start &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// block</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">7</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sleep();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello &#123;name&#125;!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Start editing to see some magic happen :)&lt;/</span>p&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const root = createRoot(document.getElementById("root"));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log("log:", 2);</span></span><br><span class="line"><span class="regexp">root.render(&lt;App name="StackBlitz" /</span>&gt;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"log:"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h2><h3 id="5-1-刷新页面，console-log打印了几次？"><a href="#5-1-刷新页面，console-log打印了几次？" class="headerlink" title="5.1 刷新页面，console.log打印了几次？"></a>5.1 刷新页面，console.log打印了几次？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="number">-100</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount1(<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'x'</span>) <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h3&gt;UseEffectPage &#123;count1&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：3次。</p>
<ul>
<li><p>第一次：函数组件初次渲染，执行log函数，并且此次由于useEffect函数执行，在fiber节点上记录了包含create函数的effect对象；</p>
</li>
<li><p>第二次：源于组件初次渲染完成之后，延迟useEffect的create函数，此时create函数中执行的是setState事件。setState导致函数组件更新，那么再次执行函数组件这个函数，log再次打印。并且此次又记录了create函数的effect对象。</p>
</li>
<li><p>第三次：基本同第二次，不同的地方在于第三次的时候，前后两次状态值相同，函数组件检测到没有更新发生，bailout了。</p>
</li>
<li><p>详细过程：</p>
<ul>
<li>初始化执行UseABC组件函数，flush -&gt; workloop -&gt; performConcurrentWorkOnRoot，进到render阶段，在当前fiber的updateQueue上记录了要更新的effect，打印一次log</li>
<li>初始化到了commit阶段，通过 scheduleCallback 向 taskQueue 加入一个优先级为 NormalPriority 的 flushPassiveEffects 任务<ul>
<li>/* commit的最后还是会ensureRootIsScheduled调度一次微任务<code>scheduleImmediateTask(processRootScheduleInMicrotask);</code>或者performConcurrentWorkOnRoot的最后调度scheduleTaskForRootDuringMicrotask是否要加入高优先级任务，可能涉及到其它高优先级任务插队执行的问题，在flushWork结束的finally里判断如果有任务再次发起宏任务调度 */</li>
</ul>
</li>
<li>不考虑高优先级任务插队或者其他各种情况的话，正常执行完毕后回到 workloop 中，会取出task 或者在下次切片中取出task执行，所以 flushPassiveEffects 任务得以执行，在从root开始遍历，执行各个fiber上的updateQueue的effect</li>
<li>执行到setCount1时候，等于执行dispatchSetState.bind(null,currentlyRenderingFiber,queue)，相当于增加了一个调度更新scheduleUpdateOnFiber，cheduleUpdateOnFiber执行时会标记root上的更新也会把对应的update添加到对应fiber上，最后通过 ensureRootIsScheduled 发起微任务调度，但是commit已经发起过了，就不重复发起了，最终是通过微任务把setCount1加入到了taskQueue中</li>
<li>不管中间发生了什么，当再次执行与setCount1任务相同优先级的调度时候，从root开始遍历，再次执行UseABC组件函数，count1变成了0，且再打印一次log（执行UseABC组件函数的过程中又遇到了useEffect执行setCount1，又添加了调度更新）</li>
<li>当再次执行与此次任务相同优先级的调度时候，那就再次同上执行UseABC组件函数，再打印一次log，但是不同的是，现在count1的值没变化，bailout了</li>
</ul>
</li>
</ul>
<h3 id="5-2-如果useEffect依赖为-，console-log打印了几次？"><a href="#5-2-如果useEffect依赖为-，console-log打印了几次？" class="headerlink" title="5.2 如果useEffect依赖为[]，console.log打印了几次？"></a>5.2 如果useEffect依赖为[]，console.log打印了几次？</h3><p>答案：2次</p>
<ul>
<li>第一次：函数组件初次渲染，执行log函数，并且此次由于useEffect函数执行，在fiber节点上记录了包含create函数的effect对象；</li>
<li>第二次：源于组件初次渲染完成之后，延迟useEffect的create函数，此时create函数中执行的是setState事件。setState导致函数组件更新，那么再次执行函数组件这个函数，log再次打印。但是此次useEffect没有变化，故不再后续执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2hook之useEffect和useLayoutEffect原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-30T00:00:00+08:00">2024-12-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先来解读下几个参数:</p>
<ul>
<li><code>fiberFlags</code>：有副作用的更新标记，用来标记hook所在的fiber；</li>
<li><code>hookFlags</code>：副作用标记；</li>
<li><code>create</code>：使用者传入的回调函数；</li>
<li><code>deps</code>：使用者传入的数组依赖；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiberFlags: Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  hookFlags: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 判断是否有传入deps，如果有会作为下次更新的deps</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 给hook所在的fiber打上有副作用的更新的标记</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 将副作用操作存放到fiber.memoizedState.hook.memoizedState中</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    createEffectInstance(),</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEffectInstance</span>(<span class="params"></span>): <span class="title">EffectInstance</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">destroy</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">inst</span>: <span class="title">EffectInstance</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">Effect</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化副作用结构</span></span><br><span class="line">  <span class="keyword">const</span> effect: Effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    inst,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向fiber的updateQueue上添加effect，并形成环形链表</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue: <span class="literal">null</span> | FunctionComponentUpdateQueue =</span><br><span class="line">    (currentlyRenderingFiber.updateQueue: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码除了初始化副作用的结构代码外，还有就是操作闭环链表，向链表末尾添加新的 <code>effect</code>，该 <code>effect.next</code> 指向 <code>fisrtEffect</code>，并且链表当前的指针指向最新添加的 <code>effect</code>。</p>
<p>简单总结一下：给 <code>hook</code> 所在的 <code>fiber</code> 打上副作用更新标记，并且 <code>fiber.memoizedState.hook.memoizedState</code> 和 <code>fiber.updateQueue</code> 存储了相关的副作用，这些副作用通过闭环链表的结构存储。</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image.png" alt="alt text"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>主要功能就是创建一个带有回调函数的 <code>newHook</code> 去覆盖之前的 <code>hook</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiberFlags: Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  hookFlags: HookFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> effect: Effect = hook.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> inst = effect.inst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// currentHook is null on initial mount when rerendering after a render phase</span></span><br><span class="line">  <span class="comment">// state update or for strict mode.</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevEffect: Effect = currentHook.memoizedState;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="comment">// 比较两次依赖数组中的值是否有变化</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    inst,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-1.png" alt="alt text"></p>
<h3 id="create-和-destroy-函数是怎样被调用？"><a href="#create-和-destroy-函数是怎样被调用？" class="headerlink" title="create 和 destroy 函数是怎样被调用？"></a>create 和 destroy 函数是怎样被调用？</h3><p>在弄清楚怎样被调用之前，我们先来看 <code>destroy</code> 函数的存在性问题。即：在 <code>hook</code> 的 <code>mount</code> 阶段，我们创建 <code>effect</code> 对象的时候，<code>destroy</code> 函数是不存在的。因为，<code>destroy</code> 函数本来就是 <code>create</code> 函数的返回值。而此时 <code>create</code> 函数还没有被调用。</p>
<p>而我们知道，组件 <code>mount</code> 阶段过后， <code>create</code> 函数是一定会被调用的。所以，我们也可以推理得出，在组件的 <code>update</code> 阶段，<code>effect</code> 对象的 <code>create</code> 函数和 <code>destroy</code> 函数肯定是存在的（现在我们假设用户一定定义 <code>destroy</code> 函数 ）。</p>
<p><code>react</code> 会在 <code>commit</code> 阶段去调用我们的 <code>create</code> 函数和 <code>destroy</code> 函数。<code>commit</code> 阶段又可以分为三个子阶段:</p>
<ul>
<li>beforeMutation</li>
<li>mutation</li>
<li>layout</li>
</ul>
<p>回到源码的视角，<code>create</code> 函数和 <code>destroy</code> 函数调用具体是发生在 <code>commit</code> 阶段的入口函数 <code>commitRootImpl</code> 内部，而真正的调用入口函数为 <code>flushPassiveEffects</code>。</p>
<h4 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h4><p>该函数在 <code>commitRootImpl</code> 出现了三次。也就是说 <code>create</code> 函数和 <code>destroy</code> 函数调用存在三个入口：</p>
<ol>
<li>处理由于调用 <code>flushSyncUpdateQueue()</code> 所衍生的 <code>effect</code></li>
<li>在 <code>beforeMutation</code> 子阶段之前的对执行 <code>effect</code> 进行调度</li>
<li>在 <code>layout</code> 子阶段完成之后的同步调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  didIncludeRenderPhaseUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: EventPriority,</span></span></span><br><span class="line"><span class="function"><span class="params">  spawnedLane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">  &#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||</span><br><span class="line">    (finishedWork.flags &amp; PassiveMask) !== NoFlags</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">      rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">      pendingPassiveEffectsRemainingLanes = remainingLanes;</span><br><span class="line">      <span class="comment">// workInProgressTransitions might be overwritten, so we want</span></span><br><span class="line">      <span class="comment">// to store it in pendingPassiveTransitions until they get processed</span></span><br><span class="line">      <span class="comment">// We need to pass this through as an argument to commitRoot</span></span><br><span class="line">      <span class="comment">// because workInProgressTransitions might have changed between</span></span><br><span class="line">      <span class="comment">// the previous render and commit if we throttle the commit</span></span><br><span class="line">      <span class="comment">// with setTimeout</span></span><br><span class="line">      pendingPassiveTransitions = transitions;</span><br><span class="line">      scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ! 1. 异步执行 passive effects</span></span><br><span class="line">        flushPassiveEffects();</span><br><span class="line">        <span class="comment">// This render triggered passive effects: release the root cache pool</span></span><br><span class="line">        <span class="comment">// *after* passive effects fire to avoid freeing a cache pool that may</span></span><br><span class="line">        <span class="comment">// be referenced by a node in the tree (HostRoot, Cache boundary etc)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subtreeHasEffects =</span><br><span class="line">    (finishedWork.subtreeFlags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line">  <span class="keyword">const</span> rootHasEffect =</span><br><span class="line">    (finishedWork.flags &amp;</span><br><span class="line">      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span><br><span class="line">    NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subtreeHasEffects || rootHasEffect) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 进入commit阶段</span></span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</span><br><span class="line">      root,</span><br><span class="line">      finishedWork,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 3. mutation阶段 (包括DOM变更)</span></span><br><span class="line">    commitMutationEffects(root, finishedWork, lanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 4. layout阶段</span></span><br><span class="line">    commitLayoutEffects(finishedWork, root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(pendingPassiveEffectsLanes) &amp;&amp; root.tag !== LegacyRoot) &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过简单的 <code>react</code> 应用来测试得到的结果是：1）在组件的 <code>mount</code> 阶段，<code>react</code> 会走第二个入口；2）在组件的 <code>update</code> 阶段，<code>react</code> 会走第三个入口</p>
</blockquote>
<p><strong>不管是从哪个入口进入，create 函数和 destroy 函数调用都是发生了 DOM 更新之后</strong></p>
<p>不管是从哪个入口进入，它们都是走同一个函数 <code>flushPassiveEffects</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushPassiveEffectsImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">  commitPassiveUnmountEffects(root.current); <span class="comment">// cleanup</span></span><br><span class="line">  commitPassiveMountEffects(root, root.current, lanes, transitions); <span class="comment">//setup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且有相同的调用栈：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-2.png" alt="alt text"></p>
<p>因为调用 <code>destroy</code> 和 调用 <code>create</code> 函数是分开的。所以，我们需要将两者分开来讨论。但是由于两者的调用逻辑几乎是一样的。所以，在这里，我们以调用 <code>destroy</code> 函数为例即可，<code>create</code> 函数的调用原理跟这个是一样的。<br>通过源码的阅读和调试，我将「调用 <code>destroy</code> 函数的过程」划分为两个步骤：</p>
<ol>
<li>遍历 <code>fiber</code> 树 - 深度优先遍历 <code>fiber</code> 树，找到身上有 <code>effect</code> 的 <code>fiber</code> 节点</li>
<li>遍历 <code>effect</code> 链表 - 遍历当前的 <code>effect</code> 链表，根据当前 <code>effect</code> 是否满足特定的条件（是否包含特定标签）来确定是否要调用 <code>destroy</code> 函数。</li>
</ol>
<h4 id="1-遍历-fiber-树"><a href="#1-遍历-fiber-树" class="headerlink" title="1. 遍历 fiber 树"></a>1. 遍历 fiber 树</h4><p>我们也知道，所有的 <code>useEffect hook</code> 函数只能用 <code>function component</code> 里面使用。</p>
<p>而 <code>fiber</code> 上可能存在多个 <code>function component</code> 类型的 <code>fiber</code> 节点使用了 <code>hook</code> 函数。所以，这一步中，遍历 <code>fiber</code> 树的目的就是要找到消费了 <code>hook</code> 函数的 <code>fiber</code> 节点。</p>
<p>在这一步之前，<code>react</code> 其实是有做一些前置工作的。那就是：因为遍历 <code>fiber</code> 都是深度优先，在 <code>render</code> 阶段，<code>performUnitOfWork</code> 中的 <code>beginWork</code> 执行到叶子节点后会进入到 <code>completeUnitOfWork</code> 中，会执行 <code>bubbleProperties</code>，也就是 <code>react</code> 会逐步向上追溯当前消费了 <code>hook</code> 函数的 <code>fiber</code> 节点的所有的祖先 <code>fiber</code> 节点，一一给它们的 <code>subtreeFlags</code> 属性值加入一个 <code>Passive</code> 标签。这种机制类似于浏览器的事件冒泡。浏览器的事件起源于特定的 <code>DOM</code> 节点，但是它会在冒泡阶段向上传播到 <code>document</code> 这个根节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberCompleteWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">  popTreeContext(workInProgress);</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleProperties</span>(<span class="params">completedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> didBailout =</span><br><span class="line">    completedWork.alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    completedWork.alternate.child === completedWork.child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildLanes = NoLanes;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = NoFlags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!didBailout) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="comment">// “向上冒泡”最早的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// ! 2. 将他们的subtreeFlags和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// $FlowFixMe[unsafe-addition] addition with possible null/undefined value</span></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the return pointer so the tree is consistent. This is a code</span></span><br><span class="line">        <span class="comment">// smell because it assumes the commit phase is never concurrent with</span></span><br><span class="line">        <span class="comment">// the render phase. Will address during refactor to alternate model.</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line"></span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 子树的flags</span></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="comment">// In profiling mode, resetChildExpirationTime is also used to reset</span></span><br><span class="line">      <span class="comment">// profiler durations.</span></span><br><span class="line">      <span class="keyword">let</span> treeBaseDuration = ((completedWork.selfBaseDuration: any): number);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "Static" flags share the lifetime of the fiber/hook they belong to,</span></span><br><span class="line">        <span class="comment">// so we should bubble those up even during a bailout. All the other</span></span><br><span class="line">        <span class="comment">// flags have a lifetime only of a single render + commit, so we should</span></span><br><span class="line">        <span class="comment">// ignore them.</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// $FlowFixMe[unsafe-addition] addition with possible null/undefined value</span></span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = completedWork.child;</span><br><span class="line">      <span class="comment">// ! 遍历completedWork的所有子节点</span></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ! 1. 将他们的lanes和childLanes合并到newChildLanes中</span></span><br><span class="line">        newChildLanes = mergeLanes(</span><br><span class="line">          newChildLanes,</span><br><span class="line">          mergeLanes(child.lanes, child.childLanes),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "Static" flags share the lifetime of the fiber/hook they belong to,</span></span><br><span class="line">        <span class="comment">// so we should bubble those up even during a bailout. All the other</span></span><br><span class="line">        <span class="comment">// flags have a lifetime only of a single render + commit, so we should</span></span><br><span class="line">        <span class="comment">// ignore them.</span></span><br><span class="line">        <span class="comment">// “静态”标志（Static flags）与它们所属的 Fiber 或 Hook 共享生命周期，因此即使在放弃（bailout）时，也应该将这些flags向上冒泡。</span></span><br><span class="line">        <span class="comment">// 而其他所有flags仅在单次render + commit 的生命周期内存在，因此我们应该忽略它们。</span></span><br><span class="line">        <span class="comment">// ! 2. 将他们的（subtreeFlags&amp;StaticMask)和flags合并到subtreeFlags中</span></span><br><span class="line">        subtreeFlags |= child.subtreeFlags &amp; StaticMask;</span><br><span class="line">        subtreeFlags |= child.flags &amp; StaticMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the return pointer so the tree is consistent. This is a code</span></span><br><span class="line">        <span class="comment">// smell because it assumes the commit phase is never concurrent with</span></span><br><span class="line">        <span class="comment">// the render phase. Will address during refactor to alternate model.</span></span><br><span class="line">        <span class="comment">// 更新return pointer以保持树的一致性。这被描述为一种代码异味（code smell），因为它假设commit阶段永远不会与 render 阶段并发。</span></span><br><span class="line">        <span class="comment">// 在重构为交替模型（alternate model）时将会解决这个问题。</span></span><br><span class="line">        child.return = completedWork;</span><br><span class="line"></span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completedWork.subtreeFlags |= subtreeFlags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ! 后代节点的lanes</span></span><br><span class="line">  completedWork.childLanes = newChildLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> didBailout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>useEffect</code> 这个主题。上面所提到的前置工作中，有一点特别需要注意的点是：如果「消费了 <code>hook</code> 函数的那个 <code>fiber</code> 节点」的子树之下没有其他消费了 <code>hook</code> 函数的 <code>fiber</code> 节点，它自己的 <code>subtreeFlags</code> 属性值是不会被贴上一个 <code>Passive</code> 标签的。这也不难理解，因为这恰恰是符合 <code>subtreeFlags</code> 属性名的语义的。</p>
<p>假设只有我们的 <code>&lt;Counter /&gt;</code> 组件里面消费到 <code>useEffect</code> 这个 <code>hook</code> 函数。那么，在 <code>render</code> 阶段，经过上面所提到的前置工作后，我们会得到这样的一颗 <code>fiber</code> 树：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-3.png" alt="alt text"></p>
<p>好了，做完上面的前置工作后，<code>react</code> 会在 <code>commit</code> 阶段发起对 <code>flushPassiveEffects</code> 的调度，将任务加入 <code>taskQueue</code> 中，在适当的时间切片内会执行到此调度。</p>
<p>这个遍历工作是从 <code>fiber</code> 树的根节点 - <code>hostRootFiber</code> 开始的。</p>
<p>源码中的 <code>commitPassiveUnmountOnFiber()</code> ， <code>recursivelyTraversePassiveUnmountEffects()</code> 和 <code>commitHookPassiveUnmountEffects()</code> 这三个函数共同完成了这个过程。而这三个函数是有分工的：</p>
<ul>
<li>commitPassiveUnmountOnFiber() - 是遍历流程的入口</li>
<li>recursivelyTraversePassiveUnmountEffects() - 负责实现了以深度优先的算法的「递」与「归」</li>
<li>commitHookPassiveUnmountEffects() - 在「归」之前，尝试去调用当前 fiber 节点 effect 链表上的所有的 destroy 函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_commitPassiveUnmountOnFiber</span>(<span class="params">parentFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentFiber.subtreeFlags &amp; PassiveMask) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = parentFiber.child;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            my_commitPassiveUnmountOnFiber(child);</span><br><span class="line">            child = child.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isfunctionComponentKind = [FunctionComponent, ForwardRef, SimpleMemoComponent].includes(parentFiber.tag);</span><br><span class="line">    <span class="keyword">const</span> hasPassiveEffect = parentFiber.flags &amp; Passive</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isfunctionComponentKind &amp;&amp; hasPassiveEffect)&#123;</span><br><span class="line">        commitHookPassiveUnmountEffects(</span><br><span class="line">            parentFiber,</span><br><span class="line">            parentFiber.return,</span><br><span class="line">            Passive | HasEffect</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实看完 <code>react</code> 源码，熟悉 <code>react</code> 内部的原理后，这种深优先遍历算法跟 <code>render</code> 阶段的 「work-loop」的遍历算法是一模一样的。唯一的一个区别点有两点：</p>
<ol>
<li>它深度优先遍历不一定会遍历到当前子树路径的叶子节点。它会因为不满足「以当前 parentFiber 为根节点的子树上是否有身上贴有 Passive 标签的 fiber 节点？」这个条件提前终止了；</li>
<li>跟 <code>render</code> 阶段的 「work-loop」的遍历算法中，归去之前必定会执行 <code>complete work</code> 不同，当前的遍历算法会先检查是否满足条件，如果不满足，则不执行 “complete work” 。显然，这里的 “complete work” 是指 <code>commitHookPassiveUnmountEffects()</code> 的调用。</li>
</ol>
<h4 id="2-遍历-effect-链表"><a href="#2-遍历-effect-链表" class="headerlink" title="2. 遍历 effect 链表"></a>2. 遍历 effect 链表</h4><p>上面，我们已经介绍了 <code>react</code> 是如何了遍历整棵 <code>fiber</code> 树，找到那些所有需要执行 <code>effect</code> 的 <code>fiber</code> 节点。上一步骤末尾，我们也指出了，执行 <code>effect</code> 的 <code>fiber</code> 节点的函数是 <code>commitHookPassiveUnmountEffects()</code>。而 <code>commitHookPassiveUnmountEffects()</code> 会直接调用 <code>commitHookEffectListUnmount()</code>。顾名思义，该函数就是 <code>react</code> 遍历 <code>effect</code> 链表去调用 <code>destroy</code> 函数的所在。</p>
<p><strong>effect 链表并不是只存储 useEffect hook 函数的 effect 对象</strong></p>
<p>那这里所提到的 「effect 类型的」hook 函数有哪些呢？从 <a href="mailto:react@18.2.0">react@18.2.0</a> 的源码来看，它包括了5 种类型的 <code>hook</code> 函数：</p>
<ul>
<li>useEffect()</li>
<li>useLayoutEffect()</li>
<li>useInsertionEffect()</li>
<li>useSyncExternalStore()</li>
<li>useImperativeHandle()</li>
</ul>
<p>提出这个结论的依据是: 这些 hook 函数的调用栈最终都是指向了 pushEffect() 函数。如下图：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-4.png" alt="alt text"></p>
<p>而 <code>pushEffect()</code> 函数就是负责创建新的 <code>effect</code> 对象，把它追加到当前 <code>fiber</code> 节点 <code>effect</code> 链表的尾部。可见，如果一个 <code>function component</code> 都消费了上面这些 <code>hook</code> 函数的话，那么它所对应的 <code>fiber</code> 节点的 <code>effect</code> 链表上并不是单纯包含 <code>useEffect hook</code> 函数所产生的 <code>effect</code>。<br>回到正题。上面我们指出了 <code>commitHookEffectListUnmount</code> 函数就是 <code>react</code> 遍历 <code>effect</code> 链表去调用 <code>destroy</code> 函数的所在，下面来看看它的源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListUnmount</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    finishedWork,</span></span></span><br><span class="line"><span class="function"><span class="params">    nearestMountedAncestor</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">    <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">          <span class="comment">// Unmount</span></span><br><span class="line">          <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">          effect.destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effect = effect.next;</span><br><span class="line">      &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyCallDestroy</span>(<span class="params">current, nearestMountedAncestor, destroy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      destroy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(current, nearestMountedAncestor, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的铺垫，我们很快就能看明白这段代码的意思。<code>react</code> 通过 <code>do{...}while()</code> 循环来遍历 <code>effect</code> 链表。我们在上面也提到过，<code>effect</code> 链表其实是单向的循环链表。所以，当前即将需要遍历的 <code>effect</code> 对象又指会了第一个 <code>effect</code> 的时候，意味着我们已经遍历完了整条链表，可以退出循环了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-5.png" alt="alt text"></p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">childEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Child effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sibling</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">siblingEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sibling effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">appEffect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'App effect been called'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">             &lt;Child /&gt;</span><br><span class="line">             &lt;Sibling /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>相信看完上面的分析，也不难得出答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child effect been called</span><br><span class="line">Sibling effect been called</span><br><span class="line">App effect been called</span><br></pre></td></tr></table></figure>

<p>react 采用的递归遍历算法是深度优先算法。示例 react 应用所对应的 fiber 树如下：</p>
<p><img src="../images/react18.2hook%E4%B9%8BuseEffect%E5%92%8CuseLayoutEffect%E5%8E%9F%E7%90%86/image-6.png" alt="alt text"></p>
<p>用文字描述整个递归遍历过程是这样的：<br><code>&lt;App&gt;</code> 的递；<br><code>&lt;div&gt;</code> 的递；<br><code>&lt;Child&gt;</code> 的递；<br><code>&lt;Child&gt;</code> 的归；<br><code>&lt;Sibling&gt;</code> 的递；<br><Sibling><code>的归；
``&lt;App&gt;</code> 的归。</p>
<p>在归时候，react 会在当前 fiber 节点上调用 commitHookEffectListMount() 函数，所以，调用结果是：</p>
<p>在 <code>&lt;Child&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>；<br>在 <code>&lt;Sibling&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>；<br>在 <code>&lt;App&gt;</code> 身上调用 <code>commitHookEffectListMount()</code>。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p><code>useLayoutEffect</code> 函数跟 <code>useEffect</code> hook 函数 的不同。两者的不同之处在于两点：</p>
<ol>
<li>它们给「自己所创建的 effect 对象」所贴的 <code>effect flag</code> 是不同的；</li>
<li>它们给「自己所关联的 fiber 节点」所追加的 <code>fiber flag</code> 的不同的。</li>
</ol>
<h3 id="所贴的-hook-flag-不同"><a href="#所贴的-hook-flag-不同" class="headerlink" title="所贴的 hook flag 不同"></a>所贴的 hook flag 不同</h3><ul>
<li>对于 <code>useLayoutEffect() hook</code> 函数而言，它给自己所创建的 <code>effect</code> 对象所贴的 <code>effect flag</code> 是 <code>Layout</code></li>
<li>而 <code>useEffect() hook</code> 函数给自己所创建的 <code>effect</code> 对象所贴的 <code>effect flag</code> 是 <code>Passive</code>；</li>
</ul>
<h3 id="所追加的-fiber-flag-不同"><a href="#所追加的-fiber-flag-不同" class="headerlink" title="所追加的 fiber flag 不同"></a>所追加的 fiber flag 不同</h3><p>对于 <code>useEffect() hook</code> 函数而言，它给自己所关联的 <code>fiber</code> 节点所追加的 <code>fiber flag</code> 是：</p>
<ul>
<li><code>mount</code> 阶段是 <code>Passive | PassiveStatic</code></li>
<li><code>update</code> 阶段是 <code>Passive</code></li>
</ul>
<p>而 <code>useLayoutEffect() hook</code> 函数给自己所关联的 <code>fiber</code> 节点所追加的 <code>fiber flag</code> 是：</p>
<ul>
<li><code>mount</code> 阶段是 <code>Update | LayoutStatic</code></li>
<li><code>update</code> 阶段是 <code>Update</code></li>
</ul>
<h3 id="useLayoutEffect-mutation-子阶段调用-destroy-函数"><a href="#useLayoutEffect-mutation-子阶段调用-destroy-函数" class="headerlink" title="useLayoutEffect - mutation 子阶段调用 destroy 函数"></a>useLayoutEffect - mutation 子阶段调用 destroy 函数</h3><p>它的 <code>destroy</code> 函数的调用是发生在 <code>mutation</code> 子阶段。具体来讲，就是发生在 <code>commitMutationEffectsOnFiber()</code> 这个函数里面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffectsOnFiber</span>(<span class="params">finishedWork, root, lanes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = finishedWork.alternate;</span><br><span class="line">    <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        recursivelyTraverseMutationEffects(root, finishedWork);</span><br><span class="line">        commitReconciliationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          <span class="comment">// ......</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              commitHookEffectListUnmount(</span><br><span class="line">                Layout | HasEffect,</span><br><span class="line">                finishedWork,</span><br><span class="line">                finishedWork.return</span><br><span class="line">              );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              captureCommitPhaseError(finishedWork, finishedWork.return, error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useLayoutEffect-layout-子阶段调用-create-函数"><a href="#useLayoutEffect-layout-子阶段调用-create-函数" class="headerlink" title="useLayoutEffect - layout 子阶段调用 create 函数"></a>useLayoutEffect - layout 子阶段调用 create 函数</h3><ul>
<li>hook 类型 - 这里就是指 useLayoutEffect() hook 的 create 函数；</li>
<li>class 类型 - 这里是指 class component 的两个生命周期函数：<ul>
<li>componentDidMount()</li>
<li>componentDidUpdate()</li>
</ul>
</li>
</ul>
<p><code>useLayoutEffect() hook</code> 的 <code>create</code> 函数的真正调用入口为 <code>commitHookLayoutEffects()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    finishedRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    current,</span></span></span><br><span class="line"><span class="function"><span class="params">    finishedWork,</span></span></span><br><span class="line"><span class="function"><span class="params">    committedLanes</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flags = finishedWork.flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        recursivelyTraverseLayoutEffects(</span><br><span class="line">          finishedRoot,</span><br><span class="line">          finishedWork,</span><br><span class="line">          committedLanes</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Update) &#123;</span><br><span class="line">          commitHookLayoutEffects(finishedWork, Layout | HasEffect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>关于这个问题，react 官方文档给出了一个使用用例： <a href="https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen" target="_blank" rel="noopener">在浏览器重绘之前测量 DOM 的布局信息</a>。</p>
<p>「界面更新时候的闪烁问题」。为什么使用 <code>useLayoutEffect()</code> 能解决这类的问题呢？</p>
<p>首先，我们要知道为什么会造成闪烁。造成闪烁的原因是 <code>react</code> 在短时间更新了多帧显示内容不一样的界面。而 <code>useLayoutEffect() hook</code> 的 <code>create</code> 函数是在 <code>layout</code> 子阶段以同步的，批量的方式去执行的。也就是说，<code>create</code> 函数里面的所发起的多次状态更新请求只会产生一次的实质性的界面重绘。 通过抹除代表着中间状态的过渡帧，将多帧压缩为一帧来更新界面，这就是 <code>useLayoutEffect()</code> 能解决「界面更新时候的闪烁问题」原因之所在。</p>
<p>上面所提到的 「界面更新时候的闪烁问题」只是 <code>useLayoutEffect()</code> 能解决问题中的一个垂类。useLayoutEffect() 应该还能解决更多不同业务场景下的问题，我们得通过现象看本质。</p>
<p>那 <code>useLayoutEffect()</code> 的本质能力是什么？</p>
<ul>
<li>访问更新后的 <code>DOM</code> 树 - 因为 <code>useLayoutEffect() hook</code> 的 <code>create</code> 函数是在 <code>mutation</code> 子阶段之后的 <code>layout</code> 子阶段执行的。所以，这就意味着我们可以去访问更新后的 <code>DOM</code> 树和做一些布局信息的测量。</li>
<li>同步/批量执行状态更新，阻塞浏览器重绘 - <code>react</code> 将会以「同步阻塞，批量更新」的方式去对待 <code>create</code> 函数体里面所发起的过个状态更新请求。也就说，在 <code>create</code> 函数体里面所发起的过个状态更新请求只会产生一次界面重绘。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从源码的角度来看， 这两者其实都是在同一个架构里面，拥有很多相同点：</p>
<ul>
<li>每一个 <code>effect</code> 类型 <code>hook</code> 都会关联一个 <code>hook</code> 对象 和 <code>effect</code> 对象；</li>
<li>同一个 <code>function component</code> 内，所有的 <code>hook</code> 对象都共用同一条 <code>hook</code> 链表；</li>
<li>同一个 <code>function component</code> 内，所有的 <code>effect</code> 对象都共用同一条 <code>effect</code> 链表；</li>
<li>同一个调用机制 - 在 <code>render</code> 阶段创建 <code>hook</code> 对象和 <code>effect</code> 对象，在 <code>commit</code> 阶段去调用 <code>hook</code> 的 <code>create</code> 和 <code>destroy</code> 函数。</li>
</ul>
<p>这两者的不同点在于：</p>
<ul>
<li><code>useEffect()</code> 的 <code>destroy</code> 和 <code>create</code> 函数是在同一个子阶段(<code>layout</code> 子阶段后的 <code>passive</code> 子阶段)调用的（调用入口要么是调度后的 <code>flushPassiveEffectImpl()</code>,要么是同步的<code>flushPassiveEffectImpl()</code>）；</li>
<li><code>useLayoutEffect()</code> 的这两个函数却是在不同的子阶段执行。<code>destroy</code> 是在 <code>mutation</code> 子阶段执行的，而 <code>create</code> 是在 <code>layout</code> 子阶段。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2hook%E4%B9%8BuseCallback%E5%92%8CuseMemo%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2hook%E4%B9%8BuseCallback%E5%92%8CuseMemo%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2hook之useCallback和useMemo原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-22 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-22T00:00:00+08:00">2024-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>useCallback</code> 和 <code>useMemo</code> 是一样的东西，只是入参有所不同。</p>
<p><code>useCallback</code> 缓存的是回调函数，如果依赖项没有更新，就会使用缓存的回调函数</p>
<p><code>useMemo</code> 缓存的是回调函数的 <code>return</code>，如果依赖项没有更新，就会使用缓存的 <code>return</code></p>
<p>官网有这样一段描述，换言之 <code>useCallback(fn, dependencies)</code> 相当于 <code>useMemo(() =&gt; fn, dependencies)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simplified implementation (inside React)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">fn, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> fn, dependencies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><strong><code>useCallback</code> 允许你在组件渲染之间保存 函数定义。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedFn = useCallback(fn, dependencies)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li><code>fn</code> ：想要缓存的函数。此函数可以接受任何参数并且返回任何值。<ol>
<li>React 将会在初次渲染⽽⾮调⽤时返回该函数。</li>
<li>当进⾏下⼀次渲染时，如果 <code>dependencies</code> 相⽐于上⼀次渲染时没有改变，那么 React 将会返回相同的函数。</li>
<li>否则，React 将返回在最新⼀次渲染中传⼊的函数，并且将其缓存以便之后使⽤。</li>
<li>React 不会调⽤此函数，⽽是返回此函数。你可以⾃⼰决定何时调⽤以及是否调⽤。</li>
</ol>
</li>
<li><code>dependencies</code> ：有关是否更新 <code>fn</code> 的所有响应式值的⼀个列表。<ol>
<li>响应式值包括 <code>props</code>、<code>state</code>，和所有在你组件内部直接声明的变量和函数。</li>
<li>依赖列表必须具有确切数量的项，并且必须像 <code>[dep1, dep2, dep3]</code> 这样编写。</li>
<li>React 使⽤ <code>Object.is</code> ⽐较每⼀个依赖和它的之前的值。</li>
</ol>
</li>
</ol>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在初次渲染时， <code>useCallback</code> 返回你已经传⼊的 <code>fn</code> 函数</p>
<p>在之后的渲染中, 如果依赖没有改变， <code>useCallback</code> 返回上⼀次渲染中缓存的 <code>fn</code> 函数；否则返回这⼀次渲染传⼊的 <code>fn</code> 。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateCallback</code> 代码意图也很简单，如果依赖数组 <code>deps</code> 没有变化，或者 <code>deps=[]</code> 的情况下，会返回之前缓存的回调函数，否则就更新对应 <code>fiber.memoizedState.hook.memoizedState</code> 并返回新的回调函数。</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p><code>useMemo</code> 是每次重新渲染的时候能够缓存计算结果的Hook。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedValue = useMemo(calculateValue, dependencies)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="comment">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span></span><br><span class="line">  <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h2><ol>
<li><code>useCallBack</code> 不要每个函数都包一下，否则就会变成反向优化。<ol>
<li><code>useCallBack</code> 本身就是需要一定性能的</li>
<li>其次 <code>useCallBack</code> 并不能阻止函数重新创建, 由于使用 <code>useCallback</code> 时，函数会作为实参传给 <code>useCallback</code>，所以无论怎样 <code>useCallback</code> 包裹的函数都是会重新创建的，只是当 <code>useCallback</code> 的依赖没有改变时返回的是缓存中的函数而已</li>
</ol>
</li>
<li><code>useMemo</code> 的关键是权衡。其目的是避免不必要的计算，但也要注意不要滥用，因为维持这些缓存值也是有开销的。最佳的做法是先写出清晰和可读的代码，然后在性能瓶颈出现时，再考虑优化。<ol>
<li>如果函数组件中某个值需要大量的计算才能得出，或者渲染某个组件时有昂贵的计算，都可以考虑使用 <code>useMemo</code> 进行包裹</li>
<li>当值作为别的 hooks 的依赖时，可以考虑使用</li>
</ol>
</li>
<li>如果某个函数或者值是传递给子组件的 <code>props</code>，可以考虑使用 <code>useCallback</code> 或者 <code>useMemo</code> 进行包裹（配合 <code>React.memo</code> 使用）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2高优先级任务插队和饥饿任务问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T00:00:00+08:00">2024-12-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>时间切片是 <code>Concurrent Mode</code> 的核心机制之一。它的主要目的是将长任务分解为小的任务单元,每个单元只执行一小段时间,然后让出控制权,避免长时间阻塞主线程。</p>
<p>react 的并发模式在 render 阶段 <strong>每处理一个 fiber 就会根据以下两点判断一次是否应该打断并把控制权交换给主线程：</strong></p>
<ol>
<li>是否超过分片时间（5ms）</li>
<li>根据 <code>isInputPending</code> 判断是否有用户输入</li>
</ol>
<p>但是并不会根据优先级来打断，优先级只会影响任务队列的任务排序，所以按照按优先级排序好的任务顺序来执行，也就能让高优先级任务得到及时处理。</p>
<p>当一个任务开始执行时, <code>Scheduler</code> 会为其分配一个时间片 (通常为 5ms)。在这个时间片内,任务可以连续执行。</p>
<ul>
<li>如果任务在时间片内完成，则直接结束</li>
<li>如果任务执行时间超过了时间片，则 <code>Scheduler</code> 会中断任务的执行，保存当前的进度，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
<li>如果任务执行中，遇到用户输入等需要浏览器及时反馈的操作，会通过判断 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduling/isInputPending" target="_blank" rel="noopener"><code>isInputPending</code></a>，会中断当前任务，并让出控制权给浏览器，以便响应用户交互或执行其他高优先级的任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>shouldYield</code> 判断，具体方法就详细说明了，可以去看<a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react调度器scheduler源码分析》</a></p>
<h2 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h2><p><code>scheduleTaskForRootDuringMicrotask</code> 每次执行都会判断上一次中断任务优先级和root下的最高优先级是否一样。</p>
<ul>
<li>如果一样，说明没有更高优先级的更新产生，可以继续上次未完成的协调；</li>
<li>如果不一样，说明有更高优先级的更新进来，要清空之前已开始的协调过程，从根节点开始重新协调。等高优先级更新处理完成以后，再次从根节点开始处理低优先级更新。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberRootScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数总是在microtask中被调用，或者在渲染任务的最后，在我们将控制权交还给主线程之前被调用。它绝对不应该被同步调用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有任何lanes被其他work饿死。如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们。</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">  <span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line">  <span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line">  <span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Check if there's nothing to work on</span></span><br><span class="line">    nextLanes === NoLanes ||</span><br><span class="line">    <span class="comment">// If this root is currently suspended and waiting for data to resolve, don't</span></span><br><span class="line">    <span class="comment">// schedule a task to render it. We'll either wait for a ping, or wait to</span></span><br><span class="line">    <span class="comment">// receive an update.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Suspended render phase</span></span><br><span class="line">    (root === workInProgressRoot &amp;&amp; isWorkLoopSuspendedOnData()) ||</span><br><span class="line">    <span class="comment">// Suspended commit phase</span></span><br><span class="line">    root.cancelPendingCommit !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There's nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="keyword">return</span> NoLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a new callback in the host environment.</span></span><br><span class="line">  <span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// sy- setState</span></span><br><span class="line">    <span class="comment">// sy-no 初次渲染</span></span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        ReactCurrentActQueue.current !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn't changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We'll schedule a new one below.</span></span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="keyword">switch</span> (lanesToEventPriority(nextLanes)) &#123;</span><br><span class="line">      <span class="keyword">case</span> DiscreteEventPriority:</span><br><span class="line">        schedulerPriorityLevel = ImmediateSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ContinuousEventPriority:</span><br><span class="line">        schedulerPriorityLevel = UserBlockingSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DefaultEventPriority: <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// ? sy 页面初次渲染、transition(128)</span></span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdleEventPriority:</span><br><span class="line">        schedulerPriorityLevel = IdleSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        schedulerPriorityLevel = NormalSchedulerPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-高优先级打断低优先级"><a href="#1-高优先级打断低优先级" class="headerlink" title="1. 高优先级打断低优先级"></a>1. 高优先级打断低优先级</h2><h3 id="cancelCallback"><a href="#cancelCallback" class="headerlink" title="cancelCallback"></a>cancelCallback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cancelCallback(existingCallbackNode)</code>，<code>cancelCallback</code> 函数就是将 <code>root.callbackNode</code> 赋值为 <code>null</code></p>
<h3 id="performConcurrentWorkOnRoot"><a href="#performConcurrentWorkOnRoot" class="headerlink" title="performConcurrentWorkOnRoot"></a>performConcurrentWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush any pending passive effects before deciding which lanes to work on,</span></span><br><span class="line">  <span class="comment">// in case they schedule additional work.</span></span><br><span class="line">  <span class="keyword">const</span> originalCallbackNode = root.callbackNode;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在某些情况下，我们会禁用时间片切片：如果work过长时间做计算（为了防止饥饿而将其视为“过期”的work），或者我们处于默认启用同步更新模式。</span></span><br><span class="line">  <span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp; <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ! 1. render</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes) <span class="comment">// 参考这个例子，UseDeferredValuePage</span></span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// ? sy, 不用时间切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus !== RootInProgress) &#123;</span><br><span class="line">    <span class="keyword">let</span> renderWasConcurrent = shouldTimeSlice;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">        <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">        <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">        <span class="comment">// consistent tree or committing.</span></span><br><span class="line">        markRootSuspended(root, lanes, NoLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ! 2. render结束，做一些检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// !3. commit</span></span><br><span class="line">        <span class="comment">// 我们现在有了一个一致的树。下一步要么是commit，要么是，如果有什么被暂停了，就等待一段时间后再commit。</span></span><br><span class="line">        root.finishedWork = finishedWork;</span><br><span class="line">        root.finishedLanes = lanes;</span><br><span class="line">        finishConcurrentRender(root, exitStatus, finishedWork, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line">  <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getContinuationForRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  originalCallbackNode: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is called at the end of `performConcurrentWorkOnRoot` to determine</span></span><br><span class="line">  <span class="comment">// if we need to schedule a continuation task.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;</span></span><br><span class="line">  <span class="comment">// however, since most of the logic for determining if we need a continuation</span></span><br><span class="line">  <span class="comment">// versus a new task is the same, we cheat a bit and call it here. This is</span></span><br><span class="line">  <span class="comment">// only safe to do because we know we're at the end of the browser task.</span></span><br><span class="line">  <span class="comment">// So although it's not an actual microtask, it might as well be.</span></span><br><span class="line">  scheduleTaskForRootDuringMicrotask(root, now());</span><br><span class="line">  <span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">    <span class="comment">// The task node scheduled for this root is the same one that's</span></span><br><span class="line">    <span class="comment">// currently executed. Need to return a continuation.</span></span><br><span class="line">    <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performConcurrentWorkOnRoot</code> 函数是每个并发任务的入口，下面简要分析以下它的运行流程：</p>
<ol>
<li>会先把 <code>root.callbackNode</code> 缓存起来，存在 <code>originalCallbackNode</code> 变量中</li>
<li>并发模式下会使用 <code>renderRootConcurrent</code> 执行<ol>
<li>在 <code>render</code> 阶段中也有可能在代码执行中，触发更高优先级事件，例如点击事件，高优先级事件又触发了 <code>setState</code> 就是相对高优先级的</li>
<li><code>setState</code> 执行 <code>scheduleUpdateOnFiber</code> 的 <code>prepareFreshStack</code>和 <code>markRootUpdated</code> 函数，就已经把 <code>update</code> 添加到 <code>fiber</code> 上并且将更新优先级标记到 <code>root</code> 的 <code>pendingLanes</code> 上了</li>
</ol>
</li>
<li>如果render阶段结束，做一些检查，commit阶段，如果render阶段中断，会直接跳过上述操作，走到函数的末尾</li>
<li>在函数末尾会调用 <code>getContinuationForRoot</code> 函数，先执行 <code>scheduleTaskForRootDuringMicrotask</code> 就是把 <code>render</code> 中目前最高优先级事件和当前任务优先级作对比，进行 <code>cancelCallback</code> 或者 <code>scheduleCallback</code>，同时 <code>root.callbackNode</code> 也可能被改掉了</li>
<li>再判断 <code>root.callbackNode</code> 和开始缓存起来的值  <code>originalCallbackNode</code>  是否一样，如果不一样，就代表 <code>root.callbackNode</code> 被赋值为 <code>null</code> 或者其他的<code>task</code> 值，代表有更高优先级任务进来。</li>
<li>此时 <code>performConcurrentWorkOnRoot</code> 返回值为 <code>null</code></li>
</ol>
<h3 id="pop-taskQueue"><a href="#pop-taskQueue" class="headerlink" title="pop(taskQueue)"></a>pop(taskQueue)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">    <span class="comment">// 返回值continuationCallback是函数，也就是performConcurrentWorkOnRoot执行后的返回值performConcurrentWorkOnRoot.bind(null, root)或null，如果是函数就继续，不是的话，如果判断如果currentTask === peek(taskQueue)，currentTask 出队</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// If a continuation is returned, immediately yield to the main thread</span></span><br><span class="line">        <span class="comment">// regardless of how much time is left in the current time slice.</span></span><br><span class="line">        <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskYield(currentTask, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          markTaskCompleted(currentTask, currentTime);</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">          currentTask.isQueued = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pop(taskQueue);</span><br><span class="line">&#125;</span><br><span class="line">currentTask = peek(taskQueue);</span><br></pre></td></tr></table></figure>

<p>上面是 <code>Scheduler</code> 模块里面 <code>workLoop</code> 函数的代码片段，<code>currentTask.callback</code> 就是 <code>scheduleCallback</code> 的第二个参数，也就是<code>performConcurrentWorkOnRoot</code> 函数。</p>
<p>承接上个主题，如果 <code>performConcurrentWorkOnRoot</code> 函数返回了 <code>null</code>，<code>workLoop</code> 内部就会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出。</p>
<h3 id="低优先级任务重启"><a href="#低优先级任务重启" class="headerlink" title="低优先级任务重启"></a>低优先级任务重启</h3><p>上一步中说道一个低优先级任务从 <code>taskQueue</code> 中被弹出。那高优先级任务执行完毕之后，如何重启回之前的低优先级任务呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span><br><span class="line">markRootFinished(root, remainingLanes, spawnedLane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Always call this before exiting `commitRoot`, to ensure that any</span></span><br><span class="line"><span class="comment">// additional work on this root is scheduled.</span></span><br><span class="line">ensureRootIsScheduled(root, now());</span><br></pre></td></tr></table></figure>

<p><code>markRootFinished</code> 函数刚刚上面说了是释放已完成任务的 <code>Lane</code>，那也就是说未完成任务依然会存在 <code>lanes</code> 中，所以我们可以重新调用 <code>ensureRootIsScheduled</code> 发起一次新的调度，去重启低优先级任务的执行。我们可以看下重启部分的判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workInProgressRoot = getWorkInProgressRoot();</span><br><span class="line"><span class="keyword">const</span> workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 如果 nextLanes 为 NoLanes，就证明所有任务都执行完毕了</span></span><br><span class="line"><span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackPriority = NoLane;</span><br><span class="line">    <span class="comment">// 只要 nextLanes 为 NoLanes，就可以结束调度了</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 nextLanes 不为 NoLanes，就代表还有任务未执行完，也就是那些被打断的低优先级任务</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><code>commit</code> 的最后还是会 <code>ensureRootIsScheduled</code>，高优先级插队后低优先级任务能重启的原因：<code>taskQueue</code>中被打断的低优先级的任务已经 <code>pop</code>了，但是 <code>root</code> 上还有 <code>pendingLanes</code>，通过 <code>ensureRootIsScheduled</code> 重新把低优先级的任务加入 <code>taskQueue</code> 中。</p>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><ol>
<li>任务通过 <code>unstable_scheduleCallback</code> 进行调度，将任务添加到 <code>taskQueue</code> 中，如果是首次加载通过 <code>requestHostCallback</code> 调度宏任务</li>
<li><code>Scheduler</code> 里执行 <code>flush</code> 后执行 <code>workLoop</code> 方法，在 <code>workLoop</code> 方法中取出第一个任务，判断是否超出切片时间或者有更需要及时反馈的用户操作，如果没有，那当执行任务的 <code>callback</code> 时，也就是 <code>performConcurrentWorkOnRoot</code> 方法，执行流程可以看上面。所以我们知道 <code>performConcurrentWorkOnRoot</code> 方法可能会返回null，也可能会返回 <code>performConcurrentWorkOnRoot</code></li>
<li>当返回 <code>null</code> 时候，<code>Scheduler</code> 会执行 <code>pop(taskQueue)</code>，将当前的任务从 <code>taskQueue</code>中弹出</li>
<li>低优先级任务重启，<code>commitRootImpl</code> 最后会再次调用 <code>ensureRootIsScheduled(root, now())</code>，判断如果 <code>nextLanes</code> 为 <code>NoLanes</code>，就证明所有任务都执行完毕了，如果 <code>nextLanes</code> 不为 <code>NoLanes</code>，就代表还有任务未执行完，也就是那些被打断的低优先级任务，会重新进行调度</li>
</ol>
<h2 id="任务插队情况具体总结分析"><a href="#任务插队情况具体总结分析" class="headerlink" title="任务插队情况具体总结分析"></a>任务插队情况具体总结分析</h2><p>结合 <code>eventLoop</code>， 用户 <code>click</code> 是一个宏任务，会把回调 <code>push</code> 到宏任务队列，等待下一次执行。<code>react</code> 的并发，也是分成了 <code>5ms</code> 的宏任务来执行。</p>
<h3 id="情况1-用户手动触发高优先级任务"><a href="#情况1-用户手动触发高优先级任务" class="headerlink" title="情况1 - 用户手动触发高优先级任务"></a>情况1 - 用户手动触发高优先级任务</h3><p>例如正在执行一个并发任务的时候，用户点击了按钮准备触发 <code>setState</code>（可能是一个 <code>lane</code> 为 <code>2</code> 的同步任务，也可能是比现在优先级高的其它任务），会把这个回调加入到宏任务队列，等到并发任务执行结束，（ <code>flushWork</code> 的返回值如果是 <code>true</code>，也会 <code>schedulePerformWorkUntilDeadline</code> 再次 <code>push</code> 一个任务到宏任务队列，<code>click</code> 的回调在这个任务的前面）</p>
<p>下次进入宏任务队列，取出一个任务也就是 <code>click</code> 的回调，执行 <code>dispatchSetState</code>，<code>isRenderPhaseUpdate</code> 为 <code>false</code>（还没进入到 <code>render</code> 阶段），<code>scheduleUpdateOnFiber</code> 也会向 <code>root</code> 上标记待执行任务的优先级，<code>ensureRootIsScheduled</code> 调度了微任务<code>scheduleImmediateTask</code>，宏任务执行完毕</p>
<p>进入微任务执行 <code>processRootScheduleInMicrotask</code>，执行 <code>scheduleTaskForRootDuringMicrotask</code>：</p>
<ol>
<li>这里会进行高优先级打断低优先级的 <code>cancelCallback</code> 操作、通过 <code>scheduleCallback</code> 将任务加入到 <code>taskQueue</code> 中（<code>taskQueue</code> 是最小堆，也会根据 <code>lane</code> 排序）</li>
<li>上面如果是同步任务，就不会执行 <code>scheduleCallback</code>，会在 <code>microtask</code> 结束时，<code>flushSyncWorkOnAllRoots()</code>;（ <code>flush</code> 任何<code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。）</li>
<li>最后执行完微任务，等到下次执行宏任务的时候，高优先级的就会先执行，以后再执行到低优先级时，其实低优先级没有 <code>callback</code> 了，就会跳过，后面<code>commit</code> 最后再重新发起调度低优先级任务</li>
</ol>
<h3 id="情况2-代码里触发了高优先级任务"><a href="#情况2-代码里触发了高优先级任务" class="headerlink" title="情况2 - 代码里触发了高优先级任务"></a>情况2 - 代码里触发了高优先级任务</h3><p>还有另一种情况是在某个并发任务的 <code>performConcurrentWorkOnRoot</code> 里的 <code>render</code> 过程中加入了可能是一个 <code>lane</code> 为 <code>2</code> 的同步任务，也可能是比现在优先级高的其它任务，会在此次任务切片<code>（5ms）</code>结束后，来进行判断（切片结束是通过 <code>workLoopConcurrent</code> 里面判断）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performConcurrentWorkOnRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  didTimeout: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">RenderTaskFn</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> getContinuationForRoot(root, originalCallbackNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果是比现在优先级高的任务但又不是同步任务，<code>getContinuationForRoot</code> 的 <code>scheduleTaskForRootDuringMicrotask</code> 会进行打断低优先级任务并对新的且不是同步任务的发起 <code>scheduleCallback</code> 调度加入到 <code>taskQueue</code> 中，最终 <code>performConcurrentWorkOnRoot</code> 的返回值 <code>return null</code>，在 <code>workLoop</code> 的 <code>continuationCallback</code> 为 <code>null</code>, 会把当前的低优先级任务移除。取出 <code>taskQueue</code> 中的目前最高优先级的任务进行新的调度。</li>
<li>如果是添加同步任务是在 <code>dispatchSetState</code> 里的 <code>ensureRootIsScheduled</code> 发起的微任务调度，或者在 <code>performConcurrentWorkOnRoot</code> 的最后 <code>ensureRootIsScheduled</code> 发起的调度，执行完本次任务切片的宏任务接着执行微任务的时候同步任务就会被执行了</li>
</ol>
<p>所以所有同步任务也都是在 <code>microtask</code> 结束时执行的，已保证最高的优先级且尽可能早的执行</p>
<h2 id="2-饥饿任务问题"><a href="#2-饥饿任务问题" class="headerlink" title="2. 饥饿任务问题"></a>2. 饥饿任务问题</h2><p>上面说到，在高优先级任务执行完毕之后，低优先级任务就会被重启，但假设如果持续有高优先级任务持续进来，那低优先级任务岂不是没有重启之日？</p>
<p>所以 <code>react</code> 为了处理解决饥饿任务问题，在 <code>ensureRootIsScheduled</code> 函数开始的时候做了以下处理：（参考markStarvedLanesAsExpired函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 调度更新的过程中会被调用</span></span><br><span class="line"><span class="comment">// 检查是有lanes挨饿，如果有，则标记他们过期，即提升优先级（以便下次执行）。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This gets called every time we yield. We can optimize by storing</span></span><br><span class="line">  <span class="comment">// the earliest expiration time on the root. Then use that to quickly bail out</span></span><br><span class="line">  <span class="comment">// of this function.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">const</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">const</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">const</span> expirationTimes = root.expirationTimes; <span class="comment">// 数组，初始化的时候，值都是-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate through the pending lanes and check if we've reached their</span></span><br><span class="line">  <span class="comment">// expiration time. If so, we'll assume the update is being starved and mark</span></span><br><span class="line">  <span class="comment">// it as expired to force it to finish.</span></span><br><span class="line">  <span class="comment">// 遍历pending lanes，并检查是否已经达到它们的过期时间。</span></span><br><span class="line">  <span class="comment">// 如果是，我们就认为这个update挨饿了，并将其标记为已过期，以强制其完成。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should be able to replace this with upgradePendingLanesToSync</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We exclude retry lanes because those must always be time sliced, in order</span></span><br><span class="line">  <span class="comment">// to unwrap uncached promises.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write a test for this</span></span><br><span class="line">  <span class="keyword">let</span> lanes = enableRetryLaneExpiration</span><br><span class="line">    ? pendingLanes <span class="comment">//  ? sy</span></span><br><span class="line">    : pendingLanes &amp; ~RetryLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面两行代码的作用是找到lanes中最低位的1，即优先级最</span></span><br><span class="line">    <span class="keyword">const</span> index = pickArbitraryLaneIndex(lanes);</span><br><span class="line">    <span class="comment">// 把1左移index位，即得到一个只有第index位为1的子掩码</span></span><br><span class="line">    <span class="keyword">const</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expirationTime = expirationTimes[index];</span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">      <span class="comment">// sy- console.log('%c [  ]-1469', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">      <span class="comment">// Found a pending lane with no expiration time. If it's not suspended, or</span></span><br><span class="line">      <span class="comment">// if it's pinged, assume it's CPU-bound. Compute a new expiration time</span></span><br><span class="line">      <span class="comment">// using the current time.</span></span><br><span class="line">      <span class="comment">// 如果这个 pending lane 没有过期时间</span></span><br><span class="line">      <span class="comment">// 如果它没有被挂起且需要更新，我们就认为它是CPU密集型操作。</span></span><br><span class="line">      <span class="comment">// 用当前时间计算出一个新的过期时间给它。</span></span><br><span class="line">      <span class="comment">// CPU bound  / IO Bound</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (lane &amp; suspendedLanes) === NoLanes ||</span><br><span class="line">        (lane &amp; pingedLanes) !== NoLanes</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// sy- console.log('%c [ 饿死 ]-482', 'font-size:13px; background:pink; color:#bf2c9f;', lane)</span></span><br><span class="line">        <span class="comment">// Assumes timestamps are monotonically increasing.</span></span><br><span class="line">        <span class="comment">// 假设timestamps(时间戳)是单调递增的</span></span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 这个 pending lane 已经过期了</span></span><br><span class="line">      <span class="comment">// This lane expired</span></span><br><span class="line">      root.expiredLanes |= lane;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把lane从lanes中移除，计算下一个lane</span></span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以参考 <code>render</code> 阶段执行的函数 <code>performConcurrentWorkOnRoot</code> 中的代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 1. render</span></span><br><span class="line"><span class="keyword">let</span> exitStatus = shouldTimeSlice</span><br><span class="line">    ? renderRootConcurrent(root, lanes)</span><br><span class="line">    : renderRootSync(root, lanes); <span class="comment">// 不用时间切片</span></span><br></pre></td></tr></table></figure>

<p>可以看到只要 <code>shouldTimeSlice</code> 只要返回 <code>false</code>，就会执行 <code>renderRootSync</code>，也就是以同步优先级进入 <code>render</code> 阶段。而 <code>shouldTimeSlice</code> 的逻辑也就是刚刚的 <code>expiredLanes</code> 属性相关</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldTimeSlice =</span><br><span class="line">    !includesBlockingLane(root, lanes) &amp;&amp;</span><br><span class="line">    !includesExpiredLane(root, lanes) &amp;&amp;</span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查root是否包含过期的lane</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">includesExpiredLane</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a separate check from includesBlockingLane because a lane can</span></span><br><span class="line">  <span class="comment">// expire after a render has already started.</span></span><br><span class="line">  <span class="keyword">return</span> (lanes &amp; root.expiredLanes) !== NoLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">react18.2并发模式（Concurrent Mode）分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li>并发指的是：多个任务，在同一时间段内同时发生，多个任务会有互相抢占资源的情况。</li>
<li>并行指的是：多个任务，在同一时间点上同时发生，多个任务之间不会互相抢占资源。</li>
</ul>
<p>在这里，我们千万不要理解 <code>Concurrent Mode</code> 是在同时执行多个任务，相信很多人包括我在内都理解混淆，在看源码后，才恍然大悟。</p>
<p>它是同一段时间内，可以执行多个任务：</p>
<ul>
<li>因为高优先级任务可以插队并打断低优先级任务</li>
<li>或当时间切片的某一条任务执行超时后，将执行权交给主线程，当主线程执行完成，又继续执行之前的切片任务</li>
</ul>
<h2 id="为什么需要并发模式"><a href="#为什么需要并发模式" class="headerlink" title="为什么需要并发模式"></a>为什么需要并发模式</h2><p>我们知道在同步模式下，从 <code>setState</code> 到 <code>虚拟DOM遍历</code>，再到 <code>真实DOM</code> 更新，整个过程都是同步执行且无法被中断的，这样可能就会出现一个问题 —— 用户事件触发的更新被阻塞。</p>
<p>因为我们期望一些不重要的更新不会影响一些重要的更新，比如长列表渲染不会阻塞用户 <code>input</code> 输入，从而提升用户体验。</p>
<h2 id="并发模式特点"><a href="#并发模式特点" class="headerlink" title="并发模式特点"></a>并发模式特点</h2><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>对于 <code>React</code> 来说，任务可能很多，如果不区分优先级，那就是先来后到的顺序。如果高优先级任务来了，但是低优先级任务还没有处理完毕，就会造成高优先级任务等待的局面。</p>
<p>由此可见，对于复杂项目来说，任务可中断这件事情很重要。那么问题来了，<code>React</code> 是如何做到的呢，其实基础还是 <code>fiber</code>，<code>fiber</code> 本身链表结构，就是指针，想指向别的地方加个属性值就行了。</p>
<h3 id="可遗弃"><a href="#可遗弃" class="headerlink" title="可遗弃"></a>可遗弃</h3><p>在 <code>Concurrent 模式</code>下，有些update可能会被遗弃掉。</p>
<p>比如我想在淘宝搜索“老人与海”，那么我在输入框输入“老人与海”的过程中，“老人”会有对应的模糊查询结果，但是不一定是我想要的结果，所以这个时候的模糊查询框的update就是低优先级，“老人”对应UI的update相对input的update，优先级就会低一些。在现在React18中，这个模糊查询相关的UI可以被当做transition。</p>
<h3 id="状态复用"><a href="#状态复用" class="headerlink" title="状态复用"></a>状态复用</h3><p>在 <code>Concurrent 模式</code> 下，还支持状态的复用。某些情况下，比如用户走了，又回来，那么上一次的页面状态应当被保存下来，而不是完全从头再来。当然实际情况下不能缓存所有的页面，不然内存不得爆炸，所以还得做成可选的。</p>
<p>目前， <code>React</code> 正在用 <code>Offscreen</code> 组件来实现这个功能。</p>
<p>另外，使用 <code>OffScreen</code>，除了可以复用原先的状态，我们也可以使用它来当做新UI的缓存准备，就是虽然新UI还没登场，但是可以先在后台准备着，这样一旦轮到它，就可以立马快速地渲染出来。</p>
<h2 id="如何实现并发模式（Concurrent-Mode）"><a href="#如何实现并发模式（Concurrent-Mode）" class="headerlink" title="如何实现并发模式（Concurrent Mode）"></a>如何实现并发模式（Concurrent Mode）</h2><p><code>Concurrent Mode</code> 这种中断渲染的行为，带来了几个关键问题：</p>
<ul>
<li>怎样做到中断渲染？</li>
<li>怎样定义任务的重要程度和执行顺序？</li>
<li>何时中断任务，怎样划分时间片？</li>
</ul>
<p>个人总结主要通过三个方面完成：</p>
<ul>
<li>颗粒化更新节点来解决递归不可中断问题；</li>
<li>任务增加优先级来解决任务执行顺序；</li>
<li>创建任务调度机制来解决时间分片和任务中断，任务恢复；</li>
</ul>
<p>对应到React的实现就是：<code>Fiber架构</code>，<code>lane模型</code>，<code>scheduler任务调度</code></p>
<h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><p>在重构 <code>Fiber</code> 架构之前，<code>React</code> 是没办法解决这些问题的。因为在此之前，<code>React</code> 的渲染更新主要是通过对比更新前后的 <code>虚拟DOM</code>，找出不同进行更新，而对比的过程因为 <code>虚拟DOM</code> 树结构的限制，只能采用递归更新，我们知道递归一旦开始，中途就无法中断。</p>
<p>那 <code>Fiber</code> 架构为什么能解决这个问题呢？</p>
<ul>
<li>每个 <code>Fiber</code> 节点对应一个 <code>React Element</code>，保存有该组件的所有基本状态信息；</li>
<li>每个 <code>Fiber</code> 节点保存有该组件的更新信息；</li>
</ul>
<p>因为 <code>Fiber</code> 节点承载了基本状态和更新信息，这样 <code>React</code> 就可以将 <code>Fiber</code> 节点视为最小的工作单元，可以实现 <code>Fiber</code> 节点这种粒度的更新，因为粒度的细化也就使得异步可中断更新成为了可能。</p>
<p><code>Fiber</code> 节点的基本状态保存了它的父节点，子节点，兄弟节点信息，这样可以将之前的递归遍历改变为循环遍历，使渲染中断成为可能。</p>
<h3 id="Lane模型"><a href="#Lane模型" class="headerlink" title="Lane模型"></a>Lane模型</h3><p><code>lane模型</code> 主要解决的是任务优先级问题。</p>
<p>我们想中断渲染的本质是想让有更高优先级的任务可以中断低优先级任务来插队执行。</p>
<p>那怎么定义任务优先级呢，<code>lane模型</code> 通过31位的位运算符来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * lane 值越小，优先级越高</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TotalLanes = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有优先级</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLanes: Lanes = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步优先级，表示同步的任务一次只能执行一个，例如：用户的交互事件产生的更新任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续触发优先级，例如：滚动事件，拖动事件等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousHydrationLane: Lane = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lanes = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认优先级，例如使用setTimeout，请求数据返回等造成的更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultHydrationLane: Lane = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lanes = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过渡优先级，例如: Suspense、useTransition、useDeferredValue等拥有的优先级</span></span><br><span class="line"><span class="keyword">const</span> TransitionHydrationLane: Lane = <span class="comment">/*                */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLanes: Lanes = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111111111111000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane1: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000001000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane2: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000010000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane3: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane4: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000010000000000</span>; <span class="comment">// 1024</span></span><br><span class="line"><span class="keyword">const</span> TransitionLane5: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000100000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane6: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane7: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000010000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane8: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000100000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane9: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000001000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane10: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000010000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane11: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000000100000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane12: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000001000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane13: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000010000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane14: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000000100000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLane15: Lane = <span class="comment">/*                       */</span> <span class="number">0b0000000001000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RetryLanes: Lanes = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane1: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000010000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane2: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000000100000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane3: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000001000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> RetryLane4: Lane = <span class="comment">/*                             */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SelectiveHydrationLane: Lane = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleHydrationLane: Lane = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> OffscreenLane: Lane = <span class="comment">/*                   */</span> <span class="number">0b0100000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DeferredLane: Lane = <span class="comment">/*                    */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>React</code> 定义的优先级：</p>
<p>同步任务 &gt; 连续触发事件任务 &gt; setTimeout，请求更新任务 &gt; 过渡任务（React18新特性）</p>
<h4 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): * </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">      <span class="comment">// 同步优先级</span></span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">      <span class="comment">// 连续触发优先级</span></span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>EventPriority</th>
<th></th>
<th>Lane</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>DiscreteEventPriority</td>
<td>离散事件。click、keydown、focusin等，事件的触发不是连续，可以做到快速响应</td>
<td>SyncLane</td>
<td>1</td>
</tr>
<tr>
<td>ContinuousEventPriority</td>
<td>连续事件。drag、scroll、mouseover等，事件的是连续触发的，快速响应可能会阻塞渲染，优先级较离散事件低</td>
<td>InputContinuousLane</td>
<td>4</td>
</tr>
<tr>
<td>DefaultEventPriority</td>
<td>默认的事件优先级</td>
<td>DefaultLane</td>
<td>16</td>
</tr>
<tr>
<td>IdleEventPriority</td>
<td>空闲的优先级</td>
<td>IdleLane</td>
<td>536870912</td>
</tr>
</tbody></table>
<h4 id="调度优先级"><a href="#调度优先级" class="headerlink" title="调度优先级"></a>调度优先级</h4><table>
<thead>
<tr>
<th>SchedulerPriority</th>
<th>EventPriority</th>
<th>大于&gt;17.0.2</th>
<th>小于&gt;17.0.2</th>
</tr>
</thead>
<tbody><tr>
<td>ImmediatePriority</td>
<td>DiscreteEventPriority</td>
<td>1</td>
<td>99</td>
</tr>
<tr>
<td>UserblockingPriority</td>
<td>Userblocking</td>
<td>2</td>
<td>98</td>
</tr>
<tr>
<td>NormalPriority</td>
<td>DefaultEventPriority</td>
<td>3</td>
<td>97</td>
</tr>
<tr>
<td>LowPriority</td>
<td>DefaultEventPriority</td>
<td>4</td>
<td>96</td>
</tr>
<tr>
<td>IdlePriority</td>
<td>IdleEventPriority</td>
<td>5</td>
<td>95</td>
</tr>
<tr>
<td>NoPriority</td>
<td></td>
<td>0</td>
<td>90</td>
</tr>
</tbody></table>
<h4 id="优先级间的转换"><a href="#优先级间的转换" class="headerlink" title="优先级间的转换"></a>优先级间的转换</h4><ul>
<li><p>lane优先级 转 event优先级（参考 lanesToEventPriority 函数）</p>
<ul>
<li>转换规则：以区间的形式根据传入的lane返回对应的 event 优先级。比如传入的优先级不大于 Discrete 优先级，就返回 Discrete 优先级，以此类推</li>
</ul>
</li>
<li><p>event优先级 转 scheduler优先级（参考 ensureRootIsScheduled 函数下的 lanesToEventPriority）</p>
<ul>
<li>转换规则：可以参考上面调度优先级表</li>
</ul>
</li>
<li><p>event优先级 转 lane优先级（参考 getEventPriority 函数）</p>
<ul>
<li>转换规则：对于非离散、连续的事件，会根据一定规则作转换，具体课参考上面 event 优先级表</li>
</ul>
</li>
</ul>
<h4 id="任务饥饿"><a href="#任务饥饿" class="headerlink" title="任务饥饿"></a>任务饥饿</h4><p>任务饥饿是讲一个低优先级的任务一直被高优先级的任务插队，导致这个任务已经过了执行期限依然没有得到执行，在这种情况下，<code>React</code> 会将该任务置为同步渲染任务，在下次更新时立即执行。</p>
<h4 id="任务插队"><a href="#任务插队" class="headerlink" title="任务插队"></a>任务插队</h4><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">《react18.2批处理场景原理并结合优先级进行的分析》</a></p>
<h3 id="scheduler任务调度"><a href="#scheduler任务调度" class="headerlink" title="scheduler任务调度"></a>scheduler任务调度</h3><p>具体可查看这篇文章 <a href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">《react18.2调度器scheduler源码分析》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E5%8E%9F%E7%90%86%E5%B9%B6%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E5%8E%9F%E7%90%86%E5%B9%B6%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2批处理场景原理并结合优先级进行的分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+08:00">2024-11-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactEventPriorities.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级从上往下，越来越小</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DiscreteEventPriority: EventPriority = SyncLane; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContinuousEventPriority: EventPriority = InputContinuousLane; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultEventPriority: EventPriority = DefaultLane; <span class="comment">// 页面初次渲染的lane 32, transition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleEventPriority: EventPriority = IdleLane;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberLane.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000010</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputContinuousLane: Lane = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000001000</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLane: Lane = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000100000</span>; <span class="comment">// 32</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0010000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="各种批处理操作场景和结果"><a href="#各种批处理操作场景和结果" class="headerlink" title="各种批处理操作场景和结果"></a>各种批处理操作场景和结果</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onPerform = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !setCount嵌套场景1  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   document.getElementById('onTest').click() // renderWithHooks时候执行这里，fiber和currentlyRenderingFiber相等，所以isRenderPhaseUpdate为true，这里最终走的renderWithHooksAgain</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// !setCount嵌套场景2  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(1000)</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// !setCount嵌套场景3  点击：页面变成1000 + render 2次，划入：页面变成1000 + render连续 2次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     document.getElementById('onTest').click()</span></span><br><span class="line">    <span class="comment">//     return prev + 10</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; prev + 100)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !插入一个click场景  点击：页面变成1100 + render 1次，划入：页面变成1100 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return prev + 10</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// document.getElementById('onTest').click() // 这里相当于在点击阶段就已经加入到pending中了，而且执行到这里的时候，isRenderPhaseUpdate为false，因为点击的时候没有还没有currentlyRenderingFiber</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 100)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// !情况1 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 点击：页面变成3 + render 1次，划入：页面变成3 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 两个不同的state 点击：页面count变成1，page变成-1 + render 1次，划入：页面变成count变成1，page变成-1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setPage(page - 1)</span></span><br><span class="line">    <span class="comment">// !情况4 点击：页面变成1 + render 1次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 点击：页面变成1 + render 2次，划入：页面变成1 + render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况6 点击：页面变成2 + render 1次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况7 点击：页面变成1 + render 2次，划入：页面变成1 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况8 点击：页面变成4 + render 2次，划入：页面变成4 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 3') // hook update 3</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">//   setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('hook update 4') // hook update 4</span></span><br><span class="line">    <span class="comment">//     return prev + 1</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况9 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况10 点击：页面变成2 + render 2次，划入：页面变成2 + render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况11 点击：页面变成2 + render 2次，划入：页面变成2 + render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// !情况12 页面变成1 + render 1次</span></span><br><span class="line">  <span class="comment">//   const changeValue = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     // setCount((prevState, props) =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">//     //   count: prevState.count + 1,</span></span><br><span class="line">  <span class="comment">//     // &#125;));</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">  <span class="comment">//     console.log(count) // react18 输出的是更新前的值 --&gt; 0</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   document.body.addEventListener('click', changeValue, false)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; milliseconds) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onPerform&#125; onMouseEnter=&#123;onPerform&#125;&gt;</span><br><span class="line">        Hello CodeSandbox &#123;count&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程和原理"><a href="#执行流程和原理" class="headerlink" title="执行流程和原理"></a>执行流程和原理</h2><p><code>dispatchSetState</code> 的源码在 setState文章中 展示过一次。这里只是重复什么是批-更新的说法，通过点击事件或者鼠标划入事件触发setState，其实就是调用 <code>dispatchSetState</code> 方法。<code>dispatchSetState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react更新</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// ! 1. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 把update暂存到concurrentQueues数组中</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 3. 调度更新</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不纠结 <code>fiber</code> 和 <code>queue</code> 的细节的话，就批处理而言，这就是 <code>setState</code>的全部了。</p>
<h3 id="步骤1：获取本次更新的优先级-requestUpdateLane"><a href="#步骤1：获取本次更新的优先级-requestUpdateLane" class="headerlink" title="步骤1：获取本次更新的优先级 - requestUpdateLane"></a>步骤1：获取本次更新的优先级 - requestUpdateLane</h3><p><code>dispatchSetState</code> 方法在 <code>创建update</code> 前，会通过 <code>requestUpdateLane</code> 方法取到 <code>update</code> 的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber: Fiber</span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special cases</span></span><br><span class="line">  <span class="keyword">const</span> mode = fiber.mode;</span><br><span class="line">  <span class="comment">// 1. 非ConcurrentMode模式 2. 目前不支持</span></span><br><span class="line">  <span class="keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">    <span class="keyword">return</span> (SyncLane: Lane);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (executionContext &amp; RenderContext) !== NoContext &amp;&amp;</span><br><span class="line">    workInProgressRootRenderLanes !== NoLanes</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is a render phase update. These are not officially supported. The</span></span><br><span class="line">    <span class="comment">// old behavior is to give this the same "thread" (lanes) as</span></span><br><span class="line">    <span class="comment">// whatever is currently rendering. So if you call `setState` on a component</span></span><br><span class="line">    <span class="comment">// that happens later in the same render, it will flush. Ideally, we want to</span></span><br><span class="line">    <span class="comment">// remove the special case and treat them as if they came from an</span></span><br><span class="line">    <span class="comment">// interleaved event. Regardless, this pattern is not officially supported.</span></span><br><span class="line">    <span class="comment">// This behavior is only a fallback. The flag only exists until we can roll</span></span><br><span class="line">    <span class="comment">// out the setState warning, since existing code might accidentally rely on</span></span><br><span class="line">    <span class="comment">// the current behavior.</span></span><br><span class="line">    <span class="keyword">return</span> pickArbitraryLane(workInProgressRootRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通更新与非紧急更新(18)</span></span><br><span class="line">  <span class="keyword">const</span> transition = requestCurrentTransition();</span><br><span class="line">  <span class="comment">// 如果有transition</span></span><br><span class="line">  <span class="keyword">if</span> (transition !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionScopeLane = peekEntangledActionLane();</span><br><span class="line">    <span class="keyword">return</span> actionScopeLane !== NoLane</span><br><span class="line">      ? <span class="comment">// We're inside an async action scope. Reuse the same lane.</span></span><br><span class="line">        actionScopeLane</span><br><span class="line">      : <span class="comment">// We may or may not be inside an async action scope. If we are, this</span></span><br><span class="line">        <span class="comment">// is the first update in that scope. Either way, we need to get a</span></span><br><span class="line">        <span class="comment">// fresh transition lane.</span></span><br><span class="line">        requestTransitionLane(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React内部的一些update，比如flushSync，会通过上下文变量来跟踪其优先级</span></span><br><span class="line">  <span class="keyword">const</span> updateLane: Lane = (getCurrentUpdatePriority(): any);</span><br><span class="line">  <span class="keyword">if</span> (updateLane !== NoLane) &#123;</span><br><span class="line">    <span class="comment">// ? sy setState click 2</span></span><br><span class="line">    <span class="keyword">return</span> updateLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React外部的update，根据事件类型，向当前环境获取对应的优先级。</span></span><br><span class="line">  <span class="keyword">const</span> eventLane: Lane = (getCurrentEventPriority(): any);</span><br><span class="line">  <span class="keyword">return</span> eventLane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getCurrentEventPriority"><a href="#getCurrentEventPriority" class="headerlink" title="getCurrentEventPriority"></a>getCurrentEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentEventPriority</span>(<span class="params"></span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentEvent = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (currentEvent === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ? sy 页面初次渲染</span></span><br><span class="line">    <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getEventPriority(currentEvent.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getEventPriority"><a href="#getEventPriority" class="headerlink" title="getEventPriority"></a>getEventPriority</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEventPriority</span>(<span class="params">domEventName: DOMEventName</span>): <span class="title">EventPriority</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="comment">// Used by SimpleEventPlugin:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'close'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'contextmenu'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'copy'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cut'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'auxclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dblclick'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusin'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focusout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'invalid'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keydown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keypress'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'keyup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousedown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'paste'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'play'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointercancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerdown'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerup'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ratechange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'resize'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'seeked'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'volumechange'</span>:</span><br><span class="line">    <span class="comment">// Used by polyfills: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectionchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textInput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionstart'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionend'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'compositionupdate'</span>:</span><br><span class="line">    <span class="comment">// Only enableCreateEventHandleAPI: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeblur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'afterblur'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'beforeinput'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'blur'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'fullscreenchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'focus'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'hashchange'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'popstate'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'selectstart'</span>:</span><br><span class="line">      <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drag'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragexit'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'dragover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mousemove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointermove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerout'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerover'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'scroll'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'toggle'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'touchmove'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'wheel'</span>:</span><br><span class="line">    <span class="comment">// Not used by React but could be by user code: (fall through)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'mouseleave'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerenter'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pointerleave'</span>:</span><br><span class="line">      <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'message'</span>: &#123;</span><br><span class="line">      <span class="comment">// We might be in the Scheduler callback.</span></span><br><span class="line">      <span class="comment">// Eventually this mechanism will be replaced by a check</span></span><br><span class="line">      <span class="comment">// of the current priority on the native scheduler.</span></span><br><span class="line">      <span class="keyword">const</span> schedulerPriority = getCurrentSchedulerPriorityLevel();</span><br><span class="line">      <span class="keyword">switch</span> (schedulerPriority) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediateSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> DiscreteEventPriority;</span><br><span class="line">        <span class="keyword">case</span> UserBlockingSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> ContinuousEventPriority;</span><br><span class="line">        <span class="keyword">case</span> NormalSchedulerPriority:</span><br><span class="line">        <span class="keyword">case</span> LowSchedulerPriority:</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</span></span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">        <span class="keyword">case</span> IdleSchedulerPriority:</span><br><span class="line">          <span class="keyword">return</span> IdleEventPriority;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> DefaultEventPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过一系列操作：</p>
<ul>
<li><code>click</code> 事件对应的优先级是 <code>DiscreteEventPriority</code>，优先级值也就是 <code>2</code></li>
<li><code>mouseenter</code> 对应的优先级是 <code>ContinuousEventPriority</code>，优先级值也就是 <code>8</code></li>
<li><code>setTimeout</code> 对应的优先级的值是默认优先级 <code>32</code></li>
</ul>
<blockquote>
<p>一般在合成事件创建之初，就会通过 <code>createEventListenerWrapperWithPriority</code> 各个事件的设置优先级，所以一般 <code>click</code>、<code>mouseenter</code> 等react内部的事件，都会通过 <code>getCurrentUpdatePriority</code> 拿到 <code>updateLane</code>。<br>类似 <code>setTimeout</code>，会走到 <code>getCurrentEventPriority</code> 返回 <code>DefaultEventPriority</code><br>如果是通过 <code>document.body.addEventListener(&#39;click&#39;, changeValue, false)</code> 触发的事件，也会走到 <code>getCurrentEventPriority</code>，通过<code>getEventPriority</code> 拿到 <code>window.event</code> 所对应的优先级</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>requestUpdateLane</code> 中获取优先级：</p>
<ol>
<li>先通过requestCurrentTransition请求并判断是否有非紧急更新</li>
<li>再通过getCurrentUpdatePriority</li>
<li>最后通过getCurrentEventPriority根据事件类型，项当前环境获取对应的优先级。</li>
</ol>
<h3 id="步骤2：创建-update-对象"><a href="#步骤2：创建-update-对象" class="headerlink" title="步骤2：创建 update 对象"></a>步骤2：创建 update 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ! 1. 创建update</span></span><br><span class="line"><span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤3：scheduleUpdateOnFiber"><a href="#步骤3：scheduleUpdateOnFiber" class="headerlink" title="步骤3：scheduleUpdateOnFiber"></a>步骤3：scheduleUpdateOnFiber</h3><p>忽略一些琐碎的细节后，你可以发现这个函数的核心逻辑甚至更简单：</p>
<ul>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ensureRootIsScheduled"><a href="#ensureRootIsScheduled" class="headerlink" title="ensureRootIsScheduled"></a>ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processRootScheduleInMicrotask"><a href="#processRootScheduleInMicrotask" class="headerlink" title="processRootScheduleInMicrotask"></a>processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="scheduleTaskForRootDuringMicrotask"><a href="#scheduleTaskForRootDuringMicrotask" class="headerlink" title="scheduleTaskForRootDuringMicrotask"></a>scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">    root.callbackPriority = newCallbackPriority;</span><br><span class="line">    root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行流程小结"><a href="#执行流程小结" class="headerlink" title="执行流程小结"></a>执行流程小结</h4><p>通过微任务调度 <code>processRootScheduleInMicrotask</code> 方法，此方法核心就是调用 <code>scheduleTaskForRootDuringMicrotask</code>，而在 <code>microtask</code> 结束时，调用 <code>flushSyncWorkOnAllRoots</code> 方法 <code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>在 <code>scheduleTaskForRootDuringMicrotask</code> 中：</p>
<ol>
<li>先是检查是否有饿死的任务，如果是，将它们标记为过期，这样我们就知道下一个要处理的是它们</li>
<li>获取当前所有优先级中最高的优先级 <code>nextLanes</code></li>
<li>先判断是否包含同步优先级，如果包含，取消其它任务并返回，不包含就继续执行</li>
<li>再判断现存的任务优先级和新任务的优先级，如果相等，就合并执行且 <code>return</code></li>
<li>如果不相等，就取消现存任务</li>
<li>继续根据 <code>nextLanes</code>，通过 <code>lanesToEventPriority</code> 方法，获取 <code>schedulerPriorityLevel</code> 调度的优先级，最后通过 <code>scheduleCallback</code> 进行调度</li>
</ol>
<h2 id="调用-scheduleTaskForRootDuringMicrotask-中的两大问题"><a href="#调用-scheduleTaskForRootDuringMicrotask-中的两大问题" class="headerlink" title="调用 scheduleTaskForRootDuringMicrotask 中的两大问题"></a>调用 scheduleTaskForRootDuringMicrotask 中的两大问题</h2><p>请看<a href="https://rile14929.github.io/zh-CN/react18.2%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E5%92%8C%E9%A5%A5%E9%A5%BF%E4%BB%BB%E5%8A%A1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html">《react18.2高优先级任务插队和饥饿任务问题分析》</a></p>
<h2 id="updateReducerImpl"><a href="#updateReducerImpl" class="headerlink" title="updateReducerImpl"></a>updateReducerImpl</h2><p>我们以函数式组件的处理 <code>setState</code> 时的实际执行函数 <code>updateReducerImpl</code> 为例，来看一下相关处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducerImpl</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  hook: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Hook,</span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录reducer</span></span><br><span class="line">  queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = hook.baseQueue; <span class="comment">// ! 单向循环链表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有 pendingQueue，说明有未处理的更新</span></span><br><span class="line">    <span class="comment">// 把pendingQueue添加到baseQueue中</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// pending queue合并到base queue中。</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseQueue 被设置为 pendingQueue，也就是待更新的 update 对象队列</span></span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    <span class="comment">// 需要清空 pending 队列，这样本次执行 hook 的 pending 队列不会影响到下一次</span></span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseState = hook.baseState;</span><br><span class="line">  <span class="comment">// 如果基础更新队列中有 update 对象，说明需要执行更新，就按照优先级依次处理每一个 update 对象（下面会进行批量更新）</span></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有pendingQueue，那么memoizedState应该等于baseState</span></span><br><span class="line">    hook.memoizedState = baseState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有待处理的queue，接下来遍历即可</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast: Update&lt;S, A&gt; | <span class="literal">null</span> = <span class="literal">null</span>;  <span class="comment">// 跳过的这些更新（低优先级任务）会被保存在这个循环链表中</span></span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="keyword">let</span> didReadFromEntangledAsyncAction = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前任务的优先级不够，也就是说当前的 renderLanes 比该 update 对象的优先级高。需要先跳过，之后再处理。</span></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          revertLane: update.revertLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果在当前被跳过的 update 对象之前没有其他的 update 被跳过，该对象就是作为新的基础更新对象。并把最初跳过任务时候的 baseState 存储起来</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果之前有更新被跳过，那么将这个更新对象添加到队列最后</span></span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前正在工作的 Fiber 节点（workInProgress）的优先级，标记这个更新对象的优先级由于不匹配当前的 renderLane，因此已经被跳过。</span></span><br><span class="line">        <span class="comment">// 在同文件的 renderWithHook() 方法中可以知道 currentlyRenderingFiber 对应了 workInProgress，表示当前正在工作的 fiber 树</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 优先级足够</span></span><br><span class="line">        <span class="comment">// 优先级足够的时候理论上可以考虑对哪些 update 对象进行收集更新，但是此时还需要考虑一个 revertLane（还原的优先级），以保证组件状态的正确。</span></span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this is an optimistic update.</span></span><br><span class="line">        <span class="keyword">const</span> revertLane = update.revertLane;</span><br><span class="line">        <span class="keyword">if</span> (!enableAsyncActions || revertLane === NoLane) &#123;</span><br><span class="line">          <span class="comment">// ? sy</span></span><br><span class="line">          <span class="comment">// This is not an optimistic update, and we're going to apply it now.</span></span><br><span class="line">          <span class="comment">// But, if there were earlier updates that were skipped, we need to</span></span><br><span class="line">          <span class="comment">// leave this update in the queue so it can be rebased later.</span></span><br><span class="line">          <span class="comment">// 如果 newBaseQueueLast 不为 null，证明有跳过的更新，要把当前的update也加入newBaseQueueLast只是到其 lane 会赋值为 0，后面进行低优先级的更新时，这些已经被处理过的更新也仍旧会被处理，保证最后计算的数据是正确的</span></span><br><span class="line">          <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">              <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">              <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              revertLane: NoLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">          <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">          <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">          <span class="keyword">if</span> (updateLane === peekEntangledActionLane()) &#123;</span><br><span class="line">            <span class="comment">// ? sy-no</span></span><br><span class="line">            didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// This is an optimistic update. If the "revert" priority is</span></span><br><span class="line">          <span class="comment">// sufficient, don't apply the update. Otherwise, apply the update,</span></span><br><span class="line">          <span class="comment">// but leave it in the queue so it can be either reverted or</span></span><br><span class="line">          <span class="comment">// rebased in a subsequent render.</span></span><br><span class="line">          <span class="keyword">if</span> (isSubsetOfLanes(renderLanes, revertLane)) &#123;</span><br><span class="line">            <span class="comment">// The transition that this optimistic update is associated with</span></span><br><span class="line">            <span class="comment">// has finished. Pretend the update doesn't exist by skipping</span></span><br><span class="line">            <span class="comment">// over it.</span></span><br><span class="line">            update = update.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">            <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">            <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line">            <span class="keyword">if</span> (revertLane === peekEntangledActionLane()) &#123;</span><br><span class="line">              didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">              <span class="comment">// Once we commit an optimistic update, we shouldn't uncommit it</span></span><br><span class="line">              <span class="comment">// until the transition it is associated with has finished</span></span><br><span class="line">              <span class="comment">// (represented by revertLane). Using NoLane here works because 0</span></span><br><span class="line">              <span class="comment">// is a subset of all bitmasks, so this will never be skipped by</span></span><br><span class="line">              <span class="comment">// the check above.</span></span><br><span class="line">              lane: NoLane,</span><br><span class="line">              <span class="comment">// Reuse the same revertLane so we know when the transition</span></span><br><span class="line">              <span class="comment">// has finished.</span></span><br><span class="line">              revertLane: update.revertLane,</span><br><span class="line">              action: update.action,</span><br><span class="line">              hasEagerState: update.hasEagerState,</span><br><span class="line">              eagerState: update.eagerState,</span><br><span class="line">              next: (<span class="literal">null</span>: any),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">              newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">              newBaseState = newState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">            <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">            currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">              currentlyRenderingFiber.lanes,</span><br><span class="line">              revertLane,</span><br><span class="line">            );</span><br><span class="line">            markSkippedUpdateLanes(revertLane);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 update 对象的优先级足够，因此开始处理它的 action，收集新的 state 状态</span></span><br><span class="line">        <span class="keyword">const</span> action = update.action;</span><br><span class="line">        <span class="keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;</span><br><span class="line">          reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ! 计算useReducer的新的state</span></span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 循环 baseQueue（实际上就是 pendingQueue），处理该队列中的每个 update 对象，</span></span><br><span class="line">      <span class="comment">// 并把对应的 action 操作得到的结果更新到 newState 中（即收集新状态）</span></span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState; <span class="comment">// 如果没有跳过的任务，那就把最终计算后的结果存到newBaseState，最终赋值给baseState，否则baseState就还是第一个被跳过的任务时可以拿到的baseState，也是保证最后执行低优先级任务计算的数据是正确的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark that the fiber performed work, but only if the new state is</span></span><br><span class="line">    <span class="comment">// different from the current state.</span></span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (didReadFromEntangledAsyncAction) &#123;</span><br><span class="line">        <span class="keyword">const</span> entangledActionThenable = peekEntangledActionThenable();</span><br><span class="line">        <span class="keyword">if</span> (entangledActionThenable !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> entangledActionThenable;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新到hook上</span></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line"></span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    <span class="comment">// 如果一直没有跳过的，newBaseQueueLast就为null，如果有跳过的就不为null也就赋值给了baseQueue，之后低优先级任务重启后可以执行baseQueue上的任务，当执行最后一批低优先级任务时newBaseQueueLast为null，baseQueue也就为null了，不会影响以后再次触发任务</span></span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// `queue.lanes` is used for entangling transitions. We can set it back to</span></span><br><span class="line">    <span class="comment">// zero once the queue is empty.</span></span><br><span class="line">    queue.lanes = NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看到，<code>updateReducerImpl</code> 方法核心内容分为四个部分：</p>
<ul>
<li>获取 <code>Hook</code> 对象中的更新队列、基础更新队列、基础状态、<code>reduce</code> 函数等信息。</li>
<li>如果更新队列中有待处理的更新对象，就将其加入到基础更新队列中。</li>
<li>按照优先级高低区分是否跳过该更新或者依次处理基础更新队列中的更新对象，计算新的状态。</li>
<li>判断新的状态和旧的状态是否相同，如果相同就不做重新渲染，反之需要重新渲染。</li>
<li>返回更新后的状态和 <code>dispatch</code> 方法。</li>
</ul>
<h2 id="针对setState嵌套场景的分析"><a href="#针对setState嵌套场景的分析" class="headerlink" title="针对setState嵌套场景的分析"></a>针对setState嵌套场景的分析</h2><p>当执行嵌套的 <code>setState</code> 时候，会执行 <code>dispatchSetState</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// ! 1. 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    revertLane: NoLane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// setState嵌套setState的情况，是同一个fiber</span></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是同一个fiber，如果发生嵌套的情况，是一个fiber，会返回true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRenderPhaseUpdate</span>(<span class="params">fiber: Fiber</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>update</code> 加入到队列中，并将 <code>didScheduleRenderPhaseUpdateDuringThisPass</code> 置为 <code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRenderPhaseUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a render phase update. Stash it in a lazily-created map of</span></span><br><span class="line">  <span class="comment">// queue -&gt; linked list of updates. After this render pass, we'll restart</span></span><br><span class="line">  <span class="comment">// and apply the stashed updates on top of the work-in-progress hook.</span></span><br><span class="line">  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =</span><br><span class="line">    <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有 <code>setState</code> 嵌套发生，是发生在 <code>render</code> 阶段的 <code>renderWithHooks</code> 中。执行完函数组件 <code>Component()</code> 会进行判断， 当<code>didScheduleRenderPhaseUpdateDuringThisPass</code>为 <code>true</code> 会执行 <code>renderWithHooksAgain</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if there was a render phase update</span></span><br><span class="line">    <span class="comment">// enqueueRenderPhaseUpdate会给didScheduleRenderPhaseUpdateDuringThisPass设置为true，所以下面还会render一次，这也就是setState嵌套setState的情况下render连续 2次</span></span><br><span class="line">    <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">        <span class="comment">// Keep rendering until the component stabilizes (there are no more render</span></span><br><span class="line">        <span class="comment">// phase updates).</span></span><br><span class="line">        children = renderWithHooksAgain(</span><br><span class="line">            workInProgress,</span><br><span class="line">            Component,</span><br><span class="line">            props,</span><br><span class="line">            secondArg,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>所以通过对执行流程和原理的分析，对于以上提到的这么多批处理的场景，也就能通过源码并结合eventLoop的知识解释的通了。</p>
<p>关于批处理的逻辑，主要有三点：</p>
<ul>
<li>通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>对比上次等待的更新和本次更新的优先级，即 <code>newCallbackPriority === existingCallbackPriority</code>，如果相等，则提前 <code>return</code></li>
<li>在更新阶段，以 <code>setState</code> 为例，会根据优先级来判断是否要同一批次执行</li>
</ul>
<p>在 <code>scheduleUpdateOnFiber</code> 中已经对 <code>setState</code> 对应的优先级做了标记，所以那个优先级在这里是可以被读取到的。如果两次更新的优先级相同，批处理就会起作用。</p>
<blockquote>
<p>批处理的发生当然意味着代码进入上述的 <code>newCallbackPriority === existingCallbackPriority</code> 分支内。但是即使是其他情形也有可能进入这个分支。<br>例如，当连续的两次 <code>setState</code> 被调用，前者优先级高于后者，那么当第二次 <code>setState</code> 被调用，从而进入 <code>ensureRootIsScheduled</code> 时，<code>existingCallbackPriority与newCallbackPriority</code> 都是第一次调用时的优先级（每次所取的都是最高优先级），导致函数提前返回。这并不意味着低优先级的更新被忽略，在高优先级的更新即将完成时，<code>ensureRootIsScheduled</code> 会被再次调用，确保所有更新会被执行。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94.html" class="post-title-link" itemprop="url">react18.2和react16批处理实现和对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-02T00:00:00+08:00">2024-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="react16-半自动批处理"><a href="#react16-半自动批处理" class="headerlink" title="react16 - 半自动批处理"></a>react16 - 半自动批处理</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：同步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中的this.setState或者setState：会批量处理</li>
<li>合成事件和钩子函数中的this.setState或者setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中任何情况：不会批量处理</li>
</ul>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-this-updater"><a href="#2-this-updater" class="headerlink" title="2. this.updater"></a>2. this.updater</h4><p><code>this.updater</code> 是在哪个地方进行赋值暂时不用关心，只需要知道他被赋值为 <code>classComponentUpdater</code>。</p>
<p><code>classComponentUpdater</code> 和 <code>render</code> 流程里面的 <code>ReactDOM.render</code>中 <code>scheduleRootUpdate</code> 非常的相似，其实他们就是同一个更新原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">    <span class="comment">// inst 就是我们调用this.setState的this，也就是classComponent实例</span></span><br><span class="line">    <span class="comment">// 获取到当前实例上的fiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = ReactInstanceMap.get(inst);</span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="comment">// 计算当前fiber的到期时间（优先级）</span></span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建更新一个更新update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload是setState传进来的要更新的对象</span></span><br><span class="line">    update.payload = payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//callback就是setState(&#123;&#125;,()=&gt;&#123;&#125;)的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把更新放到队列UpdateQueue</span></span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始进入React异步渲染的核心：React Scheduler</span></span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态更新都会创建一个保存更新状态相关内容的对象 <code>Update</code>。在 <code>render</code> 阶段的 <code>beginWork</code> 中会根据 <code>Update</code> 计算新的 <code>state</code>。</p>
<p>这里讲这个 <code>Update</code> 通过 <code>enqueueUpdate</code> 放到队列 <code>UpdateQueue</code>。</p>
<h4 id="3-requestWork"><a href="#3-requestWork" class="headerlink" title="3. requestWork"></a>3. requestWork</h4><p><code>scheduleWork</code> 里会执行 <code>requestWork</code> 方法。</p>
<p><code>requestWork</code> 中可以看到有多个 <code>if</code> 判断，这里就是 <code>setState</code> <strong>在不同的场景使用会出现同步和异步的根本原因</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root, expirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将根节点添加到调度任务中</span></span><br><span class="line">  addRootToSchedule(root, expirationTime)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isRendering是全局变量，在后面生命周期函数我们会具体分析到</span></span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isBatchingUpdates、isUnbatchingUpdates是全局变量</span></span><br><span class="line">  <span class="comment">// react事件时有对他们进行重新赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      ....</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景1-合成事件"><a href="#场景1-合成事件" class="headerlink" title="场景1 - 合成事件"></a>场景1 - 合成事件</h3><p>React有着一套自己的合成事件机制，在一个事件调用的时候会经过一些处理，这里不详细描述，最重要的一个函数就是 <code>interactiveUpdates$1</code>，在执行一个事件的时候会先调用这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleClick()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: <span class="string">'吴彦祖'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name) <span class="comment">// 狗蛋</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        age: <span class="string">'18'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.age) <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interactiveUpdates-1方法"><a href="#interactiveUpdates-1方法" class="headerlink" title="interactiveUpdates$1方法"></a>interactiveUpdates$1方法</h4><ul>
<li>isBatchingUpdates = true;让setState不马上更新</li>
<li>try finally 语句;先执行一个事件里的代码最后才更新</li>
<li>isBatchingUpdates = previousIsBatchingUpdates;合成事件里setTimeout能马上更新的原因</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interactiveUpdates$1</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// Synchronously flush pending interactive updates.</span></span><br><span class="line">    performWork(lowestPendingInteractiveExpirationTime, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    lowestPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span><br><span class="line">  <span class="keyword">var</span> previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingInteractiveUpdates = <span class="literal">true</span>;</span><br><span class="line">  isBatchingUpdates = <span class="literal">true</span>;  <span class="comment">// 把requestWork中的isBatchingUpdates标识改为true</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isBatchingUpdates变量"><a href="#isBatchingUpdates变量" class="headerlink" title="isBatchingUpdates变量"></a>isBatchingUpdates变量</h4><p><code>interactiveUpdates$1</code> 这个方法中把 <code>isBatchingUpdates</code> 设为了 <code>true</code>, 导致在 <code>requestWork</code> 方法中， <code>isBatchingUpdates</code> 为 <code>true</code> ，但是 <code>isUnbatchingUpdates</code> 是 <code>false</code> ，而被直接 <code>return</code> 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requestWork</span></span><br><span class="line"><span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就导致了 <code>requestWork</code> 根本没有执行到任何更新的函数，比如 <code>performSyncWork</code>，但在最开始的 <code>enqueueSetState</code> 这个方法里还是已经将每一次更新都存到了一个 <code>update</code> 队列里。</p>
<p>所以合成事件里的 <code>setState</code> 不会马上更新，而是存入了一个更新队列里（enqueueUpdate）</p>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try finally"></a>try finally</h4><p><code>interactiveUpdates$1</code> 最后执行了一个 <code>try finally</code> 语法，会先执行 <code>try</code> 代码块中的语句，然后再执行 <code>finally</code> 中的代码，而 <code>fn(a, b)</code> 是在 <code>try</code> 代码块中执行相关的事件回调，而在 <code>finally</code> 里才有 <code>performSyncWork()</code>;</p>
<p>也就是说我们写的事件监听函数在 <code>try</code> 中执行，但更新在 <code>finally</code> 里，这就导致了所谓的”异步”，<code>state</code> 并没有马上更新并渲染到UI上，而是等到事件执行完之后才更新的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">        performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景2-setTimeout"><a href="#场景2-setTimeout" class="headerlink" title="场景2 - setTimeout"></a>场景2 - setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出更新后的值 --&gt; 1</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>try</code> 代码块执行到 <code>setTimeout</code> 的时候，这是一个宏任务，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块。</p>
<p>等 <code>finally</code> 执行的时候会执行 <code>isBatchingUpdates = previousIsBatchingUpdates</code>; 将 <code>isBatchingUpdates</code> 重置为了 <code>false</code>。</p>
<p>导致最后下次事件循环的时候去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync if</code>分支， 可以同步拿到最新的 <code>state</code> 值。</p>
<h3 id="场景3-生命周期函数中的setState"><a href="#场景3-生命周期函数中的setState" class="headerlink" title="场景3 - 生命周期函数中的setState"></a>场景3 - 生命周期函数中的setState</h3><p>三个全局变量：isRendering、isWorking、isCommitting</p>
<ul>
<li>isRendering：开始react更新就为true</li>
<li>isWorking：进入reconciler阶段就为true、进入commit阶段就为true</li>
<li>isCommitting：进入commit阶段就为true</li>
</ul>
<p>render前生命周期属于reconciler阶段：isRendering = true、isWorking = true Fiber Reconciler 的执行阶段：</p>
<ul>
<li>阶段一是生成 Fiber 树的渐进阶段，可以被打断。</li>
<li>阶段二是批量更新节点的阶段，不可被打断。</li>
</ul>
<p><img src="../images/react18.2%E5%92%8Creact16%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%AF%B9%E6%AF%94/image.png" alt="alt text"></p>
<p>现在回过头来看 <code>requestWork</code> 里的第一个if判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和合成事件一样，当 <code>componentDidmount</code> 执行的时候，<code>isRendering</code> 为 <code>true</code>，react内部并没有更新就先 <code>return</code> 了，执行完 <code>componentDidmount</code> 后才去 <code>commitUpdateQueue</code> 更新。这就导致你在 <code>componentDidmount</code> 中 <code>setState</code> 完去 <code>console.log</code> 拿的结果还是更新前的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的还是更新前的值 --&gt; 0</span></span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="场景4-原生事件"><a href="#场景4-原生事件" class="headerlink" title="场景4 - 原生事件"></a>场景4 - 原生事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) <span class="comment">// 输出的是更新后的值 --&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.val&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发 <code>click</code> 事件，到 <code>requestWork</code> ,在 <code>requestWork</code> 里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被 <code>return</code>，所以当你在原生事件中 <code>setState</code>后，能同步拿到更新后的 <code>state</code> 值。</p>
<h3 id="场景5-setState批量更新的情况"><a href="#场景5-setState批量更新的情况" class="headerlink" title="场景5 - setState批量更新的情况"></a>场景5 - setState批量更新的情况</h3><h5 id="简单分析源码"><a href="#简单分析源码" class="headerlink" title="简单分析源码"></a>简单分析源码</h5><p><code>React</code> 加入 <code>fiber</code> 架构后，调度之前通过 <code>enqueueUpdate</code> 函数维护的 <code>UpdateQueue</code> 就是挂载在组件对应的 <code>fiber</code> 节点上，我们更新的通过调度最后会进入到 <code>updateClassComponent</code> 方法，里面最终会调用一个<code>getStateFromUpdate</code> 来获取最终的 <code>state</code> 状态。</p>
<p><code>getStateFromUpdate</code> 函数外面是对 <code>UpdateQueue</code> 队列的一个 <code>while</code> 循环，比如我们连续 <code>setState</code> 三次，那每次都会创建一个 <code>update</code> 实例通过 <code>enqueueUpdate</code> 放入 <code>fiber</code> 的 <code>UpdateQueue</code> 中，这里就是把这三次的<code>state</code> 合并计算出一个最终的值以提高性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resultState作为参数prevState传入getStateFromUpdate，然后getStateFromUpdate会合并生成</span></span><br><span class="line"><span class="comment">     * 新的状态再次赋值给resultState。完成整个循环遍历，resultState即为最终要更新的state。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resultState = getStateFromUpdate(</span><br><span class="line">        workInProgress,</span><br><span class="line">        queue,</span><br><span class="line">        update,</span><br><span class="line">        resultState,</span><br><span class="line">        props,</span><br><span class="line">        instance,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历下一个update对象</span></span><br><span class="line">    update = update.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getStateFromUpdate</code> 函数主要功能是将存储在更新对象 <code>update</code> 上的 <code>partialState</code> 与上一次的 <code>prevState</code> 进行对象合并，生成一个全新的状态 <code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevState: State,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setState会创建update对象，其属性tag当时被标记为UpdateState</span></span><br><span class="line">    <span class="keyword">case</span> UpdateState: &#123;</span><br><span class="line">      <span class="comment">// payload 存放的是要更新的状态state</span></span><br><span class="line">      <span class="keyword">const</span> payload = update.payload;</span><br><span class="line">      <span class="keyword">let</span> partialState;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取要更新的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> payload === <span class="string">'function'</span>) &#123;</span><br><span class="line">        partialState = payload.call(instance, prevState, nextProps);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        partialState = payload;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// partialState 为null 或者 undefined，则视为未操作，返回上次状态</span></span><br><span class="line">      <span class="keyword">if</span> (partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意：此处通过Object.assign生成一个全新的状态state， state的引用地址发生了变化。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prevState, partialState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prevState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="setState传入对象会合并对象"><a href="#setState传入对象会合并对象" class="headerlink" title="setState传入对象会合并对象"></a>setState传入对象会合并对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementByObject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.increment = <span class="keyword">this</span>.increment.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        <span class="comment">// 会批量更新，只会render一次，结果是 1</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;IncrementByObject&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;span&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果是一个 <code>Object</code> ，直接看最后的 <code>Object.assign({}, prevState, partialState);</code></p>
<p><code>Object.assign</code> 的作用： 主要是将所有可枚举属性的值从一个或多个源对象复制到目标对象，同时返回目标对象。如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性。</p>
<p>之前提过在合成事件中或者在生命周期了 <code>state</code> 是不会马上刷新的，是在事件执行完后也就是 <code>try finally</code> 的 <code>finally</code> 里才真正刷新，这就导致了每次 <code>Object.assign</code> 的 <code>partialState</code> 都是 <code>this.state.count + 1</code>，而 <code>state</code> 的 <code>count</code> 在三次 <code>setState</code> 的时候都不会改变都是0，所以计算过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>很明显最终的 <code>state</code> 的 <code>count</code> 只会增加 1。</p>
<h5 id="setState传入函数"><a href="#setState传入函数" class="headerlink" title="setState传入函数"></a>setState传入函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">increment() &#123;</span><br><span class="line">    <span class="comment">// 采用传入函数的方式来更新 state，会批量，只会render一次，更新但结果是 3</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是一个回调函数function 可以发现 <code>if (typeof payload === &#39;function&#39;)</code> 这里对传入的是否是方法做了判断，如果是方法，就执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partialState = payload.call(instance, prevState, nextProps);</span><br></pre></td></tr></table></figure>

<p><code>instance</code> 对于类组件来说，这里保存类组件的实例在外层的 <code>updateClassInstance</code>函数中 <code>const instance = workInProgress.stateNode;</code> 赋值的。</p>
<p>这里其实只看 <code>payload</code> 和 <code>prevState</code> 就行了，<code>payload</code> 是我们通过 <code>setState</code> 传入的回调函数，返回最新的 <code>state</code>，<code>while</code> 循环调用 <code>getStateFromUpdate</code> 每次传入的是 <code>resultState</code>，也就是说接受的 <code>state</code> 都是上一轮计算之后的新值，因此循环计算的过程可以简化如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到最终的 <code>state</code> 的 <code>count</code> 为增加 3。</p>
<h2 id="react18-自动批处理"><a href="#react18-自动批处理" class="headerlink" title="react18 - 自动批处理"></a>react18 - 自动批处理</h2><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>执行顺序</p>
<ul>
<li>合成事件和钩子函数中：异步</li>
<li>原生事件和setTimeout中：异步</li>
</ul>
</li>
<li><p>批量处理</p>
<ul>
<li>合成事件和钩子函数中：会批量处理</li>
<li>setState里面写成函数：会批量处理</li>
<li>原生事件和setTimeout中：会批量处理</li>
</ul>
</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>具体解析可以看 <a href="https://rile14929.github.io/zh-CN/react18.2%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90.html">《react18.2优先级和批处理场景解析》</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// !情况1 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1) // 1</span></span><br><span class="line">    <span class="comment">// !情况2 页面变成3，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; prev + 1) // 3</span></span><br><span class="line">    <span class="comment">// !情况3 页面变成1，render 1次</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//     setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况4 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况5 页面变成2，render 1次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2')</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// !情况6 页面变成1，render 2次</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 1') // hook update 1</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount((prev) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('hook update 2') // hook update 2</span></span><br><span class="line">    <span class="comment">//   return prev + 1</span></span><br><span class="line">    <span class="comment">// &#125;) // 2</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况7 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// !情况8 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// !情况9 页面变成2，render 2次</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// sleep(1000)</span></span><br><span class="line">    <span class="comment">// setCount(count + 2)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 onClick=&#123;onClick&#125;&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>批处理：React 会尝试将同一上下文中触发的更新合并为一个更新。</p>
<p>就 React18 而言当说到批处理的时候，需同时具备以下三者：</p>
<ul>
<li>包括了多个react<strong>更新</strong></li>
<li>每个更新具有相同的<strong>优先级</strong></li>
<li>每个更新都是<strong>待执行</strong>的</li>
</ul>
<p>这样做的好处也显而易见：</p>
<ul>
<li>合并不必要的更新，减少更新流程调用次数</li>
<li>状态按顺序保存下来，更新时不会出现「竞争问题」</li>
<li>最终触发的更新是异步流程，减少浏览器掉帧可能性</li>
</ul>
<h4 id="1-更新"><a href="#1-更新" class="headerlink" title="1. 更新"></a>1. 更新</h4><p>对于 <code>hook</code> 有更新队列，对于 <code>react</code> 也有相应的更新（通常伴随着组件render），当然对浏览器还存在页面视图的更新。</p>
<p>当我们调用dispatch或者setState时，上述三种更新都是有涉及的。但是要特别指出的是，批处理中的更新就是指 <code>react</code> 的更新，包含了render，commit阶段等。在后续的批处理部分你将看到三者的差异。</p>
<p>如果我们看 <code>dispatchSetState</code> 的源码，会发现它们主要做了两件事：</p>
<ul>
<li>记录一次 <code>hook</code> 更新（<code>enqueueConcurrentHookUpdate</code>）</li>
<li>调度一次 <code>react</code> 更新（<code>scheduleUpdateOnFiber</code>）</li>
</ul>
<p>批中的更新就是指调度一次 <code>react</code> 更新 <code>scheduleUpdateOnFiber</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 dispatchReducerAction 中同样包含的逻辑</span></span><br><span class="line"><span class="comment">// 这个函数中 fiber 和 queue 都是通过 dispatchSetState.bind 提前绑定好的，我们调用 setState 时传入的参数是 action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...异常情形</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><p>在更新部分的相关源码示例中，可以看到 <code>lane</code> 字段，它表示的就是这次更新的优先级。只有优先级相同的多个更新才在一个批中，与之相应的就是这些更新被批处理，反之则不然。</p>
<p>一般而言，如果优先级没有被手动改变，那么相同场景下多次调用 <code>setState</code> 或者 <code>dispatch</code> 对应的更新优先级是相同的。</p>
<p>例外的情况是具有一整个序列而非单一的优先级，像 <code>TransitionLanes</code> 和 <code>RetryLanes</code>。以 <code>TransitionLanes</code> 为例，它们包含了许多个优先级并不相同并且依次排列的 <code>lane</code>，但是在 <code>render</code> 场景下，这些 <code>lane</code> 是一起被处理的。</p>
<p>像下面这样的示例中的更新是不会被视为同一批的，<code>startTransition</code> 改变了第二个更新的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setCount(count + <span class="number">1</span>)</span><br><span class="line">startTransition(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">2</span>)) <span class="comment">// startTransition引自react</span></span><br></pre></td></tr></table></figure>

<h4 id="3-待执行"><a href="#3-待执行" class="headerlink" title="3. 待执行"></a>3. 待执行</h4><p>待执行指的是已经调度但还未被执行。通常执行相对于调度而言是异步的。假如两个更新具有相同的优先级，那么：</p>
<ul>
<li>只要一个已执行，另一个未执行，无法批处理</li>
<li>只要都未执行，就能批处理（一些异步场景可能带来迷惑性）</li>
</ul>
<p>对于第一点，当我们手动调用同步执行更新的api时，后续的更新就无法与同步的更新成批，在下面的示例中，你会发现点击将带来两次render。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    flushSync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    setCount(count + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然而，这样做是可以批处理的</span></span><br><span class="line">    <span class="comment">// flushSync(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setCount(count + 1)</span></span><br><span class="line">    <span class="comment">//   setCount(count + 2)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;点击数字&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>flushSync</code> 可以使更新同步地被执行，这样一来，第二个 <code>setCount</code> 带来的更新与第一个 <code>setCount</code> 的更新无法被批处理，因为 <code>setCount(count + 2)</code> 调用时，第一个更新已经执行完了。</p>
<p>对于第二点，考虑到js事件循环带来的复杂异步特性，在一些让人意想不到的场景也能批处理，下面是一个有趣的示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'render!'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'42px'</span>, <span class="attr">marginTop</span>: <span class="string">'100px'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;p&gt;划入render一次，点击render两次&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span onClick=&#123;plus&#125; onMouseEnter=&#123;plus&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &#123;count&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>click事件对应的更新优先级是被调度在微任务中的，而mouseEnter事件则是另一类。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-setState-1"><a href="#1-setState-1" class="headerlink" title="1. setState"></a>1. setState</h4><p><code>setState</code> 所做的就是：</p>
<ol>
<li>将 <code>hook</code> 更新加入更新队列</li>
<li>尝试调度一次 <code>react</code> 更新</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="comment">// 首次渲染后root !== null</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-scheduleUpdateOnFiber"><a href="#2-scheduleUpdateOnFiber" class="headerlink" title="2. scheduleUpdateOnFiber"></a>2. scheduleUpdateOnFiber</h4><p>忽略一些琐碎的细节后，可以发现这个函数的核心逻辑甚至更简单：</p>
<ol>
<li>标记一次具有某一优先级的更新（markRootUpdated）</li>
<li>调用ensureRootIsScheduled</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventTime: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ensureRootIsScheduled"><a href="#3-ensureRootIsScheduled" class="headerlink" title="3. ensureRootIsScheduled"></a>3. ensureRootIsScheduled</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里是多次调用不再调度微任务触发processRootScheduleInMicrotask</span></span><br><span class="line">  <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      <span class="comment">// ? sy</span></span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      scheduleImmediateTask(processRootScheduleInMicrotask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-processRootScheduleInMicrotask"><a href="#4-processRootScheduleInMicrotask" class="headerlink" title="4. processRootScheduleInMicrotask"></a>4. processRootScheduleInMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在microtask结束时，flush任何pending的同步work。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</span></span><br><span class="line"><span class="comment">// onClick count</span></span><br><span class="line">flushSyncWorkOnAllRoots();</span><br></pre></td></tr></table></figure>

<h4 id="5-scheduleTaskForRootDuringMicrotask"><a href="#5-scheduleTaskForRootDuringMicrotask" class="headerlink" title="5. scheduleTaskForRootDuringMicrotask"></a>5. scheduleTaskForRootDuringMicrotask</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前所有优先级中最高的优先级</span></span><br><span class="line"><span class="keyword">const</span> nextLanes = getNextLanes(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includesSyncLane(nextLanes)) &#123;</span><br><span class="line">    <span class="comment">// 同步工作始终在微任务结束时刷新，因此我们不需要安排额外的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackPriority = SyncLane;</span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本次要调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = getHighestPriorityLane(nextLanes);</span><br><span class="line">    <span class="comment">// 已经存在的调度的优先级</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">        <span class="comment">// 这里就是同等优先级做批处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 高优先级打断低优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度更新流程</span></span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...实际的调度，最后会给root.callbackPriority赋值</span></span><br><span class="line">      root.callbackPriority = newCallbackPriority;</span><br><span class="line">      root.callbackNode = newCallbackNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于批处理有三点：</p>
<ol>
<li>多次调用 <code>setState</code> 时候，在 <code>ensureRootIsScheduled</code> 中通过 <code>didScheduleMicrotask</code> 标记，第一次进入标记为 <code>true</code>，再次进入便不再调度微任务触发 <code>processRootScheduleInMicrotask</code></li>
<li>当触发后续微任务触发 <code>processRootScheduleInMicrotask</code> 方法，通过 <code>getNextLanes</code> 和 <code>getHighestPriorityLane</code> 拿到本次应该（不一定是setState时的那个）更新的优先级 <code>newCallbackPriority</code></li>
<li>如果是同步优先级，直接return，因为<code>processRootScheduleInMicrotask</code> 方法最后会调用 <code>flushSyncWorkOnAllRoots</code> 执行一遍同步任务， 否则对比上次等待的更新和本次更新的优先级，即 <code>existingCallbackPriority === newCallbackPriority</code>，如果相等，则提前return，否则通过 <code>scheduleCallback</code> 调度更新流程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2函数组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-16T00:00:00+08:00">2024-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载过程"><a href="#1-加载过程" class="headerlink" title="1. 加载过程"></a>1. 加载过程</h2><p>执行函数组件 <code>Fiber</code> 节点的 <code>beginWork</code> 工作，根据 <code>tag</code> 类型，进入 <code>IndeterminateComponent</code> 待定组件的逻辑处理【case IndeterminateComponent】：</p>
<p>每个函数组件的首次加载都是走的 <code>IndeterminateComponent</code> 分支逻辑，这是因为在创建函数组件 <code>Fiber</code> 的时候，<code>react</code> 没有更新它的 <code>tag</code> 值，所以它的首次 <code>beginWork</code> 工作就会进入 <code>IndeterminateComponent</code> 分支，在<code>mountIndeterminateComponent</code> 方法中才会更新它的 <code>tag</code>，使函数组件的Fiber在更新阶段执行 <code>beginWork</code> 时，能够进入正确的 <code>FunctionComponent</code> 分支。</p>
<h3 id="1-1-mountIndeterminateComponent"><a href="#1-1-mountIndeterminateComponent" class="headerlink" title="1.1 mountIndeterminateComponent"></a>1.1 mountIndeterminateComponent</h3><p><font color=gray><em>packages\react-reconciler\src\ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出函数组件的props</span></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储FirstChild内容</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  # 调用函数组件</span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对类组件和函数组件进行不同的处理</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    value.$$<span class="keyword">typeof</span> === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">	# 类组件的处理逻辑 【只是类组件现在已经不走这里了】</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    # 函数组件处理</span><br><span class="line">    <span class="comment">// 更新tag为函数组件类型的值，下个逻辑就可以直接进入函数组件的处理【节点更新的时候】</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    # 创建子节点</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出当前函数组件FIber节点上的最新的props，方便函数组件加载的使用，然后调用renderWithHooks方法，这个方法会执行我们定义的函数组件，返回值就是函数中return的内容，也就是jsx内容【处理过后的react-element元素对象】。</p>
<h4 id="1-1-1-renderWithHooks"><a href="#1-1-1-renderWithHooks" class="headerlink" title="1.1.1 renderWithHooks"></a>1.1.1 renderWithHooks</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  # 设置为当前渲染中的Fiber</span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  # 重置函数组件节点的数据</span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置首次加载的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current = current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  # 调用这个函数，即调用组件，循环生成Element对象，</span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line">  <span class="comment">// 重置一些信息</span></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-1-ReactCurrentDispatcher"><a href="#1-1-1-1-ReactCurrentDispatcher" class="headerlink" title="1.1.1.1 ReactCurrentDispatcher"></a>1.1.1.1 ReactCurrentDispatcher</h5><p><code>ReactCurrentDispatcher</code> 对象是一个全局变量，它是在react源码中的react包定义的：</p>
<p><font color=gray><em>packages\react\src\ReactCurrentDispatcher.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure>

<p>然后将它包装在一个新的对象中：</p>
<p><font color=gray><em>packages\react\src\ReactSharedInternalsClient.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactSharedInternals = &#123;</span><br><span class="line">  ReactCurrentDispatcher,</span><br><span class="line">  ReactCurrentCache,</span><br><span class="line">  ReactCurrentBatchConfig,</span><br><span class="line">  ReactCurrentOwner,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>而shared包【通用工具包】会引入这个对象，然后暴露给全局：</p>
<p><font color=gray><em>packages\shared\ReactSharedInternals.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternalsClient'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>其他资源包就可以通过shared工具包来拿到这个对象，所以我们在函数组件加载时才能使用这个对象：</p>
<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'shared/ReactSharedInternals'</span>;</span><br><span class="line"><span class="comment">// 拿到ReactCurrentDispatcher对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;ReactCurrentDispatcher, ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br></pre></td></tr></table></figure>

<p>知道了 <code>ReactCurrentDispatcher</code> 对象的由来，我们才能更好地理解它的作用，因为函数组件的每个 <code>hook</code> 实际就是在调用这个对象中的同名方法，比如 <code>useState</code>：</p>
<p><font color=gray><em>packages\react\src\ReactHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>resolveDispatcher</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  <span class="comment">// 返回获取到的dispatcher</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 hook 也是一样的原理。</p>
<h5 id="1-1-1-2-函数组件调用"><a href="#1-1-1-2-函数组件调用" class="headerlink" title="1.1.1.2 函数组件调用"></a>1.1.1.2 函数组件调用</h5><p>函数组件的加载核心就是执行一次函数的内容，理解起来也很简单。最后触发 return 关键字，这里的 jsx 内容会在 react 内部通过 <code>jsxRuntime.jsx</code> 方法进行处理，生成 <code>react-element</code> 对象，最后返回值就是创建的 react 元素对象。</p>
<p>最后返回生成的 <code>react-element</code> 对象，<code>renderWithHooks</code> 方法执行完成。</p>
<p>函数组件初始化执行完成后，就会更新函数组件Fiber节点的tag值为正确的类型FunctionComponent【后续逻辑函数组件节点便可以进入Function分支了】。</p>
<p>然后根据新建的value【react元素对象】创建子Fiber节点，最后返回子节点，函数组件的加载过程就基本完成了。</p>
<h3 id="1-2-hooks的加载"><a href="#1-2-hooks的加载" class="headerlink" title="1.2 hooks的加载"></a>1.2 hooks的加载</h3><p>根据上文得知，我们查看先前的 <code>ReactCurrentDispatcher</code> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnMount</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useInsertionEffect: mountInsertionEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState, <span class="comment">// 加载state</span></span><br><span class="line">  useDebugValue: mountDebugValue,</span><br><span class="line">  useDeferredValue: mountDeferredValue,</span><br><span class="line">  useTransition: mountTransition,</span><br><span class="line">  useMutableSource: mountMutableSource,</span><br><span class="line">  useSyncExternalStore: mountSyncExternalStore,</span><br><span class="line">  useId: mountId,</span><br><span class="line"></span><br><span class="line">  unstable_isNewReconciler: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>例如我们在函数中依次使用useState、useEffect、useLayoutEffect，我们来看一下执行过程：</p>
<h4 id="1-2-1-mountState"><a href="#1-2-1-mountState" class="headerlink" title="1.2.1 mountState"></a>1.2.1 mountState</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  # hook加载工作</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'function'</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 等待处理的update链表</span></span><br><span class="line">    lanes: NoLanes,</span><br><span class="line">    dispatch: <span class="literal">null</span>, <span class="comment">// dispatchSetState方法</span></span><br><span class="line">    lastRenderedReducer: basicStateReducer, <span class="comment">// 一个函数，通过action和lastRenderedState计算最新的state</span></span><br><span class="line">    lastRenderedState: initialState, <span class="comment">// 上一次的state</span></span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = queue;</span><br><span class="line">  <span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line">  # 返回值</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-1-mountWorkInProgressHook"><a href="#1-2-1-1-mountWorkInProgressHook" class="headerlink" title="1.2.1.1 mountWorkInProgressHook"></a>1.2.1.1 mountWorkInProgressHook</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  # hook对象</span><br><span class="line">  <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个hook</span></span><br><span class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 后面的hook对象添加到第一个hook的next属性上，形成一个单向链表</span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 <code>hook</code> 对象，<code>workInProgressHook</code> 默认为 <code>null</code>，它代表当前正在处理中的 <code>hook</code> 对象。</p>
<p>当前 <code>useState</code> 为函数组件中的第一个调用的 <code>hook</code> ，所以这时 <code>workInProgressHook</code> 肯定为 <code>null</code>：</p>
<p>将新建 <code>hook</code> 对象赋值给 <code>workInProgressHook</code>，表示为正在处理中的 <code>hook</code> 对象。</p>
<p>同时也将第一个 <code>hook</code> 对象赋值给当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image.png" alt="alt text"></p>
<p>继续回到 <code>mountState</code> 方法中:</p>
<p>在 <code>hook</code> 新建完成之后，判断传入的参数 <code>initialState</code> 是否为函数，如果为函数则调用此函数，将结果赋值为新的 <code>initialState</code>。</p>
<p>然后设置 <code>hook</code> 对象的 <code>memoizedState</code> 和 <code>baseState</code> 属性为初始的数据 <code>initialState</code>。</p>
<p>接下来创建一个queue对象，这里要注意两个属性：</p>
<ol>
<li>lastRenderedReducer：它是一个函数，作用是根据action和lastRenderedState计算最新的state。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action就是setCount传入的参数，如果为一个函数，则将state传入进行计算，返回新的state</span></span><br><span class="line">  <span class="comment">// 如果不是函数，则action就是最新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>lastRenderedState：代表上一次渲染的state</li>
</ol>
<p>然后更新 <code>hook</code> 对象的 <code>queue</code> 属性，同时设置 <code>queue</code> 对象的 <code>dispatch</code> 属性为一个修改函数 <code>dispatchSetState</code></p>
<p>最后返回一个数组，这就是 <code>useState hook</code> 的返回值：一个初始state和一个修改函数。</p>
<h4 id="1-2-2-mountEffect"><a href="#1-2-2-mountEffect" class="headerlink" title="1.2.2 mountEffect"></a>1.2.2 mountEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进入effect加载</span></span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, # Passive标记对应的是useEffect</span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-1-mountEffectImpl"><a href="#1-2-2-1-mountEffectImpl" class="headerlink" title="1.2.2.1 mountEffectImpl"></a>1.2.2.1 mountEffectImpl</h5><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  # 创建的新的hook对象</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 确定当前hook的deps依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 当前渲染中的Fiber节点，即函数组件对应的，打上effect钩子的flags</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">// 设置hook的memoizedState属性</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是先调用 <code>mountWorkInProgressHook</code> 创建一个 <code>hook</code> 对象，所以这里是先将第一个 <code>hook</code> 对象的 <code>next</code> 属性指向新建的 <code>hook</code>，然后再更新 <code>workInProgressHook</code> 的值为当前的 <code>hook</code> 对象。</p>
<p>此时函数组件Fiber节点的memoizedState属性指向为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-1.png" alt="alt text"></p>
<p>在 <code>hook</code> 创建完成之后，确定当前 <code>hook</code> 对象的 <code>deps</code> 依赖，因为我们传递的依赖为[]，所以此时 <code>deps</code> 为一个空数组。然后更新当前 <code>Fiber</code> 节点的 <code>flags</code> 标记，最后设置 <code>hook</code> 对象的 <code>memoizedState</code> 属性内容，这里属性的结果为<code>pushEffect</code> 方法调用的返回值</p>
<h5 id="1-2-2-2-pushEffect"><a href="#1-2-2-2-pushEffect" class="headerlink" title="1.2.2.2 pushEffect"></a>1.2.2.2 pushEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">  # 创建副作用对象</span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create, <span class="comment">// 回调函数</span></span><br><span class="line">    destroy, <span class="comment">// 销毁函数</span></span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 取出当前函数组件的UpdateQueue</span></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null时: 创建当前函数组件的UpdateQueue</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span><br><span class="line">    <span class="comment">// 第一个effect对象: 它的next属性会执行自己,形成一个单向环状链表</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次加载其他的effect时: 将</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">      # 上一个effect的next属性指向新建的effect</span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      # 新建的next属性指向第一个effect</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了一个effect对象，查看它的内容：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-3.png" alt="alt text"></p>
<ol>
<li><code>create</code> 属性即为我们传入的回调函数。</li>
<li><code>deps</code> 属性是当前 <code>useEffect hook</code>的依赖。</li>
<li><code>destory</code> 属性为 <code>undefined</code>，它存储的是 <code>useEffect hook</code>返回的clean清理函数或者说销毁函数，但是它不是在这里赋值的，并且当前我们也没有返回这个函数。</li>
</ol>
<p>然后取出当前函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性内容赋值给变量 <code>componentUpdateQueue</code>。</p>
<p>然后判断 <code>componentUpdateQueue</code> 是否为 <code>null</code>：</p>
<p>为 <code>null</code> 时，然后调用 <code>createFunctionComponentUpdateQueue</code> 方法更新它的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>): <span class="title">FunctionComponentUpdateQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    stores: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前创建的 <code>effect</code> 对象的 <code>next</code> 属性指向了自身，且同时更新 <code>updateQueue.lastEffect</code> 属性为当前 <code>effect</code> 对象，由此形成一个单向环状链表。</p>
<p>所以此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-2.png" alt="alt text"></p>
<p><code>pushEffect</code> 方法最后，返回当前创建的 <code>effect</code> 对象。</p>
<p>再回到 <code>mountEffectImpl</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect()</span><br></pre></td></tr></table></figure>

<p>所以 <code>hook</code> 对象的 <code>memoizedState</code> 属性值为一个 <code>effect</code> 对象。</p>
<p>从这里我们可以发现，虽然每个hook对象都是相同的属性，但是不同的 <code>hook</code> 类型它存储的内容却完全不同。</p>
<ul>
<li><code>useState</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为数据 <code>state</code>。</li>
<li><code>useEffect</code> 创建的 <code>hook</code> 对象，它的 <code>memoizedState</code> 属性存储的为一个 <code>effect</code> 对象。</li>
</ul>
<h4 id="1-2-3-mountLayoutEffect"><a href="#1-2-3-mountLayoutEffect" class="headerlink" title="1.2.3 mountLayoutEffect"></a>1.2.3 mountLayoutEffect</h4><p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fiberFlags: Flags = UpdateEffect;</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">    fiberFlags |= LayoutStaticEffect;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mountEffectImpl(fiberFlags, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现useEffect和useLayoutEffect共用了同一个加载方法 <code>mountEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<p><code>hook</code> 对象创建和处理，此时函数组件Fiber节点的memoizedState属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-4.png" alt="alt text"></p>
<p><code>effect</code> 对象创建和处理，依然是 <code>pushEffect</code> 方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # 第二次加载其他的effect时:</span><br><span class="line">  <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="comment">// 上一个effect的next属性指向新建的effect</span></span><br><span class="line">    lastEffect.next = effect;</span><br><span class="line">    <span class="comment">// 新建的next属性指向第一个effect</span></span><br><span class="line">    effect.next = firstEffect;</span><br><span class="line">    componentUpdateQueue.lastEffect = effect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前为第二个effect相关的 <code>hook</code> 处理，所以此时 <code>Fiber.updateQueue</code>【即componentUpdateQueue】是有值的，进入else分支处理。</p>
<p>更新<code>Fiber.updateQueue.lastEffect</code>属性指向为当前新建的 <code>effect2</code>，将 <code>effect2</code> 的 <code>next</code> 属性指向为之前的 <code>effect</code> 对象。</p>
<p>此时函数组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性指向更新为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-5.png" alt="alt text"></p>
<p>到此，函数组件加载阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="1-3-commit阶段"><a href="#1-3-commit阶段" class="headerlink" title="1.3 commit阶段"></a>1.3 commit阶段</h3><p>前面全部的加载逻辑都是在 <code>Fiber Reconciler</code> 协调流程中执行的，即函数组件大部分的加载逻辑都是在 <code>reconciler</code> 协调流程中完成的【更新阶段同理】，还有剩下的一部分逻辑在 <code>commit</code> 阶段之中处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发起调度处理useEffect回调</span></span><br><span class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">	<span class="comment">// 这个回调就是处理useEffect的</span></span><br><span class="line">	flushPassiveEffects();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1，BeforeMutation阶段</span></span><br><span class="line">  commitBeforeMutationEffects()</span><br><span class="line">  <span class="comment">// 2，Mutation阶段，渲染真实DOM加载到页面</span></span><br><span class="line">  commitMutationEffects()</span><br><span class="line">  <span class="comment">// 3，Layout阶段</span></span><br><span class="line">  commitLayoutEffects()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit</code> 阶段的内容都是同步执行，在进入具体的执行之前，都会先调用 <code>scheduleCallback</code> 方法发起一个新的调度，即创建一个新的任务 <code>task</code>，最后会生成一个新的宏任务来异步处理副作用【即执行useEffect的回调钩子】。</p>
<p>上面是 <code>useEffect</code> 的回调处理，我们再查看 <code>useLayoutEffect</code> 的回调处理。</p>
<h3 id="1-4-Layout阶段"><a href="#1-4-Layout阶段" class="headerlink" title="1.4 Layout阶段"></a>1.4 Layout阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 根据组件类型</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">          <span class="comment">// 函数组件的处理</span></span><br><span class="line">          <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">              <span class="comment">// 传入的是layout相关的flag标记</span></span><br><span class="line">              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-commitHookEffectListMount"><a href="#1-4-1-commitHookEffectListMount" class="headerlink" title="1.4.1 commitHookEffectListMount"></a>1.4.1 commitHookEffectListMount</h4><p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectListMount</span>(<span class="params">flags: HookFlags, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  # 当前函数组件的updateQueue属性，存储的是副作用链表</span><br><span class="line">  <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">  <span class="comment">// 取出最后一个effect对象</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取第一个effect对象</span></span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 开始循环处理</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">        <span class="comment">// Mount</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.create;</span><br><span class="line">        # 执行回调函数</span><br><span class="line">        effect.destroy = create();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从当前函数组件 <code>Fiber</code> 节点取出它的 <code>updateQueue</code> 属性内容，在前面我们已经知道了 <code>Fiber.updateQueue</code> 存储的是副作用相关的链表，定义一个 <code>lastEffect</code> 变量存储 <code>updateQueue.lastEffect</code> 的内容，即最后一个 <code>effect</code> 对象。</p>
<p>判断 <code>lastEffect</code> 是否为 <code>null</code> ，如果 <code>lastEffect</code> 为 <code>null</code>，代表当前函数组件没有使用过 <code>effect</code> 相关的 <code>hook</code>。</p>
<p>当前肯定是有值的，继续向下执行。从 <code>lastEffect.next</code> 中取出第一个 <code>effect</code> 对象，开始按顺序循环处理副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((effect.tag &amp; flags) === flags) &#123;</span><br><span class="line">	<span class="comment">// Mount</span></span><br><span class="line">	<span class="keyword">const</span> create = effect.create;</span><br><span class="line">	<span class="comment">// 执行回调函数</span></span><br><span class="line">	effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">  effect = effect.next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>

<p>注意在执行之前有一个条件判断，只有存在 <code>effect</code> 相关的 <code>flags</code> 标记才会执行对应副作用回调。</p>
<p>而在之前 <code>hook</code> 加载是有进行设置的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hook.memoizedState = pushEffect(</span><br><span class="line">  HookHasEffect | hookFlags, <span class="comment">// HookHasEffect标记就是表示有需要执行副作用</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在函数组件加载阶段时，每个 <code>useEffect</code> 和 <code>useLayoutEffect</code> 都有打上 <code>HookHasEffect</code> 的标记，表示在加载阶段都会默认执行一次。</p>
<p>需要注意的是：之前 <code>commitHookEffectListMount</code> 传入的是与 <code>Layout</code> 相关的 <code>flags</code> 标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); <span class="comment">// Layout</span></span><br></pre></td></tr></table></figure>

<p>所以这里只有 <code>layout hook</code> 的回调才能执行，第一个 <code>effect</code> 对象对应的是 <code>useEffect</code>，不满足判断条件</p>
<p>从当前 <code>effect</code> 对象的 <code>next</code> 属性取出下一个 <code>effect</code> 对象，开始第二次循环。</p>
<p>第二个 <code>effect</code> 对象对应的是 <code>useLayoutEffect</code>，满足判断条件，执行它的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = effect.create;</span><br><span class="line"><span class="comment">// 执行回调函数</span></span><br><span class="line">effect.destroy = create();</span><br></pre></td></tr></table></figure>

<p>到此 hook 相关的回调处理完成，函数组件加载逻辑全部执行完成。</p>
<h2 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h2><h3 id="2-1-dispatchSetState"><a href="#2-1-dispatchSetState" class="headerlink" title="2.1 dispatchSetState"></a>2.1 dispatchSetState</h3><p>当操作更新触发 <code>setState</code> 时, 就是触发之前 <code>useState</code> 加载返回的 <code>dispatch</code> 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = queue.dispatch = dispatchSetState.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue)</span><br><span class="line"># 返回值</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p><font color=gray><em>packages\react-reconciler\src\ReactFiberHooks.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchSetState</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  action: A, <span class="regexp">//</span> state <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求更新优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="comment">// 1. 创建update更新对象</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action, <span class="comment">// state 1</span></span><br><span class="line">    hasEagerState: <span class="literal">false</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRenderPhaseUpdate(fiber)) &#123;</span><br><span class="line">    enqueueRenderPhaseUpdate(queue, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    # 调度之前的一个优化策略校验: eagerState</span><br><span class="line">    <span class="comment">// 快速计算出本次最新的state，与原来的进行对比，如果没有发生变化，则跳过后续的更新逻辑</span></span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 当前的state，即旧的state</span></span><br><span class="line">          <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">          <span class="comment">// 快速计算最新的state</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">          update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">          update.eagerState = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">            # 如果state没变，组件不做更新。此处和useReducer对比下，useReducer还是会让函数组件更新</span><br><span class="line">            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将更新对象入队</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">      <span class="comment">// 3. 开启一个新的调度更新任务</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span><br><span class="line">      entangleTransitionUpdate(root, queue, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-eagerState"><a href="#2-1-1-eagerState" class="headerlink" title="2.1.1 eagerState"></a>2.1.1 eagerState</h4><p>首先看 <code>dispatchSetState</code> 方法的整个结构和类组件的更新方法 <code>enqueueSetState</code> 基本相同，还有 <code>react</code> 应用的初始加载 <code>updateContainer</code>，其实一个react应用的更新场景就只有这三种，而它们的更新逻辑就是以下几个步骤：</p>
<ol>
<li>获取更新优先级 <code>lane</code>。</li>
<li>创建 <code>update</code> 更新对象 。</li>
<li>将 <code>update</code> 更新对象添加到目标Fiber对象的更新队列中。</li>
<li>开启一个新的调度更新任务。</li>
</ol>
<p>它们的区别主要在于函数组件这里在调度之前有一个eagerState优化策略校验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的state，即旧的state</span></span><br><span class="line"><span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line"><span class="comment">// 快速计算最新的state</span></span><br><span class="line"><span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">update.hasEagerState = <span class="literal">true</span>;</span><br><span class="line">update.eagerState = eagerState;</span><br><span class="line"><span class="comment">// 比较新旧state</span></span><br><span class="line"><span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个优化策略的作用是：调用 <code>queue.lastRenderedReducer</code> 方法，通过原来的 <code>state</code> 和当前传入的 <code>action</code> 参数，快速的计算出本次最新的 <code>state</code> 【即eagerState】，通过比较新旧 <code>state</code> 来判断数据是否变化，如果没有变化则可以跳过后续的更新逻辑，即不会开启新的调度更新任务。当前我们的 <code>state</code> 是有变化的，所以不满足优化策略，将继续向下执行更新。</p>
<h4 id="2-1-2-enqueueConcurrentHookUpdate"><a href="#2-1-2-enqueueConcurrentHookUpdate" class="headerlink" title="2.1.2 enqueueConcurrentHookUpdate"></a>2.1.2 enqueueConcurrentHookUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentHookUpdate</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  queue: HookQueue&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: HookUpdate&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> concurrentQueue: ConcurrentQueue = (queue: any);</span><br><span class="line">  <span class="keyword">const</span> concurrentUpdate: ConcurrentUpdate = (update: any);</span><br><span class="line">  <span class="comment">// 通用的入队方法</span></span><br><span class="line">  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);</span><br><span class="line">  <span class="comment">// 找到根节点并返回</span></span><br><span class="line">  <span class="keyword">return</span> getRootForUpdatedFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>dispatchSetState</code> 方法中，最后还是会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h4 id="2-1-3-flushSyncWorkOnAllRoots"><a href="#2-1-3-flushSyncWorkOnAllRoots" class="headerlink" title="2.1.3 flushSyncWorkOnAllRoots"></a>2.1.3 flushSyncWorkOnAllRoots</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processRootScheduleInMicrotask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flushSyncWorkOnAllRoots();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>microtask</code> 结束时，<code>flush</code> 任何 <code>pending</code> 的同步 <code>work</code>。这必须放在最后，因为它执行实际的可能会抛出异常的渲染工作。</p>
<p>直接快进到performSyncWorkOnRoot方法中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用renderRootSync方法，开始FiberTree的创建过程。</p>
<p><strong>在这之前，还有一个处理要注意：把 <code>concurrentQueues</code> 的内容添加到 <code>fiber</code> 的 <code>queue</code> 中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	prepareFreshStack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	finishQueueingConcurrentUpdates()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-6.png" alt="alt text"></p>
<h4 id="2-1-4-updateFunctionComponent"><a href="#2-1-4-updateFunctionComponent" class="headerlink" title="2.1.4 updateFunctionComponent"></a>2.1.4 updateFunctionComponent</h4><p>下面进入 <code>beginWork</code> 工作的 <code>FunctionComponent</code> 处理分支，开始函数组件的更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  # 调用函数组件</span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  # 函数组件默认的bailout策略，满足条件比较苛刻</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见 <code>updateFunctionComponent</code> 方法主要有两个处理：</p>
<ol>
<li>调用renderWithHooks【函数组件加载也是调用了这个方法】。</li>
<li>判断是否满足Bailout优化策略，满足则进入优化逻辑，跳过本组件的更新。不满足，则执行正常的组件更新逻辑。</li>
</ol>
<h4 id="2-1-5-renderWithHooks"><a href="#2-1-5-renderWithHooks" class="headerlink" title="2.1.5 renderWithHooks"></a>2.1.5 renderWithHooks</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>&lt;<span class="title">Props</span>, <span class="title">SecondArg</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: (p: Props, arg: SecondArg</span>) =&gt; <span class="title">any</span>,</span></span><br><span class="line"><span class="function">  <span class="title">props</span>: <span class="title">Props</span>,</span></span><br><span class="line"><span class="function">  <span class="title">secondArg</span>: <span class="title">SecondArg</span>,</span></span><br><span class="line"><span class="function">  <span class="title">nextRenderLanes</span>: <span class="title">Lanes</span>,</span></span><br><span class="line"><span class="function">): <span class="title">any</span> </span>&#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// 设置为当前渲染中的Fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置函数组件节点的数据</span></span><br><span class="line">  workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置更新的dispatcher【重点】</span></span><br><span class="line">  ReactCurrentDispatcher.current =current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Component为workInProgress.type 如果是函数组件：就是自身函数</span></span><br><span class="line">  <span class="comment">// 调用这个函数，即调用组件，循环生成Element对象，</span></span><br><span class="line">  <span class="comment">// 将return返回的Jsx内容转换为reactElement对象，最后返回这个对象</span></span><br><span class="line">  <span class="keyword">let</span> children = Component(props, secondArg);</span><br><span class="line"></span><br><span class="line">  renderLanes = NoLanes;</span><br><span class="line">  currentlyRenderingFiber = (<span class="literal">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  # 返回函数组件的内容【reactElement对象】</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新阶段时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current = HooksDispatcherOnUpdate</span><br></pre></td></tr></table></figure>

<p><code>renderWithHooks</code> 方法的重点依然是组件的调用 <code>Component()</code>，这里的逻辑依然只是重新调用一遍我们定义的函数，最后返回最新的jsx内容【即reactElement对象】</p>
<h4 id="2-1-6-hooks的更新"><a href="#2-1-6-hooks的更新" class="headerlink" title="2.1.6 hooks的更新"></a>2.1.6 hooks的更新</h4><p>首先查看 <code>useState</code> 的更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123;</span><br><span class="line">	useState: updateState, <span class="comment">// 更新state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState:</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg, init?</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 更新hook工作</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-updateWorkInProgressHook"><a href="#2-1-7-updateWorkInProgressHook" class="headerlink" title="2.1.7 updateWorkInProgressHook"></a>2.1.7 updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即将处理的hook</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 第一此进入更新时，currentHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出当前正在更新的函数组件Fiber的旧节点</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.alternate;</span><br><span class="line">    <span class="comment">// 更新阶段，current都是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将旧节点的memoizedState 设置为下一个处理的Hook</span></span><br><span class="line">      <span class="comment">// 将组件加载时，初始化的hook链表取出，memoizedState指向的是hook1</span></span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个hook更新开始，会走这里</span></span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置下一个工作中的Hook为null</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook: <span class="literal">null</span> | Hook;</span><br><span class="line">  <span class="comment">// 组件的第一个Hook更新时，workInProgressHook为null</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将当前函数组件Fiber节点的memoizedState 设置为下一个处理的hook【默认是null】</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一个Hook，则取next指向的下一个</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个不为null， 说明当前hook不是最后一个更新的hook，只有最后一个hook更新时，nextWorkInProgressHook才为null</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There's already a work-in-progress. Reuse it.</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新currentHook 为第一个hook</span></span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Hook对象，复用原来的内容</span></span><br><span class="line">    <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">      memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">      baseState: currentHook.baseState,</span><br><span class="line">      baseQueue: currentHook.baseQueue,</span><br><span class="line">      queue: currentHook.queue,</span><br><span class="line"></span><br><span class="line">      next: <span class="literal">null</span>, <span class="comment">// 但是清空了next指向</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个hook更新时，workInProgressHook为null，会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">      <span class="comment">// 更新当前函数的组件的memoizedState为第一个hook对象，同时设置为当前正在工作中的hook</span></span><br><span class="line">      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Append to the end of the list.</span></span><br><span class="line">      <span class="comment">// 非第一个Hook,直接添加到上一个hook对象的next属性中</span></span><br><span class="line">      workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回当前正在工作中的hook</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像函数组件的hook在加载时都会调用一个 <code>mountWorkInProgressHook</code> 方法，生成一个hook链表。</p>
<p>而函数组件的hook在更新时也会调用一个 <code>updateWorkInProgressHook</code> 方法，生成对应的hook链表。</p>
<p>所以 <code>updateWorkInProgressHook</code> 方法的作用是：确定当前函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容，也就是生成它的 <code>hook</code> 链表。</p>
<p>它的做法就是从 <code>current</code> 节点上取出函数组件加载时生成的 <code>hook</code> 链表，按顺序取出原来的 <code>hook</code> 对象，根据原来的对象信息创建生成新的 <code>newHook</code> 对象，最后按顺序一个一个添加到新的 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性上。</p>
<p><strong>注意：</strong>这里是一个重点，如果没有清空 <code>next</code> 属性，那更新当前函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性，直接拿到第一个 <code>hook</code> 对象，就可以拿到整个 <code>hook</code> 链表，然后后续的 <code>hook</code> 更新就不需要再调用 <code>updateWorkInProgressHook</code> 方法了。</p>
<p>但是函数组件为啥不能如此处理呢？</p>
<p>因为react不能保证开发者是一定按照规范来使用的 <code>hook</code> ，如果开发者将 <code>hook</code> 置于条件语句中，在更新阶段出现了原来 <code>hook</code> 链表中不存在的 <code>hook</code> 对象，则在渲染时就会发生异常，所以react在函数组件更新时需要主动中断 <code>hook</code> 对象的next属性指向，按原来的链表顺序重新一个一个添加，如果出现了不匹配的 <code>hook</code> 对象，就会主动抛出异常，提示用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rendered more hooks than during the previous render.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-计算state"><a href="#2-1-8-计算state" class="headerlink" title="2.1.8 计算state"></a>2.1.8 计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A</span>) =&gt; <span class="title">S</span>,</span></span><br><span class="line"><span class="function">  <span class="title">initialArg</span>: <span class="title">I</span>,</span></span><br><span class="line"><span class="function">  <span class="title">init</span>?: <span class="title">I</span> =&gt; <span class="title">S</span>,</span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 返回新的hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer; <span class="comment">// 还是basicStateReducer，无变化</span></span><br><span class="line">  <span class="keyword">const</span> current = currentHook; <span class="comment">// 旧的hook对象，加载时useState创建的hook对象</span></span><br><span class="line">  <span class="comment">// The last rebase update that is NOT part of the base state.</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.baseQueue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last pending update that hasn't been processed yet.</span></span><br><span class="line">  <span class="comment">// 等待处理的更新链表：默认指向的是最后一个update对象</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// pendingQueue不为null，代表有需要处理的更新对象，然后需要将它们添加到baseQueue</span></span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Merge the pending queue and the base queue.</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.next;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.next;</span><br><span class="line">      baseQueue.next = pendingFirst;</span><br><span class="line">      pendingQueue.next = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们有一个队列要处理</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">let</span> newState = current.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line"></span><br><span class="line">    # 循环处理update更新对象</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line">          action: update.action,</span><br><span class="line">          hasEagerState: update.hasEagerState,</span><br><span class="line">          eagerState: update.eagerState,</span><br><span class="line">          next: (<span class="literal">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove</span></span><br><span class="line">        <span class="comment">// renderLanes from the original lanes.</span></span><br><span class="line">        currentlyRenderingFiber.lanes = mergeLanes(</span><br><span class="line">          currentlyRenderingFiber.lanes,</span><br><span class="line">          updateLane,</span><br><span class="line">        );</span><br><span class="line">        markSkippedUpdateLanes(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line">            action: update.action,</span><br><span class="line">            hasEagerState: update.hasEagerState,</span><br><span class="line">            eagerState: update.eagerState,</span><br><span class="line">            next: (<span class="literal">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.next = clone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">          <span class="comment">// If this update is a state update (not a reducer) and was processed eagerly,</span></span><br><span class="line">          <span class="comment">// we can use the eagerly computed state</span></span><br><span class="line">          newState = ((update.eagerState: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newBaseQueueLast.next = (newBaseQueueFirst: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	# 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line">    <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">      markWorkInProgressReceivedUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    hook.baseQueue = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedState = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>updateWorkInProgressHook</code> 方法调用完成之后，返回值就是 <code>useState</code> 对应的hook对象：</p>
<p>取出hook对象的queue队列，如果queue为null，则会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Should have a queue. This is likely a bug in React. Please file an issue.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的逻辑看似比较多，但其实比较简单，而且和this.setState计算state的逻辑基本一致。</p>
<p><strong>它的核心逻辑：</strong>按顺序正向循环 <code>update</code> 更新队列，定义一个变量 <code>newState</code> 来存储最新的 <code>state</code>，然后根据原来 <code>state</code> 和 <code>update</code> 对象里面的信息计算最新的数据更新变量 <code>newState</code>，每循环一次就会从 <code>update</code> 对象的 <code>next</code> 属性取出下一个参与计算的 <code>update</code>，直接到所有的 <code>update</code> 处理完成。</p>
<p>当前 <code>pendingQueue</code> 结构【单向环状链表】：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-7.png" alt="alt text"></p>
<p>在类组件中，会根据pendingQueue的内容重构生成一个新的单向链表，不再是环状，有明确的结束。</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-8.png" alt="alt text"></p>
<p>和类组件不同的是，函数组件这里并没有额外处理pendingQueue，而是直接复制给baseQueue，从baseQueue.next取出第一个update对象【即first】开始计算state。</p>
<p>所以函数组件这里的do while循环多了一个结束的判断条件，就是不能等于first，不然就会陷入无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first)</span><br></pre></td></tr></table></figure>

<p>然后就是函数组件计算state的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do while循环中，计算state的核心逻辑</span></span><br><span class="line"><span class="keyword">if</span> (update.hasEagerState) &#123;</span><br><span class="line">  newState = ((update.eagerState: any): S);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> action = update.action;</span><br><span class="line">  newState = reducer(newState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果eagerState存在，则直接使用eagerState的值为新的state。</p>
<p>如果不存在，则调用reducer【basicStateReducer】，根据最新的newState和当前update对象的action重新计算state。</p>
<p>循环结束，在更新state之前，还有一个校验需要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 【重点】如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量ReceivedUpdate为false，方便后续进入Bailout策略</span><br><span class="line"><span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">  markWorkInProgressReceivedUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对一个状态的批量处理之后，有一个状态变化的校验，针对的是函数组件内部的 <code>Bailout</code> 策略。</p>
<p>即如果对某一个状态多次修改的最终结果是无变化，则会设置全局变量 <code>ReceivedUpdate</code> 为 <code>false</code>，表示改组件没有更新的内容，这样就可以在 <code>renderWithHooks</code> 方法执行完成后，进入 <code>Bailout</code> 策略。</p>
<p>然后更新 <code>hook</code> 对象的 <code>memoizedState</code> 属性为最新的 <code>newState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储最新的state</span></span><br><span class="line">hook.memoizedState = newState;</span><br></pre></td></tr></table></figure>

<p>到此，<code>useState hook</code> 的更新程序执行完成，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆state</span></span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br></pre></td></tr></table></figure>

<p>同时这里我们也可以明白：函数组件 <code>useState hook</code> 能够缓存变量结果的原因，因为它的 <code>state</code> 存储在 <code>hook</code> 对象的属性之中，并且这个属性可以在函数组件重新渲染过程中得到更新。</p>
<h3 id="2-2-updateEffect"><a href="#2-2-updateEffect" class="headerlink" title="2.2 updateEffect"></a>2.2 updateEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 取出新的依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 重置销毁方法</span></span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 原来的pushEffect方法</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    <span class="comment">// 继承原来的destroy方法</span></span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面校验为true的情况下，这里就不会再执行</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先依然是调用一个 <code>updateWorkInProgressHook</code> 方法，前面已经详细讲解了它的作用。所以这里调用此方法后，就会新建一个 <code>newHook</code> 对象，添加到第一个 <code>hook</code> 对象的 <code>next</code> 属性之上，形成一个链表，后续如果还有新的 <code>newHook</code> 对象则继续执行同样的逻辑。</p>
<p>此时函数 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性内容为：</p>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-9.png" alt="alt text"></p>
<h3 id="2-2-1-areHookInputsEqual"><a href="#2-2-1-areHookInputsEqual" class="headerlink" title="2.2.1 areHookInputsEqual"></a>2.2.1 areHookInputsEqual</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况1，无依赖参数，每次渲染都会执行副作用</span></span><br><span class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情况2，有至少一项依赖参数，循环判断每个依赖是否相等，任何一个依赖变化则会重新执行副作用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 情况3，即空数组的情况，重新渲染不执行副作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前我们依赖为一个空数组，所以满足第三种情况，直接返回 <code>true</code>。</p>
<ul>
<li><p>在依赖校验为 <code>true</code> 的情况下，即表示没有变化，此时更新 <code>hook.memoizedState</code> 属性，最后触发 <code>return</code> 关键字，<code>updateEffect</code> 方法执行完成。</p>
</li>
<li><p>在依赖变化时，也会重新设置 <code>hook.memoizedState</code> 属性，依赖校验为true的情况下就是第一个参数不同，会打上 <code>HookHasEffect</code> 的标记。</p>
<ul>
<li>这个值会存储到 <code>effect</code> 对象的tag属性上，表示此effect对象有需要执行的副作用回调。</li>
<li><code>hookFlags</code> 表示副作用的类型标记，比如 <code>HookPassive</code>，<code>HookLayout</code>。</li>
<li>所以依赖发生变化的唯一区别就是：打上了 <code>HookHasEffect</code> 标记。最终会 <code>commit</code> 阶段中执行回调时，判断 <code>effect.tag</code> 的值来判断是否执行回调。</li>
</ul>
</li>
</ul>
<p>到此，函数组件的第二个hook：useEffect更新完成。</p>
<h3 id="2-3-updateLayoutEffect"><a href="#2-3-updateLayoutEffect" class="headerlink" title="2.3 updateLayoutEffect"></a>2.3 updateLayoutEffect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>useEffect</code> 和 <code>useLayoutEffect</code> 共用了同一个更新方法 <code>updateEffectImpl</code>，所以它们会执行同样的逻辑处理。</p>
<ul>
<li>调用 <code>updateWorkInProgressHook</code> 方法：创建新 <code>hook</code> 对象，此时函数组件 <code>Fiber</code> 节点的 <code>memoizedState</code> 属性指向更新为：</li>
</ul>
<p><img src="../images/react18.2%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-10.png" alt="alt text"></p>
<ul>
<li>判断 <code>deps</code> 依赖是否变化，如果变化则为对应的 <code>effect</code> 对象打上 <code>HookHasEffect</code> 的标记。</li>
</ul>
<p>到此，函数组件更新阶段的 <code>hooks</code> 就处理完成。</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>函数组件更新阶段主要有这两个重点逻辑：</p>
<ul>
<li>根据 <code>updateQueue</code> 更新队列，循环计算 <code>state</code>，最后将最新的 <code>state</code> 数据存储到 <code>Fiber.memoizedState</code> 属性上并返回。</li>
<li>更新 <code>Effect</code>类 <code>hook</code> 时，判断依赖是否变化打上 <code>HookHasEffect</code>，最后会根据 <code>effect.tag</code> 值来决定本次更新是否执行回调。</li>
</ul>
<p><code>useEffect</code> 和 <code>useLayoutEffect</code>的区别：<code>useLayoutEffect</code> 是 <code>useEffect</code> 的一个变种，它们都是在 <code>React</code> 组件中处理副作用的方法。两者之间的主要区别在于它们的执行时机。</p>
<ul>
<li><code>useEffect</code> 的回调函数会在每次渲染结束后异步执行，这意味着它不会阻塞浏览器的渲染过程。换句话说，<code>React</code> 会在处理 <code>useEffect</code> 内部的状态更新之前，让浏览器先绘制屏幕。</li>
<li>而 <code>useLayoutEffect</code> 的回调函数会在每次渲染结束后同步执行。这意味着它会阻塞浏览器的渲染过程，直到其执行完毕。因此，<code>useLayoutEffect</code> 可以在浏览器重新绘制屏幕之前触发。</li>
</ul>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 会阻塞浏览器的渲染过程，如果过度使用，可能会导致应用程序变慢，甚至引发性能问题。因此，在大多数情况下，应优先考虑使用 <code>useEffect</code>。只有在某些特定情况下，例如需要在 <code>DOM</code> 更新后立即进行某些操作，或者需要在用户看到渲染结果之前进行某些操作，才考虑使用 <code>useLayoutEffect</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react18.2%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" class="post-title-link" itemprop="url">react18.2类组件加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T00:00:00+08:00">2024-10-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1. 加载阶段"></a>1. 加载阶段</h2><h3 id="1-1-updateClassComponent"><a href="#1-1-updateClassComponent" class="headerlink" title="1.1 updateClassComponent"></a>1.1 updateClassComponent</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberBeginWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasContext;</span><br><span class="line">  <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = <span class="literal">true</span>;</span><br><span class="line">    pushLegacyContextProvider(workInProgress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hasContext = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line">  <span class="comment">// 类组件节点的stateNode 不是存储dom元素，而是组件实例 【hostComponent的stateNode才是dom元素】</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  # 第一次class组件加载，instance都为null</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化构建组件实例</span></span><br><span class="line">    constructClassInstance(workInProgress, Component, nextProps);</span><br><span class="line">    <span class="comment">// 加载组件实例</span></span><br><span class="line">    mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// In a resume, we'll already have an instance we can reuse.</span></span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update阶段：判断是否更新class组件</span></span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 最后：创建class组件child</span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  # 返回child子节点</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassComponent</code> 方法的内容并不复杂，主要就是两个逻辑的执行：</p>
<ol>
<li>class组件实例的创建或者更新。</li>
<li>创建组件的child子节点，最后返回子节点。</li>
</ol>
<h3 id="1-2-构建class组件实例-constructClassInstance"><a href="#1-2-构建class组件实例-constructClassInstance" class="headerlink" title="1.2 构建class组件实例 - constructClassInstance"></a>1.2 构建class组件实例 - constructClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  # 创建class实例对象，参数为props和context</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将instance实例对象的state数据同步到Fiber节点的memoizedState属性</span></span><br><span class="line">  <span class="keyword">const</span> state = (workInProgress.memoizedState =</span><br><span class="line">    instance.state !== <span class="literal">null</span> &amp;&amp; instance.state !== <span class="literal">undefined</span></span><br><span class="line">      ? instance.state</span><br><span class="line">      : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  # 确定class组件实例：即链接FiberNode与对应的组件实例</span><br><span class="line">  adoptClassInstance(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dev开发环境下的警告：如果class组件使用了过时的生命周期钩子，发出对应的警告</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  # 返回创建完成的实例</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-adoptClassInstance"><a href="#1-2-1-adoptClassInstance" class="headerlink" title="1.2.1 adoptClassInstance"></a>1.2.1 adoptClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adoptClassInstance</span>(<span class="params">workInProgress: Fiber, instance: any</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  instance.updater = classComponentUpdater;</span><br><span class="line">  <span class="comment">// Fiber节点存储instance实例</span></span><br><span class="line">  workInProgress.stateNode = instance;</span><br><span class="line">  <span class="comment">// instance对象定义一个_reactInternal内部属性存储Fiber节点</span></span><br><span class="line">  setInstance(instance, workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-加载组件-mountClassInstance"><a href="#1-3-加载组件-mountClassInstance" class="headerlink" title="1.3 加载组件 - mountClassInstance"></a>1.3 加载组件 - mountClassInstance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出class组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="comment">// props</span></span><br><span class="line">  instance.props = newProps;</span><br><span class="line">  <span class="comment">// 同步state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line">  <span class="comment">// ref：默认为空对象</span></span><br><span class="line">  instance.refs = emptyRefsObject;</span><br><span class="line">  <span class="comment">// 初始化一个Fiber节点的更新队列</span></span><br><span class="line">  # 设置更新队列对象：fiber.updateQueue = queue;</span><br><span class="line">  initializeUpdateQueue(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步组件实例的state数据</span></span><br><span class="line">  instance.state = workInProgress.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">    applyDerivedStateFromProps(</span><br><span class="line">      workInProgress,</span><br><span class="line">      ctor,</span><br><span class="line">      getDerivedStateFromProps,</span><br><span class="line">      newProps,</span><br><span class="line">    );</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to support react-lifecycles-compat polyfilled components,</span></span><br><span class="line">  <span class="comment">// Unsafe lifecycles should not be invoked for components using the new APIs.</span></span><br><span class="line">  <span class="comment">// 不应该使用旧的生命周期钩子</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> ctor.getDerivedStateFromProps !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate !== <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="string">'function'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> instance.componentWillMount === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    # 触发WillMount生命周期钩子</span><br><span class="line">    callComponentWillMount(workInProgress, instance);</span><br><span class="line">    <span class="comment">// If we had additional state updates during this life-cycle, let's</span></span><br><span class="line">    <span class="comment">// process them now.</span></span><br><span class="line">    processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 如果设置了class组件的componentDidMount生命周期钩子函数，则需要在组件的FiberNode上设置对应的flags</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidMount === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fiberFlags: Flags = Update;</span><br><span class="line">    <span class="keyword">if</span> (enableSuspenseLayoutEffectSemantics) &#123;</span><br><span class="line">      fiberFlags |= LayoutStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workInProgress.flags |= fiberFlags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先更新了 <code>instance</code> 组件实例上的一些属性，然后初始化了当前组件 <code>Fiber</code> 节点的 <code>updateQueue</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个更新队列对象</span></span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState, <span class="comment">// 初始state数据</span></span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>, <span class="comment">// 存储update链表</span></span><br><span class="line">      lanes: NoLanes,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置updateQueue属性</span></span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是针对 <code>componentWillMount</code> 生命周期钩子函数的处理，虽然是过时的API，但是如果定义了还是需要在这里触发。</p>
<p>最后如果定义了 <code>componentDidMount</code> 钩子函数，则需要给该 <code>Fiber</code> 节点的 <code>flags</code> 属性设置对应的副作用标记。</p>
<p><code>flags</code> 标记的作用是在 <code>commit</code> 阶段执行对应的副作用操作，所以 <code>componentDidMount</code> 钩子函数会在 <code>commit</code> 阶段中进行触发调用。</p>
<p>到此，类组件的加载就完成了。</p>
<h2 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># setState原理</span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用updater中的一个方法</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-enqueueSetState"><a href="#2-1-enqueueSetState" class="headerlink" title="2.1 enqueueSetState"></a>2.1 enqueueSetState</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  enqueueSetState(inst: any, <span class="attr">payload</span>: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ! 1. 获取current和lane</span></span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ! 2. 创建update</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(lane);</span><br><span class="line">    update.payload = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 3. update入队fiber.updateQueue中, 并返回应用的root根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = enqueueUpdate(fiber, update, lane);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ! 4. 调度更新(开启一个从root根节点开始的更新调度)</span></span><br><span class="line">      scheduleUpdateOnFiber(root, fiber, lane);</span><br><span class="line">      <span class="comment">// ! 5. 处理transitions，非紧急更新</span></span><br><span class="line">      entangleTransitions(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">      markStateUpdateScheduled(fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueReplaceState(inst: any, <span class="attr">payload</span>: any, <span class="attr">callback</span>: <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueForceUpdate(inst: any, callback) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-enqueueUpdate"><a href="#2-1-1-enqueueUpdate" class="headerlink" title="2.1.1 enqueueUpdate"></a>2.1.1 enqueueUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateQueue = fiber.updateQueue;</span><br><span class="line">  <span class="keyword">const</span> sharedQueue: SharedQueue&lt;State&gt; = (updateQueue: any).shared;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-enqueueConcurrentClassUpdate"><a href="#2-1-2-enqueueConcurrentClassUpdate" class="headerlink" title="2.1.2 enqueueConcurrentClassUpdate"></a>2.1.2 enqueueConcurrentClassUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueConcurrentClassUpdate</span>(<span class="params">fiber, sharedQueue, update, lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> interleaved = sharedQueue.interleaved;</span><br><span class="line">  <span class="comment">// 第一个update对象入队</span></span><br><span class="line">  <span class="keyword">if</span> (interleaved === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.next = update;</span><br><span class="line">    pushConcurrentUpdateQueue(sharedQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他的update对象入队</span></span><br><span class="line">    update.next = interleaved.next;</span><br><span class="line">    interleaved.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  sharedQueue.interleaved = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>enqueueSetState</code> 方法中，这个方法最后会调用 <code>scheduleUpdateOnFiber</code> 函数进入更新的调度程序。</p>
<h3 id="2-2-performSyncWorkOnRoot"><a href="#2-2-performSyncWorkOnRoot" class="headerlink" title="2.2 performSyncWorkOnRoot"></a>2.2 performSyncWorkOnRoot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">performSyncWorkOnRoot</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Should not already be working.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> didFlushPassiveEffects = flushPassiveEffects();</span><br><span class="line">  <span class="keyword">if</span> (didFlushPassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// If passive effects were flushed, exit to the outer work loop in the root</span></span><br><span class="line">    <span class="comment">// scheduler, so we can recompute the priority.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We don't actually need this `ensureRootIsScheduled` call because</span></span><br><span class="line">    <span class="comment">// this path is only reachable if the root is already part of the schedule.</span></span><br><span class="line">    <span class="comment">// I'm including it only for consistency with the other exit points from</span></span><br><span class="line">    <span class="comment">// this function. Can address in a subsequent refactor.</span></span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; enableProfilerNestedUpdatePhase) &#123;</span><br><span class="line">    syncNestedUpdateFlag();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// * setState</span></span><br><span class="line">  <span class="comment">// !1. render阶段</span></span><br><span class="line">  <span class="keyword">let</span> exitStatus = renderRootSync(root, lanes);</span><br><span class="line">  <span class="keyword">if</span> (root.tag !== LegacyRoot &amp;&amp; exitStatus === RootErrored) &#123;</span><br><span class="line">    <span class="comment">// If something threw an error, try rendering one more time. We'll render</span></span><br><span class="line">    <span class="comment">// synchronously to block concurrent data mutations, and we'll includes</span></span><br><span class="line">    <span class="comment">// all pending updates are included. If it still fails after the second</span></span><br><span class="line">    <span class="comment">// attempt, we'll give up and commit the resulting tree.</span></span><br><span class="line">    <span class="keyword">const</span> originallyAttemptedLanes = lanes;</span><br><span class="line">    <span class="keyword">const</span> errorRetryLanes = getLanesToRetrySynchronouslyOnError(</span><br><span class="line">      root,</span><br><span class="line">      originallyAttemptedLanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (errorRetryLanes !== NoLanes) &#123;</span><br><span class="line">      lanes = errorRetryLanes;</span><br><span class="line">      exitStatus = recoverFromConcurrentError(</span><br><span class="line">        root,</span><br><span class="line">        originallyAttemptedLanes,</span><br><span class="line">        errorRetryLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootFatalErrored) &#123;</span><br><span class="line">    <span class="keyword">const</span> fatalError = workInProgressRootFatalError;</span><br><span class="line">    prepareFreshStack(root, NoLanes);</span><br><span class="line">    markRootSuspended(root, lanes, NoLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">throw</span> fatalError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exitStatus === RootDidNotComplete) &#123;</span><br><span class="line">    <span class="comment">// The render unwound without completing the tree. This happens in special</span></span><br><span class="line">    <span class="comment">// cases where need to exit the current render without producing a</span></span><br><span class="line">    <span class="comment">// consistent tree or committing.</span></span><br><span class="line">    markRootSuspended(root, lanes, workInProgressDeferredLane);</span><br><span class="line">    ensureRootIsScheduled(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We now have a consistent tree. Because this is a sync render, we</span></span><br><span class="line">  <span class="comment">// will commit it even if something suspended.</span></span><br><span class="line">  <span class="keyword">const</span> finishedWork: Fiber = (root.current.alternate: any);</span><br><span class="line">  root.finishedWork = finishedWork;</span><br><span class="line">  root.finishedLanes = lanes;</span><br><span class="line">  <span class="comment">// ! 2. commit阶段</span></span><br><span class="line">  commitRoot(</span><br><span class="line">    root,</span><br><span class="line">    workInProgressRootRecoverableErrors,</span><br><span class="line">    workInProgressTransitions,</span><br><span class="line">    workInProgressRootDidIncludeRecursiveRenderUpdate,</span><br><span class="line">    workInProgressDeferredLane,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before exiting, make sure there's a callback scheduled for the next</span></span><br><span class="line">  <span class="comment">// pending level.</span></span><br><span class="line">  ensureRootIsScheduled(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-updateClassInstance"><a href="#2-3-updateClassInstance" class="headerlink" title="2.3 updateClassInstance"></a>2.3 updateClassInstance</h3><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassComponent.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateClassInstance</code> 方法里面的内容比较多，我们分成以下几个部分来分析</p>
<h4 id="2-3-1-根据updateQueue计算state"><a href="#2-3-1-根据updateQueue计算state" class="headerlink" title="2.3.1 根据updateQueue计算state"></a>2.3.1 根据updateQueue计算state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出组件实例</span></span><br><span class="line"><span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"># 从旧节点上克隆updateQueue信息，包含了shared.pending中等待处理的更新操作</span><br><span class="line">cloneUpdateQueue(current, workInProgress);</span><br><span class="line"><span class="comment">// 旧的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedOldProps = workInProgress.memoizedProps;</span><br><span class="line"><span class="keyword">const</span> oldProps =</span><br><span class="line">  workInProgress.type === workInProgress.elementType</span><br><span class="line">    ? unresolvedOldProps</span><br><span class="line">    : resolveDefaultProps(workInProgress.type, unresolvedOldProps);</span><br><span class="line">instance.props = oldProps;</span><br><span class="line"><span class="comment">// 新的props</span></span><br><span class="line"><span class="keyword">const</span> unresolvedNewProps = workInProgress.pendingProps;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line"><span class="keyword">const</span> hasNewLifecycles =</span><br><span class="line">  <span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span> ||</span><br><span class="line">  <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出旧的数据</span></span><br><span class="line"><span class="keyword">const</span> oldState = workInProgress.memoizedState;</span><br><span class="line"><span class="keyword">let</span> newState = (instance.state = oldState);</span><br><span class="line"># 更新组件实例的数据</span><br><span class="line">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span><br><span class="line">newState = workInProgress.memoizedState;</span><br></pre></td></tr></table></figure>
<p>首先处理之前的 <code>updateQueue</code> 信息：</p>
<p>这里就是将 <code>current</code> 节点中的 <code>updateQueue</code> 信息克隆到 <code>workInProgress</code> 节点中对应的属性中。<br><strong>注意：</strong>react应用每次更新都会执行Fiber Reconciler流程【即FiberTree的创建流程】，在进入此流程之前，current节点会存储本次更新相关的一些信息，但是在进入此流程之后，current就变成了旧的节点，workInProgress代表新建的节点，此时就需要将current节点上的一些信息保存到新的节点之中，也就是对应的workInProgress。</p>
<p>从class类中取出 <code>getDerivedStateFromProps</code> 钩子，判断当前类组件有没有使用此钩子，如果没有使用则设置变量 <code>hasNewLifecycles</code> 为 <code>false</code>，此变量的作用是后续判断其他生命周期钩子的执行与否。</p>
<p>下面开始对state的处理：</p>
<ol>
<li>首先取出旧的state数据：</li>
<li>重点：调用processUpdateQueue方法，根据updateQueue信息，计算生成新的state数据。</li>
</ol>
<h5 id="2-3-1-1-processUpdateQueue"><a href="#2-3-1-1-processUpdateQueue" class="headerlink" title="2.3.1.1 processUpdateQueue"></a>2.3.1.1 processUpdateQueue</h5><p><font color=gray><em>packages/react-reconciler/src/ReactFiberClassUpdateQueue.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  didReadFromEntangledAsyncAction = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is always non-null on a ClassComponent or HostRoot</span></span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = (workInProgress.updateQueue: any);</span><br><span class="line"></span><br><span class="line">  hasForceUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> firstBaseUpdate = queue.firstBaseUpdate;</span><br><span class="line">  <span class="keyword">let</span> lastBaseUpdate = queue.lastBaseUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if there are pending updates. If so, transfer them to the base queue.</span></span><br><span class="line">  <span class="comment">// *1. 检查是否有pending update。如果有，需要将它们剪开环型链表，合并到 baseQueue。</span></span><br><span class="line">  <span class="comment">// pending update是个单向循环链表，转移到 单链表 firstBaseUpdate-&gt;...-&gt;lastBaseUpdate 中去</span></span><br><span class="line">  <span class="comment">// ! 这里注意pending update不同于baseQueue，pending update只记录了尾节点</span></span><br><span class="line">  <span class="keyword">let</span> pendingQueue = queue.shared.pending;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ? sy</span></span><br><span class="line">    queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pending queue is circular. Disconnect the pointer between first</span></span><br><span class="line">    <span class="comment">// and last so that it's non-circular.</span></span><br><span class="line">    <span class="comment">// ! 这里的 pendingQueue 是在 finishQueueingConcurrentUpdates 函数中构建的单向循环链表</span></span><br><span class="line">    <span class="keyword">const</span> lastPendingUpdate = pendingQueue; <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">const</span> firstPendingUpdate = lastPendingUpdate.next; <span class="comment">// 头结点</span></span><br><span class="line">    lastPendingUpdate.next = <span class="literal">null</span>; <span class="comment">// 断开循环链表</span></span><br><span class="line">    <span class="comment">// Append pending updates to base queue</span></span><br><span class="line">    <span class="comment">// 把pending update转移到base queue上</span></span><br><span class="line">    <span class="comment">// ! 接下来构建单链表 firstBaseUpdate-&gt;...-&gt;lastBaseUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (lastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// base queue是空的，那么firstPendingUpdate就是头节点firstBaseUpdate</span></span><br><span class="line">      firstBaseUpdate = firstPendingUpdate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则往这个尾节点后继续加</span></span><br><span class="line">      lastBaseUpdate.next = firstPendingUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新尾节点, 将 lastBaseUpdate 赋值为 lastPendingUpdate</span></span><br><span class="line">    <span class="comment">// 此时已经形成了 以 firstBaseUpdate 为头以 lastBaseUpdate 为尾的新链表</span></span><br><span class="line">    <span class="comment">// 也即为本次需要处理的 update 链表</span></span><br><span class="line">    lastBaseUpdate = lastPendingUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there's a current queue, and it's different from the base queue, then</span></span><br><span class="line">    <span class="comment">// we need to transfer the updates to that queue, too. Because the base</span></span><br><span class="line">    <span class="comment">// queue is a singly-linked list with no cycles, we can append to both</span></span><br><span class="line">    <span class="comment">// lists and take advantage of structural sharing.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Pass `current` as argument</span></span><br><span class="line">    <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line">    <span class="comment">// 如果有current queue，并且它和base queue不同，那么我们也需要把更新转移到那个queue上。</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is always non-null on a ClassComponent or HostRoot</span></span><br><span class="line">      <span class="comment">// 类组件和 HostRoot 的updateQueue都初始化过，所以这里不会是null</span></span><br><span class="line">      <span class="keyword">const</span> currentQueue: UpdateQueue&lt;State&gt; = (current.updateQueue: any);</span><br><span class="line">      <span class="keyword">const</span> currentLastBaseUpdate = currentQueue.lastBaseUpdate;</span><br><span class="line">      <span class="comment">// 如果current的lastBaseUpdate和baseQueue的lastBaseUpdate不同，那么把pending update转移到currentQueue上</span></span><br><span class="line">      <span class="keyword">if</span> (currentLastBaseUpdate !== lastBaseUpdate) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">          currentQueue.firstBaseUpdate = firstPendingUpdate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          currentLastBaseUpdate.next = firstPendingUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">        currentQueue.lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These values may change as we process the queue.</span></span><br><span class="line">  <span class="keyword">if</span> (firstBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// *2. 接下来要做的就是遍历queue，然后根据这些update，计算出最后的结果。</span></span><br><span class="line">    <span class="comment">// Iterate through the list of updates to compute the result.</span></span><br><span class="line">    <span class="keyword">let</span> newState = queue.baseState;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Don't need to accumulate this. Instead, we can remove renderLanes</span></span><br><span class="line">    <span class="comment">// from the original lanes.</span></span><br><span class="line">    <span class="keyword">let</span> newLanes = NoLanes;</span><br><span class="line">    <span class="comment">// 这里的 newBaseState， newFirstBaseUpdate，newLastBaseUpdate 是计算的临时变量</span></span><br><span class="line">    <span class="comment">// 实际上会用来更新 updateQueue 的 baseState, firstBaseUpdate, lastBaseUpdate</span></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newFirstBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newLastBaseUpdate: <span class="literal">null</span> | Update&lt;State&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> update: Update&lt;State&gt; = firstBaseUpdate;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// An extra OffscreenLane bit is added to updates that were made to</span></span><br><span class="line">      <span class="comment">// a hidden tree, so that we can distinguish them from updates that were</span></span><br><span class="line">      <span class="comment">// already there when the tree was hidden.</span></span><br><span class="line">      <span class="keyword">const</span> updateLane = removeLanes(update.lane, OffscreenLane);</span><br><span class="line">      <span class="keyword">const</span> isHiddenUpdate = updateLane !== update.lane;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if this update was made while the tree was hidden. If so, then</span></span><br><span class="line">      <span class="comment">// it's not a "base" update and we should disregard the extra base lanes</span></span><br><span class="line">      <span class="comment">// that were added to renderLanes when we entered the Offscreen tree.</span></span><br><span class="line">      <span class="keyword">const</span> shouldSkipUpdate = isHiddenUpdate</span><br><span class="line">        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)</span><br><span class="line">        : !isSubsetOfLanes(renderLanes, updateLane);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新优先级不满足，该 update 会被跳过</span></span><br><span class="line">      <span class="keyword">if</span> (shouldSkipUpdate) &#123;</span><br><span class="line">        <span class="comment">// ? sy-no</span></span><br><span class="line">        <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">        <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">        <span class="comment">// update/state.</span></span><br><span class="line">        <span class="keyword">const</span> clone: Update&lt;State&gt; = &#123;</span><br><span class="line">          lane: updateLane,</span><br><span class="line"></span><br><span class="line">          tag: update.tag,</span><br><span class="line">          payload: update.payload,</span><br><span class="line">          callback: update.callback,</span><br><span class="line"></span><br><span class="line">          next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">          newFirstBaseUpdate = newLastBaseUpdate = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">        newLanes = mergeLanes(newLanes, updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 该 update 更新优先级满足，本次更新不会跳过</span></span><br><span class="line">        <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if this update is part of a pending async action. If so,</span></span><br><span class="line">        <span class="comment">// we'll need to suspend until the action has finished, so that it's</span></span><br><span class="line">        <span class="comment">// batched together with future updates in the same action.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请检查此更新是否属于待处理的异步操作。如果是的话，</span></span><br><span class="line">        <span class="comment">// 我们需要暂停直到操作完成，以便将其与将来的更新一起批处理在同一操作中。</span></span><br><span class="line">        <span class="keyword">if</span> (updateLane !== NoLane &amp;&amp; updateLane === peekEntangledActionLane()) &#123;</span><br><span class="line">          didReadFromEntangledAsyncAction = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 newLastBaseUpdate 不存在，说明之前没有跳过任何 upadte 无需添加新增</span></span><br><span class="line">        <span class="comment">// 否则无论无论该 update 是否跳过都需要添加到 baseUpdate 链表之后</span></span><br><span class="line">        <span class="keyword">if</span> (newLastBaseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// ? sy-no</span></span><br><span class="line">          <span class="keyword">const</span> clone: Update&lt;State&gt; = &#123;</span><br><span class="line">            <span class="comment">// This update is going to be committed so we never want uncommit</span></span><br><span class="line">            <span class="comment">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span></span><br><span class="line">            <span class="comment">// this will never be skipped by the check above.</span></span><br><span class="line">            lane: NoLane,</span><br><span class="line"></span><br><span class="line">            tag: update.tag,</span><br><span class="line">            payload: update.payload,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When this update is rebased, we should not fire its</span></span><br><span class="line">            <span class="comment">// callback again.</span></span><br><span class="line">            callback: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this update.</span></span><br><span class="line">        <span class="comment">// 处理这个更新</span></span><br><span class="line">        newState = getStateFromUpdate(</span><br><span class="line">          workInProgress,</span><br><span class="line">          queue,</span><br><span class="line">          update,</span><br><span class="line">          newState,</span><br><span class="line">          props,</span><br><span class="line">          instance,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 类组件的setState会在这里存储</span></span><br><span class="line">        <span class="keyword">const</span> callback = update.callback;</span><br><span class="line">        <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">          workInProgress.flags |= Callback;</span><br><span class="line">          <span class="keyword">if</span> (isHiddenUpdate) &#123;</span><br><span class="line">            workInProgress.flags |= Visibility;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> callbacks = queue.callbacks;</span><br><span class="line">          <span class="keyword">if</span> (callbacks === <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.callbacks = [callback];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callbacks.push(callback);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// $FlowFixMe[incompatible-type] we bail out when we get a null</span></span><br><span class="line">      <span class="comment">// 下一个update</span></span><br><span class="line">      update = update.next;</span><br><span class="line">      <span class="keyword">if</span> (update === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经到达尾节点，所有update被处理完毕，暂停循环</span></span><br><span class="line">        pendingQueue = queue.shared.pending;</span><br><span class="line">        <span class="comment">// 这里与函数组件有所不同，当setState套setState时候，虽然这种情况都会加入到.pending中</span></span><br><span class="line">        <span class="comment">// 但是class组件会在最后判断，如有就继续执行</span></span><br><span class="line">        <span class="comment">// 而函数组件添加时dispatchSetState会走enqueueRenderPhaseUpdate添加任务，不会走scheduleUpdateOnFiber这个分支，在renderWithHooks中Component()执行结束后会走renderWithHooksAgain，再次执行一遍组件</span></span><br><span class="line">        <span class="comment">// this.setState((prevState, props) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//   this.setState(&#123; count: 100 &#125;)</span></span><br><span class="line">        <span class="comment">//   return &#123;</span></span><br><span class="line">        <span class="comment">//     count: prevState.count + 1,</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        <span class="keyword">if</span> (pendingQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// An update was scheduled from inside a reducer. Add the new</span></span><br><span class="line">          <span class="comment">// pending updates to the end of the list and keep processing.</span></span><br><span class="line">          <span class="comment">// 已经计划在 reducer 内部进行更新。将新的待处理更新添加到列表末尾并继续处理。</span></span><br><span class="line">          <span class="keyword">const</span> lastPendingUpdate = pendingQueue;</span><br><span class="line">          <span class="comment">// Intentionally unsound. Pending updates form a circular list, but we</span></span><br><span class="line">          <span class="comment">// unravel them when transferring them to the base queue.</span></span><br><span class="line">          <span class="keyword">const</span> firstPendingUpdate =</span><br><span class="line">            ((lastPendingUpdate.next: any): Update&lt;State&gt;);</span><br><span class="line">          lastPendingUpdate.next = <span class="literal">null</span>;</span><br><span class="line">          update = firstPendingUpdate;</span><br><span class="line">          queue.lastBaseUpdate = lastPendingUpdate;</span><br><span class="line">          queue.shared.pending = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 updateQueue 的 baseState，firstBaseUpdate， lastBaseUpdate 三个属性</span></span><br><span class="line">    queue.baseState = ((newBaseState: any): State);</span><br><span class="line">    queue.firstBaseUpdate = newFirstBaseUpdate;</span><br><span class="line">    queue.lastBaseUpdate = newLastBaseUpdate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// `queue.lanes` is used for entangling transitions. We can set it back to</span></span><br><span class="line">      <span class="comment">// zero once the queue is empty.</span></span><br><span class="line">      <span class="comment">// 当多个transitions在同一个queue中时，只允许最近的一个完成。我们不应该显示中间状态。</span></span><br><span class="line">      <span class="comment">// 当queue为空，我们将queue.lanes设置回0</span></span><br><span class="line">      queue.shared.lanes = NoLanes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span></span><br><span class="line">    <span class="comment">// This should be fine because the only two other things that contribute to</span></span><br><span class="line">    <span class="comment">// expiration time are props and context. We're already in the middle of the</span></span><br><span class="line">    <span class="comment">// begin phase by the time we start processing the queue, so we've already</span></span><br><span class="line">    <span class="comment">// dealt with the props. Context in components that specify</span></span><br><span class="line">    <span class="comment">// shouldComponentUpdate is tricky; but we'll have to account for</span></span><br><span class="line">    <span class="comment">// that regardless.</span></span><br><span class="line">    <span class="comment">// 把跳过的update的lane记录下来</span></span><br><span class="line">    markSkippedUpdateLanes(newLanes);</span><br><span class="line">    workInProgress.lanes = newLanes;</span><br><span class="line">    workInProgress.memoizedState = newState; <span class="comment">// 更新状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-调用getDerivedStateFromProps钩子"><a href="#2-3-2-调用getDerivedStateFromProps钩子" class="headerlink" title="2.3.2 调用getDerivedStateFromProps钩子"></a>2.3.2 调用getDerivedStateFromProps钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用getDerivedStateFromProps钩子</span></span><br><span class="line">  applyDerivedStateFromProps(</span><br><span class="line">    workInProgress,</span><br><span class="line">    ctor,</span><br><span class="line">    getDerivedStateFromProps,</span><br><span class="line">    newProps,</span><br><span class="line">  );</span><br><span class="line">  newState = workInProgress.memoizedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>getDerivedStateFromProps</code> 钩子函数，则在此触发此回调。</p>
<h4 id="2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新"><a href="#2-3-3-调用shouldComponentUpdate钩子，检查组件是否应该更新" class="headerlink" title="2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新"></a>2.3.3 调用shouldComponentUpdate钩子，检查组件是否应该更新</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldUpdate =</span><br><span class="line">    <span class="comment">// 检查是否为强制更新</span></span><br><span class="line">    checkHasForceUpdateAfterProcessing() ||</span><br><span class="line">    <span class="comment">// 调用shouldComponentUpdate钩子，检查是否应该更新</span></span><br><span class="line">    checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)</span><br></pre></td></tr></table></figure>


<h5 id="2-3-3-1-checkHasForceUpdateAfterProcessing"><a href="#2-3-3-1-checkHasForceUpdateAfterProcessing" class="headerlink" title="2.3.3.1 checkHasForceUpdateAfterProcessing"></a>2.3.3.1 checkHasForceUpdateAfterProcessing</h5><p><code>checkHasForceUpdateAfterProcessing</code> 方法返回一个变量的状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">checkHasForceUpdateAfterProcessing</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasForceUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasForceUpdate</code> 是一个全局变量，它默认为 <code>false</code> ，表示非强制更新，它的修改就在之前计算state的逻辑中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newState = getStateFromUpdate(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStateFromUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (update.tag) &#123;</span><br><span class="line">		<span class="keyword">case</span> ReplaceState: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> CaptureUpdate: &#123;&#125;</span><br><span class="line">		<span class="keyword">case</span> UpdateState: &#123;&#125;</span><br><span class="line">		<span class="comment">// 强制更新 场景</span></span><br><span class="line">		<span class="keyword">case</span> ForceUpdate: &#123;</span><br><span class="line">      		hasForceUpdate = <span class="literal">true</span>;</span><br><span class="line">      		<span class="keyword">return</span> prevState;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为 <code>this.forceUpdate</code> 触发的场景，就会进入 <code>ForceUpdate</code> 分支，更新变量 <code>hasForceUpdate</code> 的值为 <code>true</code>。</p>
<p>这时在校验组件是否应该更新时，就会返回 <code>true</code>，代表组件需要更新。</p>
<p>而我们当前是通过 <code>this.setState</code> 修改数据触发的更新，所以当前 <code>hasForceUpdate</code> 是为 <code>false</code> 的，这也是绝大部分类组件更新的场景。</p>
<h5 id="2-3-3-2-checkShouldComponentUpdate"><a href="#2-3-3-2-checkShouldComponentUpdate" class="headerlink" title="2.3.3.2 checkShouldComponentUpdate"></a>2.3.3.2 checkShouldComponentUpdate</h5><p>查看 <code>checkShouldComponentUpdate</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkShouldComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  ctor,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldState,</span></span></span><br><span class="line"><span class="function"><span class="params">  newState,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.shouldComponentUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      nextContext,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对PureComponent纯组件的 内部校验</span></span><br><span class="line">  <span class="keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkShouldComponentUpdate</code> 方法也比较简单，主要就是调用一次我们定义的 <code>shouldComponentUpdate</code> 钩子，根据调用的返回值来决定类组件是否应该更新，如果我们没有使用 <code>shouldComponentUpdate</code> 钩子，则类组件是默认需要更新的。</p>
<p>同时在这里我们还可以发现有一个针对 <code>PureComponent</code> 纯组件的更新校验，这其实就是 <code>PureComponent</code> 和 <code>Component</code> 唯一的区别，纯组件 <code>PureComponent</code>在react内部自动帮助我们对 <code>props</code> 和 <code>state</code> 进行了浅比较，任何一个变化则返回 <code>true</code>，需要更新组件。</p>
<h4 id="2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"><a href="#2-3-4-为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记" class="headerlink" title="2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记"></a>2.3.4 为组件Fiber的flags属性设置componentDidUpdate和getSnapshotBeforeUpdate副作用标记</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 执行componentWillUpdate钩子</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentWillUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	instance.componentWillUpdate(newProps, newState, nextContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新flags标记</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Update;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">	workInProgress.flags |= Snapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类组件定义了 <code>componentWillUpdate</code> 生命周期钩子函数，则会在此处调用此函数。</p>
<p>然后如果类组件定义了 <code>componentDidUpdate</code> 或者 <code>getSnapshotBeforeUpdate</code> 生命周期钩子函数，就会更新组件 <code>Fiber</code> 的 <code>flags</code> 副作用标记。</p>
<p>这些生命周期钩子会在commit阶段，真实DOM渲染完成之后，被触发执行。</p>
<p>最后同步更新组件实例instance的props和state：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance.props = newProps;</span><br><span class="line">instance.state = newState;</span><br></pre></td></tr></table></figure>

<p>到此，一个类组件的更新程序基本执行完成。</p>
<h3 id="2-4-commit阶段"><a href="#2-4-commit阶段" class="headerlink" title="2.4 commit阶段"></a>2.4 commit阶段</h3><p>前面全部的加载逻辑都是在Fiber Reconciler协调流程中执行的，即类组件大部分的加载或者更新逻辑都是在reconciler协调流程中完成的，还有剩下的一部分逻辑在commit阶段之中处理。</p>
<p>对于类组件的更新来说，在commit阶段主要还有以下两部分逻辑需要处理：</p>
<ol>
<li>执行类组件的 <code>componentDidUpdate</code> 生命周期钩子函数。</li>
<li>执行 <code>this.setState</code> 方法传入的回调函数。</li>
</ol>
<p><font color=gray><em>packages/react-reconciler/src/ReactFiberCommitWork.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffectOnFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((finishedWork.flags &amp; LayoutMask) !== NoFlags) &#123;</span><br><span class="line">    <span class="comment">// 根据组件类型：进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 类组件的处理</span></span><br><span class="line">      <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">        <span class="comment">// 组件实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (finishedWork.flags &amp; Update) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">			  <span class="comment">// mount加载阶段</span></span><br><span class="line"></span><br><span class="line">              # 触发componentDidMount 生命周期钩子函数【这类静态方法：是存储在instance对象原型上的】</span><br><span class="line">              instance.componentDidMount();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// update更新阶段</span></span><br><span class="line">              <span class="keyword">const</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps</span><br><span class="line">                  : resolveDefaultProps( finishedWork.type, current.memoizedProps);</span><br><span class="line">              <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">			  # 触发componentDidUpdate 生命周期钩子函数</span><br><span class="line">              instance.componentDidUpdate( prevProps,prevState,</span><br><span class="line">                  instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 取出当前组件节点的updateQueue更新对象</span><br><span class="line">        <span class="keyword">const</span> updateQueue: UpdateQueue = finishedWork.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 触发更新</span></span><br><span class="line">          commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishedWork代表当前处理的类组件Fiber节点，首先从fiber.stateNode属性中取出组件实例instance。然后根据进行判断，只有存在相关的副作用标记才会继续内部的逻辑：</p>
<p>然后判断current是否为null，current表示旧的虚拟DOM节点，在组件的更新阶段，它肯定是存在的。然后直接调用 <code>componentDidUpdate</code> 生命周期钩子函数即可。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>类组件的更新逻辑主要内容是以下两点：</p>
<ol>
<li><code>reconciler</code> 协调流程中循环 <code>update</code> 链表计算出最新的 <code>state</code>。</li>
<li><code>commit</code> 阶段中触发 <code>componentDidUpdate</code> 生命周期钩子函数以及循环执行 <code>this.setState</code> 的回调。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">react18.2调度器scheduler源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-15T00:00:00+08:00">2024-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心算法-最小堆"><a href="#核心算法-最小堆" class="headerlink" title="核心算法 - 最小堆"></a>核心算法 - 最小堆</h2><p><font color=gray><em>packages\scheduler\src\SchedulerMinHeap.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">type Heap&lt;T: Node&gt; = <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">type Node = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = heap.length;</span><br><span class="line">  heap.push(node);</span><br><span class="line">  siftUp(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">peek</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heap.length === <span class="number">0</span> ? <span class="literal">null</span> : heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (heap.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> last = heap.pop();</span><br><span class="line">  <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">    heap[<span class="number">0</span>] = last;</span><br><span class="line">    siftDown(heap, last, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftUp</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> parent = heap[parentIndex];</span><br><span class="line">    <span class="keyword">if</span> (compare(parent, node) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// The parent is larger. Swap positions.</span></span><br><span class="line">      heap[parentIndex] = node;</span><br><span class="line">      heap[index] = parent;</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The parent is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftDown</span>&lt;<span class="title">T</span>: <span class="title">Node</span>&gt;(<span class="params">heap: Heap&lt;T&gt;, node: T, i: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">const</span> length = heap.length;</span><br><span class="line">  <span class="keyword">const</span> halfLength = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; halfLength) &#123;</span><br><span class="line">    <span class="keyword">const</span> leftIndex = (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = heap[leftIndex];</span><br><span class="line">    <span class="keyword">const</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> right = heap[rightIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the left or right node is smaller, swap with the smaller of those.</span></span><br><span class="line">    <span class="keyword">if</span> (compare(left, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        heap[index] = right;</span><br><span class="line">        heap[rightIndex] = node;</span><br><span class="line">        index = rightIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap[index] = left;</span><br><span class="line">        heap[leftIndex] = node;</span><br><span class="line">        index = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[index] = right;</span><br><span class="line">      heap[rightIndex] = node;</span><br><span class="line">      index = rightIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a: Node, b: Node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Compare sort index first, then task id.</span></span><br><span class="line">  <span class="keyword">const</span> diff = a.sortIndex - b.sortIndex;</span><br><span class="line">  <span class="keyword">return</span> diff !== <span class="number">0</span> ? diff : a.id - b.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h2><p>通过调用 <code>scheduleCallback</code> 方法进入调度器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newCallbackNode = scheduleCallback(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从下面开始，我们将深入scheduler的源码：</p>
<h3 id="1-定义全局变量"><a href="#1-定义全局变量" class="headerlink" title="1. 定义全局变量"></a>1. 定义全局变量</h3><p><font color=gray><em>packages\scheduler\src\forks\Scheduler.js</em></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;push, pop, peek&#125; <span class="keyword">from</span> <span class="string">'../SchedulerMinHeap'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerPriorities'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  enableIsInputPending,</span><br><span class="line">  enableIsInputPendingContinuous,</span><br><span class="line">  frameYieldMs,</span><br><span class="line">  continuousYieldMs,</span><br><span class="line">  maxYieldMs,</span><br><span class="line">  userBlockingPriorityTimeout,</span><br><span class="line">  lowPriorityTimeout,</span><br><span class="line">  normalPriorityTimeout,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerFeatureFlags'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  markTaskRun,</span><br><span class="line">  markTaskYield,</span><br><span class="line">  markTaskCompleted,</span><br><span class="line">  markTaskCanceled,</span><br><span class="line">  markTaskErrored,</span><br><span class="line">  markSchedulerSuspended,</span><br><span class="line">  markSchedulerUnsuspended,</span><br><span class="line">  markTaskStart,</span><br><span class="line">  stopLoggingProfilingEvents,</span><br><span class="line">  startLoggingProfilingEvents,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../SchedulerProfiling'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Callback = <span class="function"><span class="params">boolean</span> =&gt;</span> ?Callback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> opaque type Task = &#123;</span><br><span class="line">  id: number,</span><br><span class="line">  callback: Callback | <span class="literal">null</span>,</span><br><span class="line">  priorityLevel: PriorityLevel,</span><br><span class="line">  startTime: number,</span><br><span class="line">  expirationTime: number,</span><br><span class="line">  sortIndex: number,</span><br><span class="line">  isQueued?: boolean,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间，通过performance或者Date</span></span><br><span class="line"><span class="keyword">let</span> getCurrentTime: <span class="function"><span class="params">()</span> =&gt;</span> number | DOMHighResTimeStamp;</span><br><span class="line"><span class="keyword">const</span> hasPerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> performance.now === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasPerformanceNow) &#123;</span><br><span class="line">  <span class="keyword">const</span> localPerformance = performance;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localPerformance.now();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> localDate = <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">const</span> initialTime = localDate.now();</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> localDate.now() - initialTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tasks are stored on a min heap</span></span><br><span class="line"><span class="keyword">var</span> taskQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 没有延迟的任务</span></span><br><span class="line"><span class="keyword">var</span> timerQueue: <span class="built_in">Array</span>&lt;Task&gt; = []; <span class="comment">// 有延迟的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自增id，标记task唯一性</span></span><br><span class="line"><span class="comment">// Incrementing id counter. Used to maintain insertion order.</span></span><br><span class="line"><span class="keyword">var</span> taskIdCounter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line"><span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentTask = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> currentPriorityLevel = NormalPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="comment">// 是否有work在执行</span></span><br><span class="line"><span class="comment">// This is set while performing work, to prevent re-entrance.</span></span><br><span class="line"><span class="keyword">var</span> isPerformingWork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程是否在调度</span></span><br><span class="line"><span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有任务在倒计时</span></span><br><span class="line"><span class="keyword">var</span> isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taskTimeoutID: TimeoutID = (<span class="number">-1</span>: any);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> needsPaint = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capture local references to native APIs, in case a polyfill overrides them.</span></span><br><span class="line"><span class="keyword">const</span> localSetTimeout = <span class="keyword">typeof</span> setTimeout === <span class="string">'function'</span> ? setTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localClearTimeout =</span><br><span class="line">  <span class="keyword">typeof</span> clearTimeout === <span class="string">'function'</span> ? clearTimeout : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localSetImmediate =</span><br><span class="line">  <span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> ? setImmediate : <span class="literal">null</span>; <span class="comment">// IE and Node.js + jsdom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前是否有所有类型的输入事件，包括按键、鼠标、滚轮触控等DOM UI事件</span></span><br><span class="line"><span class="keyword">const</span> isInputPending =</span><br><span class="line">  <span class="keyword">typeof</span> navigator !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[prop-missing]</span></span><br><span class="line">  navigator.scheduling !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// $FlowFixMe[incompatible-type]</span></span><br><span class="line">  navigator.scheduling.isInputPending !== <span class="literal">undefined</span></span><br><span class="line">    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否应该把控制权交换给主线程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldYieldToHost</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前程序运行时间</span></span><br><span class="line">  <span class="keyword">const</span> timeElapsed = getCurrentTime() - startTime;</span><br><span class="line">  <span class="comment">// 如果运行时间小于帧间隔时间5ms</span></span><br><span class="line">  <span class="keyword">if</span> (timeElapsed &lt; frameInterval) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main thread has been blocked for a non-negligible amount of time. We</span></span><br><span class="line">  <span class="comment">// may want to yield control of the main thread, so the browser can perform</span></span><br><span class="line">  <span class="comment">// high priority tasks. The main ones are painting and user input. If there's</span></span><br><span class="line">  <span class="comment">// a pending paint or a pending input, then we should yield. But if there's</span></span><br><span class="line">  <span class="comment">// neither, then we can yield less often while remaining responsive. We'll</span></span><br><span class="line">  <span class="comment">// eventually yield regardless, since there could be a pending paint that</span></span><br><span class="line">  <span class="comment">// wasn't accompanied by a call to `requestPaint`, or other main thread tasks</span></span><br><span class="line">  <span class="comment">// like network events.</span></span><br><span class="line">  <span class="keyword">if</span> (enableIsInputPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needsPaint) &#123;</span><br><span class="line">      <span class="comment">// There's a pending paint (signaled by `requestPaint`). Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeElapsed &lt; continuousInputInterval) &#123;</span><br><span class="line">      <span class="comment">// We haven't blocked the thread for that long. Only yield if there's a</span></span><br><span class="line">      <span class="comment">// pending discrete input (e.g. click). It's OK if there's pending</span></span><br><span class="line">      <span class="comment">// continuous input (e.g. mouseover).</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeElapsed &lt; maxInterval) &#123;</span><br><span class="line">      <span class="comment">// Yield if there's either a pending discrete or continuous input.</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isInputPending(continuousOptions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We've blocked the thread for a long time. Even if there's no pending</span></span><br><span class="line">      <span class="comment">// input, there may be some other scheduled work that we don't know about,</span></span><br><span class="line">      <span class="comment">// like a network event. Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `isInputPending` isn't available. Yield now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-根据环境设置生成宏任务调度函数"><a href="#2-根据环境设置生成宏任务调度函数" class="headerlink" title="2. 根据环境设置生成宏任务调度函数"></a>2. 根据环境设置生成宏任务调度函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE.</span></span><br><span class="line">  <span class="comment">// There's a few reasons for why we prefer setImmediate.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span></span><br><span class="line">  <span class="comment">// (Even though this is a DOM fork of the Scheduler, you could get here</span></span><br><span class="line">  <span class="comment">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// But also, it runs earlier which is the semantic we want.</span></span><br><span class="line">  <span class="comment">// If other browsers ever implement it, it's better to use it.</span></span><br><span class="line">  <span class="comment">// Although both of these would be inferior to native scheduling.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetImmediate(performWorkUntilDeadline);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetTimeout(performWorkUntilDeadline, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-任务调度器的入口函数"><a href="#3-任务调度器的入口函数" class="headerlink" title="3. 任务调度器的入口函数"></a>3. 任务调度器的入口函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务调度器的入口函数：并发模式下调度一个回调函数 【这里传入的callback就是performConcurrentWorkOnRoot】</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  priorityLevel: PriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: Callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: &#123;delay: number&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime(); <span class="comment">// 获取当前程序执行时间，performance.now()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime; <span class="comment">// 定义任务开始时间，不是执行时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'object'</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">'number'</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在延期，则开始时间 = 当前时间 + 延期时间</span></span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，开始时间 = 当前时间</span></span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开始时间直接等于currentTime</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义超时时间 【根据优先级，设置不同的超时时间】</span></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      <span class="comment">// Times out immediately，立即超时</span></span><br><span class="line">      timeout = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = userBlockingPriorityTimeout; <span class="comment">// 250</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="comment">// Never times out，永不超时</span></span><br><span class="line">      timeout = maxSigned31BitInt; <span class="comment">// Math.pow(2, 30) - 1， 最大的31位整数。V8中32位系统的最大整数。</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = lowPriorityTimeout; <span class="comment">// 10000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Eventually times out，最终超时</span></span><br><span class="line">      timeout = normalPriorityTimeout; <span class="comment">// 5000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过期时间，也是理论上的任务执行时间，值越小，说明优先级越高，需要优先执行</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newTask: Task = &#123;</span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,</span><br><span class="line">    expirationTime,</span><br><span class="line">    sortIndex: <span class="number">-1</span>, <span class="comment">// 调度执行任务的依据</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始时间 大于当前时间：说明是延期任务，先加入到延时队列timerQueue</span></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// 有delay的任务</span></span><br><span class="line">    newTask.sortIndex = startTime; <span class="comment">// sortIndex是把任务从timerQueue中取出来放到taskQueue中的依据</span></span><br><span class="line">    push(timerQueue, newTask); <span class="comment">// 暂时存到timerQueue，等晚点到了执行时间，再放到taskQueue，再执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">      <span class="comment">// 所有任务都延迟了，而这是延迟时间最短的任务。</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">        <span class="comment">// 取消现有的setTimeout</span></span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule a timeout.</span></span><br><span class="line">      <span class="comment">// setTimeout</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有delay的任务，直接加入任务队列</span></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line">    <span class="comment">// Schedule a host callback, if needed. If we're already performing work,</span></span><br><span class="line">    <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">    <span class="comment">// 如果需要的话，调度一个HostCallback。如果我们已经在执行work，就等到下次我们让出控制权的时候。</span></span><br><span class="line">    <span class="comment">// 判断host回调任务是否已经被调度，以及是否正在工作中，只有host回调任务还没有被调度 且 当前并未在工作中；才会开启一个新的host回调任务</span></span><br><span class="line">    <span class="comment">// 【首次加载时，需要调度一个host回调任务】</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 设置host回调任务，触发localSetImmediate、MessageChannel或localSetTimeout，生成新的宏任务，在宏任务中执行工作循环workLoop</span></span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-调度异步执行，创建新的宏任务"><a href="#4-调度异步执行，创建新的宏任务" class="headerlink" title="4. 调度异步执行，创建新的宏任务"></a>4. 调度异步执行，创建新的宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 调度异步执行，创建新的宏任务</span></span><br><span class="line">    schedulePerformWorkUntilDeadline();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-异步执行宏任务"><a href="#5-异步执行宏任务" class="headerlink" title="5. 异步执行宏任务"></a>5. 异步执行宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在有效时间内执行工作</span></span><br><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line">    <span class="comment">// Keep track of the start time so we can measure how long the main thread</span></span><br><span class="line">    <span class="comment">// has been blocked.</span></span><br><span class="line">    <span class="comment">// 记录了一个work的起始时间，其实就是一个时间切片的起始时间，是个时间戳</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a scheduler task throws, exit the current browser task so the</span></span><br><span class="line">    <span class="comment">// error can be observed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Intentionally not using a try-catch, since that makes some debugging</span></span><br><span class="line">    <span class="comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span></span><br><span class="line">    <span class="comment">// remain true, and we'll continue the work loop.</span></span><br><span class="line">    <span class="keyword">let</span> hasMoreWork = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据返回判断是否还有工作</span></span><br><span class="line">      hasMoreWork = flushWork(currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">        <span class="comment">// 如果还有任务,则又触发调度宏任务事件，生成新的宏任务，即在下一个event loop中继续执行任务</span></span><br><span class="line">        schedulePerformWorkUntilDeadline();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Yielding to the browser will give it a chance to paint, so we can</span></span><br><span class="line">  <span class="comment">// reset this.</span></span><br><span class="line">  needsPaint = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We'll need a host callback the next time work is scheduled.</span></span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">    <span class="comment">// We scheduled a timeout but it's no longer needed. Cancel it.</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    cancelHostTimeout();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isPerformingWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> workLoop(initialTime);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有很多task，每个task都有一个callback，callback执行完了，就执行下一个task</span></span><br><span class="line"><span class="comment">// 一个work就是一个时间切片内执行的一些task</span></span><br><span class="line"><span class="comment">// 时间切片要循环，就是work要循环</span></span><br><span class="line"><span class="comment">// 返回为true，表示还有任务没有执行完，需要继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">initialTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  <span class="comment">// 如果timerQueue中有*有效任务*到达执行时间，就放到taskQueue中</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line">  <span class="comment">// 从任务队列中取出队列第一个任务【注意：taskQueue中是按任务的到期时间expirationTime排序的，越小越先执行】</span></span><br><span class="line">  currentTask = peek(taskQueue);</span><br><span class="line">  <span class="comment">// 循环从taskQueue中取出任务</span></span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【重点判断】</span></span><br><span class="line"><span class="comment">     * 1，如果当前任务到期时间 大于 当前时间，说明任务还未过期</span></span><br><span class="line"><span class="comment">     * 2，shouldYieldToHost为true应该暂停</span></span><br><span class="line"><span class="comment">     * 总结：如果同时满足这两个条件，即任务还没过期，但是没有剩余可执行时间了，就应该跳出本次工作循环，</span></span><br><span class="line"><span class="comment">     * 让出主线程，交给渲染流水线，等待下一个宏任务执行task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      currentTask.callback = <span class="literal">null</span>;</span><br><span class="line">      currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">      <span class="comment">// 是否属于过期的任务，可能存在还没过期的任务。</span></span><br><span class="line">      <span class="keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span><br><span class="line">      <span class="comment">// 执行任务</span></span><br><span class="line">      <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">      currentTime = getCurrentTime();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果执行完后又返回了 function，赋值给当前任务的callback</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则的话，将当前任务移除。中断在这个位置发生，高优先任务会把低优先任务的callback置空。</span></span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTimers(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pop(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTask = peek(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Return whether there's additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回是否还有任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 说明 currentTask 执行完了</span></span><br><span class="line">    <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理 timerQueue</span></span><br><span class="line">      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler periodically yields in case there is other work on the main</span></span><br><span class="line"><span class="comment">// thread, like user events. By default, it yields multiple times per frame.</span></span><br><span class="line"><span class="comment">// It does not attempt to align with frame boundaries, since most tasks don't</span></span><br><span class="line"><span class="comment">// need to be frame aligned; for those that do, use requestAnimationFrame.</span></span><br><span class="line"><span class="keyword">let</span> frameInterval = frameYieldMs;</span><br><span class="line"><span class="keyword">const</span> continuousInputInterval = continuousYieldMs;</span><br><span class="line"><span class="keyword">const</span> maxInterval = maxYieldMs;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuousOptions = &#123;<span class="attr">includeContinuous</span>: enableIsInputPendingContinuous&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceTimers</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check for tasks that are no longer delayed and add them to the queue.</span></span><br><span class="line">  <span class="keyword">let</span> timer = peek(timerQueue);</span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 无效的任务</span></span><br><span class="line">      <span class="comment">// Timer was cancelled.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.startTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 有效的任务</span></span><br><span class="line">      <span class="comment">// 任务已到达开始时间，转入taskQueue中</span></span><br><span class="line">      <span class="comment">// Timer fired. Transfer to the task queue.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">      timer.sortIndex = timer.expirationTime;</span><br><span class="line">      push(taskQueue, timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Remaining timers are pending.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = peek(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params">currentTime: number</span>) </span>&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 把延迟任务从timerQueue中推入taskQueue</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelCallback</span>(<span class="params">task: Task</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Null out the callback to indicate the task has been canceled. (Can't</span></span><br><span class="line">  <span class="comment">// remove from the queue because you can't remove arbitrary nodes from an</span></span><br><span class="line">  <span class="comment">// array based heap, only the first one.)</span></span><br><span class="line">  task.callback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentPriorityLevel</span>(<span class="params"></span>): <span class="title">PriorityLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentPriorityLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHostTimeout</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  callback: (currentTime: number</span>) =&gt; <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">ms</span>: <span class="title">number</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  taskTimeoutID = localSetTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHostTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  localClearTimeout(taskTimeoutID);</span><br><span class="line">  taskTimeoutID = ((<span class="number">-1</span>: any): TimeoutID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ImmediatePriority,</span><br><span class="line">  UserBlockingPriority,</span><br><span class="line">  NormalPriority,</span><br><span class="line">  IdlePriority,</span><br><span class="line">  LowPriority,</span><br><span class="line">  scheduleCallback,</span><br><span class="line">  cancelCallback,</span><br><span class="line">  getCurrentPriorityLevel,</span><br><span class="line">  shouldYieldToHost <span class="keyword">as</span> unstable_shouldYield,</span><br><span class="line">  getCurrentTime,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="核心流程图"><a href="#核心流程图" class="headerlink" title="核心流程图"></a>核心流程图</h2><h3 id="1-使用了-Scheduler-任务调度的流程图（Concurrent模式）"><a href="#1-使用了-Scheduler-任务调度的流程图（Concurrent模式）" class="headerlink" title="1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）"></a>1. 使用了 Scheduler 任务调度的流程图（Concurrent模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<h3 id="2-没有使用-Scheduler-任务调度的流程图（legacy模式）"><a href="#2-没有使用-Scheduler-任务调度的流程图（legacy模式）" class="headerlink" title="2. 没有使用 Scheduler 任务调度的流程图（legacy模式）"></a>2. 没有使用 Scheduler 任务调度的流程图（legacy模式）</h3><p><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-1.png" alt="alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个比较泛的流程示例：<br><img src="../images/react%E8%B0%83%E5%BA%A6%E5%99%A8scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-2.png" alt="alt text"></p>
<ul>
<li>在 React 中宏观来看，针对浏览器、Scheduler 、Reconciler 其实是有3层 Loop。浏览器级别的 eventLoop，Scheduler 级别的 workLoop，Reconciler 级别 workLoopConcurrent 。<ul>
<li>浏览器的 eventLoop 与 Scheduler 的关系<ul>
<li>每次 eventLoop 会执行宏任务的队列的宏任务，而 React 中的 Scheduler 就是用宏任务 setImmediate等 触发的。</li>
<li>当 eventLoop 开始执行跟 Scheduler 有关的宏任务时，Scheduler 会启动一次 workLoop，就是在遍历执行 Scheduler 中已存在的 taskQueue 队列的每个 task。</li>
</ul>
</li>
<li>Scheduler 与 Reconciler 的关系<ul>
<li>Scheduler中的 workLoop 中每执行一次 task，是通过调用 Reconciler 中的 performConcurrentWorkOnRoot 方法，即每一个 task 可以理解为是一个 performConcurrentWorkOnRoot 方法的调用。</li>
<li>performConcurrentWorkOnRoot 方法每次调用，其本质是在执行 workLoopConcurrent 方法，这个方法是在循环 performUnitOfWork 这个构建 Fiber 树中每个 Fiber 的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此可以梳理出来，3个大循环，从最开始的 eventLoop 的单个宏任务执行，会逐步触发 Scheduler 和 Reconciler 的任务循环执行。</p>
<ul>
<li>任务的中断与恢复，实现中断与恢复的逻辑分了2个部分，第一个是 Scheduler 中正在执行的 workLoop 的任务中断，第二个是 Reconciler 中正在执行的 workLoopConcurrent 的任务中断<ul>
<li>Reconciler 中的任务中断与恢复：在 workLoopConcurrent 的 while 循环中，通过 shouldYield() 方法来判断当前构建 fiber 树的执行过程是否超时，如果超时，则中断当前的 while 循环。由于每次 while 执行的 fiber 构建方法，即 performUnitOfWork 是按照每个 fiberNode 来遍历的，也就是说每完成一次 fiberNode 的 beginWork + completeWork 树的构建过程，会设置下一次 nextNode 的值 ，可以理解为中断时已经保留了下一次要构建的 fiberNode 指针，以至于不会下一次不知道从哪里继续。</li>
<li>Scheduler 中的任务中断与恢复：当执行任务时间超时后，如果 Reconciler 中的 performConcurrentWorkOnRoot 方法没有执行完成，会返回其自身。在 Scheduler 中，发现当前任务还有下一个任务没有执行完，则不会将当前任务从 taskQueue 中取出，同时会把 reconciler 中返回的待执行的回调函数继续赋值给当前任务，于是下一次继续启动 Scheduler 的任务时，也就连接上了。同时退出这次中断的任务前，会通过 messageChannel 向 eventLoop 的宏任务队列放入一个新的宏任务。</li>
<li>所以任务的恢复，其实就是从下一次 eventLoop 开始执行 Scheduler 相关的宏任务，而执行的宏任务也是 Reconciler 中断前赋值的 fiberNode，也就实现了整体的任务恢复。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
