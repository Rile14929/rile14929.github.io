<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/page/3/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">vue3初始化渲染流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue3 官网中有下面这样一张图，基本展现出了 Vue3 的渲染原理：</p>
<p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<p>本文会从源码角度来简单的看一下 Vue3 的运行全流程，旨在加深对上图的理解。</p>
<h2 id="初始化渲染"><a href="#初始化渲染" class="headerlink" title="初始化渲染"></a>初始化渲染</h2><p>从下面这个很简单的使用示例开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">createApp(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="card"&gt;</span></span><br><span class="line"><span class="string">            &lt;button type="button" @click="count++"&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: ref(<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>首先调用了 <code>createApp</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以看到重点在于 <code>ensureRenderer</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rendererOptions = <span class="comment">/*#__PURE__*/</span> extend(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="comment">// 因为 ensureRenderer 是在执行 createApp 的时候调用的，如果你不执行 createApp 而只使用 vue 的一些响应式 API，就不会创建这个渲染器，所以说延时渲染。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rendererOptions</code>是一个对象，渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法。</p>
<p>这么做主要是方便跨平台，比如在其他非浏览器环境，可以替换成对应的节点操作方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rendererOptions</span></span><br><span class="line">&#123;</span><br><span class="line">  insert: <span class="function">(<span class="params">child, parent, anchor</span>) =&gt;</span> &#123;</span><br><span class="line">    parent.insertBefore(child, anchor || <span class="literal">null</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  remove: <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = child.parentNode</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      parent.removeChild(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options: RendererOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseCreateRenderer(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>baseCreateRenderer</code>, 这个函数简直可以用庞大来形容，patch、mount、diff均在这个方法中实现，回头我们再来细看实现，现在我们只需要关心他最后返回的什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RendererOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  createHydrationFns?: typeof createHydrationFunctions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略2000行</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render,</span><br><span class="line">        hydrate,</span><br><span class="line">        createApp: createAppAPI(render, hydrate),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现createApp是通过createAppAPI方法调用返回的，下面我们看createAppAPI。</p>
<h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI"></a>createAppAPI</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction&lt;HostElement&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = null</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(rootComponent)) &#123;</span><br><span class="line">      rootComponent = extend(&#123;&#125;, rootComponent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootProps != <span class="literal">null</span> &amp;&amp; !isObject(rootProps)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(<span class="string">`root props passed to app.mount() must be an object.`</span>)</span><br><span class="line">      rootProps = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context = createAppContext()</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line">      _instance: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> config() &#123;</span><br><span class="line">        <span class="keyword">return</span> context.config</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">set</span> config(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`app.config cannot be replaced. Modify individual options instead.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 都是一些眼熟的方法</span></span><br><span class="line">      <span class="comment">// 注册plugin</span></span><br><span class="line">      use(plugin: Plugin, ...options: any[]) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 全局混入</span></span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局组件</span></span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局指令</span></span><br><span class="line">      directive(name: string, directive?: Directive) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 挂载根组件</span></span><br><span class="line">      mount(</span><br><span class="line">        rootContainer: HostElement, <span class="comment">// 挂载容器</span></span><br><span class="line">        isHydrate?: boolean,</span><br><span class="line">        namespace?: boolean | ElementNamespace,</span><br><span class="line">      ): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 卸载</span></span><br><span class="line">      unmount() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 分享数据</span></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是最终的 <code>createApp</code>方法，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象。</p>
<p>所谓的应用实例app其实就是一个对象，我们传进去的组件选项作为根组件存储在_component属性上，另外还可以看到应用实例提供的一些方法，比如注册插件的use方法，挂载实例的mount方法等。</p>
<h4 id="createAppContext-实现"><a href="#createAppContext-实现" class="headerlink" title="createAppContext 实现"></a>createAppContext 实现</h4><p>context其实也是一个普通对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> any,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    optionsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    propsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    emitsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是vue的初次渲染逻辑，首先官方解构了mount方法， 然后又重写了app.mount，并调用normalizeContainer校验挂载元素，临时保存了需要渲染的内容。并对vue2的写法做了兼容处理，挂载元素进行渲染。</p>
<p>在以上整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化的技巧，很好地实现了参数保留。比如，在执行 app.mount 的时候，并不需要传入渲染器 render，这是因为在执行 createAppAPI 的时候渲染器 render 参数已经被保留下来了。</p>
<p>至此，createApp的流程大概到此结束，下一部分来分析mount挂载部分。</p>
<h3 id="mounted挂载"><a href="#mounted挂载" class="headerlink" title="mounted挂载"></a>mounted挂载</h3><h4 id="重写app-mount方法"><a href="#重写app-mount方法" class="headerlink" title="重写app.mount方法"></a>重写app.mount方法</h4><p>createApp 函数中，首先取出 app 对象中的 mount 函数，然后通过 app.mount = () =&gt; {} 对 mount 函数进行重写：</p>
<ol>
<li>首先调用 normalizeContainer 函数来获取container节点；</li>
<li>判断该节点是否存在，若不存在，则直接返回；</li>
<li>清空container的innerHTML；</li>
<li>调用mount函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)这里重写的目的是考虑到跨平台(app.mount里面只包含和平台无关的代码)</span></span><br><span class="line"><span class="comment">    (2)这些重写的代码是完善web平台下的渲染逻辑(比如其他平台也可以进行类似的重写)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  app.mount = (containerOrSelector: Element | ShadowRoot | string): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根组件容器 选择器字符串兼容</span></span><br><span class="line">    <span class="keyword">const</span> container = normalizeContainer(containerOrSelector)</span><br><span class="line">    <span class="keyword">if</span> (!container) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// rootComponent</span></span><br><span class="line">    <span class="keyword">const</span> component = app._component</span><br><span class="line">    <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">    <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      <span class="comment">// __UNSAFE__</span></span><br><span class="line">      <span class="comment">// Reason: potential execution of JS expressions in in-DOM template.</span></span><br><span class="line">      <span class="comment">// The user must make sure the in-DOM template is trusted. If it's</span></span><br><span class="line">      <span class="comment">// rendered by the server, the template should not contain any user data.</span></span><br><span class="line">      component.template = container.innerHTML</span><br><span class="line">      <span class="comment">// 2.x compat check</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * __COMPAT__ 是启动的时候通过rollup去注入进去的</span></span><br><span class="line"><span class="comment">       * 用来判断是否向下兼容</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (__COMPAT__ &amp;&amp; __DEV__) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; container.attributes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> attr = container.attributes[i]</span><br><span class="line">          <span class="keyword">if</span> (attr.name !== <span class="string">'v-cloak'</span> &amp;&amp; <span class="regexp">/^(v-|:|@)/</span>.test(attr.name)) &#123;</span><br><span class="line">            compatUtils.warnDeprecation(</span><br><span class="line">              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,</span><br><span class="line">              <span class="literal">null</span>,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear content before mounting</span></span><br><span class="line">    container.innerHTML = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 调用初始app.mount，挂载元素进行渲染</span></span><br><span class="line">    <span class="keyword">const</span> proxy = mount(container, <span class="literal">false</span>, resolveRootNamespace(container))</span><br><span class="line">    <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      <span class="comment">// vue2的话，会给#app设置一个v-cloak属性，在render的时候清空掉</span></span><br><span class="line">      container.removeAttribute(<span class="string">'v-cloak'</span>)</span><br><span class="line">      container.setAttribute(<span class="string">'data-v-app'</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器），然后做一个 if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容；接着在挂载前清空容器内容，最终再调用 app.mount 的方法走标准的组件渲染流程。</p>
<p>在这里，重写的逻辑都是和 Web 平台相关的，所以要放在外部实现。此外，这么做的目的是既能让用户在使用 API 时可以更加灵活，也兼容了 Vue.js 2.x 的写法，比如 app.mount 的第一个参数就同时支持选择器字符串和 DOM 对象两种类型。</p>
<p>从 app.mount 开始，才算真正进入组件渲染流程。</p>
<h3 id="真正的挂载mounted"><a href="#真正的挂载mounted" class="headerlink" title="真正的挂载mounted"></a>真正的挂载mounted</h3><p><strong>核心流程：</strong></p>
<ol>
<li><strong>根据传入的根组件App创建vnode</strong></li>
<li><strong>渲染vnode。</strong></li>
</ol>
<h4 id="mount方法"><a href="#mount方法" class="headerlink" title="mount方法"></a>mount方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mount(</span><br><span class="line">    rootContainer: HostElement,</span><br><span class="line">    isHydrate?: boolean,</span><br><span class="line">    namespace?: boolean | ElementNamespace,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">        <span class="comment">// #5571</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; (rootContainer <span class="keyword">as</span> any).__vue_app__) &#123;</span><br><span class="line">            warn(</span><br><span class="line">                <span class="string">`There is already an app instance mounted on the host container.\n`</span> +</span><br><span class="line">                <span class="string">` If you want to mount another app on the same host container,`</span> +</span><br><span class="line">                <span class="string">` you need to unmount the previous app by calling \`app.unmount()\` first.`</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line">        <span class="comment">// store app context on the root VNode.</span></span><br><span class="line">        <span class="comment">// this will be set on the root instance on initial mount.</span></span><br><span class="line">        vnode.appContext = context</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (namespace === <span class="literal">true</span>) &#123;</span><br><span class="line">            namespace = <span class="string">'svg'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace === <span class="literal">false</span>) &#123;</span><br><span class="line">            namespace = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HMR root reload</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        context.reload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// casting to ElementNamespace because TS doesn't guarantee type narrowing</span></span><br><span class="line">            <span class="comment">// over function boundaries</span></span><br><span class="line">            render(</span><br><span class="line">                cloneVNode(vnode),</span><br><span class="line">                rootContainer,</span><br><span class="line">                namespace <span class="keyword">as</span> ElementNamespace,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode <span class="keyword">as</span> VNode&lt;Node, Element&gt;, rootContainer <span class="keyword">as</span> any)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(vnode, rootContainer, namespace)</span><br><span class="line">        &#125;</span><br><span class="line">        isMounted = <span class="literal">true</span></span><br><span class="line">        app._container = rootContainer</span><br><span class="line">        <span class="comment">// for devtools and telemetry</span></span><br><span class="line">        ;(rootContainer <span class="keyword">as</span> any).__vue_app__ = app</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            app._instance = vnode.component</span><br><span class="line">            devtoolsInitApp(app, version)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getExposeProxy(vnode.component!) || vnode.component!.proxy</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">        <span class="string">`App has already been mounted.\n`</span> +</span><br><span class="line">            <span class="string">`If you want to remount the same app, move your app creation logic `</span> +</span><br><span class="line">            <span class="string">`into a factory function and create fresh app instances for each `</span> +</span><br><span class="line">            <span class="string">`mount - e.g. \`const createMyApp = () =&gt; createApp(App)\``</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createVNode"><a href="#createVNode" class="headerlink" title="createVNode"></a>createVNode</h4><p>createVNode方法会根据组件的类型生成一个标志，后续会通过这个标志做一些优化处理。我们传的是一个组件选项，也就是一个普通对象，shapeFlag的值为4。后续我们会重点关注我们的主线组件 vnode 和普通元素 vnode。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createVNode = _createVNode;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createVNode</span>(<span class="params">type, props = null, children = null, patchFlag = <span class="number">0</span>, dynamicProps = null, isBlockNode = false</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> shapeFlag = isString(type)</span><br><span class="line">        ? <span class="number">1</span> <span class="comment">/* ShapeFlags.ELEMENT */</span></span><br><span class="line">        : isSuspense(type)</span><br><span class="line">            ? <span class="number">128</span> <span class="comment">/* ShapeFlags.SUSPENSE */</span></span><br><span class="line">            : isTeleport(type)</span><br><span class="line">                ? <span class="number">64</span> <span class="comment">/* ShapeFlags.TELEPORT */</span></span><br><span class="line">                : isObject(type)</span><br><span class="line">                    ? <span class="number">4</span> <span class="comment">/* ShapeFlags.STATEFUL_COMPONENT */</span></span><br><span class="line">                    : isFunction(type)</span><br><span class="line">                        ? <span class="number">2</span> <span class="comment">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span></span><br><span class="line">                        : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用了createBaseVNode方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBaseVNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: (Data &amp; VNodeProps</span>) | <span class="title">null</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">children</span>: <span class="title">unknown</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">patchFlag</span> = 0,</span></span><br><span class="line">  dynamicProps: string[] | null = null,</span><br><span class="line">  shapeFlag = type === Fragment ? <span class="number">0</span> : ShapeFlags.ELEMENT,</span><br><span class="line">  isBlockNode = <span class="literal">false</span>,</span><br><span class="line">  needFullChildrenNormalization = <span class="literal">false</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    __v_isVNode: <span class="literal">true</span>,</span><br><span class="line">    __v_skip: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    key: props &amp;&amp; normalizeKey(props),</span><br><span class="line">    ref: props &amp;&amp; normalizeRef(props),</span><br><span class="line">    scopeId: currentScopeId,</span><br><span class="line">    slotScopeIds: <span class="literal">null</span>,</span><br><span class="line">    children,</span><br><span class="line">    component: <span class="literal">null</span>,</span><br><span class="line">    suspense: <span class="literal">null</span>,</span><br><span class="line">    ssContent: <span class="literal">null</span>,</span><br><span class="line">    ssFallback: <span class="literal">null</span>,</span><br><span class="line">    dirs: <span class="literal">null</span>,</span><br><span class="line">    transition: <span class="literal">null</span>,</span><br><span class="line">    el: <span class="literal">null</span>,</span><br><span class="line">    anchor: <span class="literal">null</span>,</span><br><span class="line">    target: <span class="literal">null</span>,</span><br><span class="line">    targetAnchor: <span class="literal">null</span>,</span><br><span class="line">    staticCount: <span class="number">0</span>,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    dynamicChildren: <span class="literal">null</span>,</span><br><span class="line">    appContext: <span class="literal">null</span>,</span><br><span class="line">    ctx: currentRenderingInstance,</span><br><span class="line">  &#125; <span class="keyword">as</span> VNode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到返回的虚拟DOM也是一个普通对象，我们传进去的组件选项会存储在type属性上。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>虚拟DOM创建完后就会调用render方法将虚拟DOM渲染为实际的DOM节点，render方法就是在baseCreateRenderer中创建的，通过参数传给createAppAPI的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container, namespace</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新vnode不存在</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 卸载</span></span><br><span class="line">      <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建或者更新组件</span></span><br><span class="line">      patch(</span><br><span class="line">        container._vnode || <span class="literal">null</span>, <span class="comment">// 如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可</span></span><br><span class="line">        vnode,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        namespace,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">      isFlushing = <span class="literal">true</span></span><br><span class="line">      flushPreFlushCbs()</span><br><span class="line">      flushPostFlushCbs()</span><br><span class="line">      isFlushing = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">    container._vnode = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要渲染的新VNode不存在，那么从容器元素上获取之前VNode进行卸载，否则调用patch方法进行打补丁，如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可，否则会对比新旧VNode，使用diff算法进行打补丁，Vue2中使用的是双端diff算法，Vue3中使用的是快速diff算法。</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>看看render方法里调用的patch方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1, <span class="comment">// n1 表示旧的vnode，当n1为null时就表示是一次挂载（挂载or更新由n1决定）</span></span><br><span class="line">    n2, <span class="comment">// n2 表示新的vnode，根据n2的type进行不同的处理</span></span><br><span class="line">    container, <span class="comment">// 渲染后会将vnode渲染到container上</span></span><br><span class="line">    anchor = <span class="literal">null</span>,</span><br><span class="line">    parentComponent = <span class="literal">null</span>,</span><br><span class="line">    parentSuspense = <span class="literal">null</span>,</span><br><span class="line">    namespace = <span class="literal">undefined</span>,</span><br><span class="line">    slotScopeIds = <span class="literal">null</span>,</span><br><span class="line">    optimized = __DEV__ &amp;&amp; isHmrUpdating ? <span class="literal">false</span> : !!n2.dynamicChildren,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 === n2) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">    <span class="comment">// 如果新的节点和旧的节点类型不同，则销毁旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        anchor = getNextHostNode(n1)</span><br><span class="line">        unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">        n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n2.patchFlag === PatchFlags.BAIL) &#123;</span><br><span class="line">        optimized = <span class="literal">false</span></span><br><span class="line">        n2.dynamicChildren = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; type, ref, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Text: <span class="comment">//... 处理文本节点</span></span><br><span class="line">        <span class="keyword">case</span> Comment: <span class="comment">//... 处理注释节点</span></span><br><span class="line">        <span class="keyword">case</span> Static: <span class="comment">//... 处理静态节点</span></span><br><span class="line">        <span class="keyword">case</span> Fragment: <span class="comment">//... 处理Fragment组件节点</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">          <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">           processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            namespace,</span><br><span class="line">            slotScopeIds,</span><br><span class="line">            optimized,</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">          <span class="comment">// 处理组件</span></span><br><span class="line">            processComponent(</span><br><span class="line">                n1,</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                slotScopeIds,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;</span><br><span class="line">          	<span class="comment">// 处理 TELEPORT</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">          	<span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            warn(<span class="string">'Invalid VNode type:'</span>, type, <span class="string">`(<span class="subst">$&#123;<span class="keyword">typeof</span> type&#125;</span>)`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span> &amp;&amp; parentComponent) &#123;</span><br><span class="line">        setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM。</p>
<p>patch的多个参数中，重点关注前三个：</p>
<ol>
<li><p>第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程；</p>
</li>
<li><p>第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；</p>
</li>
<li><p>第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</p>
</li>
</ol>
<p>switch里面根据VNode的类型不同做的处理也不同，因为我们的例子传的是一个组件选项对象，所以会走processComponent处理分支：</p>
<h4 id="processComponent"><a href="#processComponent" class="headerlink" title="processComponent"></a>processComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = (</span><br><span class="line">    n1: VNode | <span class="literal">null</span>,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    slotScopeIds: string[] | <span class="literal">null</span>,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    n2.slotScopeIds = slotScopeIds</span><br><span class="line">    <span class="comment">// n1等于null，表示挂载组件</span></span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            ;(parentComponent!.ctx <span class="keyword">as</span> KeepAliveContext).activate(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用mountComponent挂载组件</span></span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// n1不为null，表示更新组件</span></span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否存在旧的VNode判断是调用挂载方法还是更新方法，先看mountComponent方法：</p>
<h5 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent: MountComponentFn = (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 2.x compat may pre-create the component instance before actually</span></span><br><span class="line">    <span class="comment">// mounting</span></span><br><span class="line">    <span class="keyword">const</span> compatMountInstance =</span><br><span class="line">      __COMPAT__ &amp;&amp; initialVNode.isCompatRoot &amp;&amp; initialVNode.component</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.调用ComponentInternalInstance创建组件的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance: ComponentInternalInstance =</span><br><span class="line">      compatMountInstance ||</span><br><span class="line">      <span class="comment">// 调用createComponentInstance函数创建一个实例对象，其属性皆为没有值</span></span><br><span class="line">      (initialVNode.component = createComponentInstance(</span><br><span class="line">        initialVNode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">      ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve props and slots for setup context</span></span><br><span class="line">    <span class="keyword">if</span> (!(__COMPAT__ &amp;&amp; compatMountInstance)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2.设置组件实例</span></span><br><span class="line">      <span class="comment">// 初始化组件, 主要是对组件的props/slots进行初始化处理</span></span><br><span class="line">      <span class="comment">// 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</span></span><br><span class="line">      setupComponent(instance)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line">    <span class="comment">// before proceeding</span></span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3.调用设置和运行有副作用的渲染函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 创建一个组件更新函数</span></span><br><span class="line">      <span class="comment">//  1.1 render获得vnode</span></span><br><span class="line">      <span class="comment">//  1.2 patch(oldVnode, newVnode)</span></span><br><span class="line">      <span class="comment">// 2 创建更新机制 new ReactiveEffect(更新函数)</span></span><br><span class="line">      <span class="comment">// 执行渲染副作用函数</span></span><br><span class="line">      setupRenderEffect(</span><br><span class="line">        instance,</span><br><span class="line">        initialVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        namespace,</span><br><span class="line">        optimized,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      popWarningContext()</span><br><span class="line">      endMeasure(instance, <span class="string">`mount`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用ComponentInternalInstance创建组件的实例</li>
<li>设置组件实例，初始化组件 处理setup的两个参数, 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</li>
<li>调用设置和运行有副作用的渲染函数</li>
</ol>
<p>下面我们依次来看这三个方法：</p>
<h5 id="1-createComponentInstance"><a href="#1-createComponentInstance" class="headerlink" title="1. createComponentInstance"></a>1. createComponentInstance</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  parent: ComponentInternalInstance | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  suspense: SuspenseBoundary | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = vnode.type <span class="keyword">as</span> ConcreteComponent</span><br><span class="line">  <span class="comment">// inherit parent app context - or - if root, adopt from root vnode</span></span><br><span class="line">  <span class="keyword">const</span> appContext =</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance: ComponentInternalInstance = &#123;</span><br><span class="line">    uid: uid++,</span><br><span class="line">    vnode,</span><br><span class="line">    type,</span><br><span class="line">    parent,</span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// 还有非常多属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-setupComponent"><a href="#2-setupComponent" class="headerlink" title="2. setupComponent"></a>2. setupComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(isSSR)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vnode的props和子元素</span></span><br><span class="line">  <span class="keyword">const</span> &#123; props, children &#125; = instance.vnode</span><br><span class="line">  <span class="comment">// 是否是有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = isStatefulComponent(instance)</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="comment">// 初始化slots</span></span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  <span class="comment">// 执行setupStatefulComponent获取setupResult</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR) <span class="comment">// 执行setup</span></span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到setupComponent会初始化props和slots，然后执行setupStatefulComponent，这里主要是执行setup函数，并返回结果</p>
<h6 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent"></a>setupStatefulComponent</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 组件描述对象</span></span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0. create render proxy property access cache</span></span><br><span class="line">  <span class="comment">// 创建render proxy属性访问缓存 作用是缓存访问过的属性</span></span><br><span class="line">  instance.accessCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 1. create public instance / render proxy</span></span><br><span class="line">  <span class="comment">// also mark it raw so it's never observed</span></span><br><span class="line">  <span class="comment">// 代理ctx，拦截ctx的属性访问 从而实现取值的优先级：setupState &gt; data &gt; props &gt; ctx</span></span><br><span class="line">  instance.proxy = markRaw(<span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, PublicInstanceProxyHandlers))</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    exposePropsOnRenderContext(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. call setup()</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component</span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 创建setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instance赋值给currentInstance</span></span><br><span class="line">    <span class="comment">// 设置当前实例为instance 为了在setup中可以通过getCurrentInstance获取到当前实例</span></span><br><span class="line">    <span class="comment">// 同时开启instance.scope.on()</span></span><br><span class="line">    <span class="keyword">const</span> reset = setCurrentInstance(instance)</span><br><span class="line">    <span class="comment">// 暂停tracking 暂停收集副作用函数</span></span><br><span class="line">    pauseTracking()</span><br><span class="line">    <span class="comment">// 执行setup</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [</span><br><span class="line">        __DEV__ ? shallowReadonly(instance.props) : instance.props,</span><br><span class="line">        setupContext,</span><br><span class="line">      ],</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 重新开启副作用收集</span></span><br><span class="line">    resetTracking()</span><br><span class="line">    <span class="comment">// currentInstance置为空</span></span><br><span class="line">    <span class="comment">// activeEffectScope赋值为instance.scope.parent</span></span><br><span class="line">    <span class="comment">// 同时instance.scope.off()</span></span><br><span class="line">    reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPromise(setupResult)) &#123;</span><br><span class="line">      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">      <span class="keyword">if</span> (isSSR) &#123;</span><br><span class="line">        <span class="comment">// return the promise so server-renderer can wait on it</span></span><br><span class="line">        <span class="keyword">return</span> setupResult</span><br><span class="line">          .then(<span class="function">(<span class="params">resolvedResult: unknown</span>) =&gt;</span> &#123;</span><br><span class="line">            handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        <span class="comment">// async setup returned Promise.</span></span><br><span class="line">        <span class="comment">// bail here and wait for re-entry.</span></span><br><span class="line">        instance.asyncDep = setupResult</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; !instance.suspense) &#123;</span><br><span class="line">          <span class="keyword">const</span> name = Component.name ?? <span class="string">'Anonymous'</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Component &lt;<span class="subst">$&#123;name&#125;</span>&gt;: setup function returned a promise, but no `</span> +</span><br><span class="line">              <span class="string">`&lt;Suspense&gt; boundary was found in the parent component tree. `</span> +</span><br><span class="line">              <span class="string">`A component with async setup() must be nested in a &lt;Suspense&gt; `</span> +</span><br><span class="line">              <span class="string">`in order to be rendered.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`setup() returned a Promise, but the version of Vue you are using `</span> +</span><br><span class="line">            <span class="string">`does not support it yet.`</span>,</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里会调用组件选项的setup方法，这个函数中返回的对象会暴露给模板和组件实例，看一下handleSetupResult方法：</p>
<h6 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult"></a>handleSetupResult</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params">instance, setupResult, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFunction(setupResult)) &#123;</span><br><span class="line">        instance.render = setupResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123;</span><br><span class="line">        instance.setupState = proxyRefs(setupResult);</span><br><span class="line">    &#125;</span><br><span class="line">    finishComponentSetup(instance, isSSR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果setup返回的是一个函数，那么这个函数会直接被作为渲染函数。否则如果返回的是一个对象，会使用proxyRefs将这个对象转为Proxy代理的响应式对象。</p>
<h6 id="finishComponentSetup"><a href="#finishComponentSetup" class="headerlink" title="finishComponentSetup"></a>finishComponentSetup</h6><p>最后又调用了finishComponentSetup方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span>(<span class="params">instance, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Component = instance.type;</span><br><span class="line">    <span class="keyword">if</span> (!instance.render) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSSR &amp;&amp; compile &amp;&amp; !Component.render) &#123;</span><br><span class="line">            <span class="keyword">const</span> template = Component.template ||</span><br><span class="line">                  resolveMergedOptions(instance).template;</span><br><span class="line">            <span class="keyword">if</span> (template) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; isCustomElement, compilerOptions &#125; = instance.appContext.config;</span><br><span class="line">                <span class="keyword">const</span> &#123; delimiters, <span class="attr">compilerOptions</span>: componentCompilerOptions &#125; = Component;</span><br><span class="line">                <span class="keyword">const</span> finalCompilerOptions = extend(extend(&#123;</span><br><span class="line">                    isCustomElement,</span><br><span class="line">                    delimiters</span><br><span class="line">                &#125;, compilerOptions), componentCompilerOptions);</span><br><span class="line">                Component.render = compile(template, finalCompilerOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        instance.render = (Component.render || NOOP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是判断组件是否存在渲染函数render，如果不存在则判断是否存在template选项，我们传的组件选项显然是没有render属性，而是传的模板template，所以会使用compile方法来将模板编译成渲染函数。</p>
<h5 id="3-setupRenderEffect"><a href="#3-setupRenderEffect" class="headerlink" title="3. setupRenderEffect"></a>3. setupRenderEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode, <span class="comment">// 组件 vnode</span></span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 组件更新方法</span></span><br><span class="line">    <span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">    <span class="comment">// 创建一个effect, 将componentUpdateFn更新方法传入响应式更新方法</span></span><br><span class="line">    <span class="keyword">const</span> effect = (instance.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">      componentUpdateFn,</span><br><span class="line">      NOOP,</span><br><span class="line">      () =&gt; queueJob(update),</span><br><span class="line">      instance.scope, <span class="comment">// track it in component's effect scope</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件更新函数</span></span><br><span class="line">    <span class="keyword">const</span> update: SchedulerJob = <span class="function">(<span class="params">instance.update = (</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect.dirty) &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    update.id = instance.uid</span><br><span class="line">    <span class="comment">// allowRecurse</span></span><br><span class="line">    <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">    toggleRecurse(instance, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      effect.onTrack = instance.rtc</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtc!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      effect.onTrigger = instance.rtg</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtg!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      update.ownerInstance = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行组件更新</span></span><br><span class="line">    update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就涉及到Vue3的响应式原理了，核心就是使用Proxy拦截数据，然后在属性读取时将属性和读取该属性的函数（称为副作用函数）关联起来，然后在更新该属性时取出该属性关联的副作用函数出来执行。</p>
<p>简化后的ReactiveEffect类就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactiveEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn, scheduler = null, scope) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        activeEffect = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fn();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            activeEffect = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行它的run方法时会把自身赋值给全局的activeEffect变量，然后执行副作用函数时如果读取了Proxy代理后的对象的某个属性时就会将对象、属性和这个ReactiveEffect示例关联存储起来，如果属性发生改变，会取出关联的ReactiveEffect实例，执行它的run方法，达到自动更新的目的。</p>
<h6 id="componentUpdateFn"><a href="#componentUpdateFn" class="headerlink" title="componentUpdateFn"></a>componentUpdateFn</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断组件是否已经挂载</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">const</span> &#123; el, props &#125; = initialVNode</span><br><span class="line">    <span class="comment">// 生命周期和父instance</span></span><br><span class="line">    <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance</span><br><span class="line">    <span class="keyword">const</span> isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><br><span class="line">    toggleRecurse(instance, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// beforeMount hook</span></span><br><span class="line">    <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">      invokeArrayFns(bm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeBeforeMount</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">      <span class="comment">// ssr 相关</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行render函数获得subTree(也是一个vnode) 将subTree挂载到instance上 以供更新使用</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance)) <span class="comment">// 整个组件渲染生成 DOM 对应的 vnode 树</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// patch subTree初次挂载</span></span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        subTree,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// el同步到initialVNode</span></span><br><span class="line">      initialVNode.el = subTree.el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mounted hook</span></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      queuePostRenderEffect(m, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeMounted</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 组件已经挂载</span></span><br><span class="line">    instance.isMounted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">      devtoolsComponentAdded(instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2458: deference mount-only object parameters to prevent memleaks</span></span><br><span class="line">    initialVNode = container = anchor = <span class="literal">null</span> <span class="keyword">as</span> any</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">    <span class="keyword">let</span> originNext = next</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      next.el = vnode.el</span><br><span class="line">      <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">      updateComponentPreRender(instance, next, optimized)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行render函数获得nextTree</span></span><br><span class="line">    <span class="keyword">const</span> nextTree = renderComponentRoot(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取老的subTree</span></span><br><span class="line">    <span class="keyword">const</span> prevTree = instance.subTree</span><br><span class="line">    instance.subTree = nextTree</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patch新旧节点更新组件</span></span><br><span class="line">    patch(</span><br><span class="line">      prevTree,</span><br><span class="line">      nextTree,</span><br><span class="line">      <span class="comment">// parent may have changed if it's in a teleport</span></span><br><span class="line">      hostParentNode(prevTree.el!)!,</span><br><span class="line">      <span class="comment">// anchor may have changed if it's in a fragment</span></span><br><span class="line">      getNextHostNode(prevTree),</span><br><span class="line">      instance,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的patch操作其实就是调用本章开头的那个patch，可以看到patch其实是一个递归操作，这里patch subtree如果根组件的根元素是组件则会继续执行processComponent，如果是一个element元素则会执行processElement，processElement中会处理children，又会调用patch，如此递归直到整个组件挂载完成。</p>
<p>组件无论是首次挂载，还是更新，做的事情核心是一样的，先调用renderComponentRoot方法生成组件模板的虚拟DOM，然后调用patch方法打补丁。</p>
<h6 id="renderComponentRoot"><a href="#renderComponentRoot" class="headerlink" title="renderComponentRoot"></a>renderComponentRoot</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponentRoot</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component, vnode, proxy, withProxy, props, <span class="attr">propsOptions</span>: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs &#125; = instance;</span><br><span class="line">	  <span class="comment">// 执行render函数</span></span><br><span class="line">  	<span class="comment">// render函数内部会通过_createVNode或者_createElementVNode等函数进一步生成子vnode</span></span><br><span class="line">    <span class="keyword">let</span> result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderComponentRoot核心就是调用组件的渲染函数render方法生成组件模板的虚拟DOM，然后扔给patch方法更新就好了。</p>
<h5 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h5><p>看完了mountComponent方法，再来看看updateComponent方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponent = <span class="function">(<span class="params">n1, n2, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = (n2.component = n1.component);</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdateComponent(n1, n2, optimized)) &#123;</span><br><span class="line">        <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">        instance.next = n2;</span><br><span class="line">        <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    	  invalidateJob(instance.update)</span><br><span class="line">        <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">        instance.update();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要更新</span></span><br><span class="line">        n2.el = n1.el;</span><br><span class="line">        instance.vnode = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用shouldUpdateComponent方法判断组件是否需要更新，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。</p>
<p>如果需要更新，那么会执行instance.update方法，这个方法就是前面setupRenderEffect方法里保存的effect.run方法，所以最终执行的也是componentUpdateFn方法。</p>
<h6 id="updateComponentPreRender"><a href="#updateComponentPreRender" class="headerlink" title="updateComponentPreRender"></a>updateComponentPreRender</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponentPreRender = (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    nextVNode: VNode,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.component = instance</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.vnode.props</span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.vnode = nextVNode</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.next = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  updateProps(instance, nextVNode.props, prevProps, optimized)</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  updateSlots(instance, nextVNode.children, optimized)</span><br><span class="line"></span><br><span class="line">  pauseTracking()</span><br><span class="line">  <span class="comment">// props update may have triggered pre-flush watchers.</span></span><br><span class="line">  <span class="comment">// flush them before the render update.</span></span><br><span class="line">  flushPreFlushCbs(instance)</span><br><span class="line">  resetTracking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">'svg'</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p>
<p>我们接着来看挂载元素的 mountElement 函数的实现：</p>
<h6 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is)</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况</span></span><br><span class="line">    mountChildren(vnode.children, el, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG &amp;&amp; type !== <span class="string">'foreignObject'</span>, optimized || !!vnode.dynamicChildren)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。</p>
<p>首先是创建 DOM 元素节点，通过 hostCreateElement 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag, isSVG, is</span>) </span>&#123;</span><br><span class="line">  isSVG ? <span class="built_in">document</span>.createElementNS(svgNS, tag)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(tag, is ? &#123; is &#125; : <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了底层的 DOM API document.createElement 创建元素，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。</p>
<p>创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。</p>
<p>接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p>
<p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElementText</span>(<span class="params">el, text</span>) </span>&#123;</span><br><span class="line">  el.textContent = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子节点是数组，则执行 mountChildren 方法：</p>
<h6 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountChildren = <span class="function">(<span class="params">children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 预处理 child</span></span><br><span class="line">    <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">      ? cloneIfMounted(children[i])</span><br><span class="line">      : normalizeVNode(children[i]))</span><br><span class="line">    <span class="comment">// 递归 patch 挂载 child</span></span><br><span class="line">    patch(<span class="literal">null</span>, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。</p>
<p>可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。</p>
<p>另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。</p>
<p>处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">child, parent, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (anchor) &#123;</span><br><span class="line">    parent.insertBefore(child, anchor)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。</p>
<p>因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-1.png" alt="image-1"></p>
<p>到这里，从我们创建实例到页面渲染，再到更新的全流程就讲完了，总结一下，大致就是:</p>
<ol>
<li><p>每个Vue组件都需要产出一份虚拟DOM，也就是组件的render函数的返回值，render函数你可以直接手写，也可以通过template传递模板字符串，由Vue内部来编译成渲染函数，平常我们开发时写的Vue单文件，最终也会编译成普通的Vue组件选项对象；</p>
</li>
<li><p>render函数会作为副作用函数执行，也就是如果在模板中使用到了响应式数据（所谓响应式数据就是能拦截到它的各种读取、修改操作），那么响应式数据和属性会与render函数关联起来，那么当响应式数据被修改以后，就能找到依赖它的render函数，那么就可以通知依赖的组件进行更新；</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%88Update%20the%20rendering%EF%BC%89%E7%9A%84%E6%97%B6%E6%9C%BA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%88Update%20the%20rendering%EF%BC%89%E7%9A%84%E6%97%B6%E6%9C%BA.html" class="post-title-link" itemprop="url">EventLoop规范 - 更新渲染（Update the rendering）的时机验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-18T00:00:00+08:00">2023-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="event-loop-中的-Update-the-rendering（更新渲染）"><a href="#event-loop-中的-Update-the-rendering（更新渲染）" class="headerlink" title="event loop 中的 Update the rendering（更新渲染）"></a>event loop 中的 Update the rendering（更新渲染）</h2><p>这是 event loop 中很重要部分，在<a href="https://rile14929.github.io/zh-CN/eventloop.html">这篇文章处理流程（processing model）中第 3 步会进行 Update the rendering（更新渲染）</a>，规范允许浏览器自己选择是否更新视图。也就是说可能不是每轮事件循环都去更新视图，只在有必要的时候才更新视图。</p>
<p>渲染的基本流程：</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image.png" alt="alt text"></p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树， 将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>Note: 可以看到渲染树的一个重要组成部分是 CSSOM 树，绘制会等待 css 样式全部加载完成才进行，所以 css 样式加载的快慢是首屏呈现快慢的关键点。</p>
<p>下面讨论一下渲染的时机。规范定义在一次循环中，Update the rendering 会在 Microtasks: Perform a microtask checkpoint 后运行。</p>
<h2 id="渲染时机"><a href="#渲染时机" class="headerlink" title="渲染时机"></a>渲染时机</h2><blockquote>
<p>以下的例子中，用 chrome 的 Developer tools 的 Timeline 查看各部分运行的时间点。当我们点击这个 div 的时候，截取了部分时间线。</p>
<p>黄色部分是脚本运行，紫色部分是更新 render 树、计算布局，绿色部分是绘制。</p>
<p>绿色和紫色部分可以认为是 Update the rendering。</p>
</blockquote>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> t = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = t</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-1.png" alt="alt text"></p>
<p>在这一轮事件循环中，setTimeout1 是作为 task 运行的，可以看到 paint 确实是在 task 运行完后才进行的。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>现在换成一个 microtask 任务，看看有什么变化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      con.textContext = 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-2.png" alt="alt text"></p>
<p>和上一个例子很像，不同的是这一轮事件循环的 task 是 click 的回调函数，Promise1 则是 microtask，paint 同样是在他们之后完成。</p>
<p>标准就是那么定义的，答案似乎显而易见，我们把例子变得稍微复杂一些。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子 3"></a>例子 3</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="title">click1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-3.png" alt="alt text"><br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-4.png" alt="alt text"></p>
<p>经过多次测试，执行和渲染顺序可能会出现上图的两种情况，根据 timeline 可以看出，图 1 中 setTimeout 分别执行并且浏览器绘制了两次，图二中 setTimeout1 和 setTimeout2 中间并没有绘制, 而是最后绘制了一次，也基本符合规范，但是需要验证这两次 setTimeout 是否在两次 task 中。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>在两个 setTimeout 中增加 microtask。再次确认 setTimeout 在两个 task 中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-5.png" alt="alt text"><br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-9.png" alt="alt text"></p>
<p>从 run microtasks 中可以看出来，setTimeout1、setTimeout2 是运行在两次 event loop 中</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子 5"></a>例子 5</h3><p>将时间间隔加大一些。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="title">click1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 17)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当间隔增大，大部分时候可以肉眼从看到先变成 0，再变成 1 的过程。但是有时也是会合并起来，只 paint 一次</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-6.png" alt="alt text"></p>
<p>通过 timeline，可以看到 setTimeout1 后接着 paint，后执行了 setTimeout2 后也有 paint</p>
<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子 6"></a>例子 6</h3><p>我们在同一时间执行多个 setTimeout 来模拟执行间隔很短的 task。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 2</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 3</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 4</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 5</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 6</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-7.png" alt="alt text"><br>图一中总共 paint 了一次</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-8.png" alt="alt text"></p>
<p>图二中一共 paint 了两次，所以多次 task 的间隔很短，仍会进行绘制。</p>
<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子 7"></a>例子 7</h3><p>有说法是一轮 event loop 执行的 microtask 有数量限制，多余的 microtask 会放到下一轮执行。下面例子将 microtask 的数量增加到 25000。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      con.textContent = <span class="string">'task1'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">250000</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          con.textContent = i</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      con.textContent = <span class="string">'task2'</span></span></span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-10.png" alt="alt text"></p>
<p>可以看到脚本的运行耗费大量的时间，并且阻塞了渲染。</p>
<p>我们看 setTimeout2 的运行情况</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-11.png" alt="alt text"></p>
<p>可以看到 setTimeout2 这轮 event loop 没有 run microtasks，microtasks 在 setTimeout1 被全部执行完了。</p>
<p>25000 个 microtasks 不能说明 event loop 对 microtasks 数量没有限制，有可能这个限制数很高，远超 25000，但日常使用基本不会使用那么多了。</p>
<p>对 microtasks 增加数量限制，一个很大的作用是防止脚本运行时间过长，阻塞渲染。</p>
<h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子 8"></a>例子 8</h3><p>使用 requestAnimationFrame。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> i = <span class="number">0</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> raf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = i</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        i++</span><br><span class="line">        if (i &lt; 3) raf()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">    raf()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看下总体的 timeline<br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-12.png" alt="alt text"></p>
<p>单看某一个 requestAnimationFrame<br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-13.png" alt="alt text"></p>
<ul>
<li>可以看出 requestAnimationFrame 是在更新渲染阶段的执行的，其执行顺序早于 paint，并且不会被合并执行，非常适合做动画</li>
<li>在 requestAnimationFrame 回调内有新的 microtasks 进入时，也会执行完所有的 microtasks 才会进入到渲染阶段</li>
</ul>
<h3 id="例子-9"><a href="#例子-9" class="headerlink" title="例子 9"></a>例子 9</h3><p>验证 postMessage 是否是 task</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel()</span></span><br><span class="line"><span class="actionscript">  channel.port1.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">onmessage1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'postMessage'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  channel.port2.postMessage(0)</span><br><span class="line"><span class="actionscript">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'sync'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br><span class="line">setTimeout1</span><br><span class="line">postMessage</span><br><span class="line">promise1</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-14.png" alt="alt text"></p>
<p>第一个黄块是 setTimeout1，第二个是 onmessage1，第三个是 promise1，第四个是 setTimeout2。显而易见，postMessage 属于 task。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合规范和以上验证案例可以得出一些结论：</p>
<ul>
<li>event loop 的大致循环过程，可以用下边的图表示：</li>
</ul>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-15.png" alt="alt text"></p>
<ul>
<li>在一轮 event loop 中多次修改同一 dom，只有最后一次会进行绘制。</li>
<li>例 3-例 6 这几个结果是非常不可控的，如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。</li>
<li>渲染更新（Update the rendering）会在 event loop 中的 tasks 和 microtasks 完成后进行，但并不是每轮 event loop 都会更新渲染，这里有一个 rendering opportunity 的概念，判断是否需要渲染，这取决于是否修改了 dom 和浏览器觉得是否有必要在此时立即将新状态呈现给用户，也要要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定。通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）</li>
<li>事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行。</li>
<li>如果希望在每轮 event loop 都即时呈现变动，可以使用 requestAnimationFrame。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/semantic-release.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/semantic-release.html" class="post-title-link" itemprop="url">团队敏捷实践 —— 使用 semantic-release 实现自动化发布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-09-01T00:00:00+08:00">2023-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的分享中，我们团队已经成功运用了 Gitlab CI，并且已经结构化提交 git commit 记录，我们希望更进一步，自动管理发布版本，自动生成更新日志，自动发布 NPM 包，因此我们引入了 semantic-release 进一步自动化管理我们的发布流程。</p>
<h2 id="semantic-release-概述"><a href="#semantic-release-概述" class="headerlink" title="semantic-release 概述"></a>semantic-release 概述</h2><p>有关<a href="https://semantic-release.gitbook.io/semantic-release/" target="_blank" rel="noopener">semantic-release</a>的详细介绍可以阅读官方文档，这里只做一些概述性的总结。和 standard-version 相比，semantic-release 更适合在 CI 环境中运行，它自带支持各种 git server 的认证支持，如 Github，Gitlab，Bitbucket 等等，此外，还支持插件，以便完成其他后续的流程步骤，比如自动生成 git tag 和 release note 之后再 push 回中央仓库，自动发布 npm 包等等。</p>
<p>semantic-release 会根据规范化的 commit 信息生成发布日志，默认使用 angular 规则，其他规则可以配置插件完成。</p>
<p>semantic-release 大致的工作流如下:</p>
<ul>
<li>提交到特定的分支触发 release 流程</li>
<li>验证 commit 信息，生成 release note，打 git tag</li>
<li>其他后续流程，如生成 CHANGELOG.md，npm publish 等等（通过插件完成）</li>
</ul>
<p><strong>由 CI 自动执行之后的效果就像这样，在 Git tag 页面可以看到 tag 信息，同时包含更新记录:</strong><br><img src="/images/semantic-release.resources/4AC0ED82-F6DB-47DF-BF40-55D3D102E62E.png" alt="86f880f284d3072ec2179cbc46c32396"></p>
<p><strong>如果启用了@semantic-release/git 插件，还会将生成的 CHANGELOG.md  反向 push 回中央仓库:</strong><br><img src="/images/semantic-release.resources/0ECB644A-F473-44BD-B48D-88C694133D7C.png" alt="6cfc655f89c58bc6a2faa5e3aee6eea1"></p>
<p><strong>commit history 的实际效果如下</strong><br><img src="/images/semantic-release.resources/6FB7CB34-8D1F-46EB-98EA-801CABF7D39F.png" alt="c15015e5517056c98eca17829d479a12"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在项目工程中添加 release.config.js 配置如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">parserOpts = &#123;</span><br><span class="line">  mergePattern: <span class="regexp">/^Merge pull request #(\d+) from (.*)$/</span>,</span><br><span class="line">  mergeCorrespondence: [<span class="string">'id'</span>, <span class="string">'source'</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copied from https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-angular/writer-opts.js#L27</span></span><br><span class="line"><span class="comment">// and modified to support adding all commit types to the release notes</span></span><br><span class="line">customTransform = <span class="function">(<span class="params">commit, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> issues = []</span><br><span class="line">  commit.notes.forEach(<span class="function">(<span class="params">note</span>) =&gt;</span> &#123;</span><br><span class="line">    note.title = <span class="string">`BREAKING CHANGES`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (commit.type === <span class="string">`feat`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`✨ Features`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`fix`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🐞 Bug Fixes`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`perf`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🎈 Performance Improvements`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`revert`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`Reverts`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`docs`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`📃 Documentation`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`style`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🌈 Styles`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`refactor`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🦄 Code Refactoring`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`test`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🧪 Tests`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`build`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🔧 Build System`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`ci`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🐎 Continuous Integration`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (commit.scope === <span class="string">`*`</span>) &#123;</span><br><span class="line">    commit.scope = <span class="string">``</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> commit.hash === <span class="string">`string`</span>) &#123;</span><br><span class="line">    commit.shortHash = commit.hash.substring(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> commit.subject === <span class="string">`string`</span>) &#123;</span><br><span class="line">    commit.subject = commit.subject.substring(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> url = context.repository</span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;context.host&#125;</span>/<span class="subst">$&#123;context.owner&#125;</span>/<span class="subst">$&#123;context.repository&#125;</span>`</span></span><br><span class="line">      : context.repoUrl</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">      url = <span class="string">`<span class="subst">$&#123;url&#125;</span>/issues/`</span> <span class="comment">// Issue URLs.</span></span><br><span class="line">      commit.subject = commit.subject.replace(<span class="regexp">/#([0-9]+)/g</span>, (_, issue) =&gt; &#123;</span><br><span class="line">        issues.push(issue)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;issue&#125;</span>](<span class="subst">$&#123;url&#125;</span><span class="subst">$&#123;issue&#125;</span>)`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.host) &#123;</span><br><span class="line">      <span class="comment">// User URLs.</span></span><br><span class="line">      commit.subject = commit.subject.replace(</span><br><span class="line">        /\B@([a-z0<span class="number">-9</span>](?:-?[a-z0<span class="number">-9</span>/])&#123;<span class="number">0</span>,<span class="number">38</span>&#125;)/g,</span><br><span class="line">        (_, username) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (username.includes(<span class="string">'/'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`@<span class="subst">$&#123;username&#125;</span>`</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">`[@<span class="subst">$&#123;username&#125;</span>](<span class="subst">$&#123;context.host&#125;</span>/<span class="subst">$&#123;username&#125;</span>)`</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    commit.subject = <span class="string">`<span class="subst">$&#123;commit.subject&#125;</span> (by @<span class="subst">$&#123;commit.committer.name&#125;</span>)`</span></span><br><span class="line">  &#125; <span class="comment">// remove references that already appear in the subject</span></span><br><span class="line">  commit.references = commit.references.filter(<span class="function">(<span class="params">reference</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (issues.indexOf(reference.issue) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> commit</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  branches: <span class="string">'master'</span>,</span><br><span class="line">  parserOpts,</span><br><span class="line">  writerOpts: &#123; <span class="attr">transform</span>: customTransform &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/commit-analyzer'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        preset: <span class="string">'angular'</span>,</span><br><span class="line">        releaseRules: [</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'docs'</span>, <span class="attr">scope</span>: <span class="string">'README'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'refactor'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'style'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'test'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'build'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'ci'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@semantic-release/release-notes-generator'</span>,</span><br><span class="line">    [<span class="string">'@semantic-release/changelog'</span>, &#123; <span class="attr">changelogFile</span>: <span class="string">'CHANGELOG.md'</span> &#125;],</span><br><span class="line">    <span class="string">'@semantic-release/npm'</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/git'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        assets: [<span class="string">'package.json'</span>, <span class="string">'CHANGELOG.md'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/gitlab'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        gitlabUrl: <span class="string">'http://git.example.com'</span>,</span><br><span class="line">        assets: [],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成  .gitlab-ci.yml  配置如下（仅部分关键的配置片段）:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">lint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"><span class="attr">commitlint:</span></span><br><span class="line">    <span class="attr">stage:</span> <span class="string">lint</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^chore\(release\)/'</span></span><br><span class="line">          <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^Merge branch/'</span></span><br><span class="line">          <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span> <span class="comment"># 一般当分支master有 push 或 merge 时才会执行该工作</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span> <span class="string">bin/commitlint-gitlab-ci.sh</span></span><br><span class="line"><span class="attr">release:</span></span><br><span class="line">    <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">semantic-release</span></span><br></pre></td></tr></table></figure>

<p>commitlint 脚本请参考<a href="https://gitlab.com/dmoonfire/commitlint-gitlab-ci/-/blob/main/bin/commitlint-gitlab-ci.sh" target="_blank" rel="noopener">commitlint-gitlab-ci.sh</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们完成了通过 CI 自动管理版本号和发布日志的需求，大大节省了人力，同时，还留下了发布痕迹，方便追溯历史版本。<br>另外，需要注意的是上述的配置并不会修改源码部分的版本号配置内容（如 build.gradle 或 package.json 等），如果需要自动管理这些地方的版本，与 git tag 版本保持一致，可以引入@semantic-release/exec 插件，自己写脚本，通过脚本自动化修改这些地方的版本号。<br>还需要注意的是 semantic-release 默认产生的 commit 记录为了避免不必要的 CI 流程，会在 commit 记录加上[skip ci]（见上面的截图）来跳过 CI，如果你的流水线需要由 git tag 触发，可以配置@semantic-release/git 插件，自定义 commit 记录，去掉[skip ci]。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/eventloop.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/eventloop.html" class="post-title-link" itemprop="url">EventLoop规范 阅读和总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-07T00:00:00+08:00">2023-08-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步的思考"><a href="#异步的思考" class="headerlink" title="异步的思考"></a>异步的思考</h2><p>提起异步，相信每个人都知道。异步背后的“靠山”就是 event loops。这里的异步准确的说应该叫浏览器的 event loops 或者说是 javaScript 运行环境的 event loops，因为<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">ECMAScript</a>中没有 event loops，event loops 是在<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">HTML Standard</a>定义的。</p>
<h4 id="（1）单线程的-JavaScript"><a href="#（1）单线程的-JavaScript" class="headerlink" title="（1）单线程的 JavaScript"></a>（1）单线程的 JavaScript</h4><p>我们知道，JavaScript 是一种单线程语言，它主要用来与用户互动，以及操作 DOM。<br>JavaScript 有同步和异步的概念，这就解决了代码阻塞的问题：</p>
<pre><code>- 同步：如果在一个函数返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的；
- 异步：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</code></pre><h5 id="那单线程有什么好处呢？"><a href="#那单线程有什么好处呢？" class="headerlink" title="那单线程有什么好处呢？"></a>那单线程有什么好处呢？</h5><pre><code>在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。
得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间的好处。</code></pre><h4 id="（2）多线程的浏览器"><a href="#（2）多线程的浏览器" class="headerlink" title="（2）多线程的浏览器"></a>（2）多线程的浏览器</h4><p>JS 是单线程的，在同一个时间只能做一件事情，那为什么浏览器可以同时执行异步任务呢？</p>
<p>这是因为浏览器是多线程的，当 JS 需要执行异步任务时，浏览器会另外启动一个线程去执行该任务。也就是说，JavaScript 是单线程的指的是执行 JavaScript 代码的线程只有一个，是浏览器提供的 JavaScript 引擎线程（主线程）。除此之外，浏览器中还有定时器线程、 HTTP 请求线程等线程，这些线程主要不是来执行 JS 代码的。</p>
<p>比如主线程中需要发送数据请求，就会把这个任务交给异步 HTTP 请求线程去执行，等请求数据返回之后，再将 callback 里需要执行的 JS 回调交给 JS 引擎线程去执行。也就是说，浏览器才是真正执行发送请求这个任务的角色，而 JS 只是负责执行最后的回调处理。所以这里的异步不是 JS 自身实现的，而是浏览器为其提供的能力。</p>
<p><img src="../images/eventloop/image.png" alt="alt text"></p>
<p>可以看到，Chrome 不仅拥有多个进程，还有多个线程。以渲染进程为例，就包含 GUI 渲染线程、JS 引擎线程、事件触发线程、定时器触发线程、异步 HTTP 请求线程。这些线程为 JS 在浏览器中完成异步任务提供了基础。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们来看看 event loop 在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="noopener">HTML Standard</a> 中的定义章节:</p>
<p>第一句话：</p>
<blockquote>
<p>为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的 event loop。</p>
</blockquote>
<p><strong>事件</strong>，<strong>用户交互</strong>，<strong>脚本</strong>，<strong>渲染</strong>，<strong>网络</strong>这些都是我们所熟悉的东西，他们都是由 event loop 协调的。触发一个 click 事件，进行一次 ajax 请求，背后都有 event loop 在运作。</p>
<h3 id="task-queues"><a href="#task-queues" class="headerlink" title="task queues"></a>task queues</h3><blockquote>
<p>一个 event loop 有一个或者多个 task 队列。</p>
</blockquote>
<blockquote>
<p>当用户代理安排一个任务，必须将该任务增加到相应的 event loop 的一个 tsak 队列中。</p>
</blockquote>
<blockquote>
<p>每一个 task 都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个 task 队列，其他事件又是一个单独的队列。可以为鼠标、键盘事件分配更多的时间，保证交互的流畅。</p>
</blockquote>
<h3 id="哪些是-task-任务源呢？"><a href="#哪些是-task-任务源呢？" class="headerlink" title="哪些是 task 任务源呢？"></a>哪些是 task 任务源呢？</h3><p>规范在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources" target="_blank" rel="noopener">Generic task sources</a>中有提及：</p>
<blockquote>
<p>DOM 操作任务源：<br>此任务源被用来相应 dom 操作，例如一个元素以非阻塞的方式插入文档。</p>
</blockquote>
<blockquote>
<p>用户交互任务源：<br>此任务源用于对用户交互作出反应，例如键盘或鼠标输入。响应用户操作的事件（例如 click）必须使用 task 队列。</p>
</blockquote>
<blockquote>
<p>网络任务源：<br>网络任务源被用来响应网络活动。</p>
</blockquote>
<blockquote>
<p>history traversal 任务源：<br>当调用 history.back()等类似的 api 时，将任务插进 task 队列。</p>
</blockquote>
<p>task 任务源非常宽泛，比如 ajax 的 onload，click 事件，基本上我们经常绑定的各种事件都是 task 任务源，还有数据库操作（IndexedDB ），需要注意的是 setTimeout、setInterval、setImmediate 也是 task 任务源。总结来说 task 任务源：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendering</li>
</ul>
<h3 id="microtask"><a href="#microtask" class="headerlink" title="microtask"></a>microtask</h3><blockquote>
<p>微任务队列不是任务队列。</p>
</blockquote>
<blockquote>
<p>每个事件循环都有一个微任务队列，这是一个微任务队列，最初是空的。微任务是一种口语化的方式，指的是通过微任务算法队列创建的任务。</p>
</blockquote>
<blockquote>
<p>如果在初期执行时，<a href="https://html.spec.whatwg.org/multipage/webappapis.html#spin-the-event-loop" target="_blank" rel="noopener">spin the event loop</a>，microtasks 有可能被移动到常规的 task 队列，在这种情况下，microtasks 任务源会被 task 任务源所用。通常情况，task 任务源和 microtasks 是不相关的。</p>
</blockquote>
<p>microtask 队列和 task 队列有些相似，都是先进先出的队列，由指定的任务源去提供任务，不同的是一个 event loop 里只有一个 microtask 队列。</p>
<p>HTML Standard 没有具体指明哪些是 microtask 任务源，通常认为是 microtask 任务源有：</p>
<ul>
<li>process.nextTick</li>
<li>promises</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<h2 id="处理流程（processing-model）"><a href="#处理流程（processing-model）" class="headerlink" title="处理流程（processing model）"></a><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">处理流程（processing model）</a></h2><ol>
<li><p>在 tasks 队列中选择最老的一个 task，用户代理可以选择任何 task 队列，如果没有可选的任务，则跳到下边的 microtasks 步骤。(从任务队列中取出一个宏任务并执行)</p>
<p>1.1 将上边选择的 task 设置为正在运行的 task</p>
<p>1.2 Run: 运行被选择的 task。</p>
<p>1.3 将 event loop 的 currently running task 变为 null。</p>
<p>1.4 从 task 队列里移除前边运行的 task。</p>
</li>
<li><p>Microtasks: 执行 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">microtasks 任务检查点</a>。（检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。）</p>
</li>
<li><p>进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）</p>
<ul>
<li>浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。</li>
<li>如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。</li>
<li>如果满足以下条件，也会跳过渲染：<ul>
<li>浏览器判断更新渲染不会带来视觉上的改变。</li>
<li>map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：</p>
</li>
</ol>
<blockquote>
<p>This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.<br>有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask 的执行，而不会穿插屏幕渲染相关的流程</p>
</blockquote>
<ol start="5">
<li><p>对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 resize 方法。</p>
</li>
<li><p>对于需要渲染的文档，如果页面发生了滚动，执行 scroll 方法。</p>
</li>
<li><p>对于需要渲染的文档，执行帧动画回调，也就是 requestAnimationFrame 的回调。（后文会详解）</p>
</li>
<li><p>对于需要渲染的文档， 执行 IntersectionObserver 的回调。</p>
</li>
<li><p>对于需要渲染的文档，重新渲染绘制用户界面。</p>
</li>
<li><p>判断 task 队列和 microTask 队列是否都为空，如果是的话，则进行 Idle 空闲周期的算法，判断是否要执行 requestIdleCallback 的回调函数。（后文会详解）</p>
</li>
</ol>
<p>对于 resize 和 scroll 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据 CSSOM 规范所讲，浏览器会保存一个 pending scroll event targets，等到事件循环中的 scroll 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。resize 也是同理。</p>
<h2 id="microtasks-检查点（microtask-checkpoint）"><a href="#microtasks-检查点（microtask-checkpoint）" class="headerlink" title="microtasks 检查点（microtask checkpoint）"></a>microtasks 检查点（microtask checkpoint）</h2><p>上文 event loop 处理流程第 2 步，执行了一个 microtask checkpoint，看看规范如何描述 microtask checkpoint：</p>
<p>当用户代理去执行一个 microtask checkpoint，如果 microtask checkpoint 的 flag（标识）为 false，用户代理必须运行下面的步骤：</p>
<ol>
<li>将 microtask checkpoint 的 flag 设为 true。</li>
<li>Microtask queue handling: 如果 event loop 的 microtask 队列为空，直接跳到第八步（Done）。</li>
<li>在 microtask 队列中选择最老的一个任务。</li>
<li>将上一步选择的任务设为 event loop 的 currently running task。</li>
<li>运行选择的任务。</li>
<li>将 event loop 的 currently running task 变为 null。</li>
<li>将前面运行的 microtask 从 microtask 队列中删除，然后返回到第二步（Microtask queue handling）。</li>
<li>Done: 每一个 environment settings object 它们的 responsible event loop 就是当前的 event loop，会给 environment settings object 发一个 rejected promises 的通知。</li>
<li>清理 IndexedDB 的事务。</li>
<li>将 microtask checkpoint 的 flag 设为 flase。</li>
</ol>
<p>microtask checkpoint 所做的就是执行 microtask 队列里的任务。什么时候会调用 microtask checkpoint 呢?</p>
<ul>
<li>当上下文执行栈为空时，执行一个 microtask checkpoint。</li>
<li>在 event loop 的第六步（Microtasks: Perform a microtask checkpoint）执行 checkpoint，也就是在运行 task 之后，更新渲染之前。</li>
</ul>
<h2 id="多任务队列"><a href="#多任务队列" class="headerlink" title="多任务队列"></a>多任务队列</h2><p>上文也提到了，每一个 task 都来源于指定的任务源， 所以 task 队列并不是我们想象中的那样只有一个，根据规范里的描述：</p>
<blockquote>
<p>An event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.</p>
</blockquote>
<p>事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：</p>
<ol>
<li>鼠标和键盘事件</li>
<li>其他的一些 Task</li>
</ol>
<p>浏览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。</p>
<p>这个规范也导致 vue 的这个<a href="https://github.com/vuejs/vue/issues/3771" target="_blank" rel="noopener">Issue</a>。简单描述一下就是采用了 task 实现的 nextTick，在用户持续滚动的情况下 nextTick 任务被延后了很久才去执行，导致动画跟不上滚动了。</p>
<p>迫于无奈，尤大还是改回了 microTask 去实现 nextTick，目前来说 promise.then 微任务已经很稳定并且 vue3 就是这样实现的，并且 Chrome 也已经实现了 queueMicroTask 这个官方 API。我们想要调用微任务队列的话，也可以节省掉实例化 Promise 在开销了。</p>
<p>从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。</p>
<h2 id="执行栈（JavaScript-execution-context-stack）"><a href="#执行栈（JavaScript-execution-context-stack）" class="headerlink" title="执行栈（JavaScript execution context stack）"></a>执行栈（JavaScript execution context stack）</h2><p>task 和 microtask 都是推入栈中执行的，要完整了解 event loops 还需要认识 JavaScript execution context stack，它的规范位于<a href="https://tc39.github.io/ecma262/#execution-context-stack。" target="_blank" rel="noopener">https://tc39.github.io/ecma262/#execution-context-stack。</a></p>
<p>javaScript 是单线程，也就是说只有一个主线程，主线程有一个栈，每一个函数执行的时候，都会生成新的 execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。</p>
<p><img src="../images/eventloop/image-1.png" alt="alt text"></p>
<p>举个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>执行过程中栈的变化：<br><img src="../images/eventloop/image-2.png" alt="alt text"></p>
<h4 id="完整异步过程"><a href="#完整异步过程" class="headerlink" title="完整异步过程"></a>完整异步过程</h4><p>主线程类似一个加工厂，它只有一条流水线，待执行的任务就是流水线上的原料，只有前一个加工完，后一个才能进行。event loops 就是把原料放上流水线的工人。只要已经放在流水线上的，它们会被依次处理，称为同步任务。一些待处理的原料，工人会按照它们的种类排序，在适当的时机放上流水线，这些称为异步任务。</p>
<p><img src="../images/eventloop/image-3.png" alt="alt text"></p>
<p>举个简单的例子，假设一个 script 标签的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>运行过程：</p>
<p>script 里的代码被列为一个 task，放入 task 队列。</p>
<ul>
<li><p><strong>循环 1</strong>：</p>
</li>
<li><p>【task 队列：script ；microtask 队列：】</p>
<ul>
<li>1.从 task 队列中取出 script 任务，推入栈中执行。</li>
<li>2.promise1 列为 microtask，setTimeout1 列为 task，setTimeout2 列为 task。</li>
</ul>
</li>
<li><p>task 队列：setTimeout1 setTimeout2；microtask 队列：promise1】</p>
<ul>
<li>3.script 任务执行完毕，执行 microtask checkpoint，取出 microtask 队列的 promise1 执行。</li>
</ul>
</li>
<li><p><strong>循环 2</strong>：</p>
</li>
<li><p>【task 队列：setTimeout1 setTimeout2；microtask 队列：】</p>
<ul>
<li>4.从 task 队列中取出 setTimeout1，推入栈中执行，将 promise2 列为 microtask。</li>
</ul>
</li>
<li><p>【task 队列：setTimeout2；microtask 队列：promise2】</p>
<ul>
<li>5.执行 microtask checkpoint，取出 microtask 队列的 promise2 执行。</li>
</ul>
</li>
<li><p><strong>循环 3</strong>：</p>
</li>
<li><p>【task 队列：setTimeout2；microtask 队列：】</p>
<ul>
<li>6.从 task 队列中取出 setTimeout2，推入栈中执行。</li>
<li>7.setTimeout2 任务执行完毕，执行 microtask checkpoint。</li>
</ul>
</li>
<li><p>【task 队列：；microtask 队列：】</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是对 event loop 规范 和一些运行的流程做的总结。但是包括 requestAnimationFrame，requestIdleCallback 和 浏览器中 js 的执行机制等细节的总结将会单独写文章进行归纳总结。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/Gitlab%20CI_CD%20%E5%AE%9E%E8%B7%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/Gitlab%20CI_CD%20%E5%AE%9E%E8%B7%B5.html" class="post-title-link" itemprop="url">Gitlab CI/CD 实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-07-20T00:00:00+08:00">2023-07-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GitLab CI/CD 是一个内置在 GitLab 中的工具，用于通过持续方法进行软件开发：</p>
<h5 id="Continuous-Integration（持续集成）"><a href="#Continuous-Integration（持续集成）" class="headerlink" title="Continuous Integration（持续集成）"></a>Continuous Integration（持续集成）</h5><p>假设一个应用程序，其代码存储在 GitLab 的 Git 仓库中。开发人员每天都要多次推送代码更改。对于每次向仓库的推送，你都可以创建一组脚本来自动构建和测试你的应用程序，从而减少了向应用程序引入错误的机会。这种做法称为持续集成，对于提交给应用程序（甚至是开发分支）的每项更改，它都会自动连续进行构建和测试，以确保所引入的更改通过你为应用程序建立的所有测试，准则和代码合规性标准。</p>
<h5 id="Continuous-Delivery（持续交付）"><a href="#Continuous-Delivery（持续交付）" class="headerlink" title="Continuous Delivery（持续交付）"></a>Continuous Delivery（持续交付）</h5><p>持续交付是超越持续集成的更进一步的操作。应用程序不仅会在推送到代码库的每次代码更改时进行构建和测试，而且，尽管部署是手动触发的，但作为一个附加步骤，它也可以连续部署。此方法可确保自动检查代码，但需要人工干预才能从策略上手动触发以必输此次变更。</p>
<h5 id="Continuous-Deployment（持续部署）"><a href="#Continuous-Deployment（持续部署）" class="headerlink" title="Continuous Deployment（持续部署）"></a>Continuous Deployment（持续部署）</h5><p>与持续交付类似，但不同之处在于，你无需将其手动部署，而是将其设置为自动部署。完全不需要人工干预即可部署你的应用程序。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>为了使用 GitLab CI/CD，你需要一个托管在 GitLab 上的应用程序代码库，并且在根目录中的.gitlab-ci.yml 文件中指定构建、测试和部署的脚本。</p>
<p>在这个文件中，你可以定义要运行的脚本，定义包含的依赖项，选择要按顺序运行的命令和要并行运行的命令，定义要在何处部署应用程序，以及指定是否 要自动运行脚本或手动触发脚本。</p>
<p>为了可视化处理过程，假设添加到配置文件中的所有脚本与在计算机的终端上运行的命令相同。</p>
<p>一旦你已经添加了.gitlab-ci.yml 到仓库中，GitLab 将检测到该文件，并使用名为 GitLab Runner 的工具运行你的脚本。该工具的操作与终端类似。</p>
<p>这些脚本被分组到 jobs，它们共同组成一个 pipeline。一个最简单的.gitlab-ci.yml 文件可能是这样的：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">rubygems</span> <span class="string">ruby-dev</span> <span class="string">-y</span></span><br><span class="line"></span><br><span class="line"><span class="attr">run-test:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ruby</span> <span class="string">--version</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>before_script 属性将在运行任何内容之前为你的应用安装依赖，一个名为 run-test 的 job（作业）将打印当前系统的 Ruby 版本。二者共同构成了在每次推送到仓库的任何分支时都会被触发的 pipeline（管道）。</p>
<p>GitLab CI/CD 不仅可以执行你设置的 job，还可以显示执行期间发生的情况，正如你在终端看到的那样：<br><img src="/images/GitlabCI_CD.resources/2551D6FD-98FB-42FB-B217-232C6028B2AC.png" alt="74b8f022354a48a2a663a996ae2c1dd8"></p>
<h4 id="通过-GitLab-UI-所有的步骤都是可视化的"><a href="#通过-GitLab-UI-所有的步骤都是可视化的" class="headerlink" title="通过 GitLab UI 所有的步骤都是可视化的"></a>通过 GitLab UI 所有的步骤都是可视化的</h4><p><img src="/images/GitlabCI_CD.resources/E239A99B-76CC-4F14-9DA2-4286A51588B9.png" alt="aae548d462b9c6b5e8bab016b96c5512"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h4 id="创建一个-gitlab-ci-yml-文件"><a href="#创建一个-gitlab-ci-yml-文件" class="headerlink" title="创建一个.gitlab-ci.yml 文件"></a>创建一个.gitlab-ci.yml 文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"><span class="attr">commitlint:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">lint</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^chore\(release\)/'</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^Merge branch/'</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span> <span class="comment"># 一般当分支master有 push 或 merge 时才会执行该工作</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span> <span class="string">bin/commitlint-gitlab-ci.sh</span></span><br><span class="line"><span class="attr">release:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">semantic-release</span></span><br></pre></td></tr></table></figure>

<h4 id="配置一个-Runner"><a href="#配置一个-Runner" class="headerlink" title="配置一个 Runner"></a>配置一个 Runner</h4><p>在 GitLab 中，Runner 运行你定义在.gitlab-ci.yml 中的作业（job）<br>一个 Runner 可以是一个虚拟机、物理机、docker 容器，或者一个容器集群 GitLab 与 Runner 之间通过 API 进行通信，因此只需要 Runner 所在的机器有网络并且可以访问 GitLab 服务器即可<br>你可以去  <strong>Settings ➔ CI/CD</strong>  看是否已经有 Runner 关联到你的项目，设置 Runner 简单又直接<br><img src="/images/GitlabCI_CD.resources/A9EF490C-2A96-495A-AEBC-135E32A9FAE1.png" alt="7b99f010133b6b0689a1dc90c2893831"></p>
<h4 id="查看-pipeline-和-jobs-状态"><a href="#查看-pipeline-和-jobs-状态" class="headerlink" title="查看 pipeline 和 jobs 状态"></a>查看 pipeline 和 jobs 状态</h4><p><img src="/images/GitlabCI_CD.resources/159D77C9-7C89-4B37-8A6A-9DB90473D0ED.png" alt="e57d2652f09e520231cae9358ac69e10"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>团队计划使用 semantic-release 自动管理发布版本，结合 Gitlab CI/CD 是一个很不错的选择，具体的实践过程和心得会在后面分享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/chrome%20performance%E9%9D%A2%E6%9D%BF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/chrome%20performance%E9%9D%A2%E6%9D%BF.html" class="post-title-link" itemprop="url">chrome performance 面板解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-15T00:00:00+08:00">2023-06-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概况图"><a href="#概况图" class="headerlink" title="概况图"></a>概况图</h2><p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/B31D1703-5E66-4F19-8D12-448E4D283BC9.png" alt="71d6a82a01519413ca2a1be4b957c544"></p>
<h4 id="无痕模式"><a href="#无痕模式" class="headerlink" title="无痕模式"></a>无痕模式</h4><p>无痕模式可以保证 Chrome 在一个相对干净的环境下运行，避免 chrome 上安装的插件影响性能分析结果。<br>文件—&gt;打开新的无痕式窗口，或使用快捷键 ctrl + shift + N 打开无痕模式下的 chrome 新标签页</p>
<h4 id="性能记录"><a href="#性能记录" class="headerlink" title="性能记录"></a>性能记录</h4><p>点击面板里的 ○，可以记录运行时的性能记录，如下图：<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/8B1B5662-14CE-47BA-A799-07447D14021C.png" alt="0b82ba7820c6d3ec5b21fe563191a08d"></p>
<p>再次点击 Record 或者点击 Stop 停止记录。</p>
<h4 id="加载时性能记录录制"><a href="#加载时性能记录录制" class="headerlink" title="加载时性能记录录制"></a>加载时性能记录录制</h4><p>若要分析页面记载时性能需要录制加载时性能。</p>
<ol>
<li>打开待分析性能的页面。</li>
<li>打开 Devtools 中 Performance 窗口。</li>
<li>点击左上角重新加载按钮。DevTools 会自动记录页面加载是各项性能指标，加载完成几秒后自动停止记录。<br>Devtools 记录会自动增加<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/8BE55FF4-23D8-4373-9700-6FC306487719.png" alt="bcc3faa215dab1b20aefba15f42fa29d"></li>
</ol>
<p>页面加载时记录<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/2E1306AE-F26B-4DE5-8E02-96106AA7CA11.png" alt="8faf902b1637f885df323e7791713c33"></p>
<h4 id="清除记录"><a href="#清除记录" class="headerlink" title="清除记录"></a>清除记录</h4><p>清除 Performance 窗口中的记录数据。</p>
<h4 id="抓取运行时屏幕快照"><a href="#抓取运行时屏幕快照" class="headerlink" title="抓取运行时屏幕快照"></a>抓取运行时屏幕快照</h4><p>点选 Screenshots 选项开启为每一帧记录屏幕快照功能。</p>
<h4 id="查看内存度量值"><a href="#查看内存度量值" class="headerlink" title="查看内存度量值"></a>查看内存度量值</h4><p>点选 Memory 选项打开内存度量功能。<br>DevTools 在 Summary 面板上侧显示一个新的 Memory 图表。在 NET 图表下边也显示一个 HEAP 图表。HEAP 图表提供的信息同 Memory 面板中 JS Heap 提供的信息相同。</p>
<h4 id="开启加速渲染工具"><a href="#开启加速渲染工具" class="headerlink" title="开启加速渲染工具"></a>开启加速渲染工具</h4><p>点选 Enable advanced paint instrumentation 选项（会带来大量的性能开销）</p>
<h4 id="控制录制过程中-CPU-工作频率"><a href="#控制录制过程中-CPU-工作频率" class="headerlink" title="控制录制过程中 CPU 工作频率"></a>控制录制过程中 CPU 工作频率</h4><p>将 CPU 设置为需要的运算速度模式。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9DD1F5C8-9131-4F02-BDA0-8D5DCB6095A3.png" alt="886c6b4d80132d8e286af2d6ed89cdb9"></p>
<p>CPU 工作频率的控制结果跟实际使用的机器能力有关。例如，4x slowdown 选项会使你本地 CPU 运算速率比正常情况下降低 4 倍。不同设备由于设计架构不同，Devtools 不能精确模拟移动端设备的 CPU 运算模式。</p>
<h4 id="保存记录"><a href="#保存记录" class="headerlink" title="保存记录"></a>保存记录</h4><p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/F4D6D133-2769-4173-9090-79276AFC56D4.png" alt="da01643afd3f94a7927b96b2ddd7a044"><br>会生成 JSON 文件</p>
<h4 id="加载记录"><a href="#加载记录" class="headerlink" title="加载记录"></a>加载记录</h4><p>单击鼠标右键选择 Load Profile 加载记录</p>
<h2 id="分析性能记录"><a href="#分析性能记录" class="headerlink" title="分析性能记录"></a>分析性能记录</h2><p>运行时或者加载时性能录制结束后，在 Performance 窗口中会显示相关数据，从而对于记录过程中的情况进行分析。</p>
<h4 id="选择记录中的一部分"><a href="#选择记录中的一部分" class="headerlink" title="选择记录中的一部分"></a>选择记录中的一部分</h4><p>在 Overview 窗口中，可以选中记录的某一部分。 Overview 窗口指的是包含 FPS, CPU 和 NET 图表部分。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/7D7EC5FB-7086-4767-99DB-4BCB7AE4E430.png" alt="3c66d685cee9f55228ca867b5a07a88e"></p>
<h4 id="查看主线程活动"><a href="#查看主线程活动" class="headerlink" title="查看主线程活动"></a>查看主线程活动</h4><p>利用 Main 区域查看页面主线程加载时的主要活动。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/A2BE4509-9F3E-4AAC-90D2-E0F68820471A.png" alt="26247567fd6f9281d4a16d8fcbcba32f"></p>
<p>点击某一函数在 Summary 窗口中查看更多详细信息。如图中所示 DevTools 选中_getRequestData 事件。<br>DevTools 采用随机的颜色标识脚本信息，如上面图中浅绿色标识函数调用，深黄色标识脚本活动。<br>若想隐藏火焰图中的 JavaScript 中调用的详细信息，请查看前面介绍的禁用 JavaScript 样例功能。若禁用 JavaScript 样例功能，你只可以看到初始调用事件。比如，图中标识的 Timer fired 和 Function Call 。</p>
<h4 id="在表格中查看活动"><a href="#在表格中查看活动" class="headerlink" title="在表格中查看活动"></a>在表格中查看活动</h4><p>录制结束后，利用 Main 窗口中信息不是分析数据的唯一方式。DevTools 另外提供了三种表格式分析活动方式，每种方式都是从不同的角度出发:<br>若想分析那些活动占用时间更多时，可以利用 Bottom-Up 窗口。<br>若想分析导致更多活动的根活动时，可以采用 Call Tree。<br>若想按顺序分析记录中发生的活动时，可以利用 Event Log 窗口。</p>
<h4 id="根活动"><a href="#根活动" class="headerlink" title="根活动"></a>根活动</h4><p>根活动指的是浏览器触发的一系列流程。例如，当你点击页面内容，浏览器触发一个 Event 作为根活动，该 Event 可能回调一个事件处理事件。<br>在 Main 面板中的火焰图中，根活动展示在上部，在 Call Tree 和 Event Log 面板中，根活动展示在顶层。</p>
<h4 id="Call-Tree-标签页"><a href="#Call-Tree-标签页" class="headerlink" title="Call Tree 标签页"></a>Call Tree 标签页</h4><p>Call Tree 标签页中展示记录中被选中部分的活动信息。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9E98C9B1-90D8-4D50-A6BC-FDCB4EB51B0F.png" alt="6f4e0500bac02ec6143b950c159c63ae"></p>
<p>图中 Activity 列中显示的 Timer fired、 Paint、Recalculate Style 和 Layout 代表根活动。层级嵌套表示代表回调栈。如图中 Function Call 调用 u，再调用 getImageUrl，继续调用 getLinkUrl 等等。<br>Self Time 表示对应活动消耗的时间，Total Time 表示对应活动以及子活动共同消耗的时间。<br>点击 Self Time，Total Time 或者 Activity 表头区域，可按对应列排序。<br>利用 Filter 输入框区域，输入活动名过滤事件。<br>Grouping 分组菜单默认为 No Grouping，利用该功能可以根据不同的分类将活动进行分组。<br>点击右侧 Show Heaviest Stack，在右侧展示当前选中活动中占用时间最多的子活动信息。</p>
<p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/BBFE6629-C9A4-4901-A79C-3E850194B322.png" alt="6562aca6f7e21ca7a5746f1cff491455"></p>
<h4 id="Bottom-Up-标签页"><a href="#Bottom-Up-标签页" class="headerlink" title="Bottom-Up 标签页"></a>Bottom-Up 标签页</h4><p>利用 Bottom-Up 标签查看占用最多时间的活动。<br>Self Time 表示对应活动消耗的时间。<br>Total Time 表示对应活动以及子活动共同消耗的时间。</p>
<h4 id="Event-Log-标签页"><a href="#Event-Log-标签页" class="headerlink" title="Event Log 标签页"></a>Event Log 标签页</h4><p>Event Log 标签页按顺序展示记录中发生的活动。<br>Start Time 列表示该项活动的开始时间，该时间相对于记录开始时间计算。例如图中选中项开始时间为 1566.2 ms，代表该活动在记录开始之后 1566.2 ms 后开始。<br>Self Time 表示对应活动消耗的时间。<br>Total Time 表示对应活动以及子活动共同消耗的时间。<br>点击 Start Time 、Self Time、Total Time 表头区域，可按对应列排序。<br>利用 Filter 输入框区域，输入活动名过滤事件。<br>利用 Duration 下拉菜单过滤&gt;=1ms 或者&gt;=15ms 的活动。该菜单默认选中 All 选项，展示所有活动。<br>利用 Loading、Experience、Scripting、Rendering、Painting 选项进行分类过滤。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9278865D-99FC-4945-A7DA-55264A743F15.png" alt="58c29a0d627c26c7d9fc1afd80a348ef"></p>
<h4 id="分析每秒传输帧数（FPS）"><a href="#分析每秒传输帧数（FPS）" class="headerlink" title="分析每秒传输帧数（FPS）"></a>分析每秒传输帧数（FPS）</h4><ul>
<li>查看 FPS 图表了解整个记录中 FPS 的概况。</li>
<li>Frames 模块查看每一帧时间消耗。</li>
<li>利用 FPS meter 工具(MoreTools—&gt;Rendering)在页面运行时实时查看 FPS 信息。</li>
</ul>
<h4 id="FPS-图表"><a href="#FPS-图表" class="headerlink" title="FPS 图表"></a>FPS 图表</h4><p>FPS 图表显示了整个记录过程中帧率的概况。图表中绿色折线越高代表帧率越好。<br>FPS 折线图上测出现的红色横线为一条性能警示线，表示帧率低于该值会严重影响用户体验。</p>
<h4 id="Frames-模块"><a href="#Frames-模块" class="headerlink" title="Frames 模块"></a>Frames 模块</h4><p>Frames 模块清晰表明每个帧消耗时间。<br>鼠标在某一帧上悬停可以查看更多详细信息。</p>
<h4 id="查看交互信息"><a href="#查看交互信息" class="headerlink" title="查看交互信息"></a>查看交互信息</h4><p>利用 Interactions 模块查看并分析记录过程中用户的交互操作。</p>
<h4 id="查看-GPU-活动"><a href="#查看-GPU-活动" class="headerlink" title="查看 GPU 活动"></a>查看 GPU 活动</h4><p>在 GPU 模块查看 GPU 活动信息<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/DCF59BFE-D663-4BF2-B581-1562C15B425E.png" alt="69c660e3d248b30ffc310f2813525e08"></p>
<h4 id="查看栅格活动"><a href="#查看栅格活动" class="headerlink" title="查看栅格活动"></a>查看栅格活动</h4><p>在 Raster 模块查看栅格活动信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.html" class="post-title-link" itemprop="url">前端脚手架搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-04T00:00:00+08:00">2023-05-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于公司标准化产品逐渐成熟，项目越来越多，需要一款脚手架通过业务标准化模板自动生成项目，可以让开发人员专注于业务开发，降低心智成本，提升团队效率。</p>
<p>参考了常用的脚手架，create-react-app、vue-cli、egg-init 的实现，搭建出了一套符合团队实际情况的脚手架工具。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>脚手架就是在启动的时候询问一些简单的问题，并且通过用户回答的结果去渲染对应的模板文件。</strong><br>基本工作流程如下：</p>
<ol>
<li>通过命令行交互询问用户问题</li>
<li>拉取远端标准化模板</li>
<li>根据用户回答的结果生成文件</li>
<li>自动下载依赖</li>
</ol>
<h4 id="热门脚手架工具库"><a href="#热门脚手架工具库" class="headerlink" title="热门脚手架工具库"></a>热门脚手架工具库</h4><p><img src="/images/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.resources/81447CFF-3772-41A2-9663-9BFE685C3473.png" alt="116d0e8220abc84e44593738478cbee7"></p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h4 id="1-判断当前环境是否符合要求"><a href="#1-判断当前环境是否符合要求" class="headerlink" title="1. 判断当前环境是否符合要求"></a>1. 判断当前环境是否符合要求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> currentNodeVersion = process.versions.node</span><br><span class="line"><span class="keyword">const</span> semver = currentNodeVersion.split(<span class="string">'.'</span>)</span><br><span class="line"><span class="keyword">const</span> major = semver[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> (major &lt; <span class="number">14</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    <span class="string">'You are running Node '</span> +</span><br><span class="line">      currentNodeVersion +</span><br><span class="line">      <span class="string">'.\n'</span> +</span><br><span class="line">      <span class="string">'Create React App requires Node 14 or higher. \n'</span> +</span><br><span class="line">      <span class="string">'Please update your version of Node.'</span></span><br><span class="line">  )</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-创建脚手架启动命令（使用-commander）"><a href="#2-创建脚手架启动命令（使用-commander）" class="headerlink" title="2. 创建脚手架启动命令（使用 commander）"></a>2. 创建脚手架启动命令（使用 commander）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> commander.Command(packageJson.name)</span><br><span class="line">  .version(packageJson.version)</span><br><span class="line">  .arguments(<span class="string">'&lt;project-directory&gt;'</span>)</span><br><span class="line">  .usage(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span> [options]`</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    projectName = name</span><br><span class="line">  &#125;)</span><br><span class="line">  .parse(process.argv)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> projectName === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Please specify the project directory:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'For example:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'my-app'</span>)&#125;</span>`</span>)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-判断当前脚手架版本是否是最新"><a href="#3-判断当前脚手架版本是否是最新" class="headerlink" title="3. 判断当前脚手架版本是否是最新"></a>3. 判断当前脚手架版本是否是最新</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最新的version</span></span><br><span class="line"><span class="keyword">const</span> checkForLatestVersion = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    http</span><br><span class="line">      .get(url, (res) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> body = <span class="string">''</span></span><br><span class="line">          res.on(<span class="string">'data'</span>, (data) =&gt; (body += data))</span><br><span class="line">          res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(body).version)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">        reject()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkForLatestVersion(<span class="string">`<span class="subst">$&#123;host&#125;</span>create-my-app/latest`</span>)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> execSync(<span class="string">'npm view create-my-app version'</span>).toString().trim()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">latest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (latest &amp;&amp; semver.lt(packageJson.version, latest)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        chalk.yellow(</span><br><span class="line">          <span class="string">`You are running \`create-my-app\` <span class="subst">$&#123;packageJson.version&#125;</span>, which is behind the latest release (<span class="subst">$&#123;latest&#125;</span>).\n\n`</span> +</span><br><span class="line">            <span class="string">'We recommend always using the latest version of create-my-app if possible.'</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">'The latest instructions for creating a new app can be found here:\n'</span> +</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;host&#125;</span>-/web/detail/create-my-app`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createApp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-询问用户问题获取创建所需信息（使用-inquirer）"><a href="#4-询问用户问题获取创建所需信息（使用-inquirer）" class="headerlink" title="4. 询问用户问题获取创建所需信息（使用 inquirer）"></a>4. 询问用户问题获取创建所需信息（使用 inquirer）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getAnswers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'projectZHName'</span>,</span><br><span class="line">      message: <span class="string">'请输入项目中文名'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'version'</span>,</span><br><span class="line">      message: <span class="string">'请输入版本'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'1.0.0'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'author'</span>,</span><br><span class="line">      message: <span class="string">'请输入创建人(拼音全拼)'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-下载远程模板（使用-hyperquest-或-download-git-repo）"><a href="#5-下载远程模板（使用-hyperquest-或-download-git-repo）" class="headerlink" title="5. 下载远程模板（使用 hyperquest 或 download-git-repo）"></a>5. 下载远程模板（使用 hyperquest 或 download-git-repo）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> latest = <span class="keyword">await</span> checkForLatestVersion(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/latest`</span></span><br><span class="line">).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> execSync(<span class="string">'npm view my-frontend-template version'</span>).toString().trim()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; tmpdir, cleanup &#125; = <span class="keyword">await</span> getPackageInfo(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/-/my-frontend-template-<span class="subst">$&#123;latest&#125;</span>.tgz`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extractStream = <span class="function">(<span class="params">stream, dest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    stream.pipe(</span><br><span class="line">      unpack(dest, (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(dest)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getTemporaryDirectory = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Unsafe cleanup lets us recursively delete the directory if it contains</span></span><br><span class="line">    <span class="comment">// contents; by default it only allows removal if it's empty</span></span><br><span class="line">    tmp.dir(&#123; <span class="attr">unsafeCleanup</span>: <span class="literal">true</span> &#125;, (err, tmpdir, callback) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">          tmpdir: tmpdir,</span><br><span class="line">          cleanup: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ignored) &#123;</span><br><span class="line">              <span class="comment">// Callback might throw and fail, since it's a temp directory the</span></span><br><span class="line">              <span class="comment">// OS will clean it up eventually...</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPackageInfo = <span class="function">(<span class="params">installPackage</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (installPackage.match(<span class="regexp">/^.+\.(tgz|tar\.gz)$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getTemporaryDirectory().then(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> stream</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^http/</span>.test(installPackage)) &#123;</span><br><span class="line">        stream = hyperquest(installPackage)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stream = fsExtra.createReadStream(installPackage)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> extractStream(stream, obj.tmpdir).then(<span class="function"><span class="params">()</span> =&gt;</span> obj)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">name</span>: installPackage &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-根据需要读取修改文件和复制文件"><a href="#6-根据需要读取修改文件和复制文件" class="headerlink" title="6. 根据需要读取修改文件和复制文件"></a>6. 根据需要读取修改文件和复制文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; tmpdir, cleanup &#125; = <span class="keyword">await</span> getPackageInfo(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/-/my-frontend-template-<span class="subst">$&#123;latest&#125;</span>.tgz`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = path.resolve(projectName)</span><br><span class="line">fsExtra.mkdirSync(root)</span><br><span class="line">process.chdir(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templates = [</span><br><span class="line">   ...,</span><br><span class="line">    <span class="string">'src/common'</span>,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> templates) &#123;</span><br><span class="line">    fsExtra.copy(templatePath(tmpdir, item), item)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-自动下载依赖"><a href="#7-自动下载依赖" class="headerlink" title="7. 自动下载依赖"></a>7. 自动下载依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'pnpm'</span>, [<span class="string">'install'</span>], &#123; <span class="attr">stdio</span>: <span class="string">'inherit'</span> &#125;)</span><br><span class="line">child.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;chalk.cyan(projectName)&#125;</span> is created <span class="subst">$&#123;chalk.green(<span class="string">'successfully'</span>)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Get Started with the following commands:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;chalk.gray(<span class="string">'$'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'cd'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(projectName)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;chalk.gray(<span class="string">'$'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'pnpm run serve'</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="8-发布和使用"><a href="#8-发布和使用" class="headerlink" title="8. 发布和使用"></a>8. 发布和使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"bin"</span>: &#123;</span><br><span class="line">        <span class="string">"create-my-app"</span>: <span class="string">"./index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>将脚手架发布到公司私库内，在使用中使用一行命令即可完成生成工作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-my-app &lt;project-directory&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章中贴出来了关键部分的脱敏代码，整体主要参考了<a href="https://github.com/facebook/create-react-app/blob/main/packages/create-react-app/createReactApp.js" target="_blank" rel="noopener">create-react-app</a>的实现，对其代码逻辑之严谨深受启发，其几乎对每一个环节可能出现的问题都做了第二种甚至第三种容错处理，在自己实现过程中，学习到了很多，对日后的开发大有帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/webpack-rollup.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/webpack-rollup.html" class="post-title-link" itemprop="url">webpack 和 rollup 对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-15T00:00:00+08:00">2023-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>在打包工具出现之前，在浏览器中运行 Javascript 中有两种写法：</p>
<ul>
<li>第一种方式，引用一些脚本(script 标签)来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。</li>
<li>第二种方式，使用一个包含所有项目代码的大型  .js  文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</li>
</ul>
<p>历史的解决方案：</p>
<ul>
<li>iife</li>
<li>commonjs（最大的问题是浏览器不支持 commonjs，因为 commonjs 是运行时 动态加载的，是同步的，浏览器同步的话，太慢了）</li>
<li>ESM<ul>
<li>未来的官方标准和主流。但是浏览器的版本需要比较高，比如 chorme 都需要 63 版本以上</li>
<li>esm 是静态的，可以在编译的时候就分析出对应的依赖关系，不用像 commonjs 一样，运行时加载</li>
</ul>
</li>
</ul>
<p>背景总结：</p>
<ol>
<li>commonjs 很好，推出 npm 管理 JavaScript 模块包，但浏览器不支持</li>
<li>esm 更好，浏览器也支持，但只有很新的浏览器才支持。 你可以源代码内写 esm 模块，webpack 可以帮忙打包，让不兼容 esm 的浏览器，也能兼容</li>
</ol>
<h2 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h2><p>在了解了背景之后，理解打包原理就很简单了。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="所有内容打包到一个-chunk-包内（单-chunk-包）"><a href="#所有内容打包到一个-chunk-包内（单-chunk-包）" class="headerlink" title="所有内容打包到一个 chunk 包内（单 chunk 包）"></a>所有内容打包到一个 chunk 包内（单 chunk 包）</h4><blockquote>
<p>无额外配置，webpack 一般会把所有 js 打成一个包。实现步骤</p>
</blockquote>
<ul>
<li>读文件，扫描代码，按模块加载顺序，排列模块，分为模块 1，模块 2，…，模块 n 。放到一个作用域内，用 modules 保存，modules 是一个数组，所有模块按加载顺序，索引排序</li>
<li>webpack 自己实现对应的 api（比如自己实现 require），让浏览器支持源代码内的模块化的写法（比如：module.export, require, esm 稍微有些不同 见下方）打包外部依赖也是一样的</li>
</ul>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><ul>
<li><strong>纯 commonjs</strong><ul>
<li><strong>所有的 js 依赖，打包到一个文件内，然后自己实现一套 require 和 module.exports，让浏览器可以执行源代码</strong></li>
<li>源代码的 require 会被换成  <strong>webpack_require</strong></li>
<li>源代码的 module.exports 不变，会由 webpack 作为函数的参数传给源代码</li>
</ul>
</li>
<li><strong>纯 esm</strong><ul>
<li>webpack 会做 tree shaking，最终的产物，会和 rollup 的产物比较接近，不会有过多的 webpack 注入的兼容代码</li>
<li>实现思路类似 rollup，<strong>通过 esm 的静态特性，可以在编译的时候，就分析出对应的依赖关系</strong></li>
</ul>
</li>
<li><strong>esm + commonjs 混用</strong><ul>
<li>webpack 很强大，他是支持混用的！！</li>
<li>你可以 module.exports 导出， import xx from xx 导入</li>
<li>也可以 exports { } 导出，require 引入</li>
<li>实现的思路和上面的模拟 module.exports 和提供<strong>webpack_require</strong>替代 require 的思路类似，<strong>webpack 会去模拟 esm 的 exports 对象</strong> 让浏览器支持</li>
</ul>
</li>
</ul>
<h4 id="多个-chunk-包"><a href="#多个-chunk-包" class="headerlink" title="多个 chunk 包"></a>多个 chunk 包</h4><h5 id="多个打包入口"><a href="#多个打包入口" class="headerlink" title="多个打包入口"></a>多个打包入口</h5><ul>
<li>多个入口分离多个包，然后生成多个 script 标签（按入口的顺序</li>
<li>分离出来的多个包，都包含同样多的模拟代码（webpack 注入的代码）</li>
</ul>
<h5 id="分离公共依赖"><a href="#分离公共依赖" class="headerlink" title="分离公共依赖"></a>分离公共依赖</h5><ul>
<li>先加载 venders 包（第三方公共依赖），此加载不是解析代码，只是把第三方依赖的模块，以 webpack 能解析的格式，存到全局对象 window[“webpackJsonp”]内，方便后续的代码能访问到</li>
<li>只需要把 window[“webpackJsonp”]内的 venders 内的模块，放到 main 代码作用域内的 modules 里面，后面就和单 chunk 解析是一样的了</li>
</ul>
<h5 id="import-动态加载（懒加载）"><a href="#import-动态加载（懒加载）" class="headerlink" title="import() 动态加载（懒加载）"></a>import() 动态加载（懒加载）</h5><ul>
<li><p>先执行 main 模块的内容，从上到下执行，关注 import(‘xx’).then()行。打包后，import()会被替换成 webpack 的 api（<strong>webpack_require</strong>.e(/_ import() _/ 1).then(<strong>webpack_require</strong>.bind(null, 1)).then()）</p>
</li>
<li><p>替换后的 api 做了几件事</p>
<ul>
<li>生成 script 标签，并 appendChild 到 ducument.head 内</li>
<li>return 一个 Promise 对象，状态是 pending（pending 状态不会往后执行.then(<strong>webpack_require</strong>.bind(null, 1)).then()，但不会阻塞主程序，因为是异步的，不懂的可以了解一下 promise）</li>
<li>（异步）等了一段时间后，需求懒加载的模块通过 script 标签，被下载到浏览器后会直接解析执行，触发 window[“webpackJsonp”].push（此方法被改写了，和生成同步多 chunk 有点不一样，会触发 webpackJsonpCallback 函数</li>
<li>webpackJsonpCallback 函数的作用<ul>
<li>懒加载的模块 内容 会被加入到 main 的 mudules 的模块列表内去（等效 push 的作用）</li>
<li>会把 Promise 的状态从 pending 改成 fulfilled，因为要懒加载的模块，通过 script 标签，已经解析完成了，所以.then()可以往后了</li>
</ul>
</li>
<li>后面就是正常解析包，和单 chunk 解析多模块是一样的了</li>
</ul>
</li>
</ul>
<hr>
<h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><p>浏览器环境使用的话：</p>
<ol>
<li>无需考虑浏览器兼容问题的话：<ul>
<li>开发者写 esm 代码 -&gt; rollup 通过入口，递归识别 esm 模块 -&gt; 最终打包成一个或多个 bundle.js -&gt; 浏览器直接可以支持引入<script type="module"></script></li>
</ul>
</li>
<li>需考虑浏览器兼容问题的话<ul>
<li>可能会比较复杂，需要用额外的 polyfill 库，或结合 webpack 使用</li>
</ul>
</li>
</ol>
<p>打包成 npm 包的话：</p>
<ul>
<li>开发者写 esm 代码 -&gt; rollup 通过入口，递归识别 esm 模块 -&gt; （可以支持配置输出多种格式的模块，如 esm、cjs、umd、amd）最终打包成一个或多个 bundle.js<ul>
<li>（开发者要写 cjs 也可以，需要插件@rollup/plugin-commonjs） 初步看来</li>
</ul>
</li>
<li>很明显，rollup 比较适合打包 js 库（react、vue2 等的源代码库都是 rollup 打包的）或 高版本无需往下兼容的浏览器应用程序</li>
<li>这样打包出来的库，可以充分使用上 esm 的 tree shaking，使源库体积最小</li>
</ul>
<h4 id="单-chunk-包"><a href="#单-chunk-包" class="headerlink" title="单 chunk 包"></a>单 chunk 包</h4><p>无额外配置，一般会把所有 js 打成一个包。打包外部依赖（第三方）也是一样的</p>
<h4 id="多-chunk-包"><a href="#多-chunk-包" class="headerlink" title="多 chunk 包"></a>多 chunk 包</h4><ul>
<li>配置多个入口，此法比较简单，可自行测试</li>
<li>代码分离 （动态 import，懒加载， import(xxx).then(module =&gt; {}) ）<ul>
<li><a href="https://rollupjs.org/repl/?version=1.6.0&shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMiUyRiolMjBEWU5BTUlDJTIwSU1QT1JUUyU1Q24lMjAlMjAlMjBSb2xsdXAlMjBzdXBwb3J0cyUyMGF1dG9tYXRpYyUyMGNodW5raW5nJTIwYW5kJTIwbGF6eS1sb2FkaW5nJTVDbiUyMCUyMCUyMHZpYSUyMGR5bmFtaWMlMjBpbXBvcnRzJTIwdXRpbGl6aW5nJTIwdGhlJTIwaW1wb3J0JTIwbWVjaGFuaXNtJTVDbiUyMCUyMCUyMG9mJTIwdGhlJTIwaG9zdCUyMHN5c3RlbS4lMjAqJTJGJTVDbmlmJTIwKGRpc3BsYXlNYXRoKSUyMCU3QiU1Q24lNUN0aW1wb3J0KCcuJTJGbWF0aHMuanMnKS50aGVuKGZ1bmN0aW9uJTIwKG1hdGhzKSUyMCU3QiU1Q24lNUN0JTVDdGNvbnNvbGUubG9nKG1hdGhzLnNxdWFyZSg1KSklM0IlNUNuJTVDdCU1Q3Rjb25zb2xlLmxvZyhtYXRocy5jdWJlKDUpKSUzQiU1Q24lNUN0JTdEKSUzQiU1Q24lN0QlMjIlMkMlMjJpc0VudHJ5JTIyJTNBdHJ1ZSU3RCUyQyU3QiUyMm5hbWUlMjIlM0ElMjJtYXRocy5qcyUyMiUyQyUyMmNvZGUlMjIlM0ElMjJpbXBvcnQlMjBzcXVhcmUlMjBmcm9tJTIwJy4lMkZzcXVhcmUuanMnJTNCJTVDbiU1Q25leHBvcnQlMjAlN0JkZWZhdWx0JTIwYXMlMjBzcXVhcmUlN0QlMjBmcm9tJTIwJy4lMkZzcXVhcmUuanMnJTNCJTVDbiU1Q25leHBvcnQlMjBmdW5jdGlvbiUyMGN1YmUlMjAoeCUyMCklMjAlN0IlNUNuJTVDdHJldHVybiUyMHNxdWFyZSh4KSUyMColMjB4JTNCJTVDbiU3RCUyMiUyQyUyMmlzRW50cnklMjIlM0FmYWxzZSU3RCUyQyU3QiUyMm5hbWUlMjIlM0ElMjJzcXVhcmUuanMlMjIlMkMlMjJjb2RlJTIyJTNBJTIyZXhwb3J0JTIwZGVmYXVsdCUyMGZ1bmN0aW9uJTIwc3F1YXJlJTIwKCUyMHglMjApJTIwJTdCJTVDbiU1Q3RyZXR1cm4lMjB4JTIwKiUyMHglM0IlNUNuJTdEJTIyJTJDJTIyaXNFbnRyeSUyMiUzQWZhbHNlJTdEJTVEJTJDJTIyb3B0aW9ucyUyMiUzQSU3QiUyMmZvcm1hdCUyMiUzQSUyMmNqcyUyMiUyQyUyMm5hbWUlMjIlM0ElMjJteUJ1bmRsZSUyMiUyQyUyMmFtZCUyMiUzQSU3QiUyMmlkJTIyJTNBJTIyJTIyJTdEJTJDJTIyZ2xvYmFscyUyMiUzQSU3QiU3RCU3RCUyQyUyMmV4YW1wbGUlMjIlM0FudWxsJTdE" target="_blank" rel="noopener">此处有一个官方的例子，再清楚不过了</a></li>
<li>对于代码分割，还有一种方法可以通过  output.manualChunks  选项显式告诉 Rollup 哪些模块要分割成单独的块。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a>webpack</h3><blockquote>
<p><code>webpack</code> 诞生在 <code>esm</code> 标准出来前，<code>commonjs</code> 出来后</p>
</blockquote>
<ul>
<li><p>当时的浏览器只能通过 script 标签加载模块</p>
<ul>
<li><strong>script 标签加载代码是没有作用域的，只能在代码内 用 iife 的方式 实现作用域效果</strong><ul>
<li>这就是 webpack 打包出来的代码 大结构都是 iife 的原因</li>
<li>并且<strong>每个模块都要装到 function 里面</strong>，才能保证互相之间作用域不干扰。</li>
<li>这就是为什么 webpack 打包的代码为什么乍看会感觉乱，找不到自己写的代码的真正原因</li>
</ul>
</li>
</ul>
</li>
<li><p>关于 webpack 的代码注入问题，是因为<strong>浏览器不支持 cjs</strong>，所以 webpack 要去<strong>自己实现 require 和 module.exports 方法</strong>（才有很多注入）</p>
<ul>
<li>这么多年了，甚至到现在 2022 年，<strong>浏览器为什么不支持 cjs</strong>？<ul>
<li><strong>cjs 是同步的，运行时的，node 环境用 cjs，node 本身运行在服务器，无需等待网络握手，所以同步处理是很快的</strong></li>
<li><strong>浏览器是 客户端，访问的是服务端资源，中间需要等待网络握手，可能会很慢，所以不能 同步的 卡在那里等服务器返回的，体验太差</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>后续出来 esm 后，webpack 为了兼容以前发在 npm 上的老包</strong>（并且当时心还不够决绝，导致这种“丑结构的包”越来越多，以后就更不可能改这种“丑结构了”），所以保留这个 iife 的结构和代码注入，<strong>导致现在看 webpack 打包的产物，乍看结构比较乱且有很多的代码注入，自己写的代码都找不到</strong></p>
</li>
</ul>
<h3 id="rollup-1"><a href="#rollup-1" class="headerlink" title="rollup"></a>rollup</h3><blockquote>
<p>rollup 诞生在 esm 标准出来后</p>
</blockquote>
<ul>
<li><strong>出发点就是希望开发者去写 esm 模块</strong>，这样适合做代码静态分析，可以做 tree shaking 减少代码体积，也是浏览器除了 script 标签外，真正让 JavaScript 拥有模块化能力。是 js 语言的未来</li>
<li><strong>rollup 完全依赖高版本浏览器原生去支持 esm 模块，所以无额外代码注入，打包后的代码结构也是清晰的</strong>（不用像 webpack 那样 iife）<ul>
<li>目前浏览器支持模块化只有 3 种方法：<ul>
<li>script 标签（缺点没有作用域的概念</li>
<li>script 标签 + iife + window + 函数作用域（可以解决作用域问题。webpack 的打包的产物就这样</li>
<li>esm （什么都好，唯一缺点 需要高版本浏览器）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="最终使用推荐"><a href="#最终使用推荐" class="headerlink" title="最终使用推荐"></a>最终使用推荐</h2><ol>
<li>打包<strong>开源库</strong>：rollup 会是更好的选择</li>
<li>打包应用程序：看是否需要<strong>兼容老浏览器</strong><br>如果不考虑兼容老浏览器，建议用 <code>vite</code> 开发应用程序，<code>vite</code>打包实际使用的就是<code>rollup</code>，开发体验很棒，打的生产包比用<code>webpack</code>小很多，有不错的性能提升<br>如果需要考虑兼容，则选择<code>webpack</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/tsconfig.json%E6%96%87%E4%BB%B6%E5%85%A8%E8%A7%A3%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/tsconfig.json%E6%96%87%E4%BB%B6%E5%85%A8%E8%A7%A3%E6%9E%90.html" class="post-title-link" itemprop="url">tsconfig.json文件解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-10T00:00:00+08:00">2023-03-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>TypeScript</code>带来的类型系统以及强大的<code>IDE</code>支持，让前端开发也变得严谨而流畅。但<code>TypeScript</code>不是原生的<code>Javascript</code>代码，需要进行编译才能转换为<code>Javascript</code>代码。</p>
<p><code>tsconfig.json</code>是编译<code>TypeScript</code>的配置文件，对书写<code>TypeScript</code>代码十分重要。接下来会介绍一些常用的编译选项和所有<code>tsconfig.json</code>选项的解释。</p>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h4 id="1-experimentalDecorators"><a href="#1-experimentalDecorators" class="headerlink" title="1.experimentalDecorators"></a>1.experimentalDecorators</h4><p><code>是否启用实验性的ES装饰器</code>。 默认值：<strong>false</strong>, <a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">官方解释</a></p>
<p>TypeScript 和 ES6 中引入了 Class 的概念，同时在 stage 2 proposal (opens new window)提出了 Java 等服务器端语言早就有的装饰器模式。通过引入装饰器模式，能极大简化书写代码，把一些通用逻辑封装到装饰器中。</p>
<h4 id="2-strictPropertyInitialization"><a href="#2-strictPropertyInitialization" class="headerlink" title="2.strictPropertyInitialization"></a>2.strictPropertyInitialization</h4><p><code>是否类的非undefined属性已经在构造函数里初始化</code>。 默认值：<strong>false</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> </span>&#123;</span><br><span class="line">  id: string <span class="comment">// 如果开启strictPropertyInitialization，则这里会报错，因为没有赋值默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-noImplicitAny"><a href="#3-noImplicitAny" class="headerlink" title="3.noImplicitAny"></a>3.noImplicitAny</h4><p><code>有隐含的 any类型时是否报错</code>。 默认值：<strong>false</strong></p>
<p>ts 是有默认推导的，同时还有 any 类型，所以不是每个变量或参数定义需要明确告知类型是什么。如果开启该值，当有隐含 any 类型时，会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当开启noImplicitAny时，需要隐含当any需要明确指出</span></span><br><span class="line">arr.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.name === name) <span class="comment">// error</span></span><br><span class="line">arr.find(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> item.name === name) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h4 id="4-target"><a href="#4-target" class="headerlink" title="4.target"></a>4.target</h4><p><code>指定编译的ECMAScript目标版本</code>。默认值: “ES3”<a href="https://www.typescriptlang.org/tsconfig#target" target="_blank" rel="noopener">官方解释</a><br>枚举值：”ES3”， “ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”，”ES2018”，”ES2019”，”ES2020”，”ES2021”，”ES2022”，”ESNext”</p>
<blockquote>
<p>target: “ESNext” 是指 tc39 最新的<a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">ECMAScript proposals</a></p>
</blockquote>
<p>当编译 ts 代码时，可以把 ts 转为 ES5 或更早的 js 代码。所以需要选择一个编译的目标版本。</p>
<h4 id="5-module"><a href="#5-module" class="headerlink" title="5.module"></a>5.module</h4><p><code>指定生成哪个模块系统代码</code> <a href="https://www.typescriptlang.org/tsconfig#module" target="_blank" rel="noopener">官方解释</a></p>
<p>枚举值：”None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”， “ES2015”，”ES2020”, “ES2022”, “ESNext”, “node16”, “nodenext”,</p>
<p>默认值根据–target 选项不同而不同，当 target 设置为 ES6 时，默认 module 为“ES6”，否则为“commonjs”</p>
<h4 id="6-lib"><a href="#6-lib" class="headerlink" title="6.lib"></a>6.lib</h4><p><code>编译过程中需要引入的库文件的列表</code></p>
<ul>
<li><a href="https://www.typescriptlang.org/tsconfig#lib" target="_blank" rel="noopener">官方解释</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/typings/lib.html#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">实际场景下的解释</a></li>
</ul>
<p>string[]类型，可选的值有很多，常用的有 ES5，ES6，ESNext，DOM，DOM.Iterable、WebWorker、ScriptHost 等。</p>
<p>该值默认值是根据–target 选项不同而不同。<br>当 target 为 ES5 时，默认值为[‘DOM ‘, ‘ES5’, ‘ScriptHost’];<br>当 target 为 ES6 时，默认值为[‘DOM’, ‘ES6’, ‘DOM.Iterable’, ‘ScriptHost’]</p>
<h4 id="7-moduleResolution"><a href="#7-moduleResolution" class="headerlink" title="7.moduleResolution"></a>7.moduleResolution</h4><p><code>决定如何处理模块</code> <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" target="_blank" rel="noopener">官方解释</a></p>
<p>说直白点，也就是遇到 import { AAA } from ‘./aaa’该如何去找对应文件模块解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在源文件&#x2F;root&#x2F;src&#x2F;A.ts中import &#123; b &#125; from &quot;.&#x2F;moduleB&quot;</span><br><span class="line">&#x2F;&#x2F; 两种解析方式查找文件方式不同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; classic模块解析方式</span><br><span class="line">1. &#x2F;root&#x2F;src&#x2F;moduleB.ts</span><br><span class="line">2. &#x2F;root&#x2F;src&#x2F;moduleB.d.ts</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; node模块解析方式</span><br><span class="line">1. &#x2F;root&#x2F;src&#x2F;moduleB.ts</span><br><span class="line">2. &#x2F;root&#x2F;src&#x2F;moduleB.tsx</span><br><span class="line">3. &#x2F;root&#x2F;src&#x2F;moduleB.d.ts</span><br><span class="line">4. &#x2F;root&#x2F;src&#x2F;moduleB&#x2F;package.json (if it specifies a &quot;types&quot; property)</span><br><span class="line">5. &#x2F;root&#x2F;src&#x2F;moduleB&#x2F;index.ts</span><br><span class="line">6. &#x2F;root&#x2F;src&#x2F;moduleB&#x2F;index.tsx</span><br><span class="line">7. &#x2F;root&#x2F;src&#x2F;moduleB&#x2F;index.d.ts</span><br></pre></td></tr></table></figure>

<h4 id="8-paths"><a href="#8-paths" class="headerlink" title="8.paths"></a>8.paths</h4><p><code>模块名或路径映射的列表</code></p>
<p>这是一个非常有用的选项，比如我们经常使用‘@/util/help’来代替’./src/util/help’，省的每次在不同层级文件 import 模块时,都纠结于是’./‘还是’../‘。该选项告诉编译器遇到匹配的值时，去映射的路径下加载模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"."</span>, <span class="comment">// 注意：baseUrl不可少</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;</span><br><span class="line">      <span class="comment">// 映射列表</span></span><br><span class="line">      <span class="string">"@/*"</span>: [</span><br><span class="line">        <span class="string">"src/*"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"moduleA"</span>: [</span><br><span class="line">        <span class="string">"src/libs/moduleA"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ts code</span></span><br><span class="line"><span class="keyword">import</span> Setting <span class="keyword">from</span> <span class="string">'@/components/Setting.vue'</span> <span class="comment">// 模块实际位置: src/components/Setting.vue</span></span><br><span class="line"><span class="keyword">import</span> TestModule <span class="keyword">from</span> <span class="string">'moduleA/index.js'</span> <span class="comment">// 模块实际位置: src/libs/moduleA/index.js</span></span><br></pre></td></tr></table></figure>

<h4 id="9-strictNullChecks"><a href="#9-strictNullChecks" class="headerlink" title="9.strictNullChecks"></a>9.strictNullChecks</h4><p><code>是否启用严格的 null检查模式</code> 默认值: <strong>false</strong> 建议开启该选项</p>
<p>未处理的 null 和 undefined 经常会导致 BUG 的产生，所以 TypeScript 包含了 strictNullChecks 选项来帮助我们减少对这种情况的担忧。当启用了 strictNullChecks，null 和 undefined 获得了它们自己各自的类型 null 和 undefined。开启该模式有助于发现并处理可能为 undefined 的赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未开启strictNullChecks，number类型包含了null和undefined类型</span></span><br><span class="line"><span class="keyword">let</span> foo: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line">foo = <span class="literal">null</span> <span class="comment">// Okay</span></span><br><span class="line">foo = <span class="literal">undefined</span> <span class="comment">// Okay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> foo: <span class="built_in">string</span>[] | <span class="literal">undefined</span> = arr.find(<span class="function">(<span class="params">key</span>) =&gt;</span> key === <span class="string">'test'</span>)</span><br><span class="line"><span class="comment">// foo.push('1') // error - 'foo' is possibly 'undefined'</span></span><br><span class="line">foo &amp;&amp; foo.push(<span class="string">'1'</span>) <span class="comment">// okay</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：启用 –strict 相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict, –strictNullChecks, –strictFunctionTypes 和–strictPropertyInitialization</p>
</blockquote>
<h4 id="10-noUnusedLocals"><a href="#10-noUnusedLocals" class="headerlink" title="10.noUnusedLocals"></a>10.noUnusedLocals</h4><p><code>有未使用的变量时，是否抛出错误</code> 默认值: <strong>false</strong></p>
<p>当发现变量定义但没有使用时，编译不报错。eslint 的 rule 中也有该条，建议正式项目将该选项开启，设置为 true，使得代码干净整洁</p>
<h4 id="11-noUnusedParameters"><a href="#11-noUnusedParameters" class="headerlink" title="11.noUnusedParameters"></a>11.noUnusedParameters</h4><p><code>有未使用的参数时，是否抛出错误</code> 默认值: <strong>false</strong></p>
<p>建议开启，理由同上。</p>
<h4 id="12-allowJs"><a href="#12-allowJs" class="headerlink" title="12.allowJs"></a>12.allowJs</h4><p><code>是否允许编译javascript文件</code> 默认值: <strong>false</strong></p>
<p>如果设置为 true，js 后缀的文件也会被 typescript 进行编译。</p>
<h4 id="13-typeRoots-和-types"><a href="#13-typeRoots-和-types" class="headerlink" title="13.typeRoots 和 types"></a>13.typeRoots 和 types</h4><p>默认所有可见的”@types”包会在编译过程中被包含进来。如果指定了 typeRoots，只有 typeRoots 下面的包才会被包含进来。如果指定了 types，只有被列出来的 npm 包才会被包含进来。<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html#types-typeroots-and-types" target="_blank" rel="noopener">详细解释</a></p>
<blockquote>
<p>可以指定”types”: []来禁用自动引入@types 包#14. files、include 和 exclude</p>
</blockquote>
<h4 id="14-files、include-和-exclude"><a href="#14-files、include-和-exclude" class="headerlink" title="14.files、include 和 exclude"></a>14.files、include 和 exclude</h4><p><code>编译文件包含哪些文件以及排除哪些文件</code></p>
<p>未设置 include 时，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（.ts, .d.ts 和 .tsx）。如果 allowJs 被设置成 true，JS 文件（.js 和.jsx）也被包含进来。exclude 排除那些不需要编译的文件或文件夹。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"include"</span>: [</span><br><span class="line">        <span class="string">"src/**/*"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"exclude"</span>: [</span><br><span class="line">        <span class="string">"node_modules"</span>,</span><br><span class="line">        <span class="string">"**/*.spec.ts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全解析"><a href="#全解析" class="headerlink" title="全解析"></a>全解析</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'（"ESNext"表示最新的ES语法，包括还处在stage X阶段）</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)。默认是classic</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,         <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">    <span class="string">"strictFunctionTypes"</span>: <span class="literal">false</span>           <span class="comment">// 禁用函数参数双向协变检查。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 指定编译文件或排除指定编译文件 */</span></span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">      <span class="string">"src/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">      <span class="string">"node_modules"</span>,</span><br><span class="line">      <span class="string">"**/*.spec.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"core.ts"</span>,</span><br><span class="line">    <span class="string">"sys.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 从另一个配置文件里继承配置</span></span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"./config/base"</span>,</span><br><span class="line">  <span class="comment">// 让IDE在保存文件的时候根据tsconfig.json重新生成文件</span></span><br><span class="line">  <span class="string">"compileOnSave"</span>: <span class="literal">true</span> <span class="comment">// 支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装atom-typescript插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9FGitCommitMessage.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_2044.jpg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/%E8%A7%84%E8%8C%83%E5%9B%A2%E9%98%9FGitCommitMessage.html" class="post-title-link" itemprop="url">规范团队 Git Commit Message</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-06 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-06T00:00:00+08:00">2023-02-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>目前正在推动团队做持续部署，包括自动提交 npm 包到公司私库和自动生成 CHANGELOG，重中之重是根据 commit 来自动判断版本号，所以规范 git commit message 势在必行。<br>本文就介绍下团队是如何做的 commit message 的规范和格式化。</p>
<h2 id="Commit-Message-格式"><a href="#Commit-Message-格式" class="headerlink" title="Commit Message 格式"></a>Commit Message 格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<h4 id="type-必须"><a href="#type-必须" class="headerlink" title="type(必须)"></a>type(必须)</h4><ul>
<li>feat: 新功能（feature）</li>
<li>fix: 修复 bug</li>
<li>perf: 优化相关，比如提升性能、体验</li>
<li>refactor: 重构（即不是新增功能，也不是修改 bug 的代码变动）</li>
<li>docs: 文档（documentation）</li>
<li>style: 格式（不影响代码运行的变动, 不是 css 样式）</li>
<li>test: 增加测试</li>
</ul>
<h4 id="scope-可选"><a href="#scope-可选" class="headerlink" title="scope(可选)"></a>scope(可选)</h4><ul>
<li>scope 用于说明 commit 影响的范围</li>
</ul>
<h4 id="subject-必须"><a href="#subject-必须" class="headerlink" title="subject(必须)"></a>subject(必须)</h4><ul>
<li>subject 是 commit 目的的简短描述，不超过 50 个字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">fix: 修复xxx问题</span><br><span class="line">feat: 新增xxx功能</span><br></pre></td></tr></table></figure>

<h2 id="Commintlint-校验你的-Message"><a href="#Commintlint-校验你的-Message" class="headerlink" title="Commintlint 校验你的 Message"></a>Commintlint 校验你的 Message</h2><p>commitlint 可以帮助我们 lint commit messages, 如果我们提交的不符合预设的规范, 直接拒绝提交。</p>
<p>目前团队使用的是<a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional" target="_blank" rel="noopener"><br>@commitlint/config-conventional</a>，因为团队后面要使用<br><a href="https://github.com/semantic-release/commit-analyzer/tree/master" target="_blank" rel="noopener">@semantic-release/commit-analyzer</a>进行一系列自动化操作，</p>
<p>，二者底层均依赖<a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-conventionalcommits" target="_blank" rel="noopener">conventional-changelog-conventionalcommits</a>，属于完美适配。</p>
<h2 id="结合-Husky"><a href="#结合-Husky" class="headerlink" title="结合 Husky"></a>结合 Husky</h2><p>本地校验 commit message 的最佳方式是结合 git hook, 所以需要配合 Husky。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br><span class="line"></span><br><span class="line">npx husky install</span><br><span class="line"></span><br><span class="line">npm set-script prepare &quot;husky install&quot;</span><br></pre></td></tr></table></figure>

<h5 id="执行完上面命令将带来以下几个变化"><a href="#执行完上面命令将带来以下几个变化" class="headerlink" title="执行完上面命令将带来以下几个变化"></a>执行完上面命令将带来以下几个变化</h5><ul>
<li>在.git 同级目录生成.husky 文件夹，文件夹下有一个可以编辑的示例 pre-commit 钩子</li>
<li>在 package.json 中的 scripts 中添加了”prepare”: “husky install”</li>
<li>更改 git 配置项 core.hooksPath 为.husky</li>
</ul>
<h5 id="package-json-配置"><a href="#package-json-配置" class="headerlink" title="package.json 配置:"></a>package.json 配置:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">        &quot;hooks&quot;: &#123;</span><br><span class="line">            &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h2><p>上文的操作中会有一个小 bug，就是在本地绕过 git hook 校验的情况，当通过 gitlab 做持续部署时，会导致自动计算版本号等操作出错，所以在持续部署脚本启动前，通过 commit lint shell 脚本来避免这种情况发生。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>commit message 的规范性很重要, 但是是否需要像本文这样强制限制, 每个团队和个人都有自己的想法, 但是个人认为: 好的习惯, 受益终身.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/IMG_2044.jpg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
