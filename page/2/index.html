<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rile14929.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FE">
<meta property="og:type" content="website">
<meta property="og:title" content="右耳听风">
<meta property="og:url" content="https://rile14929.github.io/page/2/index.html">
<meta property="og:site_name" content="右耳听风">
<meta property="og:description" content="FE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rile14929.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>右耳听风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">右耳听风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tag"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3-computed%E5%92%8Cwatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3-computed%E5%92%8Cwatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">vue3 computed和watch的实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-03T00:00:00+08:00">2024-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-03 00:00:00" itemprop="dateModified" datetime="2023-02-03T00:00:00+08:00">2023-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算属性：computed"><a href="#计算属性：computed" class="headerlink" title="计算属性：computed"></a>计算属性：computed</h2><p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 2</span></span><br><span class="line">plusOne.value++ <span class="comment">// error</span></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。</p>
<p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p>
<p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。</p>
<p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(&#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; count.value + 1,</span><br><span class="line">  <span class="keyword">set</span>: val =&gt; &#123;</span><br><span class="line">    count.value = val - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">plusOne.value = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p>
<p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  debugOptions?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getter 函数</span></span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="comment">// setter 函数</span></span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否只有getter的情况，也就是上面第一种例子情况</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = isFunction(getterOrOptions)</span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          warn(<span class="string">'Write operation failed: computed value is readonly'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成computed实例</span></span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; debugOptions &amp;&amp; !isSSR) &#123;</span><br><span class="line">    cRef.effect.onTrack = debugOptions.onTrack</span><br><span class="line">    cRef.effect.onTrigger = debugOptions.onTrigger</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cRef <span class="keyword">as</span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed接收3个参数，主要看第一个参数，观察其类型，发现可以传两种参数：一种是一个getter函数，一种是个包含get、set的对象。<br>首先从getterOrOptions中确定getter、setter（如果getterOrOptions是个function，说明computed是不可写的，所以会将setter设置为一个空函数），确定好之后，创建ComputedRefImpl的实例，并将其返回。</p>
<h3 id="ComputedRefImpl"><a href="#ComputedRefImpl" class="headerlink" title="ComputedRefImpl"></a>ComputedRefImpl</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputedRefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span> <span class="comment">// 存储effect的集合</span></span><br><span class="line"></span><br><span class="line">  private _value!: T</span><br><span class="line">  public readonly effect: ReactiveEffect&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line">  public readonly [ReactiveFlags.IS_READONLY]: boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  public _cacheable: boolean</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Dev only</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _warnRecursive?: boolean</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private getter: ComputedGetter&lt;T&gt;,</span><br><span class="line">    private readonly _setter: ComputedSetter&lt;T&gt;,</span><br><span class="line">    isReadonly: boolean,</span><br><span class="line">    isSSR: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 创建effect</span></span><br><span class="line">    <span class="keyword">this</span>.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">      () =&gt; getter(<span class="keyword">this</span>._value), <span class="comment">// fn</span></span><br><span class="line">      <span class="comment">// trigger</span></span><br><span class="line">      () =&gt;</span><br><span class="line">        triggerRefValue(</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          <span class="keyword">this</span>.effect._dirtyLevel === DirtyLevels.MaybeDirty_ComputedSideEffect</span><br><span class="line">            ? DirtyLevels.MaybeDirty_ComputedSideEffect</span><br><span class="line">            : DirtyLevels.MaybeDirty,</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 用于区分effect是否是computed</span></span><br><span class="line">    <span class="keyword">this</span>.effect.computed = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// this.effect.active与this._cacheable在SSR中为false</span></span><br><span class="line">    <span class="keyword">this</span>.effect.active = <span class="keyword">this</span>._cacheable = !isSSR</span><br><span class="line">    <span class="keyword">this</span>[ReactiveFlags.IS_READONLY] = isReadonly</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="comment">// 计算出的 ref 可能会被其他代理包装，例如 readonly（），所以转成原始类型</span></span><br><span class="line">    <span class="keyword">const</span> self = toRaw(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 当未缓存或者dirty也就是需要更新 并且值发生了改变，触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (!self._cacheable || self.effect.dirty) &amp;&amp;</span><br><span class="line">      hasChanged(self._value, (self._value = self.effect.run()!)) <span class="comment">// 会触发一次run，相当于获取最新的依赖值，如果结果发生改变，触发更新</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      triggerRefValue(self, DirtyLevels.Dirty)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行依赖收集</span></span><br><span class="line">    trackRefValue(self)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 _dirtyLevel 高于 DirtyLevels.MaybeDirty_ComputedSideEffect， 触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (self.effect._dirtyLevel &gt;= DirtyLevels.MaybeDirty_ComputedSideEffect) &#123;</span><br><span class="line">      triggerRefValue(self, DirtyLevels.MaybeDirty_ComputedSideEffect)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> value(newValue: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>._setter(newValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #region polyfill _dirty for backward compatibility third party code for Vue &lt;= 3.3.x</span></span><br><span class="line">  <span class="keyword">get</span> _dirty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.effect.dirty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> _dirty(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.effect.dirty = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="侦听器：watch"><a href="#侦听器：watch" class="headerlink" title="侦听器：watch"></a>侦听器：watch</h2><p>1.watch API 可以侦听一个 getter 函数，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> state.count, (count, prevCount) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 state.count 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.watch API 也可以直接侦听一个响应式对象，当响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, (count, prevCount) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 count.value 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.watch API 还可以直接侦听多个响应式对象，任意一个响应式对象更新后，就会执行对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> count2 = ref(<span class="number">1</span>)</span><br><span class="line">watch([count, count2], ([count, count2], [prevCount, prevCount2]) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当 count.value 或者 count2.value 更新，会触发此回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Immediate</span> <span class="title">extends</span> <span class="title">Readonly</span>&lt;<span class="title">boolean</span>&gt; = <span class="title">false</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: T | WatchSource&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptions&lt;Immediate&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(source <span class="keyword">as</span> any, cb, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到watch内部调用了doWatch：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | object,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    immediate,</span></span></span><br><span class="line"><span class="function"><span class="params">    deep,</span></span></span><br><span class="line"><span class="function"><span class="params">    flush,</span></span></span><br><span class="line"><span class="function"><span class="params">    once,</span></span></span><br><span class="line"><span class="function"><span class="params">    onTrack,</span></span></span><br><span class="line"><span class="function"><span class="params">    onTrigger,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有回调函数，并且只监听一次后移除watch</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; once) &#123;</span><br><span class="line">    <span class="keyword">const</span> _cb = cb</span><br><span class="line">    cb = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      _cb(...args)</span><br><span class="line">      unwatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance</span><br><span class="line">  <span class="keyword">const</span> reactiveGetter = <span class="function">(<span class="params">source: object</span>) =&gt;</span></span><br><span class="line">    deep === <span class="literal">true</span></span><br><span class="line">      ? source <span class="comment">// traverse will happen in wrapped getter below</span></span><br><span class="line">      : <span class="comment">// for deep: false, only traverse root-level properties</span></span><br><span class="line">        traverse(source, deep === <span class="literal">false</span> ? <span class="number">1</span> : <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: <span class="function"><span class="params">()</span> =&gt;</span> any</span><br><span class="line">  <span class="keyword">let</span> forceTrigger = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> isMultiSource = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 根据不同source 创建不同的getter函数</span></span><br><span class="line">  <span class="comment">// getter 函数与computed的getter函数作用类似</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(source)) &#123;</span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> source.value</span><br><span class="line">    forceTrigger = isShallow(source)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123;</span><br><span class="line">    <span class="comment">// source是reactive对象时 自动开启deep=true</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> reactiveGetter(source)</span><br><span class="line">    forceTrigger = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(source)) &#123;</span><br><span class="line">    isMultiSource = <span class="literal">true</span></span><br><span class="line">    forceTrigger = source.some(<span class="function"><span class="params">s</span> =&gt;</span> isReactive(s) || isShallow(s))</span><br><span class="line">    <span class="comment">// source是一个数组的时候，getter 遍历通过类型判断</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> s.value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> reactiveGetter(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warnInvalidSource(s)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果有cb，代表source是个getter函数</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// getter with cb</span></span><br><span class="line">      getter = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则代表是watchEffect</span></span><br><span class="line">      <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">      getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">          source,</span><br><span class="line">          instance,</span><br><span class="line">          ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">          [onCleanup],</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = NOOP</span><br><span class="line">    __DEV__ &amp;&amp; warnInvalidSource(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.x array mutation watch compat</span></span><br><span class="line">  <span class="comment">// 兼容vue2</span></span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__ &amp;&amp; cb &amp;&amp; !deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> val = baseGetter()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        isArray(val) &amp;&amp;</span><br><span class="line">        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)</span><br><span class="line">      ) &#123;</span><br><span class="line">        traverse(val)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 深度监听</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    <span class="comment">// traverse会递归遍历对象的所有属性 以达到深度监听的目的</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> traverse(baseGetter())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watch回调的第三个参数 可以用此注册一个cleanup函数 会在下一次watch cb调用前执行</span></span><br><span class="line">  <span class="comment">// 常用于竞态问题的处理</span></span><br><span class="line">  <span class="keyword">let</span> cleanup: <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">void</span>) | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> onCleanup: OnCleanup = <span class="function">(<span class="params">fn: (</span>) =&gt;</span> <span class="keyword">void</span>) =&gt; &#123;</span><br><span class="line">    cleanup = effect.onStop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)</span><br><span class="line">      cleanup = effect.onStop = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// in SSR there is no need to setup an actual effect, and it should be noop</span></span><br><span class="line">  <span class="comment">// unless it's eager or sync flush</span></span><br><span class="line">  <span class="keyword">let</span> ssrCleanup: <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">void</span>)[] | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (__SSR__ &amp;&amp; isInSSRComponentSetup) &#123;</span><br><span class="line">    <span class="comment">// we will also not call the invalidate callback (+ runner is not set up)</span></span><br><span class="line">    <span class="comment">// ssr处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// oldValue声明 多个source监听则初始化为数组</span></span><br><span class="line">  <span class="keyword">let</span> oldValue: any = isMultiSource</span><br><span class="line">    ? <span class="keyword">new</span> <span class="built_in">Array</span>((source <span class="keyword">as</span> []).length).fill(INITIAL_WATCHER_VALUE)</span><br><span class="line">    : INITIAL_WATCHER_VALUE</span><br><span class="line">  <span class="comment">// 调度器调用时执行</span></span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active || !effect.dirty) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// watch(source, cb)</span></span><br><span class="line">      <span class="comment">// 获取newValue</span></span><br><span class="line">      <span class="keyword">const</span> newValue = effect.run()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        deep ||</span><br><span class="line">        forceTrigger ||</span><br><span class="line">        (isMultiSource</span><br><span class="line">          ? <span class="function">(<span class="params">newValue <span class="keyword">as</span> any[]</span>).<span class="params">some</span>(<span class="params">(v, i</span>) =&gt;</span> hasChanged(v, oldValue[i]))</span><br><span class="line">          : hasChanged(newValue, oldValue)) ||</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          isArray(newValue) &amp;&amp;</span><br><span class="line">          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// cleanup before running cb again</span></span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用cb 参数为newValue、oldValue、onCleanup</span></span><br><span class="line">        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [</span><br><span class="line">          newValue,</span><br><span class="line">          <span class="comment">// pass undefined as the old value when it's changed for the first time</span></span><br><span class="line">          oldValue === INITIAL_WATCHER_VALUE</span><br><span class="line">            ? <span class="literal">undefined</span></span><br><span class="line">            : isMultiSource &amp;&amp; oldValue[<span class="number">0</span>] === INITIAL_WATCHER_VALUE</span><br><span class="line">              ? []</span><br><span class="line">              : oldValue,</span><br><span class="line">          onCleanup,</span><br><span class="line">        ])</span><br><span class="line">         <span class="comment">// 更新oldValue</span></span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// watchEffect</span></span><br><span class="line">      effect.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// important: mark the job as a watcher callback so that scheduler knows</span></span><br><span class="line">  <span class="comment">// it is allowed to self-trigger (#1727)</span></span><br><span class="line">  job.allowRecurse = !!cb</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建任务队列的调度回调scheduler</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: EffectScheduler</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">'sync'</span>) &#123;</span><br><span class="line">    <span class="comment">// 同步更新 即每次响应式数据改变都会回调一次cb</span></span><br><span class="line">    scheduler = job <span class="keyword">as</span> any <span class="comment">// the scheduler function gets called directly</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">    <span class="comment">// job放入pendingPostFlushCbs队列中</span></span><br><span class="line">    <span class="comment">// pendingPostFlushCbs队列会在queue队列执行完毕后执行 函数更新effect通常会放在queue队列中</span></span><br><span class="line">    <span class="comment">// 所以pendingPostFlushCbs队列执行时组件已经更新完毕</span></span><br><span class="line">    scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: 'pre'</span></span><br><span class="line">    job.pre = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (instance) job.id = instance.uid</span><br><span class="line">    <span class="comment">// 默认更新</span></span><br><span class="line">    <span class="comment">// 原理在这：https://rile14929.github.io/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html</span></span><br><span class="line">    scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queueJob(job)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect effect.run的时候建立effect与getter内响应式数据的关系</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">new</span> ReactiveEffect(getter, NOOP, scheduler)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scope = getCurrentScope()</span><br><span class="line">  <span class="comment">// 取消监听的函数</span></span><br><span class="line">  <span class="keyword">const</span> unwatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    effect.stop()</span><br><span class="line">    <span class="keyword">if</span> (scope) &#123;</span><br><span class="line">      remove(scope.effects, effect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initial run</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">       <span class="comment">// 立即执行一次job</span></span><br><span class="line">      job()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则执行effect.run() 会执行getter 获取oldValue</span></span><br><span class="line">      oldValue = effect.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">    queuePostRenderEffect(</span><br><span class="line">      effect.run.bind(effect),</span><br><span class="line">      instance &amp;&amp; instance.suspense,</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    effect.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__SSR__ &amp;&amp; ssrCleanup) ssrCleanup.push(unwatch)</span><br><span class="line">  <span class="keyword">return</span> unwatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WatchEffect"><a href="#WatchEffect" class="headerlink" title="WatchEffect"></a>WatchEffect</h3><p>watchEffect API 的作用是注册一个副作用函数，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再立即执行这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line">count.value++</span><br></pre></td></tr></table></figure>

<p>watchEffect 和前面的 watch API 主要有三点不同：</p>
<ol>
<li><p><strong>侦听的源不同</strong> 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。</p>
</li>
<li><p><strong>没有回调函数</strong> 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。</p>
</li>
<li><p><strong>立即执行</strong> 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate 为 true，才会立即执行回调函数。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchPostEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(</span><br><span class="line">    effect,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    __DEV__ ? extend(&#123;&#125;, options <span class="keyword">as</span> any, &#123; <span class="attr">flush</span>: <span class="string">'post'</span> &#125;) : &#123; <span class="attr">flush</span>: <span class="string">'post'</span> &#125;,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchSyncEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: DebuggerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(</span><br><span class="line">    effect,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    __DEV__ ? extend(&#123;&#125;, options <span class="keyword">as</span> any, &#123; <span class="attr">flush</span>: <span class="string">'sync'</span> &#125;) : &#123; <span class="attr">flush</span>: <span class="string">'sync'</span> &#125;,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简易版实现原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">    getter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">        cleanup()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">        source,</span><br><span class="line">        instance,</span><br><span class="line">        ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">        [onCleanup],</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scheduler: EffectScheduler</span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">'sync'</span>) &#123;</span><br><span class="line">  scheduler = job <span class="keyword">as</span> any <span class="comment">// the scheduler function gets called directly</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">  scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// default: 'pre'</span></span><br><span class="line">  job.pre = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (instance) job.id = instance.uid</span><br><span class="line">  scheduler = <span class="function"><span class="params">()</span> =&gt;</span> queueJob(job)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effect = <span class="keyword">new</span> ReactiveEffect(getter, NOOP, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// initial run</span></span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">'post'</span>) &#123;</span><br><span class="line">  queuePostRenderEffect(</span><br><span class="line">    effect.run.bind(effect),</span><br><span class="line">    instance &amp;&amp; instance.suspense,</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  effect.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是计算属性computed和侦听器watch的实现原理，总的来说就是侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。</p>
<p>文章里面涉及到<a href="https://rile14929.github.io/zh-CN/vue3%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%92%8CNextTick%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html">任务队列异步更新的原理</a>在这。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">vue3响应式实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-06T00:00:00+08:00">2024-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们分析了 Composition API 的核心 setup 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这次我们就来深入学习和分析响应式内部的实现原理。</p>
<p><strong>响应式它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。响应式是 Vue.js 组件化更新渲染的一个核心机制。</strong></p>
<p>Vue.js 2.x的响应式：在内部通过 Object.defineProperty API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用vue2官网的一张图可以直观地看清这个流程。</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image.png" alt="alt text"></p>
<p>在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。这里有两个流程，首先是依赖收集流程，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；然后是派发通知流程，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。</p>
<p>但是Object.defineProperty API 有一些缺点：包括不能监听对象属性新增和删除；初始化阶段递归执行 Object.defineProperty 带来的性能负担。</p>
<p>Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用 Proxy API 重写了响应式部分，并独立维护和发布整个 reactivity 库，下面就来分析响应式部分的实现原理。</p>
<h2 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span></span><br><span class="line">  <span class="keyword">if</span> (isReadonly(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: Target,</span></span></span><br><span class="line"><span class="function"><span class="params">  isReadonly: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  proxyMap: WeakMap&lt;Target, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标必须是对象或数组类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target is already a Proxy, return it.</span></span><br><span class="line">  <span class="comment">// exception: calling readonly() on a reactive object</span></span><br><span class="line">  <span class="comment">// target 已经是 Proxy 对象，直接返回</span></span><br><span class="line">  <span class="comment">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target already has corresponding Proxy</span></span><br><span class="line">  <span class="comment">// target 已经有对应的 Proxy 了</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// only specific value types can be observed.</span></span><br><span class="line">  <span class="comment">// 只有在白名单里的数据类型才能变成响应式</span></span><br><span class="line">  <span class="keyword">const</span> targetType = getTargetType(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === TargetType.INVALID) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用 Proxy 创建响应式</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,</span><br><span class="line">  )</span><br><span class="line">  proxyMap.set(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，reactive 内部通过 createReactiveObject 函数把 target 变成了一个响应式对象。</p>
<p>在这个过程中，createReactiveObject 函数主要做了以下几件事情。</p>
<ol>
<li>函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以原始数据 target 必须是对象或者数组。</li>
<li>如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象</li>
<li>如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象</li>
<li>只有在白名单里的数据类型才能变成响应式，比如，带有 __v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。</li>
</ol>
<p>接下来，我们继续看 Proxy 处理器对象 mutableHandlers 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它其实就是劫持了我们对 observed 对象的一些操作，比如：</p>
<p>访问对象属性会触发 get 函数；</p>
<p>设置对象属性会触发 set 函数；</p>
<p>删除对象属性会触发 deleteProperty 函数；</p>
<p>in 操作符会触发 has 函数；</p>
<p>通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。</p>
<p>因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。</p>
<h3 id="依赖收集：get-函数"><a href="#依赖收集：get-函数" class="headerlink" title="依赖收集：get 函数"></a>依赖收集：get 函数</h3><p><strong>依赖收集发生在数据访问的阶段</strong>，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 get 函数，我们来看一下 get 函数的实现流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(target: Target, key: string | symbol, receiver: object) &#123;</span><br><span class="line">    <span class="keyword">const</span> isReadonly = <span class="keyword">this</span>._isReadonly,</span><br><span class="line">      shallow = <span class="keyword">this</span>._shallow</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isReactive</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_SHALLOW) &#123;</span><br><span class="line">      <span class="comment">// 代理 __v_isShallow</span></span><br><span class="line">      <span class="keyword">return</span> shallow</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.RAW) &#123;</span><br><span class="line">      <span class="comment">// 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        receiver ===</span><br><span class="line">          (isReadonly</span><br><span class="line">            ? shallow</span><br><span class="line">              ? shallowReadonlyMap</span><br><span class="line">              : readonlyMap</span><br><span class="line">            : shallow</span><br><span class="line">              ? shallowReactiveMap</span><br><span class="line">              : reactiveMap</span><br><span class="line">          ).get(target) ||</span><br><span class="line">        <span class="comment">// receiver is not the reactive proxy, but has the same prototype</span></span><br><span class="line">        <span class="comment">// this means the reciever is a user proxy of the reactive proxy</span></span><br><span class="line">        <span class="built_in">Object</span>.getPrototypeOf(target) === <span class="built_in">Object</span>.getPrototypeOf(receiver)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// early return undefined</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是数组</span></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = isArray(target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">        <span class="comment">// arrayInstrumentations 包含对数组一些方法修改的函数</span></span><br><span class="line">      <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'hasOwnProperty'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasOwnProperty</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    <span class="comment">// 内置 Symbol key 不需要依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - skip unwrap for Array + integer key.</span></span><br><span class="line">      <span class="keyword">return</span> targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? readonly(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面代码来看，get 函数主要做了四件事情，首先对特殊的 key 做了代理，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p>
<p>接着通过 Reflect.get 方法求值，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现：</p>
<h4 id="arrayInstrumentations"><a href="#arrayInstrumentations" class="headerlink" title="arrayInstrumentations"></a>arrayInstrumentations</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = <span class="comment">/*#__PURE__*/</span> createArrayInstrumentations()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayInstrumentations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instrumentations: Record&lt;string, <span class="built_in">Function</span>&gt; = &#123;&#125;</span><br><span class="line">  <span class="comment">// instrument identity-sensitive Array methods to account for possible reactive</span></span><br><span class="line">  <span class="comment">// values</span></span><br><span class="line">  ;([<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>] <span class="keyword">as</span> <span class="keyword">const</span>).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">this: unknown[], ...args: unknown[]</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// toRaw 可以把响应式对象转成原始数据，this就是Reflect的receiver</span></span><br><span class="line">      <span class="keyword">const</span> arr = toRaw(<span class="keyword">this</span>) <span class="keyword">as</span> any</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        track(arr, TrackOpTypes.GET, i + <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// we run the method using the original args first (which may be reactive)</span></span><br><span class="line">      <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">      <span class="keyword">if</span> (res === <span class="number">-1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// if that didn't work, run it again using raw values.</span></span><br><span class="line">        <span class="keyword">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// instrument length-altering mutation methods to avoid length being tracked</span></span><br><span class="line">  <span class="comment">// which leads to infinite loops in some cases (#2137)</span></span><br><span class="line">  ;([<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>] <span class="keyword">as</span> <span class="keyword">const</span>).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">this: unknown[], ...args: unknown[]</span>) </span>&#123;</span><br><span class="line">      pauseTracking()</span><br><span class="line">      pauseScheduling()</span><br><span class="line">      <span class="keyword">const</span> res = (toRaw(<span class="keyword">this</span>) <span class="keyword">as</span> any)[key].apply(<span class="keyword">this</span>, args)</span><br><span class="line">      resetScheduling()</span><br><span class="line">      resetTracking()</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当 target 是一个数组的时候，我们去访问 target.includes、target.indexOf、 target.lastIndexOf 就会执行 arrayInstrumentations 代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个 API 的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。</p>
<p>当调用 target.push、target.pop、target.shift、target.unshift、target.splice 时候，由于都会访问.length导致收集了数组的length，在某种场景下造成无限循环，看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/core/pull/2138</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = reactive([])</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  arr.push(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  arr.push(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以为避免此种情况发生，会暂停收集依赖，在执行完毕后，再恢复依赖收集。</p>
<p>回到 get 函数，第三步就是通过 Reflect.get 求值，然后会执行 track 函数收集依赖，我们稍后重点分析这个过程。</p>
<p>函数最后会对计算的值 res 进行判断，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。</p>
<p>整个 get 函数最核心的部分其实是执行 track 函数收集依赖，下面我们重点分析这个过程。</p>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: object, type: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是否应该收集依赖 和 当前激活的 effect</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 每个 target 对应一个 depsMap</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      <span class="comment">// 每个 key 对应一个 dep Map</span></span><br><span class="line">      depsMap.set(key, (dep = createDep(<span class="function"><span class="params">()</span> =&gt;</span> depsMap!.delete(key))))</span><br><span class="line">    &#125;</span><br><span class="line">    trackEffect(</span><br><span class="line">      activeEffect,</span><br><span class="line">      dep,</span><br><span class="line">      __DEV__</span><br><span class="line">        ? &#123;</span><br><span class="line">            target,</span><br><span class="line">            type,</span><br><span class="line">            key,</span><br><span class="line">          &#125;</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trackEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: ReactiveEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  dep: Dep,</span></span></span><br><span class="line"><span class="function"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dep.get(effect) !== effect._trackId) &#123;</span><br><span class="line">    <span class="comment">// 收集当前激活的 effect 作为依赖</span></span><br><span class="line">    dep.set(effect, effect._trackId)</span><br><span class="line">    <span class="keyword">const</span> oldDep = effect.deps[effect._depsLength]</span><br><span class="line">    <span class="keyword">if</span> (oldDep !== dep) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldDep) &#123;</span><br><span class="line">        cleanupDepEffect(oldDep, effect)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当前激活的 effect 收集 dep 集合作为依赖</span></span><br><span class="line">      effect.deps[effect._depsLength++] = dep</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect._depsLength++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      effect.onTrack?.(extend(&#123; effect &#125;, debuggerEventExtraInfo!))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析track函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们收集的依赖就是数据变化后执行的副作用函数。</p>
<p>再来看实现，我们把 target 作为原始的数据，key 作为访问的属性。我们创建了全局的 targetMap 作为原始数据对象的 Map，它的键是 target，值是 depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系：</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-1.png" alt="../images/vue3响应式实现原理/image-20240316133230452"></p>
<p>所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。</p>
<h3 id="派发通知：set-函数"><a href="#派发通知：set-函数" class="headerlink" title="派发通知：set 函数"></a>派发通知：set 函数</h3><p>派发通知发生在数据更新的阶段 ，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性更新的时候就会执行 set 函数。我们来看一下 set 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(</span><br><span class="line">    target: object,</span><br><span class="line">    key: string | symbol,</span><br><span class="line">    value: unknown,</span><br><span class="line">    receiver: object,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._shallow) &#123;</span><br><span class="line">      <span class="keyword">const</span> isOldValueReadonly = isReadonly(oldValue)</span><br><span class="line">      <span class="keyword">if</span> (!isShallow(value) &amp;&amp; !isReadonly(value)) &#123;</span><br><span class="line">        oldValue = toRaw(oldValue)</span><br><span class="line">        value = toRaw(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOldValueReadonly) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          oldValue.value = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数组是否包含index或者对象是否有这个属性</span></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="comment">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上述代码来看，set 函数的实现逻辑很简单，主要就做两件事情， 首先通过 Reflect.set 求值 ， 然后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型，即新增还是修改。</p>
<p>整个 set 函数最核心的部分就是 执行 trigger 函数派发通知 ，下面我们将重点分析这个过程。</p>
<p>我们先来看一下 trigger 函数的实现：</p>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 targetMap 拿到 target 对应的依赖集合</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 没有依赖，直接返回</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建要执行的deps数组</span></span><br><span class="line">  <span class="keyword">let</span> deps: (Dep | <span class="literal">undefined</span>)[] = []</span><br><span class="line">  <span class="keyword">if</span> (type === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    <span class="comment">// 清空数组或者map的时候触发所有key对应的的effect函数</span></span><br><span class="line">    deps = [...depsMap.values()]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'length'</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    <span class="keyword">const</span> newLength = <span class="built_in">Number</span>(newValue)</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'length'</span> || (!isSymbol(key) &amp;&amp; key &gt;= newLength)) &#123;</span><br><span class="line">        deps.push(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="comment">// set add delete操作 将key对应的effect函数添加到deps数组中</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      deps.push(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="comment">// 根据不同的操作类型push对应的dep</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.ADD:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIntegerKey(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          deps.push(depsMap.get(<span class="string">'length'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.DELETE:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.SET:</span><br><span class="line">        <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">          deps.push(depsMap.get(ITERATE_KEY))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pauseScheduling()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> deps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">      triggerEffects(</span><br><span class="line">        dep,</span><br><span class="line">        DirtyLevels.Dirty,</span><br><span class="line">        __DEV__</span><br><span class="line">          ? &#123;</span><br><span class="line">              target,</span><br><span class="line">              type,</span><br><span class="line">              key,</span><br><span class="line">              newValue,</span><br><span class="line">              oldValue,</span><br><span class="line">              oldTarget,</span><br><span class="line">            &#125;</span><br><span class="line">          : <span class="keyword">void</span> <span class="number">0</span>,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resetScheduling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">triggerEffects</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  dep: Dep,</span></span></span><br><span class="line"><span class="function"><span class="params">  dirtyLevel: DirtyLevels,</span></span></span><br><span class="line"><span class="function"><span class="params">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pauseScheduling()</span><br><span class="line">  <span class="comment">// 执行triggerEffects，执行dep里所有的effect</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> dep.keys()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      effect._dirtyLevel &lt; dirtyLevel &amp;&amp;</span><br><span class="line">      dep.get(effect) === effect._trackId</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastDirtyLevel = effect._dirtyLevel</span><br><span class="line">      effect._dirtyLevel = dirtyLevel</span><br><span class="line">      <span class="keyword">if</span> (lastDirtyLevel === DirtyLevels.NotDirty) &#123;</span><br><span class="line">        effect._shouldSchedule = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          effect.onTrigger?.(extend(&#123; effect &#125;, debuggerEventExtraInfo))</span><br><span class="line">        &#125;</span><br><span class="line">        effect.trigger()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  scheduleEffects(dep)</span><br><span class="line">  resetScheduling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。</p>
<h2 id="ref-API"><a href="#ref-API" class="headerlink" title="ref API"></a>ref API</h2><p>通过前面的分析，我们知道 reactive API 对传入的 target 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。</p>
<p>但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 Vue.js 3.0 设计并实现了 ref API。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createRef(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params">rawValue: unknown, shallow: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果传入的就是一个 ref，那么返回自身即可，处理嵌套 ref 的情况。</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RefImpl(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  private _value: T</span><br><span class="line">  private _rawValue: T</span><br><span class="line"></span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    value: T,</span><br><span class="line">    public readonly __v_isShallow: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rawValue = __v_isShallow ? value : toRaw(value)</span><br><span class="line">    <span class="keyword">this</span>._value = __v_isShallow ? value : toReactive(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="comment">// 依赖收集，key 为固定的 value</span></span><br><span class="line">    trackRefValue(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> value(newVal) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue = <span class="keyword">this</span>.__v_isShallow || isShallow(newVal) || isReadonly(newVal)</span><br><span class="line">    newVal = useDirectValue ? newVal : toRaw(newVal)</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newVal, <span class="keyword">this</span>._rawValue)) &#123;</span><br><span class="line">      <span class="comment">// 判断有变化后更新值</span></span><br><span class="line">      <span class="keyword">this</span>._rawValue = newVal</span><br><span class="line">      <span class="keyword">this</span>._value = useDirectValue ? newVal : toReactive(newVal)</span><br><span class="line">      <span class="comment">// 派发通知</span></span><br><span class="line">      triggerRefValue(<span class="keyword">this</span>, DirtyLevels.Dirty, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数首先处理了嵌套 ref 的情况，如果传入的 rawValue 也是 ref，那么直接返回。</p>
<p>接着对 rawValue 做了一层转换，如果 rawValue 是对象或者数组类型，那么把它转换成一个 reactive 对象。</p>
<p>最后定义一个对 value 属性做 getter 和 setter 劫持的对象并返回，get 部分就是执行 track 函数做依赖收集然后返回它的值；set 部分就是设置新值并且执行 trigger 函数派发通知。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后通过一张图来看一下响应式的工作流程。</p>
<p><img src="../images/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-3.png" alt="alt text"></p>
<p>Vue.js 3.0 在响应式的实现思路和 Vue.js 2.x 差别并不大，主要就是 <strong>劫持数据的方式改成用 Proxy 实现 ， 以及收集的依赖由 watcher 实例变成了组件副作用渲染函数</strong> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%89%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%A6%E8%A7%A3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%89%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%A6%E8%A7%A3.html" class="post-title-link" itemprop="url">vue3组件渲染前初始化详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-10T00:00:00+08:00">2023-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="创建和设置组件实例"><a href="#创建和设置组件实例" class="headerlink" title="创建和设置组件实例"></a>创建和设置组件实例</h3><p>首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染 vnode 和生成 DOM。</p>
<p>其中渲染 vnode 的过程主要就是在挂载组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent = <span class="function">(<span class="params">initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  setupComponent(instance)</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前面的文章没有仔细分析，所以我们重点分析前两个流程。</p>
<p>先看创建组件实例的流程，我们要关注 createComponentInstance 方法的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span> (<span class="params">vnode, parent, suspense</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span></span><br><span class="line">  <span class="keyword">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    <span class="comment">// 组件唯一 id</span></span><br><span class="line">    uid: uid++,</span><br><span class="line">    <span class="comment">// 组件 vnode</span></span><br><span class="line">    vnode,</span><br><span class="line">    <span class="comment">// 父组件实例</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// app 上下文</span></span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// vnode 节点类型</span></span><br><span class="line">    type: vnode.type,</span><br><span class="line">    <span class="comment">// 根组件实例</span></span><br><span class="line">    root: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 新的组件 vnode</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 子节点 vnode</span></span><br><span class="line">    subTree: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带副作用更新函数</span></span><br><span class="line">    update: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    render: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染上下文代理</span></span><br><span class="line">    proxy: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带有 with 区块的渲染上下文代理</span></span><br><span class="line">    withProxy: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 响应式相关对象</span></span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 依赖注入相关</span></span><br><span class="line">    provides: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides),</span><br><span class="line">    <span class="comment">// 渲染代理的属性访问缓存</span></span><br><span class="line">    accessCache: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染缓存</span></span><br><span class="line">    renderCache: [],</span><br><span class="line">    <span class="comment">// 渲染上下文</span></span><br><span class="line">    ctx: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// data 数据</span></span><br><span class="line">    data: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// props 数据</span></span><br><span class="line">    props: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    attrs: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 插槽相关</span></span><br><span class="line">    slots: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 组件或者 DOM 的 ref 引用</span></span><br><span class="line">    refs: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// setup 函数返回的响应式结果</span></span><br><span class="line">    setupState: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// setup 函数上下文数据</span></span><br><span class="line">    setupContext: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 注册的组件</span></span><br><span class="line">    components: <span class="built_in">Object</span>.create(appContext.components),</span><br><span class="line">    <span class="comment">// 注册的指令</span></span><br><span class="line">    directives: <span class="built_in">Object</span>.create(appContext.directives),</span><br><span class="line">    <span class="comment">// suspense 相关</span></span><br><span class="line">    suspense,</span><br><span class="line">    <span class="comment">// suspense 异步依赖</span></span><br><span class="line">    asyncDep: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// suspense 异步依赖是否都已处理</span></span><br><span class="line">    asyncResolved: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否挂载</span></span><br><span class="line">    isMounted: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否卸载</span></span><br><span class="line">    isUnmounted: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否激活</span></span><br><span class="line">    isDeactivated: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before create</span></span><br><span class="line">    bc: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，created</span></span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before mount</span></span><br><span class="line">    bm: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，mounted</span></span><br><span class="line">    m: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before update</span></span><br><span class="line">    bu: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，updated</span></span><br><span class="line">    u: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，unmounted</span></span><br><span class="line">    um: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before unmount</span></span><br><span class="line">    bum: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期, deactivate</span></span><br><span class="line">    da: <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 生命周期 activated</span></span><br><span class="line">    a: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render triggered</span></span><br><span class="line">    rtg: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render tracked</span></span><br><span class="line">    rtc: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 error captured</span></span><br><span class="line">    ec: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 派发事件方法</span></span><br><span class="line">    emit: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化渲染上下文</span></span><br><span class="line">  instance.ctx = &#123; <span class="attr">_</span>: instance &#125;</span><br><span class="line">  <span class="comment">// 初始化根组件指针</span></span><br><span class="line">  instance.root = parent ? parent.root : instance</span><br><span class="line">  <span class="comment">// 初始化派发事件方法</span></span><br><span class="line">  instance.emit = emit.bind(<span class="literal">null</span>, instance)</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好 instance 实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。</p>
<p>接着是组件实例的设置流程，对 setup 函数的处理就在这里完成，我们来看一下 setupComponent 方法的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span> (<span class="params">instance, isSSR = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props, children, shapeFlag &#125; = instance.vnode</span><br><span class="line">  <span class="comment">// 判断是否是一个有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = shapeFlag &amp; <span class="number">4</span></span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="comment">// 初始化 插槽</span></span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  <span class="comment">// 设置有状态的组件实例</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们从组件 vnode 中获取了 props、children、shapeFlag 等属性，然后分别对 props 和插槽进行初始化。</p>
<p>根据 shapeFlag 的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。</p>
<p>接下来我们要关注到 setupStatefulComponent 函数，它主要做了三件事：创建渲染上下文代理、判断处理 setup 函数和完成组件实例设置。它代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span> (<span class="params">instance, isSSR</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type</span><br><span class="line">  <span class="comment">// 创建渲染代理的属性访问缓存</span></span><br><span class="line">  instance.accessCache = &#123;&#125;</span><br><span class="line">  <span class="comment">// 1.创建渲染上下文代理</span></span><br><span class="line">  instance.proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  <span class="comment">// 2.判断处理 setup 函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component</span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 执行 setup 函数，获取结果</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])</span><br><span class="line">    <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">    handleSetupResult(instance, setupResult)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 完成组件实例设置</span></span><br><span class="line">    finishComponentSetup(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建渲染上下文代理"><a href="#创建渲染上下文代理" class="headerlink" title="创建渲染上下文代理"></a>创建渲染上下文代理</h3><p>首先是创建渲染上下文代理的流程，它主要对 instance.ctx 做了代理。</p>
<p>在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 this._props 上，而 data 中定义的数据存储在 this._data 上。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    msg: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在初始化组件的时候，data 中定义的 msg 在组件内部是存储在 this._data 上的，而模板渲染的时候访问 this.msg，实际上访问的是 this._data.msg，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p>
<p>到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。</p>
<p>明确了代理的需求后，我们接下来就要分析 proxy 的几个方法： get、set 和 has。</p>
<p>当我们访问 instance.ctx 渲染上下文中的属性时，就会进入 get 函数。我们来看一下它的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span> (&#123; _: instance &#125;, key) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">'$'</span>) &#123;</span><br><span class="line">      <span class="comment">// setupState / data / props / ctx</span></span><br><span class="line">      <span class="comment">// 渲染代理的属性访问缓存中</span></span><br><span class="line">      <span class="keyword">const</span> n = accessCache[key]</span><br><span class="line">      <span class="keyword">if</span> (n !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 从缓存中取</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* SETUP */</span></span><br><span class="line">            <span class="keyword">return</span> setupState[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :<span class="comment">/* DATA */</span></span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span> :<span class="comment">/* CONTEXT */</span></span><br><span class="line">            <span class="keyword">return</span> ctx[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* PROPS */</span></span><br><span class="line">            <span class="keyword">return</span> props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 从 setupState 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> setupState[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 从 data 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> data[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        type.props &amp;&amp;</span><br><span class="line">        hasOwn(normalizePropsOptions(type.props)[<span class="number">0</span>], key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">2</span></span><br><span class="line">        <span class="comment">// 从 props 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> props[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">3</span></span><br><span class="line">        <span class="comment">// 从 ctx 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> ctx[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 都取不到</span></span><br><span class="line">        accessCache[key] = <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> publicGetter = publicPropertiesMap[key]</span><br><span class="line">    <span class="keyword">let</span> cssModule, globalProperties</span><br><span class="line">    <span class="comment">// 公开的 $xxx 属性或方法</span></span><br><span class="line">    <span class="keyword">if</span> (publicGetter) &#123;</span><br><span class="line">      <span class="keyword">return</span> publicGetter(instance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// css 模块，通过 vue-loader 编译的时候注入</span></span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> cssModule</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      <span class="comment">// 用户自定义的属性，也用 `$` 开头</span></span><br><span class="line">      accessCache[key] = <span class="number">3</span></span><br><span class="line">      <span class="keyword">return</span> ctx[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 全局定义的属性</span></span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">        hasOwn(globalProperties, key))) &#123;</span><br><span class="line">      <span class="keyword">return</span> globalProperties[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">'production'</span>) &amp;&amp;</span><br><span class="line">      currentRenderingInstance &amp;&amp; key.indexOf(<span class="string">'__v'</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; key[<span class="number">0</span>] === <span class="string">'$'</span> &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        <span class="comment">// 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span></span><br><span class="line">        warn(<span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> must be accessed via $data because it starts with a reserved `</span> +</span><br><span class="line">          <span class="string">`character and is not proxied on the render context.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在模板中使用的变量如果没有定义，报警告</span></span><br><span class="line">        warn(<span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> was accessed during render `</span> +</span><br><span class="line">          <span class="string">`but is not defined on instance.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数首先判断 key 不以 $ 开头的情况，这部分数据可能是 setupState、data、props、ctx 中的一种，setupState 就是 setup 函数返回的数据，ctx 包括了计算属性、组件方法和用户自定义的一些数据。</p>
<p>如果 key 不以 $ 开头，那么就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。注意这个判断顺序很重要，在 key 相同时它会决定数据获取的优先级。</p>
<p>再回到 get 函数中，我们可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发 get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key 在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取 key 对应的数据后，我们利用 accessCache[key] 去缓存数据，下一次再次根据 key 查找数据，我们就可以直接通过 accessCache[key] 获取对应的值，就不需要依次调用 hasOwn 去判断了。这也是一个性能优化的小技巧。</p>
<p>如果 key 以 $ 开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js 内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是 vue-loader 编译注入的 css 模块内部的 key；接着判断是不是用户自定义以 $ 开头的 key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 $ 开头的警告，因为 $ 是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。</p>
<p>接下来是 set 代理过程，当我们修改 instance.ctx 渲染上下文中的属性的时候，就会进入 set 函数。我们来看一下 set 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  <span class="keyword">set</span> (&#123; _: instance &#125;, key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    <span class="keyword">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 setupState 赋值</span></span><br><span class="line">      setupState[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 data 赋值</span></span><br><span class="line">      data[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key <span class="keyword">in</span> instance.props) &#123;</span><br><span class="line">      <span class="comment">// 不能直接给 props 赋值</span></span><br><span class="line">      (process.env.NODE_ENV !== <span class="string">'production'</span>) &amp;&amp;</span><br><span class="line">      warn(<span class="string">`Attempting to mutate prop "<span class="subst">$&#123;key&#125;</span>". Props are readonly.`</span>, instance)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'$'</span> &amp;&amp; key.slice(<span class="number">1</span>) <span class="keyword">in</span> instance) &#123;</span><br><span class="line">      <span class="comment">// 不能给 Vue 内部以 $ 开头的保留属性赋值</span></span><br><span class="line">      (process.env.NODE_ENV !== <span class="string">'production'</span>) &amp;&amp;</span><br><span class="line">      warn(<span class="string">`Attempting to mutate public property "<span class="subst">$&#123;key&#125;</span>". `</span> +</span><br><span class="line">        <span class="string">`Properties starting with $ are reserved and readonly.`</span>, instance)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用户自定义数据赋值</span></span><br><span class="line">      ctx[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。</p>
<p>最后是 has 代理过程，当我们判断属性是否存在于 instance.ctx 渲染上下文中时，就会进入 has 函数，这个在平时项目中用的比较少，同样来举个例子，当执行 created 钩子函数中的 ‘msg’ in this 时，就会触发 has 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  has</span><br><span class="line">    (&#123; <span class="attr">_</span>: &#123; data, setupState, accessCache, ctx, type, appContext &#125; &#125;, key) &#123;</span><br><span class="line">    <span class="comment">// 依次判断</span></span><br><span class="line">    <span class="keyword">return</span> (accessCache[key] !== <span class="literal">undefined</span> ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) ||</span><br><span class="line">      (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[<span class="number">0</span>], key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) ||</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现很简单，依次判断 key 是否存在于 accessCache、data、setupState、props 、用户数据、公开属性以及全局属性中，然后返回结果。</p>
<p>至此，我们就分析完创建上下文代理的过程，让我们回到 setupStatefulComponent 函数中，接下来分析第二个流程——判断处理 setup 函数。</p>
<h3 id="判断处理-setup-函数"><a href="#判断处理-setup-函数" class="headerlink" title="判断处理 setup 函数"></a>判断处理 setup 函数</h3><p>我们看一下整个逻辑涉及的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断处理 setup 函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; setup &#125; = Component</span><br><span class="line"><span class="keyword">if</span> (setup) &#123;</span><br><span class="line">  <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">  <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">    setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 执行 setup 函数获取结果</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])</span><br><span class="line">  <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">  handleSetupResult(instance, setupResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在组件中定义了 setup 函数，接下来就是处理 setup 函数的流程，主要是三个步骤：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果。接下来我们就逐个来分析。</p>
<p>首先判断 setup 函数的参数长度，如果大于 1，则创建 setupContext 上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupContext</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> attrs() &#123;</span><br><span class="line">            <span class="keyword">return</span> getAttrsProxy(instance)</span><br><span class="line">        &#125;,</span><br><span class="line">        slots: instance.slots,</span><br><span class="line">        emit: instance.emit,</span><br><span class="line">        expose,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回了一个对象，包括 attrs、slots 和 emit 三个属性。setupContext 让我们在 setup 函数内部可以获取到组件的属性、插槽以及派发事件的方法 emit。</p>
<p>可以预见的是，这个 setupContext 对应的就是 setup 函数第二个参数，我们接下来看一下 setup 函数具体是如何执行的。</p>
<p>我们通过callWithErrorHandling来执行 setup 函数并获取结果，具体来看一下 callWithErrorHandling 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callWithErrorHandling</span> (<span class="params">fn, instance, type, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? fn(...args) : fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    handleError(err, instance, type)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它其实就是对 fn 做的一层包装，内部还是执行了 fn，并在有参数的时候传入参数，所以 setup 的第一个参数是 instance.props，第二个参数是 setupContext。函数执行过程中如果有 JavaScript 执行错误就会捕获错误，并执行 handleError 函数来处理。</p>
<p>执行 setup 函数并拿到了返回的结果，那么接下来就要用 handleSetupResult 函数来处理结果。</p>
<p>我们详细看一下 handleSetupResult 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params">instance, setupResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// setup 返回渲染函数</span></span><br><span class="line">    instance.render = setupResult</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// 把 setup 返回结果变成响应式</span></span><br><span class="line">    instance.setupState = proxyRefs(setupResult)</span><br><span class="line">  &#125;</span><br><span class="line">  finishComponentSetup(instance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxyRefs</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  objectWithRefs: T,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ShallowUnwrapRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isReactive(objectWithRefs)</span><br><span class="line">    ? objectWithRefs</span><br><span class="line">    : <span class="keyword">new</span> <span class="built_in">Proxy</span>(objectWithRefs, shallowUnwrapHandlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowUnwrapHandlers: ProxyHandler&lt;any&gt; = &#123;</span><br><span class="line">  <span class="keyword">get</span>: (target, key, receiver) =&gt; unref(Reflect.<span class="keyword">get</span>(target, key, receiver)),</span><br><span class="line">  <span class="keyword">set</span>: (target, key, value, receiver) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">    <span class="keyword">if</span> (isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">      oldValue.value = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当 setupResult 是一个对象的时候，我们把它变成了响应式并赋值给 instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx 就可以从 instance.setupState 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系。</p>
<p>另外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。</p>
<p>在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置，其实这个函数和 setup 函数的执行结果已经没什么关系了，提取到外面放在 handleSetupResult 函数后面执行更合理一些。</p>
<p>另外当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。</p>
<h3 id="完成组件实例设置"><a href="#完成组件实例设置" class="headerlink" title="完成组件实例设置"></a>完成组件实例设置</h3><p>接下来我们来看一下 finishComponentSetup 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  skipOptions?: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// template / render function normalization</span></span><br><span class="line">  <span class="comment">// could be already set when returned from setup()</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.render) &#123;</span><br><span class="line">    <span class="comment">// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation</span></span><br><span class="line">    <span class="comment">// is done by server-renderer</span></span><br><span class="line">    <span class="keyword">if</span> (!isSSR &amp;&amp; compile &amp;&amp; !Component.render) &#123;</span><br><span class="line">      <span class="comment">// 获取模板</span></span><br><span class="line">      <span class="keyword">const</span> template =</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          instance.vnode.props &amp;&amp;</span><br><span class="line">          instance.vnode.props[<span class="string">'inline-template'</span>]) ||</span><br><span class="line">        Component.template ||</span><br><span class="line">        resolveMergedOptions(instance).template</span><br><span class="line">      <span class="keyword">if</span> (template) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; isCustomElement, compilerOptions &#125; = instance.appContext.config</span><br><span class="line">        <span class="keyword">const</span> &#123; delimiters, <span class="attr">compilerOptions</span>: componentCompilerOptions &#125; =</span><br><span class="line">          Component</span><br><span class="line">        <span class="comment">// 合并最终编译选项</span></span><br><span class="line">        <span class="keyword">const</span> finalCompilerOptions: CompilerOptions = extend(</span><br><span class="line">          extend(</span><br><span class="line">            &#123;</span><br><span class="line">              isCustomElement,</span><br><span class="line">              delimiters,</span><br><span class="line">            &#125;,</span><br><span class="line">            compilerOptions,</span><br><span class="line">          ),</span><br><span class="line">          componentCompilerOptions,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 编译模板，生成render</span></span><br><span class="line">        Component.render = compile(template, finalCompilerOptions)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于使用 with 块运行时编译的渲染函数，配置渲染上下文的代理RuntimeCompiledPublicInstanceProxyHandlers，是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对has做处理优化。</span></span><br><span class="line">    <span class="keyword">if</span> (installWithProxy) &#123;</span><br><span class="line">      installWithProxy(instance)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// support for 2.x options</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) &#123;</span><br><span class="line">    <span class="keyword">const</span> reset = setCurrentInstance(instance)</span><br><span class="line">    pauseTracking()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      applyOptions(instance)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resetTracking()</span><br><span class="line">      reset()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件最终通过运行 render 函数生成子树 vnode，但是我们很少直接去编写 render 函数，通常会使用两种方式开发组件。</p>
<p>一个是通过编写组件的 template 模板去描述一个组件的 DOM 结构，或者是使用直接在组件的 render 方法内调用 h 方法来创建 vnode。</p>
<p>所以这里首先判断了组件的 render 函数是否存在，如果不存在说明使用的是 template 模版。</p>
<p>对于使用 with 块运行时编译的渲染函数，配置渲染上下文的代理RuntimeCompiledPublicInstanceProxyHandlers，基于PublicInstanceProxyHandlers，主要对has做处理</p>
<p>组件实例设置的最后一个流程——兼容 Vue.js 2.x 的 Options API。我们知道 Vue.js 2.x 是通过组件对象的方式去描述一个组件，Vue.js 3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过 applyOptions方法实现的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%89%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%A6%E8%A7%A3/image-1.png" alt="alt text"></p>
<p>这次主要详细分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了 Composition API 中的 setup 启动函数执行的时机，以及如何建立 setup 返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容 Vue.js 2.x 的 Options API。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="post-title-link" itemprop="url">vue3初始化渲染流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-17T00:00:00+08:00">2023-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue3 官网中有下面这样一张图，基本展现出了 Vue3 的渲染原理：</p>
<p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<p>本文会从源码角度来简单的看一下 Vue3 的运行全流程，旨在加深对上图的理解。</p>
<h2 id="初始化渲染"><a href="#初始化渲染" class="headerlink" title="初始化渲染"></a>初始化渲染</h2><p>从下面这个很简单的使用示例开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">createApp(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="card"&gt;</span></span><br><span class="line"><span class="string">            &lt;button type="button" @click="count++"&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: ref(<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>首先调用了 <code>createApp</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以看到重点在于 <code>ensureRenderer</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rendererOptions = <span class="comment">/*#__PURE__*/</span> extend(&#123; patchProp &#125;, nodeOps)</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="comment">// 因为 ensureRenderer 是在执行 createApp 的时候调用的，如果你不执行 createApp 而只使用 vue 的一些响应式 API，就不会创建这个渲染器，所以说延时渲染。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    renderer ||</span><br><span class="line">    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rendererOptions</code>是一个对象，渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法。</p>
<p>这么做主要是方便跨平台，比如在其他非浏览器环境，可以替换成对应的节点操作方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rendererOptions</span></span><br><span class="line">&#123;</span><br><span class="line">  insert: <span class="function">(<span class="params">child, parent, anchor</span>) =&gt;</span> &#123;</span><br><span class="line">    parent.insertBefore(child, anchor || <span class="literal">null</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  remove: <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = child.parentNode</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      parent.removeChild(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options: RendererOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baseCreateRenderer(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>baseCreateRenderer</code>, 这个函数简直可以用庞大来形容，patch、mount、diff均在这个方法中实现，回头我们再来细看实现，现在我们只需要关心他最后返回的什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RendererOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  createHydrationFns?: typeof createHydrationFunctions,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...此处省略2000行</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render,</span><br><span class="line">        hydrate,</span><br><span class="line">        createApp: createAppAPI(render, hydrate),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现createApp是通过createAppAPI方法调用返回的，下面我们看createAppAPI。</p>
<h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI"></a>createAppAPI</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction&lt;HostElement&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = null</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(rootComponent)) &#123;</span><br><span class="line">      rootComponent = extend(&#123;&#125;, rootComponent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootProps != <span class="literal">null</span> &amp;&amp; !isObject(rootProps)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(<span class="string">`root props passed to app.mount() must be an object.`</span>)</span><br><span class="line">      rootProps = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context = createAppContext()</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isMounted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line">      _instance: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> config() &#123;</span><br><span class="line">        <span class="keyword">return</span> context.config</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">set</span> config(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`app.config cannot be replaced. Modify individual options instead.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 都是一些眼熟的方法</span></span><br><span class="line">      <span class="comment">// 注册plugin</span></span><br><span class="line">      use(plugin: Plugin, ...options: any[]) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 全局混入</span></span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局组件</span></span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 注册全局指令</span></span><br><span class="line">      directive(name: string, directive?: Directive) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 挂载根组件</span></span><br><span class="line">      mount(</span><br><span class="line">        rootContainer: HostElement, <span class="comment">// 挂载容器</span></span><br><span class="line">        isHydrate?: boolean,</span><br><span class="line">        namespace?: boolean | ElementNamespace,</span><br><span class="line">      ): any &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 卸载</span></span><br><span class="line">      unmount() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 分享数据</span></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是最终的 <code>createApp</code>方法，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象。</p>
<p>所谓的应用实例app其实就是一个对象，我们传进去的组件选项作为根组件存储在_component属性上，另外还可以看到应用实例提供的一些方法，比如注册插件的use方法，挂载实例的mount方法等。</p>
<h4 id="createAppContext-实现"><a href="#createAppContext-实现" class="headerlink" title="createAppContext 实现"></a>createAppContext 实现</h4><p>context其实也是一个普通对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> any,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    optionsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    propsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    emitsCache: <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是vue的初次渲染逻辑，首先官方解构了mount方法， 然后又重写了app.mount，并调用normalizeContainer校验挂载元素，临时保存了需要渲染的内容。并对vue2的写法做了兼容处理，挂载元素进行渲染。</p>
<p>在以上整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化的技巧，很好地实现了参数保留。比如，在执行 app.mount 的时候，并不需要传入渲染器 render，这是因为在执行 createAppAPI 的时候渲染器 render 参数已经被保留下来了。</p>
<p>至此，createApp的流程大概到此结束，下一部分来分析mount挂载部分。</p>
<h3 id="mounted挂载"><a href="#mounted挂载" class="headerlink" title="mounted挂载"></a>mounted挂载</h3><h4 id="重写app-mount方法"><a href="#重写app-mount方法" class="headerlink" title="重写app.mount方法"></a>重写app.mount方法</h4><p>createApp 函数中，首先取出 app 对象中的 mount 函数，然后通过 app.mount = () =&gt; {} 对 mount 函数进行重写：</p>
<ol>
<li>首先调用 normalizeContainer 函数来获取container节点；</li>
<li>判断该节点是否存在，若不存在，则直接返回；</li>
<li>清空container的innerHTML；</li>
<li>调用mount函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)这里重写的目的是考虑到跨平台(app.mount里面只包含和平台无关的代码)</span></span><br><span class="line"><span class="comment">    (2)这些重写的代码是完善web平台下的渲染逻辑(比如其他平台也可以进行类似的重写)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  app.mount = (containerOrSelector: Element | ShadowRoot | string): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根组件容器 选择器字符串兼容</span></span><br><span class="line">    <span class="keyword">const</span> container = normalizeContainer(containerOrSelector)</span><br><span class="line">    <span class="keyword">if</span> (!container) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// rootComponent</span></span><br><span class="line">    <span class="keyword">const</span> component = app._component</span><br><span class="line">    <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">    <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      <span class="comment">// __UNSAFE__</span></span><br><span class="line">      <span class="comment">// Reason: potential execution of JS expressions in in-DOM template.</span></span><br><span class="line">      <span class="comment">// The user must make sure the in-DOM template is trusted. If it's</span></span><br><span class="line">      <span class="comment">// rendered by the server, the template should not contain any user data.</span></span><br><span class="line">      component.template = container.innerHTML</span><br><span class="line">      <span class="comment">// 2.x compat check</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * __COMPAT__ 是启动的时候通过rollup去注入进去的</span></span><br><span class="line"><span class="comment">       * 用来判断是否向下兼容</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (__COMPAT__ &amp;&amp; __DEV__) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; container.attributes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> attr = container.attributes[i]</span><br><span class="line">          <span class="keyword">if</span> (attr.name !== <span class="string">'v-cloak'</span> &amp;&amp; <span class="regexp">/^(v-|:|@)/</span>.test(attr.name)) &#123;</span><br><span class="line">            compatUtils.warnDeprecation(</span><br><span class="line">              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,</span><br><span class="line">              <span class="literal">null</span>,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear content before mounting</span></span><br><span class="line">    container.innerHTML = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 调用初始app.mount，挂载元素进行渲染</span></span><br><span class="line">    <span class="keyword">const</span> proxy = mount(container, <span class="literal">false</span>, resolveRootNamespace(container))</span><br><span class="line">    <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      <span class="comment">// vue2的话，会给#app设置一个v-cloak属性，在render的时候清空掉</span></span><br><span class="line">      container.removeAttribute(<span class="string">'v-cloak'</span>)</span><br><span class="line">      container.setAttribute(<span class="string">'data-v-app'</span>, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器），然后做一个 if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容；接着在挂载前清空容器内容，最终再调用 app.mount 的方法走标准的组件渲染流程。</p>
<p>在这里，重写的逻辑都是和 Web 平台相关的，所以要放在外部实现。此外，这么做的目的是既能让用户在使用 API 时可以更加灵活，也兼容了 Vue.js 2.x 的写法，比如 app.mount 的第一个参数就同时支持选择器字符串和 DOM 对象两种类型。</p>
<p>从 app.mount 开始，才算真正进入组件渲染流程。</p>
<h3 id="真正的挂载mounted"><a href="#真正的挂载mounted" class="headerlink" title="真正的挂载mounted"></a>真正的挂载mounted</h3><p><strong>核心流程：</strong></p>
<ol>
<li><strong>根据传入的根组件App创建vnode</strong></li>
<li><strong>渲染vnode。</strong></li>
</ol>
<h4 id="mount方法"><a href="#mount方法" class="headerlink" title="mount方法"></a>mount方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mount(</span><br><span class="line">    rootContainer: HostElement,</span><br><span class="line">    isHydrate?: boolean,</span><br><span class="line">    namespace?: boolean | ElementNamespace,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">        <span class="comment">// #5571</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; (rootContainer <span class="keyword">as</span> any).__vue_app__) &#123;</span><br><span class="line">            warn(</span><br><span class="line">                <span class="string">`There is already an app instance mounted on the host container.\n`</span> +</span><br><span class="line">                <span class="string">` If you want to mount another app on the same host container,`</span> +</span><br><span class="line">                <span class="string">` you need to unmount the previous app by calling \`app.unmount()\` first.`</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line">        <span class="comment">// store app context on the root VNode.</span></span><br><span class="line">        <span class="comment">// this will be set on the root instance on initial mount.</span></span><br><span class="line">        vnode.appContext = context</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (namespace === <span class="literal">true</span>) &#123;</span><br><span class="line">            namespace = <span class="string">'svg'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace === <span class="literal">false</span>) &#123;</span><br><span class="line">            namespace = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HMR root reload</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        context.reload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// casting to ElementNamespace because TS doesn't guarantee type narrowing</span></span><br><span class="line">            <span class="comment">// over function boundaries</span></span><br><span class="line">            render(</span><br><span class="line">                cloneVNode(vnode),</span><br><span class="line">                rootContainer,</span><br><span class="line">                namespace <span class="keyword">as</span> ElementNamespace,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode <span class="keyword">as</span> VNode&lt;Node, Element&gt;, rootContainer <span class="keyword">as</span> any)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(vnode, rootContainer, namespace)</span><br><span class="line">        &#125;</span><br><span class="line">        isMounted = <span class="literal">true</span></span><br><span class="line">        app._container = rootContainer</span><br><span class="line">        <span class="comment">// for devtools and telemetry</span></span><br><span class="line">        ;(rootContainer <span class="keyword">as</span> any).__vue_app__ = app</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            app._instance = vnode.component</span><br><span class="line">            devtoolsInitApp(app, version)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getExposeProxy(vnode.component!) || vnode.component!.proxy</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">        <span class="string">`App has already been mounted.\n`</span> +</span><br><span class="line">            <span class="string">`If you want to remount the same app, move your app creation logic `</span> +</span><br><span class="line">            <span class="string">`into a factory function and create fresh app instances for each `</span> +</span><br><span class="line">            <span class="string">`mount - e.g. \`const createMyApp = () =&gt; createApp(App)\``</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createVNode"><a href="#createVNode" class="headerlink" title="createVNode"></a>createVNode</h4><p>createVNode方法会根据组件的类型生成一个标志，后续会通过这个标志做一些优化处理。我们传的是一个组件选项，也就是一个普通对象，shapeFlag的值为4。后续我们会重点关注我们的主线组件 vnode 和普通元素 vnode。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createVNode = _createVNode;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createVNode</span>(<span class="params">type, props = null, children = null, patchFlag = <span class="number">0</span>, dynamicProps = null, isBlockNode = false</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> shapeFlag = isString(type)</span><br><span class="line">        ? <span class="number">1</span> <span class="comment">/* ShapeFlags.ELEMENT */</span></span><br><span class="line">        : isSuspense(type)</span><br><span class="line">            ? <span class="number">128</span> <span class="comment">/* ShapeFlags.SUSPENSE */</span></span><br><span class="line">            : isTeleport(type)</span><br><span class="line">                ? <span class="number">64</span> <span class="comment">/* ShapeFlags.TELEPORT */</span></span><br><span class="line">                : isObject(type)</span><br><span class="line">                    ? <span class="number">4</span> <span class="comment">/* ShapeFlags.STATEFUL_COMPONENT */</span></span><br><span class="line">                    : isFunction(type)</span><br><span class="line">                        ? <span class="number">2</span> <span class="comment">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span></span><br><span class="line">                        : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用了createBaseVNode方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBaseVNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: (Data &amp; VNodeProps</span>) | <span class="title">null</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">children</span>: <span class="title">unknown</span> = <span class="title">null</span>,</span></span><br><span class="line"><span class="function">  <span class="title">patchFlag</span> = 0,</span></span><br><span class="line">  dynamicProps: string[] | null = null,</span><br><span class="line">  shapeFlag = type === Fragment ? <span class="number">0</span> : ShapeFlags.ELEMENT,</span><br><span class="line">  isBlockNode = <span class="literal">false</span>,</span><br><span class="line">  needFullChildrenNormalization = <span class="literal">false</span>,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    __v_isVNode: <span class="literal">true</span>,</span><br><span class="line">    __v_skip: <span class="literal">true</span>,</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    key: props &amp;&amp; normalizeKey(props),</span><br><span class="line">    ref: props &amp;&amp; normalizeRef(props),</span><br><span class="line">    scopeId: currentScopeId,</span><br><span class="line">    slotScopeIds: <span class="literal">null</span>,</span><br><span class="line">    children,</span><br><span class="line">    component: <span class="literal">null</span>,</span><br><span class="line">    suspense: <span class="literal">null</span>,</span><br><span class="line">    ssContent: <span class="literal">null</span>,</span><br><span class="line">    ssFallback: <span class="literal">null</span>,</span><br><span class="line">    dirs: <span class="literal">null</span>,</span><br><span class="line">    transition: <span class="literal">null</span>,</span><br><span class="line">    el: <span class="literal">null</span>,</span><br><span class="line">    anchor: <span class="literal">null</span>,</span><br><span class="line">    target: <span class="literal">null</span>,</span><br><span class="line">    targetAnchor: <span class="literal">null</span>,</span><br><span class="line">    staticCount: <span class="number">0</span>,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    dynamicChildren: <span class="literal">null</span>,</span><br><span class="line">    appContext: <span class="literal">null</span>,</span><br><span class="line">    ctx: currentRenderingInstance,</span><br><span class="line">  &#125; <span class="keyword">as</span> VNode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到返回的虚拟DOM也是一个普通对象，我们传进去的组件选项会存储在type属性上。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>虚拟DOM创建完后就会调用render方法将虚拟DOM渲染为实际的DOM节点，render方法就是在baseCreateRenderer中创建的，通过参数传给createAppAPI的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container, namespace</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新vnode不存在</span></span><br><span class="line">    <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 卸载</span></span><br><span class="line">      <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建或者更新组件</span></span><br><span class="line">      patch(</span><br><span class="line">        container._vnode || <span class="literal">null</span>, <span class="comment">// 如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可</span></span><br><span class="line">        vnode,</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        namespace,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushing) &#123;</span><br><span class="line">      isFlushing = <span class="literal">true</span></span><br><span class="line">      flushPreFlushCbs()</span><br><span class="line">      flushPostFlushCbs()</span><br><span class="line">      isFlushing = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">    container._vnode = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要渲染的新VNode不存在，那么从容器元素上获取之前VNode进行卸载，否则调用patch方法进行打补丁，如果是首次渲染，container._vnode不存在，那么直接将新VNode渲染为DOM元素即可，否则会对比新旧VNode，使用diff算法进行打补丁，Vue2中使用的是双端diff算法，Vue3中使用的是快速diff算法。</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>看看render方法里调用的patch方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1, <span class="comment">// n1 表示旧的vnode，当n1为null时就表示是一次挂载（挂载or更新由n1决定）</span></span><br><span class="line">    n2, <span class="comment">// n2 表示新的vnode，根据n2的type进行不同的处理</span></span><br><span class="line">    container, <span class="comment">// 渲染后会将vnode渲染到container上</span></span><br><span class="line">    anchor = <span class="literal">null</span>,</span><br><span class="line">    parentComponent = <span class="literal">null</span>,</span><br><span class="line">    parentSuspense = <span class="literal">null</span>,</span><br><span class="line">    namespace = <span class="literal">undefined</span>,</span><br><span class="line">    slotScopeIds = <span class="literal">null</span>,</span><br><span class="line">    optimized = __DEV__ &amp;&amp; isHmrUpdating ? <span class="literal">false</span> : !!n2.dynamicChildren,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 === n2) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">    <span class="comment">// 如果新的节点和旧的节点类型不同，则销毁旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        anchor = getNextHostNode(n1)</span><br><span class="line">        unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">        n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n2.patchFlag === PatchFlags.BAIL) &#123;</span><br><span class="line">        optimized = <span class="literal">false</span></span><br><span class="line">        n2.dynamicChildren = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; type, ref, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Text: <span class="comment">//... 处理文本节点</span></span><br><span class="line">        <span class="keyword">case</span> Comment: <span class="comment">//... 处理注释节点</span></span><br><span class="line">        <span class="keyword">case</span> Static: <span class="comment">//... 处理静态节点</span></span><br><span class="line">        <span class="keyword">case</span> Fragment: <span class="comment">//... 处理Fragment组件节点</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">          <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">           processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            namespace,</span><br><span class="line">            slotScopeIds,</span><br><span class="line">            optimized,</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">          <span class="comment">// 处理组件</span></span><br><span class="line">            processComponent(</span><br><span class="line">                n1,</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                slotScopeIds,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;</span><br><span class="line">          	<span class="comment">// 处理 TELEPORT</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">          	<span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            warn(<span class="string">'Invalid VNode type:'</span>, type, <span class="string">`(<span class="subst">$&#123;<span class="keyword">typeof</span> type&#125;</span>)`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ref</span></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span> &amp;&amp; parentComponent) &#123;</span><br><span class="line">        setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM。</p>
<p>patch的多个参数中，重点关注前三个：</p>
<ol>
<li><p>第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程；</p>
</li>
<li><p>第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；</p>
</li>
<li><p>第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</p>
</li>
</ol>
<p>switch里面根据VNode的类型不同做的处理也不同，因为我们的例子传的是一个组件选项对象，所以会走processComponent处理分支：</p>
<h4 id="processComponent"><a href="#processComponent" class="headerlink" title="processComponent"></a>processComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = (</span><br><span class="line">    n1: VNode | <span class="literal">null</span>,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    slotScopeIds: string[] | <span class="literal">null</span>,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    n2.slotScopeIds = slotScopeIds</span><br><span class="line">    <span class="comment">// n1等于null，表示挂载组件</span></span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            ;(parentComponent!.ctx <span class="keyword">as</span> KeepAliveContext).activate(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用mountComponent挂载组件</span></span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                namespace,</span><br><span class="line">                optimized,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// n1不为null，表示更新组件</span></span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否存在旧的VNode判断是调用挂载方法还是更新方法，先看mountComponent方法：</p>
<h5 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent: MountComponentFn = (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 2.x compat may pre-create the component instance before actually</span></span><br><span class="line">    <span class="comment">// mounting</span></span><br><span class="line">    <span class="keyword">const</span> compatMountInstance =</span><br><span class="line">      __COMPAT__ &amp;&amp; initialVNode.isCompatRoot &amp;&amp; initialVNode.component</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.调用ComponentInternalInstance创建组件的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance: ComponentInternalInstance =</span><br><span class="line">      compatMountInstance ||</span><br><span class="line">      <span class="comment">// 调用createComponentInstance函数创建一个实例对象，其属性皆为没有值</span></span><br><span class="line">      (initialVNode.component = createComponentInstance(</span><br><span class="line">        initialVNode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">      ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve props and slots for setup context</span></span><br><span class="line">    <span class="keyword">if</span> (!(__COMPAT__ &amp;&amp; compatMountInstance)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2.设置组件实例</span></span><br><span class="line">      <span class="comment">// 初始化组件, 主要是对组件的props/slots进行初始化处理</span></span><br><span class="line">      <span class="comment">// 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</span></span><br><span class="line">      setupComponent(instance)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line">    <span class="comment">// before proceeding</span></span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3.调用设置和运行有副作用的渲染函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 创建一个组件更新函数</span></span><br><span class="line">      <span class="comment">//  1.1 render获得vnode</span></span><br><span class="line">      <span class="comment">//  1.2 patch(oldVnode, newVnode)</span></span><br><span class="line">      <span class="comment">// 2 创建更新机制 new ReactiveEffect(更新函数)</span></span><br><span class="line">      <span class="comment">// 执行渲染副作用函数</span></span><br><span class="line">      setupRenderEffect(</span><br><span class="line">        instance,</span><br><span class="line">        initialVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        namespace,</span><br><span class="line">        optimized,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      popWarningContext()</span><br><span class="line">      endMeasure(instance, <span class="string">`mount`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用ComponentInternalInstance创建组件的实例</li>
<li>设置组件实例，初始化组件 处理setup的两个参数, 执行setup 生成render函数（所以setup是在所有选项式API钩子之前调用 包括beforeCreate）</li>
<li>调用设置和运行有副作用的渲染函数</li>
</ol>
<p>下面我们依次来看这三个方法：</p>
<h5 id="1-createComponentInstance"><a href="#1-createComponentInstance" class="headerlink" title="1. createComponentInstance"></a>1. createComponentInstance</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  parent: ComponentInternalInstance | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  suspense: SuspenseBoundary | null,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = vnode.type <span class="keyword">as</span> ConcreteComponent</span><br><span class="line">  <span class="comment">// inherit parent app context - or - if root, adopt from root vnode</span></span><br><span class="line">  <span class="keyword">const</span> appContext =</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance: ComponentInternalInstance = &#123;</span><br><span class="line">    uid: uid++,</span><br><span class="line">    vnode,</span><br><span class="line">    type,</span><br><span class="line">    parent,</span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// 还有非常多属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-setupComponent"><a href="#2-setupComponent" class="headerlink" title="2. setupComponent"></a>2. setupComponent</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(isSSR)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vnode的props和子元素</span></span><br><span class="line">  <span class="keyword">const</span> &#123; props, children &#125; = instance.vnode</span><br><span class="line">  <span class="comment">// 是否是有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = isStatefulComponent(instance)</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="comment">// 初始化slots</span></span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  <span class="comment">// 执行setupStatefulComponent获取setupResult</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR) <span class="comment">// 执行setup</span></span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  isSSR &amp;&amp; setInSSRSetupState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到setupComponent会初始化props和slots，然后执行setupStatefulComponent，这里主要是执行setup函数，并返回结果</p>
<h6 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent"></a>setupStatefulComponent</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 组件描述对象</span></span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0. create render proxy property access cache</span></span><br><span class="line">  <span class="comment">// 创建render proxy属性访问缓存 作用是缓存访问过的属性</span></span><br><span class="line">  instance.accessCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 1. create public instance / render proxy</span></span><br><span class="line">  <span class="comment">// also mark it raw so it's never observed</span></span><br><span class="line">  <span class="comment">// 代理ctx，拦截ctx的属性访问 从而实现取值的优先级：setupState &gt; data &gt; props &gt; ctx</span></span><br><span class="line">  instance.proxy = markRaw(<span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, PublicInstanceProxyHandlers))</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    exposePropsOnRenderContext(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. call setup()</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component</span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 创建setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instance赋值给currentInstance</span></span><br><span class="line">    <span class="comment">// 设置当前实例为instance 为了在setup中可以通过getCurrentInstance获取到当前实例</span></span><br><span class="line">    <span class="comment">// 同时开启instance.scope.on()</span></span><br><span class="line">    <span class="keyword">const</span> reset = setCurrentInstance(instance)</span><br><span class="line">    <span class="comment">// 暂停tracking 暂停收集副作用函数</span></span><br><span class="line">    pauseTracking()</span><br><span class="line">    <span class="comment">// 执行setup</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [</span><br><span class="line">        __DEV__ ? shallowReadonly(instance.props) : instance.props,</span><br><span class="line">        setupContext,</span><br><span class="line">      ],</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 重新开启副作用收集</span></span><br><span class="line">    resetTracking()</span><br><span class="line">    <span class="comment">// currentInstance置为空</span></span><br><span class="line">    <span class="comment">// activeEffectScope赋值为instance.scope.parent</span></span><br><span class="line">    <span class="comment">// 同时instance.scope.off()</span></span><br><span class="line">    reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPromise(setupResult)) &#123;</span><br><span class="line">      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)</span><br><span class="line">      <span class="keyword">if</span> (isSSR) &#123;</span><br><span class="line">        <span class="comment">// return the promise so server-renderer can wait on it</span></span><br><span class="line">        <span class="keyword">return</span> setupResult</span><br><span class="line">          .then(<span class="function">(<span class="params">resolvedResult: unknown</span>) =&gt;</span> &#123;</span><br><span class="line">            handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        <span class="comment">// async setup returned Promise.</span></span><br><span class="line">        <span class="comment">// bail here and wait for re-entry.</span></span><br><span class="line">        instance.asyncDep = setupResult</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; !instance.suspense) &#123;</span><br><span class="line">          <span class="keyword">const</span> name = Component.name ?? <span class="string">'Anonymous'</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Component &lt;<span class="subst">$&#123;name&#125;</span>&gt;: setup function returned a promise, but no `</span> +</span><br><span class="line">              <span class="string">`&lt;Suspense&gt; boundary was found in the parent component tree. `</span> +</span><br><span class="line">              <span class="string">`A component with async setup() must be nested in a &lt;Suspense&gt; `</span> +</span><br><span class="line">              <span class="string">`in order to be rendered.`</span>,</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`setup() returned a Promise, but the version of Vue you are using `</span> +</span><br><span class="line">            <span class="string">`does not support it yet.`</span>,</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里会调用组件选项的setup方法，这个函数中返回的对象会暴露给模板和组件实例，看一下handleSetupResult方法：</p>
<h6 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult"></a>handleSetupResult</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params">instance, setupResult, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFunction(setupResult)) &#123;</span><br><span class="line">        instance.render = setupResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123;</span><br><span class="line">        instance.setupState = proxyRefs(setupResult);</span><br><span class="line">    &#125;</span><br><span class="line">    finishComponentSetup(instance, isSSR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果setup返回的是一个函数，那么这个函数会直接被作为渲染函数。否则如果返回的是一个对象，会使用proxyRefs将这个对象转为Proxy代理的响应式对象。</p>
<h6 id="finishComponentSetup"><a href="#finishComponentSetup" class="headerlink" title="finishComponentSetup"></a>finishComponentSetup</h6><p>最后又调用了finishComponentSetup方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span>(<span class="params">instance, isSSR</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Component = instance.type;</span><br><span class="line">    <span class="keyword">if</span> (!instance.render) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSSR &amp;&amp; compile &amp;&amp; !Component.render) &#123;</span><br><span class="line">            <span class="keyword">const</span> template = Component.template ||</span><br><span class="line">                  resolveMergedOptions(instance).template;</span><br><span class="line">            <span class="keyword">if</span> (template) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; isCustomElement, compilerOptions &#125; = instance.appContext.config;</span><br><span class="line">                <span class="keyword">const</span> &#123; delimiters, <span class="attr">compilerOptions</span>: componentCompilerOptions &#125; = Component;</span><br><span class="line">                <span class="keyword">const</span> finalCompilerOptions = extend(extend(&#123;</span><br><span class="line">                    isCustomElement,</span><br><span class="line">                    delimiters</span><br><span class="line">                &#125;, compilerOptions), componentCompilerOptions);</span><br><span class="line">                Component.render = compile(template, finalCompilerOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        instance.render = (Component.render || NOOP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是判断组件是否存在渲染函数render，如果不存在则判断是否存在template选项，我们传的组件选项显然是没有render属性，而是传的模板template，所以会使用compile方法来将模板编译成渲染函数。</p>
<h5 id="3-setupRenderEffect"><a href="#3-setupRenderEffect" class="headerlink" title="3. setupRenderEffect"></a>3. setupRenderEffect</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode, <span class="comment">// 组件 vnode</span></span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    namespace: ElementNamespace,</span><br><span class="line">    optimized,</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 组件更新方法</span></span><br><span class="line">    <span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">    <span class="comment">// 创建一个effect, 将componentUpdateFn更新方法传入响应式更新方法</span></span><br><span class="line">    <span class="keyword">const</span> effect = (instance.effect = <span class="keyword">new</span> ReactiveEffect(</span><br><span class="line">      componentUpdateFn,</span><br><span class="line">      NOOP,</span><br><span class="line">      () =&gt; queueJob(update),</span><br><span class="line">      instance.scope, <span class="comment">// track it in component's effect scope</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件更新函数</span></span><br><span class="line">    <span class="keyword">const</span> update: SchedulerJob = <span class="function">(<span class="params">instance.update = (</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect.dirty) &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    update.id = instance.uid</span><br><span class="line">    <span class="comment">// allowRecurse</span></span><br><span class="line">    <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">    toggleRecurse(instance, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      effect.onTrack = instance.rtc</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtc!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      effect.onTrigger = instance.rtg</span><br><span class="line">        ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtg!, e)</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">      update.ownerInstance = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行组件更新</span></span><br><span class="line">    update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就涉及到Vue3的响应式原理了，核心就是使用Proxy拦截数据，然后在属性读取时将属性和读取该属性的函数（称为副作用函数）关联起来，然后在更新该属性时取出该属性关联的副作用函数出来执行。</p>
<p>简化后的ReactiveEffect类就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactiveEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn, scheduler = null, scope) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        activeEffect = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fn();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            activeEffect = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行它的run方法时会把自身赋值给全局的activeEffect变量，然后执行副作用函数时如果读取了Proxy代理后的对象的某个属性时就会将对象、属性和这个ReactiveEffect示例关联存储起来，如果属性发生改变，会取出关联的ReactiveEffect实例，执行它的run方法，达到自动更新的目的。</p>
<h6 id="componentUpdateFn"><a href="#componentUpdateFn" class="headerlink" title="componentUpdateFn"></a>componentUpdateFn</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentUpdateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断组件是否已经挂载</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">const</span> &#123; el, props &#125; = initialVNode</span><br><span class="line">    <span class="comment">// 生命周期和父instance</span></span><br><span class="line">    <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance</span><br><span class="line">    <span class="keyword">const</span> isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><br><span class="line">    toggleRecurse(instance, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// beforeMount hook</span></span><br><span class="line">    <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">      invokeArrayFns(bm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeBeforeMount</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">      <span class="comment">// ssr 相关</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行render函数获得subTree(也是一个vnode) 将subTree挂载到instance上 以供更新使用</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance)) <span class="comment">// 整个组件渲染生成 DOM 对应的 vnode 树</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// patch subTree初次挂载</span></span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        subTree,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// el同步到initialVNode</span></span><br><span class="line">      initialVNode.el = subTree.el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mounted hook</span></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      queuePostRenderEffect(m, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onVnodeMounted</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 组件已经挂载</span></span><br><span class="line">    instance.isMounted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">      devtoolsComponentAdded(instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2458: deference mount-only object parameters to prevent memleaks</span></span><br><span class="line">    initialVNode = container = anchor = <span class="literal">null</span> <span class="keyword">as</span> any</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件更新</span></span><br><span class="line">    <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">    <span class="keyword">let</span> originNext = next</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      next.el = vnode.el</span><br><span class="line">      <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">      updateComponentPreRender(instance, next, optimized)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行render函数获得nextTree</span></span><br><span class="line">    <span class="keyword">const</span> nextTree = renderComponentRoot(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取老的subTree</span></span><br><span class="line">    <span class="keyword">const</span> prevTree = instance.subTree</span><br><span class="line">    instance.subTree = nextTree</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patch新旧节点更新组件</span></span><br><span class="line">    patch(</span><br><span class="line">      prevTree,</span><br><span class="line">      nextTree,</span><br><span class="line">      <span class="comment">// parent may have changed if it's in a teleport</span></span><br><span class="line">      hostParentNode(prevTree.el!)!,</span><br><span class="line">      <span class="comment">// anchor may have changed if it's in a fragment</span></span><br><span class="line">      getNextHostNode(prevTree),</span><br><span class="line">      instance,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的patch操作其实就是调用本章开头的那个patch，可以看到patch其实是一个递归操作，这里patch subtree如果根组件的根元素是组件则会继续执行processComponent，如果是一个element元素则会执行processElement，processElement中会处理children，又会调用patch，如此递归直到整个组件挂载完成。</p>
<p>组件无论是首次挂载，还是更新，做的事情核心是一样的，先调用renderComponentRoot方法生成组件模板的虚拟DOM，然后调用patch方法打补丁。</p>
<h6 id="renderComponentRoot"><a href="#renderComponentRoot" class="headerlink" title="renderComponentRoot"></a>renderComponentRoot</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponentRoot</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">type</span>: Component, vnode, proxy, withProxy, props, <span class="attr">propsOptions</span>: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs &#125; = instance;</span><br><span class="line">	  <span class="comment">// 执行render函数</span></span><br><span class="line">  	<span class="comment">// render函数内部会通过_createVNode或者_createElementVNode等函数进一步生成子vnode</span></span><br><span class="line">    <span class="keyword">let</span> result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderComponentRoot核心就是调用组件的渲染函数render方法生成组件模板的虚拟DOM，然后扔给patch方法更新就好了。</p>
<h5 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a>updateComponent</h5><p>看完了mountComponent方法，再来看看updateComponent方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponent = <span class="function">(<span class="params">n1, n2, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = (n2.component = n1.component);</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdateComponent(n1, n2, optimized)) &#123;</span><br><span class="line">        <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">        instance.next = n2;</span><br><span class="line">        <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    	  invalidateJob(instance.update)</span><br><span class="line">        <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">        instance.update();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要更新</span></span><br><span class="line">        n2.el = n1.el;</span><br><span class="line">        instance.vnode = n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用shouldUpdateComponent方法判断组件是否需要更新，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。</p>
<p>如果需要更新，那么会执行instance.update方法，这个方法就是前面setupRenderEffect方法里保存的effect.run方法，所以最终执行的也是componentUpdateFn方法。</p>
<h6 id="updateComponentPreRender"><a href="#updateComponentPreRender" class="headerlink" title="updateComponentPreRender"></a>updateComponentPreRender</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateComponentPreRender = (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    nextVNode: VNode,</span><br><span class="line">    optimized: boolean,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.component = instance</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.vnode.props</span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.vnode = nextVNode</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.next = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  updateProps(instance, nextVNode.props, prevProps, optimized)</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  updateSlots(instance, nextVNode.children, optimized)</span><br><span class="line"></span><br><span class="line">  pauseTracking()</span><br><span class="line">  <span class="comment">// props update may have triggered pre-flush watchers.</span></span><br><span class="line">  <span class="comment">// flush them before the render update.</span></span><br><span class="line">  flushPreFlushCbs(instance)</span><br><span class="line">  resetTracking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">'svg'</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p>
<p>我们接着来看挂载元素的 mountElement 函数的实现：</p>
<h6 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement"></a>mountElement</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is)</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况</span></span><br><span class="line">    mountChildren(vnode.children, el, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG &amp;&amp; type !== <span class="string">'foreignObject'</span>, optimized || !!vnode.dynamicChildren)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。</p>
<p>首先是创建 DOM 元素节点，通过 hostCreateElement 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tag, isSVG, is</span>) </span>&#123;</span><br><span class="line">  isSVG ? <span class="built_in">document</span>.createElementNS(svgNS, tag)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(tag, is ? &#123; is &#125; : <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了底层的 DOM API document.createElement 创建元素，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。</p>
<p>创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。</p>
<p>接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p>
<p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElementText</span>(<span class="params">el, text</span>) </span>&#123;</span><br><span class="line">  el.textContent = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子节点是数组，则执行 mountChildren 方法：</p>
<h6 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountChildren = <span class="function">(<span class="params">children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 预处理 child</span></span><br><span class="line">    <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">      ? cloneIfMounted(children[i])</span><br><span class="line">      : normalizeVNode(children[i]))</span><br><span class="line">    <span class="comment">// 递归 patch 挂载 child</span></span><br><span class="line">    patch(<span class="literal">null</span>, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。</p>
<p>可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。</p>
<p>另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。</p>
<p>处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">child, parent, anchor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (anchor) &#123;</span><br><span class="line">    parent.insertBefore(child, anchor)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。</p>
<p>因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../images/vue3%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-1.png" alt="image-1"></p>
<p>到这里，从我们创建实例到页面渲染，再到更新的全流程就讲完了，总结一下，大致就是:</p>
<ol>
<li><p>每个Vue组件都需要产出一份虚拟DOM，也就是组件的render函数的返回值，render函数你可以直接手写，也可以通过template传递模板字符串，由Vue内部来编译成渲染函数，平常我们开发时写的Vue单文件，最终也会编译成普通的Vue组件选项对象；</p>
</li>
<li><p>render函数会作为副作用函数执行，也就是如果在模板中使用到了响应式数据（所谓响应式数据就是能拦截到它的各种读取、修改操作），那么响应式数据和属性会与render函数关联起来，那么当响应式数据被修改以后，就能找到依赖它的render函数，那么就可以通知依赖的组件进行更新；</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%88Update%20the%20rendering%EF%BC%89%E7%9A%84%E6%97%B6%E6%9C%BA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%88Update%20the%20rendering%EF%BC%89%E7%9A%84%E6%97%B6%E6%9C%BA.html" class="post-title-link" itemprop="url">EventLoop规范 - 更新渲染（Update the rendering）的时机验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-18T00:00:00+08:00">2023-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="event-loop-中的-Update-the-rendering（更新渲染）"><a href="#event-loop-中的-Update-the-rendering（更新渲染）" class="headerlink" title="event loop 中的 Update the rendering（更新渲染）"></a>event loop 中的 Update the rendering（更新渲染）</h2><p>这是 event loop 中很重要部分，在<a href="https://rile14929.github.io/zh-CN/eventloop.html">这篇文章处理流程（processing model）中第 3 步会进行 Update the rendering（更新渲染）</a>，规范允许浏览器自己选择是否更新视图。也就是说可能不是每轮事件循环都去更新视图，只在有必要的时候才更新视图。</p>
<p>渲染的基本流程：</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image.png" alt="alt text"></p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树， 将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>Note: 可以看到渲染树的一个重要组成部分是 CSSOM 树，绘制会等待 css 样式全部加载完成才进行，所以 css 样式加载的快慢是首屏呈现快慢的关键点。</p>
<p>下面讨论一下渲染的时机。规范定义在一次循环中，Update the rendering 会在 Microtasks: Perform a microtask checkpoint 后运行。</p>
<h2 id="渲染时机"><a href="#渲染时机" class="headerlink" title="渲染时机"></a>渲染时机</h2><blockquote>
<p>以下的例子中，用 chrome 的 Developer tools 的 Timeline 查看各部分运行的时间点。当我们点击这个 div 的时候，截取了部分时间线。</p>
<p>黄色部分是脚本运行，紫色部分是更新 render 树、计算布局，绿色部分是绘制。</p>
<p>绿色和紫色部分可以认为是 Update the rendering。</p>
</blockquote>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> t = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = t</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-1.png" alt="alt text"></p>
<p>在这一轮事件循环中，setTimeout1 是作为 task 运行的，可以看到 paint 确实是在 task 运行完后才进行的。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>现在换成一个 microtask 任务，看看有什么变化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      con.textContext = 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-2.png" alt="alt text"></p>
<p>和上一个例子很像，不同的是这一轮事件循环的 task 是 click 的回调函数，Promise1 则是 microtask，paint 同样是在他们之后完成。</p>
<p>标准就是那么定义的，答案似乎显而易见，我们把例子变得稍微复杂一些。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子 3"></a>例子 3</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="title">click1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-3.png" alt="alt text"><br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-4.png" alt="alt text"></p>
<p>经过多次测试，执行和渲染顺序可能会出现上图的两种情况，根据 timeline 可以看出，图 1 中 setTimeout 分别执行并且浏览器绘制了两次，图二中 setTimeout1 和 setTimeout2 中间并没有绘制, 而是最后绘制了一次，也基本符合规范，但是需要验证这两次 setTimeout 是否在两次 task 中。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>在两个 setTimeout 中增加 microtask。再次确认 setTimeout 在两个 task 中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">Promise2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-5.png" alt="alt text"><br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-9.png" alt="alt text"></p>
<p>从 run microtasks 中可以看出来，setTimeout1、setTimeout2 是运行在两次 event loop 中</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子 5"></a>例子 5</h3><p>将时间间隔加大一些。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="title">click1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 17)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当间隔增大，大部分时候可以肉眼从看到先变成 0，再变成 1 的过程。但是有时也是会合并起来，只 paint 一次</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-6.png" alt="alt text"></p>
<p>通过 timeline，可以看到 setTimeout1 后接着 paint，后执行了 setTimeout2 后也有 paint</p>
<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子 6"></a>例子 6</h3><p>我们在同一时间执行多个 setTimeout 来模拟执行间隔很短的 task。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 0</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 2</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 3</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 4</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 5</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = 6</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-7.png" alt="alt text"><br>图一中总共 paint 了一次</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-8.png" alt="alt text"></p>
<p>图二中一共 paint 了两次，所以多次 task 的间隔很短，仍会进行绘制。</p>
<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子 7"></a>例子 7</h3><p>有说法是一轮 event loop 执行的 microtask 有数量限制，多余的 microtask 会放到下一轮执行。下面例子将 microtask 的数量增加到 25000。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      con.textContent = <span class="string">'task1'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">250000</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          con.textContent = i</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      con.textContent = <span class="string">'task2'</span></span></span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-10.png" alt="alt text"></p>
<p>可以看到脚本的运行耗费大量的时间，并且阻塞了渲染。</p>
<p>我们看 setTimeout2 的运行情况</p>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-11.png" alt="alt text"></p>
<p>可以看到 setTimeout2 这轮 event loop 没有 run microtasks，microtasks 在 setTimeout1 被全部执行完了。</p>
<p>25000 个 microtasks 不能说明 event loop 对 microtasks 数量没有限制，有可能这个限制数很高，远超 25000，但日常使用基本不会使用那么多了。</p>
<p>对 microtasks 增加数量限制，一个很大的作用是防止脚本运行时间过长，阻塞渲染。</p>
<h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子 8"></a>例子 8</h3><p>使用 requestAnimationFrame。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> con = <span class="built_in">document</span>.getElementById(<span class="string">'con'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> i = <span class="number">0</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> raf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">      con.textContent = i</span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        i++</span><br><span class="line">        if (i &lt; 3) raf()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  con.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">    raf()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看下总体的 timeline<br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-12.png" alt="alt text"></p>
<p>单看某一个 requestAnimationFrame<br><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-13.png" alt="alt text"></p>
<ul>
<li>可以看出 requestAnimationFrame 是在更新渲染阶段的执行的，其执行顺序早于 paint，并且不会被合并执行，非常适合做动画</li>
<li>在 requestAnimationFrame 回调内有新的 microtasks 进入时，也会执行完所有的 microtasks 才会进入到渲染阶段</li>
</ul>
<h3 id="例子-9"><a href="#例子-9" class="headerlink" title="例子 9"></a>例子 9</h3><p>验证 postMessage 是否是 task</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel()</span></span><br><span class="line"><span class="actionscript">  channel.port1.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">onmessage1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'postMessage'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  channel.port2.postMessage(0)</span><br><span class="line"><span class="actionscript">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'sync'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br><span class="line">setTimeout1</span><br><span class="line">postMessage</span><br><span class="line">promise1</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure>

<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-14.png" alt="alt text"></p>
<p>第一个黄块是 setTimeout1，第二个是 onmessage1，第三个是 promise1，第四个是 setTimeout2。显而易见，postMessage 属于 task。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合规范和以上验证案例可以得出一些结论：</p>
<ul>
<li>event loop 的大致循环过程，可以用下边的图表示：</li>
</ul>
<p><img src="../images/EventLoop%E9%AA%8C%E8%AF%81%E6%9B%B4%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%97%B6%E6%9C%BA/image-15.png" alt="alt text"></p>
<ul>
<li>在一轮 event loop 中多次修改同一 dom，只有最后一次会进行绘制。</li>
<li>例 3-例 6 这几个结果是非常不可控的，如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。</li>
<li>渲染更新（Update the rendering）会在 event loop 中的 tasks 和 microtasks 完成后进行，但并不是每轮 event loop 都会更新渲染，这里有一个 rendering opportunity 的概念，判断是否需要渲染，这取决于是否修改了 dom 和浏览器觉得是否有必要在此时立即将新状态呈现给用户，也要要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定。通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）</li>
<li>事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行。</li>
<li>如果希望在每轮 event loop 都即时呈现变动，可以使用 requestAnimationFrame。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/semantic-release.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/semantic-release.html" class="post-title-link" itemprop="url">团队敏捷实践 —— 使用 semantic-release 实现自动化发布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-09-01T00:00:00+08:00">2023-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的分享中，我们团队已经成功运用了 Gitlab CI，并且已经结构化提交 git commit 记录，我们希望更进一步，自动管理发布版本，自动生成更新日志，自动发布 NPM 包，因此我们引入了 semantic-release 进一步自动化管理我们的发布流程。</p>
<h2 id="semantic-release-概述"><a href="#semantic-release-概述" class="headerlink" title="semantic-release 概述"></a>semantic-release 概述</h2><p>有关<a href="https://semantic-release.gitbook.io/semantic-release/" target="_blank" rel="noopener">semantic-release</a>的详细介绍可以阅读官方文档，这里只做一些概述性的总结。和 standard-version 相比，semantic-release 更适合在 CI 环境中运行，它自带支持各种 git server 的认证支持，如 Github，Gitlab，Bitbucket 等等，此外，还支持插件，以便完成其他后续的流程步骤，比如自动生成 git tag 和 release note 之后再 push 回中央仓库，自动发布 npm 包等等。</p>
<p>semantic-release 会根据规范化的 commit 信息生成发布日志，默认使用 angular 规则，其他规则可以配置插件完成。</p>
<p>semantic-release 大致的工作流如下:</p>
<ul>
<li>提交到特定的分支触发 release 流程</li>
<li>验证 commit 信息，生成 release note，打 git tag</li>
<li>其他后续流程，如生成 CHANGELOG.md，npm publish 等等（通过插件完成）</li>
</ul>
<p><strong>由 CI 自动执行之后的效果就像这样，在 Git tag 页面可以看到 tag 信息，同时包含更新记录:</strong><br><img src="/images/semantic-release.resources/4AC0ED82-F6DB-47DF-BF40-55D3D102E62E.png" alt="86f880f284d3072ec2179cbc46c32396"></p>
<p><strong>如果启用了@semantic-release/git 插件，还会将生成的 CHANGELOG.md  反向 push 回中央仓库:</strong><br><img src="/images/semantic-release.resources/0ECB644A-F473-44BD-B48D-88C694133D7C.png" alt="6cfc655f89c58bc6a2faa5e3aee6eea1"></p>
<p><strong>commit history 的实际效果如下</strong><br><img src="/images/semantic-release.resources/6FB7CB34-8D1F-46EB-98EA-801CABF7D39F.png" alt="c15015e5517056c98eca17829d479a12"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在项目工程中添加 release.config.js 配置如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">parserOpts = &#123;</span><br><span class="line">  mergePattern: <span class="regexp">/^Merge pull request #(\d+) from (.*)$/</span>,</span><br><span class="line">  mergeCorrespondence: [<span class="string">'id'</span>, <span class="string">'source'</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copied from https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-angular/writer-opts.js#L27</span></span><br><span class="line"><span class="comment">// and modified to support adding all commit types to the release notes</span></span><br><span class="line">customTransform = <span class="function">(<span class="params">commit, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> issues = []</span><br><span class="line">  commit.notes.forEach(<span class="function">(<span class="params">note</span>) =&gt;</span> &#123;</span><br><span class="line">    note.title = <span class="string">`BREAKING CHANGES`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (commit.type === <span class="string">`feat`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`✨ Features`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`fix`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🐞 Bug Fixes`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`perf`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🎈 Performance Improvements`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`revert`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`Reverts`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`docs`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`📃 Documentation`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`style`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🌈 Styles`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`refactor`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🦄 Code Refactoring`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`test`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🧪 Tests`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`build`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🔧 Build System`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commit.type === <span class="string">`ci`</span>) &#123;</span><br><span class="line">    commit.type = <span class="string">`🐎 Continuous Integration`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (commit.scope === <span class="string">`*`</span>) &#123;</span><br><span class="line">    commit.scope = <span class="string">``</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> commit.hash === <span class="string">`string`</span>) &#123;</span><br><span class="line">    commit.shortHash = commit.hash.substring(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> commit.subject === <span class="string">`string`</span>) &#123;</span><br><span class="line">    commit.subject = commit.subject.substring(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> url = context.repository</span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;context.host&#125;</span>/<span class="subst">$&#123;context.owner&#125;</span>/<span class="subst">$&#123;context.repository&#125;</span>`</span></span><br><span class="line">      : context.repoUrl</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">      url = <span class="string">`<span class="subst">$&#123;url&#125;</span>/issues/`</span> <span class="comment">// Issue URLs.</span></span><br><span class="line">      commit.subject = commit.subject.replace(<span class="regexp">/#([0-9]+)/g</span>, (_, issue) =&gt; &#123;</span><br><span class="line">        issues.push(issue)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;issue&#125;</span>](<span class="subst">$&#123;url&#125;</span><span class="subst">$&#123;issue&#125;</span>)`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.host) &#123;</span><br><span class="line">      <span class="comment">// User URLs.</span></span><br><span class="line">      commit.subject = commit.subject.replace(</span><br><span class="line">        /\B@([a-z0<span class="number">-9</span>](?:-?[a-z0<span class="number">-9</span>/])&#123;<span class="number">0</span>,<span class="number">38</span>&#125;)/g,</span><br><span class="line">        (_, username) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (username.includes(<span class="string">'/'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`@<span class="subst">$&#123;username&#125;</span>`</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">`[@<span class="subst">$&#123;username&#125;</span>](<span class="subst">$&#123;context.host&#125;</span>/<span class="subst">$&#123;username&#125;</span>)`</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    commit.subject = <span class="string">`<span class="subst">$&#123;commit.subject&#125;</span> (by @<span class="subst">$&#123;commit.committer.name&#125;</span>)`</span></span><br><span class="line">  &#125; <span class="comment">// remove references that already appear in the subject</span></span><br><span class="line">  commit.references = commit.references.filter(<span class="function">(<span class="params">reference</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (issues.indexOf(reference.issue) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> commit</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  branches: <span class="string">'master'</span>,</span><br><span class="line">  parserOpts,</span><br><span class="line">  writerOpts: &#123; <span class="attr">transform</span>: customTransform &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/commit-analyzer'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        preset: <span class="string">'angular'</span>,</span><br><span class="line">        releaseRules: [</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'docs'</span>, <span class="attr">scope</span>: <span class="string">'README'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'refactor'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'style'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'test'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'build'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">'ci'</span>, <span class="attr">release</span>: <span class="string">'patch'</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'@semantic-release/release-notes-generator'</span>,</span><br><span class="line">    [<span class="string">'@semantic-release/changelog'</span>, &#123; <span class="attr">changelogFile</span>: <span class="string">'CHANGELOG.md'</span> &#125;],</span><br><span class="line">    <span class="string">'@semantic-release/npm'</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/git'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        assets: [<span class="string">'package.json'</span>, <span class="string">'CHANGELOG.md'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@semantic-release/gitlab'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        gitlabUrl: <span class="string">'http://git.example.com'</span>,</span><br><span class="line">        assets: [],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成  .gitlab-ci.yml  配置如下（仅部分关键的配置片段）:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">lint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"><span class="attr">commitlint:</span></span><br><span class="line">    <span class="attr">stage:</span> <span class="string">lint</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^chore\(release\)/'</span></span><br><span class="line">          <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^Merge branch/'</span></span><br><span class="line">          <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span> <span class="comment"># 一般当分支master有 push 或 merge 时才会执行该工作</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span> <span class="string">bin/commitlint-gitlab-ci.sh</span></span><br><span class="line"><span class="attr">release:</span></span><br><span class="line">    <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">semantic-release</span></span><br></pre></td></tr></table></figure>

<p>commitlint 脚本请参考<a href="https://gitlab.com/dmoonfire/commitlint-gitlab-ci/-/blob/main/bin/commitlint-gitlab-ci.sh" target="_blank" rel="noopener">commitlint-gitlab-ci.sh</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们完成了通过 CI 自动管理版本号和发布日志的需求，大大节省了人力，同时，还留下了发布痕迹，方便追溯历史版本。<br>另外，需要注意的是上述的配置并不会修改源码部分的版本号配置内容（如 build.gradle 或 package.json 等），如果需要自动管理这些地方的版本，与 git tag 版本保持一致，可以引入@semantic-release/exec 插件，自己写脚本，通过脚本自动化修改这些地方的版本号。<br>还需要注意的是 semantic-release 默认产生的 commit 记录为了避免不必要的 CI 流程，会在 commit 记录加上[skip ci]（见上面的截图）来跳过 CI，如果你的流水线需要由 git tag 触发，可以配置@semantic-release/git 插件，自定义 commit 记录，去掉[skip ci]。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/eventloop.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/eventloop.html" class="post-title-link" itemprop="url">EventLoop规范 阅读和总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-07T00:00:00+08:00">2023-08-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步的思考"><a href="#异步的思考" class="headerlink" title="异步的思考"></a>异步的思考</h2><p>提起异步，相信每个人都知道。异步背后的“靠山”就是 event loops。这里的异步准确的说应该叫浏览器的 event loops 或者说是 javaScript 运行环境的 event loops，因为<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">ECMAScript</a>中没有 event loops，event loops 是在<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">HTML Standard</a>定义的。</p>
<h4 id="（1）单线程的-JavaScript"><a href="#（1）单线程的-JavaScript" class="headerlink" title="（1）单线程的 JavaScript"></a>（1）单线程的 JavaScript</h4><p>我们知道，JavaScript 是一种单线程语言，它主要用来与用户互动，以及操作 DOM。<br>JavaScript 有同步和异步的概念，这就解决了代码阻塞的问题：</p>
<pre><code>- 同步：如果在一个函数返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的；
- 异步：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</code></pre><h5 id="那单线程有什么好处呢？"><a href="#那单线程有什么好处呢？" class="headerlink" title="那单线程有什么好处呢？"></a>那单线程有什么好处呢？</h5><pre><code>在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。
得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间的好处。</code></pre><h4 id="（2）多线程的浏览器"><a href="#（2）多线程的浏览器" class="headerlink" title="（2）多线程的浏览器"></a>（2）多线程的浏览器</h4><p>JS 是单线程的，在同一个时间只能做一件事情，那为什么浏览器可以同时执行异步任务呢？</p>
<p>这是因为浏览器是多线程的，当 JS 需要执行异步任务时，浏览器会另外启动一个线程去执行该任务。也就是说，JavaScript 是单线程的指的是执行 JavaScript 代码的线程只有一个，是浏览器提供的 JavaScript 引擎线程（主线程）。除此之外，浏览器中还有定时器线程、 HTTP 请求线程等线程，这些线程主要不是来执行 JS 代码的。</p>
<p>比如主线程中需要发送数据请求，就会把这个任务交给异步 HTTP 请求线程去执行，等请求数据返回之后，再将 callback 里需要执行的 JS 回调交给 JS 引擎线程去执行。也就是说，浏览器才是真正执行发送请求这个任务的角色，而 JS 只是负责执行最后的回调处理。所以这里的异步不是 JS 自身实现的，而是浏览器为其提供的能力。</p>
<p><img src="../images/eventloop/image.png" alt="alt text"></p>
<p>可以看到，Chrome 不仅拥有多个进程，还有多个线程。以渲染进程为例，就包含 GUI 渲染线程、JS 引擎线程、事件触发线程、定时器触发线程、异步 HTTP 请求线程。这些线程为 JS 在浏览器中完成异步任务提供了基础。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们来看看 event loop 在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="noopener">HTML Standard</a> 中的定义章节:</p>
<p>第一句话：</p>
<blockquote>
<p>为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的 event loop。</p>
</blockquote>
<p><strong>事件</strong>，<strong>用户交互</strong>，<strong>脚本</strong>，<strong>渲染</strong>，<strong>网络</strong>这些都是我们所熟悉的东西，他们都是由 event loop 协调的。触发一个 click 事件，进行一次 ajax 请求，背后都有 event loop 在运作。</p>
<h3 id="task-queues"><a href="#task-queues" class="headerlink" title="task queues"></a>task queues</h3><blockquote>
<p>一个 event loop 有一个或者多个 task 队列。</p>
</blockquote>
<blockquote>
<p>当用户代理安排一个任务，必须将该任务增加到相应的 event loop 的一个 tsak 队列中。</p>
</blockquote>
<blockquote>
<p>每一个 task 都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个 task 队列，其他事件又是一个单独的队列。可以为鼠标、键盘事件分配更多的时间，保证交互的流畅。</p>
</blockquote>
<h3 id="哪些是-task-任务源呢？"><a href="#哪些是-task-任务源呢？" class="headerlink" title="哪些是 task 任务源呢？"></a>哪些是 task 任务源呢？</h3><p>规范在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources" target="_blank" rel="noopener">Generic task sources</a>中有提及：</p>
<blockquote>
<p>DOM 操作任务源：<br>此任务源被用来相应 dom 操作，例如一个元素以非阻塞的方式插入文档。</p>
</blockquote>
<blockquote>
<p>用户交互任务源：<br>此任务源用于对用户交互作出反应，例如键盘或鼠标输入。响应用户操作的事件（例如 click）必须使用 task 队列。</p>
</blockquote>
<blockquote>
<p>网络任务源：<br>网络任务源被用来响应网络活动。</p>
</blockquote>
<blockquote>
<p>history traversal 任务源：<br>当调用 history.back()等类似的 api 时，将任务插进 task 队列。</p>
</blockquote>
<p>task 任务源非常宽泛，比如 ajax 的 onload，click 事件，基本上我们经常绑定的各种事件都是 task 任务源，还有数据库操作（IndexedDB ），需要注意的是 setTimeout、setInterval、setImmediate 也是 task 任务源。总结来说 task 任务源：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendering</li>
</ul>
<h3 id="microtask"><a href="#microtask" class="headerlink" title="microtask"></a>microtask</h3><blockquote>
<p>微任务队列不是任务队列。</p>
</blockquote>
<blockquote>
<p>每个事件循环都有一个微任务队列，这是一个微任务队列，最初是空的。微任务是一种口语化的方式，指的是通过微任务算法队列创建的任务。</p>
</blockquote>
<blockquote>
<p>如果在初期执行时，<a href="https://html.spec.whatwg.org/multipage/webappapis.html#spin-the-event-loop" target="_blank" rel="noopener">spin the event loop</a>，microtasks 有可能被移动到常规的 task 队列，在这种情况下，microtasks 任务源会被 task 任务源所用。通常情况，task 任务源和 microtasks 是不相关的。</p>
</blockquote>
<p>microtask 队列和 task 队列有些相似，都是先进先出的队列，由指定的任务源去提供任务，不同的是一个 event loop 里只有一个 microtask 队列。</p>
<p>HTML Standard 没有具体指明哪些是 microtask 任务源，通常认为是 microtask 任务源有：</p>
<ul>
<li>process.nextTick</li>
<li>promises</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<h2 id="处理流程（processing-model）"><a href="#处理流程（processing-model）" class="headerlink" title="处理流程（processing model）"></a><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">处理流程（processing model）</a></h2><ol>
<li><p>在 tasks 队列中选择最老的一个 task，用户代理可以选择任何 task 队列，如果没有可选的任务，则跳到下边的 microtasks 步骤。(从任务队列中取出一个宏任务并执行)</p>
<p>1.1 将上边选择的 task 设置为正在运行的 task</p>
<p>1.2 Run: 运行被选择的 task。</p>
<p>1.3 将 event loop 的 currently running task 变为 null。</p>
<p>1.4 从 task 队列里移除前边运行的 task。</p>
</li>
<li><p>Microtasks: 执行 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">microtasks 任务检查点</a>。（检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。）</p>
</li>
<li><p>进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）</p>
<ul>
<li>浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。</li>
<li>如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。</li>
<li>如果满足以下条件，也会跳过渲染：<ul>
<li>浏览器判断更新渲染不会带来视觉上的改变。</li>
<li>map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：</p>
</li>
</ol>
<blockquote>
<p>This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.<br>有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask 的执行，而不会穿插屏幕渲染相关的流程</p>
</blockquote>
<ol start="5">
<li><p>对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 resize 方法。</p>
</li>
<li><p>对于需要渲染的文档，如果页面发生了滚动，执行 scroll 方法。</p>
</li>
<li><p>对于需要渲染的文档，执行帧动画回调，也就是 requestAnimationFrame 的回调。（后文会详解）</p>
</li>
<li><p>对于需要渲染的文档， 执行 IntersectionObserver 的回调。</p>
</li>
<li><p>对于需要渲染的文档，重新渲染绘制用户界面。</p>
</li>
<li><p>判断 task 队列和 microTask 队列是否都为空，如果是的话，则进行 Idle 空闲周期的算法，判断是否要执行 requestIdleCallback 的回调函数。（后文会详解）</p>
</li>
</ol>
<p>对于 resize 和 scroll 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据 CSSOM 规范所讲，浏览器会保存一个 pending scroll event targets，等到事件循环中的 scroll 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。resize 也是同理。</p>
<h2 id="microtasks-检查点（microtask-checkpoint）"><a href="#microtasks-检查点（microtask-checkpoint）" class="headerlink" title="microtasks 检查点（microtask checkpoint）"></a>microtasks 检查点（microtask checkpoint）</h2><p>上文 event loop 处理流程第 2 步，执行了一个 microtask checkpoint，看看规范如何描述 microtask checkpoint：</p>
<p>当用户代理去执行一个 microtask checkpoint，如果 microtask checkpoint 的 flag（标识）为 false，用户代理必须运行下面的步骤：</p>
<ol>
<li>将 microtask checkpoint 的 flag 设为 true。</li>
<li>Microtask queue handling: 如果 event loop 的 microtask 队列为空，直接跳到第八步（Done）。</li>
<li>在 microtask 队列中选择最老的一个任务。</li>
<li>将上一步选择的任务设为 event loop 的 currently running task。</li>
<li>运行选择的任务。</li>
<li>将 event loop 的 currently running task 变为 null。</li>
<li>将前面运行的 microtask 从 microtask 队列中删除，然后返回到第二步（Microtask queue handling）。</li>
<li>Done: 每一个 environment settings object 它们的 responsible event loop 就是当前的 event loop，会给 environment settings object 发一个 rejected promises 的通知。</li>
<li>清理 IndexedDB 的事务。</li>
<li>将 microtask checkpoint 的 flag 设为 flase。</li>
</ol>
<p>microtask checkpoint 所做的就是执行 microtask 队列里的任务。什么时候会调用 microtask checkpoint 呢?</p>
<ul>
<li>当上下文执行栈为空时，执行一个 microtask checkpoint。</li>
<li>在 event loop 的第六步（Microtasks: Perform a microtask checkpoint）执行 checkpoint，也就是在运行 task 之后，更新渲染之前。</li>
</ul>
<h2 id="多任务队列"><a href="#多任务队列" class="headerlink" title="多任务队列"></a>多任务队列</h2><p>上文也提到了，每一个 task 都来源于指定的任务源， 所以 task 队列并不是我们想象中的那样只有一个，根据规范里的描述：</p>
<blockquote>
<p>An event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.</p>
</blockquote>
<p>事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：</p>
<ol>
<li>鼠标和键盘事件</li>
<li>其他的一些 Task</li>
</ol>
<p>浏览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。</p>
<p>这个规范也导致 vue 的这个<a href="https://github.com/vuejs/vue/issues/3771" target="_blank" rel="noopener">Issue</a>。简单描述一下就是采用了 task 实现的 nextTick，在用户持续滚动的情况下 nextTick 任务被延后了很久才去执行，导致动画跟不上滚动了。</p>
<p>迫于无奈，尤大还是改回了 microTask 去实现 nextTick，目前来说 promise.then 微任务已经很稳定并且 vue3 就是这样实现的，并且 Chrome 也已经实现了 queueMicroTask 这个官方 API。我们想要调用微任务队列的话，也可以节省掉实例化 Promise 在开销了。</p>
<p>从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。</p>
<h2 id="执行栈（JavaScript-execution-context-stack）"><a href="#执行栈（JavaScript-execution-context-stack）" class="headerlink" title="执行栈（JavaScript execution context stack）"></a>执行栈（JavaScript execution context stack）</h2><p>task 和 microtask 都是推入栈中执行的，要完整了解 event loops 还需要认识 JavaScript execution context stack，它的规范位于<a href="https://tc39.github.io/ecma262/#execution-context-stack。" target="_blank" rel="noopener">https://tc39.github.io/ecma262/#execution-context-stack。</a></p>
<p>javaScript 是单线程，也就是说只有一个主线程，主线程有一个栈，每一个函数执行的时候，都会生成新的 execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。</p>
<p><img src="../images/eventloop/image-1.png" alt="alt text"></p>
<p>举个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>执行过程中栈的变化：<br><img src="../images/eventloop/image-2.png" alt="alt text"></p>
<h4 id="完整异步过程"><a href="#完整异步过程" class="headerlink" title="完整异步过程"></a>完整异步过程</h4><p>主线程类似一个加工厂，它只有一条流水线，待执行的任务就是流水线上的原料，只有前一个加工完，后一个才能进行。event loops 就是把原料放上流水线的工人。只要已经放在流水线上的，它们会被依次处理，称为同步任务。一些待处理的原料，工人会按照它们的种类排序，在适当的时机放上流水线，这些称为异步任务。</p>
<p><img src="../images/eventloop/image-3.png" alt="alt text"></p>
<p>举个简单的例子，假设一个 script 标签的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>运行过程：</p>
<p>script 里的代码被列为一个 task，放入 task 队列。</p>
<ul>
<li><p><strong>循环 1</strong>：</p>
</li>
<li><p>【task 队列：script ；microtask 队列：】</p>
<ul>
<li>1.从 task 队列中取出 script 任务，推入栈中执行。</li>
<li>2.promise1 列为 microtask，setTimeout1 列为 task，setTimeout2 列为 task。</li>
</ul>
</li>
<li><p>task 队列：setTimeout1 setTimeout2；microtask 队列：promise1】</p>
<ul>
<li>3.script 任务执行完毕，执行 microtask checkpoint，取出 microtask 队列的 promise1 执行。</li>
</ul>
</li>
<li><p><strong>循环 2</strong>：</p>
</li>
<li><p>【task 队列：setTimeout1 setTimeout2；microtask 队列：】</p>
<ul>
<li>4.从 task 队列中取出 setTimeout1，推入栈中执行，将 promise2 列为 microtask。</li>
</ul>
</li>
<li><p>【task 队列：setTimeout2；microtask 队列：promise2】</p>
<ul>
<li>5.执行 microtask checkpoint，取出 microtask 队列的 promise2 执行。</li>
</ul>
</li>
<li><p><strong>循环 3</strong>：</p>
</li>
<li><p>【task 队列：setTimeout2；microtask 队列：】</p>
<ul>
<li>6.从 task 队列中取出 setTimeout2，推入栈中执行。</li>
<li>7.setTimeout2 任务执行完毕，执行 microtask checkpoint。</li>
</ul>
</li>
<li><p>【task 队列：；microtask 队列：】</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是对 event loop 规范 和一些运行的流程做的总结。但是包括 requestAnimationFrame，requestIdleCallback 和 浏览器中 js 的执行机制等细节的总结将会单独写文章进行归纳总结。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/Gitlab%20CI_CD%20%E5%AE%9E%E8%B7%B5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/Gitlab%20CI_CD%20%E5%AE%9E%E8%B7%B5.html" class="post-title-link" itemprop="url">Gitlab CI/CD 实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-07-20T00:00:00+08:00">2023-07-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GitLab CI/CD 是一个内置在 GitLab 中的工具，用于通过持续方法进行软件开发：</p>
<h5 id="Continuous-Integration（持续集成）"><a href="#Continuous-Integration（持续集成）" class="headerlink" title="Continuous Integration（持续集成）"></a>Continuous Integration（持续集成）</h5><p>假设一个应用程序，其代码存储在 GitLab 的 Git 仓库中。开发人员每天都要多次推送代码更改。对于每次向仓库的推送，你都可以创建一组脚本来自动构建和测试你的应用程序，从而减少了向应用程序引入错误的机会。这种做法称为持续集成，对于提交给应用程序（甚至是开发分支）的每项更改，它都会自动连续进行构建和测试，以确保所引入的更改通过你为应用程序建立的所有测试，准则和代码合规性标准。</p>
<h5 id="Continuous-Delivery（持续交付）"><a href="#Continuous-Delivery（持续交付）" class="headerlink" title="Continuous Delivery（持续交付）"></a>Continuous Delivery（持续交付）</h5><p>持续交付是超越持续集成的更进一步的操作。应用程序不仅会在推送到代码库的每次代码更改时进行构建和测试，而且，尽管部署是手动触发的，但作为一个附加步骤，它也可以连续部署。此方法可确保自动检查代码，但需要人工干预才能从策略上手动触发以必输此次变更。</p>
<h5 id="Continuous-Deployment（持续部署）"><a href="#Continuous-Deployment（持续部署）" class="headerlink" title="Continuous Deployment（持续部署）"></a>Continuous Deployment（持续部署）</h5><p>与持续交付类似，但不同之处在于，你无需将其手动部署，而是将其设置为自动部署。完全不需要人工干预即可部署你的应用程序。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>为了使用 GitLab CI/CD，你需要一个托管在 GitLab 上的应用程序代码库，并且在根目录中的.gitlab-ci.yml 文件中指定构建、测试和部署的脚本。</p>
<p>在这个文件中，你可以定义要运行的脚本，定义包含的依赖项，选择要按顺序运行的命令和要并行运行的命令，定义要在何处部署应用程序，以及指定是否 要自动运行脚本或手动触发脚本。</p>
<p>为了可视化处理过程，假设添加到配置文件中的所有脚本与在计算机的终端上运行的命令相同。</p>
<p>一旦你已经添加了.gitlab-ci.yml 到仓库中，GitLab 将检测到该文件，并使用名为 GitLab Runner 的工具运行你的脚本。该工具的操作与终端类似。</p>
<p>这些脚本被分组到 jobs，它们共同组成一个 pipeline。一个最简单的.gitlab-ci.yml 文件可能是这样的：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">rubygems</span> <span class="string">ruby-dev</span> <span class="string">-y</span></span><br><span class="line"></span><br><span class="line"><span class="attr">run-test:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ruby</span> <span class="string">--version</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>before_script 属性将在运行任何内容之前为你的应用安装依赖，一个名为 run-test 的 job（作业）将打印当前系统的 Ruby 版本。二者共同构成了在每次推送到仓库的任何分支时都会被触发的 pipeline（管道）。</p>
<p>GitLab CI/CD 不仅可以执行你设置的 job，还可以显示执行期间发生的情况，正如你在终端看到的那样：<br><img src="/images/GitlabCI_CD.resources/2551D6FD-98FB-42FB-B217-232C6028B2AC.png" alt="74b8f022354a48a2a663a996ae2c1dd8"></p>
<h4 id="通过-GitLab-UI-所有的步骤都是可视化的"><a href="#通过-GitLab-UI-所有的步骤都是可视化的" class="headerlink" title="通过 GitLab UI 所有的步骤都是可视化的"></a>通过 GitLab UI 所有的步骤都是可视化的</h4><p><img src="/images/GitlabCI_CD.resources/E239A99B-76CC-4F14-9DA2-4286A51588B9.png" alt="aae548d462b9c6b5e8bab016b96c5512"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h4 id="创建一个-gitlab-ci-yml-文件"><a href="#创建一个-gitlab-ci-yml-文件" class="headerlink" title="创建一个.gitlab-ci.yml 文件"></a>创建一个.gitlab-ci.yml 文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"><span class="attr">commitlint:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">lint</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^chore\(release\)/'</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TITLE =~ /^Merge branch/'</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span> <span class="comment"># 一般当分支master有 push 或 merge 时才会执行该工作</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span> <span class="string">bin/commitlint-gitlab-ci.sh</span></span><br><span class="line"><span class="attr">release:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">semantic-release</span></span><br></pre></td></tr></table></figure>

<h4 id="配置一个-Runner"><a href="#配置一个-Runner" class="headerlink" title="配置一个 Runner"></a>配置一个 Runner</h4><p>在 GitLab 中，Runner 运行你定义在.gitlab-ci.yml 中的作业（job）<br>一个 Runner 可以是一个虚拟机、物理机、docker 容器，或者一个容器集群 GitLab 与 Runner 之间通过 API 进行通信，因此只需要 Runner 所在的机器有网络并且可以访问 GitLab 服务器即可<br>你可以去  <strong>Settings ➔ CI/CD</strong>  看是否已经有 Runner 关联到你的项目，设置 Runner 简单又直接<br><img src="/images/GitlabCI_CD.resources/A9EF490C-2A96-495A-AEBC-135E32A9FAE1.png" alt="7b99f010133b6b0689a1dc90c2893831"></p>
<h4 id="查看-pipeline-和-jobs-状态"><a href="#查看-pipeline-和-jobs-状态" class="headerlink" title="查看 pipeline 和 jobs 状态"></a>查看 pipeline 和 jobs 状态</h4><p><img src="/images/GitlabCI_CD.resources/159D77C9-7C89-4B37-8A6A-9DB90473D0ED.png" alt="e57d2652f09e520231cae9358ac69e10"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>团队计划使用 semantic-release 自动管理发布版本，结合 Gitlab CI/CD 是一个很不错的选择，具体的实践过程和心得会在后面分享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/chrome%20performance%E9%9D%A2%E6%9D%BF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/chrome%20performance%E9%9D%A2%E6%9D%BF.html" class="post-title-link" itemprop="url">chrome performance 面板解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-15T00:00:00+08:00">2023-06-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概况图"><a href="#概况图" class="headerlink" title="概况图"></a>概况图</h2><p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/B31D1703-5E66-4F19-8D12-448E4D283BC9.png" alt="71d6a82a01519413ca2a1be4b957c544"></p>
<h4 id="无痕模式"><a href="#无痕模式" class="headerlink" title="无痕模式"></a>无痕模式</h4><p>无痕模式可以保证 Chrome 在一个相对干净的环境下运行，避免 chrome 上安装的插件影响性能分析结果。<br>文件—&gt;打开新的无痕式窗口，或使用快捷键 ctrl + shift + N 打开无痕模式下的 chrome 新标签页</p>
<h4 id="性能记录"><a href="#性能记录" class="headerlink" title="性能记录"></a>性能记录</h4><p>点击面板里的 ○，可以记录运行时的性能记录，如下图：<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/8B1B5662-14CE-47BA-A799-07447D14021C.png" alt="0b82ba7820c6d3ec5b21fe563191a08d"></p>
<p>再次点击 Record 或者点击 Stop 停止记录。</p>
<h4 id="加载时性能记录录制"><a href="#加载时性能记录录制" class="headerlink" title="加载时性能记录录制"></a>加载时性能记录录制</h4><p>若要分析页面记载时性能需要录制加载时性能。</p>
<ol>
<li>打开待分析性能的页面。</li>
<li>打开 Devtools 中 Performance 窗口。</li>
<li>点击左上角重新加载按钮。DevTools 会自动记录页面加载是各项性能指标，加载完成几秒后自动停止记录。<br>Devtools 记录会自动增加<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/8BE55FF4-23D8-4373-9700-6FC306487719.png" alt="bcc3faa215dab1b20aefba15f42fa29d"></li>
</ol>
<p>页面加载时记录<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/2E1306AE-F26B-4DE5-8E02-96106AA7CA11.png" alt="8faf902b1637f885df323e7791713c33"></p>
<h4 id="清除记录"><a href="#清除记录" class="headerlink" title="清除记录"></a>清除记录</h4><p>清除 Performance 窗口中的记录数据。</p>
<h4 id="抓取运行时屏幕快照"><a href="#抓取运行时屏幕快照" class="headerlink" title="抓取运行时屏幕快照"></a>抓取运行时屏幕快照</h4><p>点选 Screenshots 选项开启为每一帧记录屏幕快照功能。</p>
<h4 id="查看内存度量值"><a href="#查看内存度量值" class="headerlink" title="查看内存度量值"></a>查看内存度量值</h4><p>点选 Memory 选项打开内存度量功能。<br>DevTools 在 Summary 面板上侧显示一个新的 Memory 图表。在 NET 图表下边也显示一个 HEAP 图表。HEAP 图表提供的信息同 Memory 面板中 JS Heap 提供的信息相同。</p>
<h4 id="开启加速渲染工具"><a href="#开启加速渲染工具" class="headerlink" title="开启加速渲染工具"></a>开启加速渲染工具</h4><p>点选 Enable advanced paint instrumentation 选项（会带来大量的性能开销）</p>
<h4 id="控制录制过程中-CPU-工作频率"><a href="#控制录制过程中-CPU-工作频率" class="headerlink" title="控制录制过程中 CPU 工作频率"></a>控制录制过程中 CPU 工作频率</h4><p>将 CPU 设置为需要的运算速度模式。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9DD1F5C8-9131-4F02-BDA0-8D5DCB6095A3.png" alt="886c6b4d80132d8e286af2d6ed89cdb9"></p>
<p>CPU 工作频率的控制结果跟实际使用的机器能力有关。例如，4x slowdown 选项会使你本地 CPU 运算速率比正常情况下降低 4 倍。不同设备由于设计架构不同，Devtools 不能精确模拟移动端设备的 CPU 运算模式。</p>
<h4 id="保存记录"><a href="#保存记录" class="headerlink" title="保存记录"></a>保存记录</h4><p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/F4D6D133-2769-4173-9090-79276AFC56D4.png" alt="da01643afd3f94a7927b96b2ddd7a044"><br>会生成 JSON 文件</p>
<h4 id="加载记录"><a href="#加载记录" class="headerlink" title="加载记录"></a>加载记录</h4><p>单击鼠标右键选择 Load Profile 加载记录</p>
<h2 id="分析性能记录"><a href="#分析性能记录" class="headerlink" title="分析性能记录"></a>分析性能记录</h2><p>运行时或者加载时性能录制结束后，在 Performance 窗口中会显示相关数据，从而对于记录过程中的情况进行分析。</p>
<h4 id="选择记录中的一部分"><a href="#选择记录中的一部分" class="headerlink" title="选择记录中的一部分"></a>选择记录中的一部分</h4><p>在 Overview 窗口中，可以选中记录的某一部分。 Overview 窗口指的是包含 FPS, CPU 和 NET 图表部分。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/7D7EC5FB-7086-4767-99DB-4BCB7AE4E430.png" alt="3c66d685cee9f55228ca867b5a07a88e"></p>
<h4 id="查看主线程活动"><a href="#查看主线程活动" class="headerlink" title="查看主线程活动"></a>查看主线程活动</h4><p>利用 Main 区域查看页面主线程加载时的主要活动。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/A2BE4509-9F3E-4AAC-90D2-E0F68820471A.png" alt="26247567fd6f9281d4a16d8fcbcba32f"></p>
<p>点击某一函数在 Summary 窗口中查看更多详细信息。如图中所示 DevTools 选中_getRequestData 事件。<br>DevTools 采用随机的颜色标识脚本信息，如上面图中浅绿色标识函数调用，深黄色标识脚本活动。<br>若想隐藏火焰图中的 JavaScript 中调用的详细信息，请查看前面介绍的禁用 JavaScript 样例功能。若禁用 JavaScript 样例功能，你只可以看到初始调用事件。比如，图中标识的 Timer fired 和 Function Call 。</p>
<h4 id="在表格中查看活动"><a href="#在表格中查看活动" class="headerlink" title="在表格中查看活动"></a>在表格中查看活动</h4><p>录制结束后，利用 Main 窗口中信息不是分析数据的唯一方式。DevTools 另外提供了三种表格式分析活动方式，每种方式都是从不同的角度出发:<br>若想分析那些活动占用时间更多时，可以利用 Bottom-Up 窗口。<br>若想分析导致更多活动的根活动时，可以采用 Call Tree。<br>若想按顺序分析记录中发生的活动时，可以利用 Event Log 窗口。</p>
<h4 id="根活动"><a href="#根活动" class="headerlink" title="根活动"></a>根活动</h4><p>根活动指的是浏览器触发的一系列流程。例如，当你点击页面内容，浏览器触发一个 Event 作为根活动，该 Event 可能回调一个事件处理事件。<br>在 Main 面板中的火焰图中，根活动展示在上部，在 Call Tree 和 Event Log 面板中，根活动展示在顶层。</p>
<h4 id="Call-Tree-标签页"><a href="#Call-Tree-标签页" class="headerlink" title="Call Tree 标签页"></a>Call Tree 标签页</h4><p>Call Tree 标签页中展示记录中被选中部分的活动信息。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9E98C9B1-90D8-4D50-A6BC-FDCB4EB51B0F.png" alt="6f4e0500bac02ec6143b950c159c63ae"></p>
<p>图中 Activity 列中显示的 Timer fired、 Paint、Recalculate Style 和 Layout 代表根活动。层级嵌套表示代表回调栈。如图中 Function Call 调用 u，再调用 getImageUrl，继续调用 getLinkUrl 等等。<br>Self Time 表示对应活动消耗的时间，Total Time 表示对应活动以及子活动共同消耗的时间。<br>点击 Self Time，Total Time 或者 Activity 表头区域，可按对应列排序。<br>利用 Filter 输入框区域，输入活动名过滤事件。<br>Grouping 分组菜单默认为 No Grouping，利用该功能可以根据不同的分类将活动进行分组。<br>点击右侧 Show Heaviest Stack，在右侧展示当前选中活动中占用时间最多的子活动信息。</p>
<p><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/BBFE6629-C9A4-4901-A79C-3E850194B322.png" alt="6562aca6f7e21ca7a5746f1cff491455"></p>
<h4 id="Bottom-Up-标签页"><a href="#Bottom-Up-标签页" class="headerlink" title="Bottom-Up 标签页"></a>Bottom-Up 标签页</h4><p>利用 Bottom-Up 标签查看占用最多时间的活动。<br>Self Time 表示对应活动消耗的时间。<br>Total Time 表示对应活动以及子活动共同消耗的时间。</p>
<h4 id="Event-Log-标签页"><a href="#Event-Log-标签页" class="headerlink" title="Event Log 标签页"></a>Event Log 标签页</h4><p>Event Log 标签页按顺序展示记录中发生的活动。<br>Start Time 列表示该项活动的开始时间，该时间相对于记录开始时间计算。例如图中选中项开始时间为 1566.2 ms，代表该活动在记录开始之后 1566.2 ms 后开始。<br>Self Time 表示对应活动消耗的时间。<br>Total Time 表示对应活动以及子活动共同消耗的时间。<br>点击 Start Time 、Self Time、Total Time 表头区域，可按对应列排序。<br>利用 Filter 输入框区域，输入活动名过滤事件。<br>利用 Duration 下拉菜单过滤&gt;=1ms 或者&gt;=15ms 的活动。该菜单默认选中 All 选项，展示所有活动。<br>利用 Loading、Experience、Scripting、Rendering、Painting 选项进行分类过滤。<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/9278865D-99FC-4945-A7DA-55264A743F15.png" alt="58c29a0d627c26c7d9fc1afd80a348ef"></p>
<h4 id="分析每秒传输帧数（FPS）"><a href="#分析每秒传输帧数（FPS）" class="headerlink" title="分析每秒传输帧数（FPS）"></a>分析每秒传输帧数（FPS）</h4><ul>
<li>查看 FPS 图表了解整个记录中 FPS 的概况。</li>
<li>Frames 模块查看每一帧时间消耗。</li>
<li>利用 FPS meter 工具(MoreTools—&gt;Rendering)在页面运行时实时查看 FPS 信息。</li>
</ul>
<h4 id="FPS-图表"><a href="#FPS-图表" class="headerlink" title="FPS 图表"></a>FPS 图表</h4><p>FPS 图表显示了整个记录过程中帧率的概况。图表中绿色折线越高代表帧率越好。<br>FPS 折线图上测出现的红色横线为一条性能警示线，表示帧率低于该值会严重影响用户体验。</p>
<h4 id="Frames-模块"><a href="#Frames-模块" class="headerlink" title="Frames 模块"></a>Frames 模块</h4><p>Frames 模块清晰表明每个帧消耗时间。<br>鼠标在某一帧上悬停可以查看更多详细信息。</p>
<h4 id="查看交互信息"><a href="#查看交互信息" class="headerlink" title="查看交互信息"></a>查看交互信息</h4><p>利用 Interactions 模块查看并分析记录过程中用户的交互操作。</p>
<h4 id="查看-GPU-活动"><a href="#查看-GPU-活动" class="headerlink" title="查看 GPU 活动"></a>查看 GPU 活动</h4><p>在 GPU 模块查看 GPU 活动信息<br><img src="/images/chromeperformance%E9%9D%A2%E6%9D%BF.resources/DCF59BFE-D663-4BF2-B581-1562C15B425E.png" alt="69c660e3d248b30ffc310f2813525e08"></p>
<h4 id="查看栅格活动"><a href="#查看栅格活动" class="headerlink" title="查看栅格活动"></a>查看栅格活动</h4><p>在 Raster 模块查看栅格活动信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rile14929.github.io/zh-CN/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Trevor.jpeg">
      <meta itemprop="name" content="rile">
      <meta itemprop="description" content="FE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="右耳听风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zh-CN/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.html" class="post-title-link" itemprop="url">前端脚手架搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-04T00:00:00+08:00">2023-05-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于公司标准化产品逐渐成熟，项目越来越多，需要一款脚手架通过业务标准化模板自动生成项目，可以让开发人员专注于业务开发，降低心智成本，提升团队效率。</p>
<p>参考了常用的脚手架，create-react-app、vue-cli、egg-init 的实现，搭建出了一套符合团队实际情况的脚手架工具。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>脚手架就是在启动的时候询问一些简单的问题，并且通过用户回答的结果去渲染对应的模板文件。</strong><br>基本工作流程如下：</p>
<ol>
<li>通过命令行交互询问用户问题</li>
<li>拉取远端标准化模板</li>
<li>根据用户回答的结果生成文件</li>
<li>自动下载依赖</li>
</ol>
<h4 id="热门脚手架工具库"><a href="#热门脚手架工具库" class="headerlink" title="热门脚手架工具库"></a>热门脚手架工具库</h4><p><img src="/images/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA.resources/81447CFF-3772-41A2-9663-9BFE685C3473.png" alt="116d0e8220abc84e44593738478cbee7"></p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h4 id="1-判断当前环境是否符合要求"><a href="#1-判断当前环境是否符合要求" class="headerlink" title="1. 判断当前环境是否符合要求"></a>1. 判断当前环境是否符合要求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> currentNodeVersion = process.versions.node</span><br><span class="line"><span class="keyword">const</span> semver = currentNodeVersion.split(<span class="string">'.'</span>)</span><br><span class="line"><span class="keyword">const</span> major = semver[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> (major &lt; <span class="number">14</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    <span class="string">'You are running Node '</span> +</span><br><span class="line">      currentNodeVersion +</span><br><span class="line">      <span class="string">'.\n'</span> +</span><br><span class="line">      <span class="string">'Create React App requires Node 14 or higher. \n'</span> +</span><br><span class="line">      <span class="string">'Please update your version of Node.'</span></span><br><span class="line">  )</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-创建脚手架启动命令（使用-commander）"><a href="#2-创建脚手架启动命令（使用-commander）" class="headerlink" title="2. 创建脚手架启动命令（使用 commander）"></a>2. 创建脚手架启动命令（使用 commander）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> commander.Command(packageJson.name)</span><br><span class="line">  .version(packageJson.version)</span><br><span class="line">  .arguments(<span class="string">'&lt;project-directory&gt;'</span>)</span><br><span class="line">  .usage(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span> [options]`</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    projectName = name</span><br><span class="line">  &#125;)</span><br><span class="line">  .parse(process.argv)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> projectName === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Please specify the project directory:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'For example:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'my-app'</span>)&#125;</span>`</span>)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-判断当前脚手架版本是否是最新"><a href="#3-判断当前脚手架版本是否是最新" class="headerlink" title="3. 判断当前脚手架版本是否是最新"></a>3. 判断当前脚手架版本是否是最新</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最新的version</span></span><br><span class="line"><span class="keyword">const</span> checkForLatestVersion = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    http</span><br><span class="line">      .get(url, (res) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> body = <span class="string">''</span></span><br><span class="line">          res.on(<span class="string">'data'</span>, (data) =&gt; (body += data))</span><br><span class="line">          res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(body).version)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">        reject()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkForLatestVersion(<span class="string">`<span class="subst">$&#123;host&#125;</span>create-my-app/latest`</span>)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> execSync(<span class="string">'npm view create-my-app version'</span>).toString().trim()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">latest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (latest &amp;&amp; semver.lt(packageJson.version, latest)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        chalk.yellow(</span><br><span class="line">          <span class="string">`You are running \`create-my-app\` <span class="subst">$&#123;packageJson.version&#125;</span>, which is behind the latest release (<span class="subst">$&#123;latest&#125;</span>).\n\n`</span> +</span><br><span class="line">            <span class="string">'We recommend always using the latest version of create-my-app if possible.'</span></span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">'The latest instructions for creating a new app can be found here:\n'</span> +</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;host&#125;</span>-/web/detail/create-my-app`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="built_in">console</span>.log()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createApp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-询问用户问题获取创建所需信息（使用-inquirer）"><a href="#4-询问用户问题获取创建所需信息（使用-inquirer）" class="headerlink" title="4. 询问用户问题获取创建所需信息（使用 inquirer）"></a>4. 询问用户问题获取创建所需信息（使用 inquirer）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getAnswers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'projectZHName'</span>,</span><br><span class="line">      message: <span class="string">'请输入项目中文名'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'version'</span>,</span><br><span class="line">      message: <span class="string">'请输入版本'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'1.0.0'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'author'</span>,</span><br><span class="line">      message: <span class="string">'请输入创建人(拼音全拼)'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-下载远程模板（使用-hyperquest-或-download-git-repo）"><a href="#5-下载远程模板（使用-hyperquest-或-download-git-repo）" class="headerlink" title="5. 下载远程模板（使用 hyperquest 或 download-git-repo）"></a>5. 下载远程模板（使用 hyperquest 或 download-git-repo）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> latest = <span class="keyword">await</span> checkForLatestVersion(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/latest`</span></span><br><span class="line">).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> execSync(<span class="string">'npm view my-frontend-template version'</span>).toString().trim()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; tmpdir, cleanup &#125; = <span class="keyword">await</span> getPackageInfo(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/-/my-frontend-template-<span class="subst">$&#123;latest&#125;</span>.tgz`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extractStream = <span class="function">(<span class="params">stream, dest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    stream.pipe(</span><br><span class="line">      unpack(dest, (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(dest)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getTemporaryDirectory = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Unsafe cleanup lets us recursively delete the directory if it contains</span></span><br><span class="line">    <span class="comment">// contents; by default it only allows removal if it's empty</span></span><br><span class="line">    tmp.dir(&#123; <span class="attr">unsafeCleanup</span>: <span class="literal">true</span> &#125;, (err, tmpdir, callback) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">          tmpdir: tmpdir,</span><br><span class="line">          cleanup: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ignored) &#123;</span><br><span class="line">              <span class="comment">// Callback might throw and fail, since it's a temp directory the</span></span><br><span class="line">              <span class="comment">// OS will clean it up eventually...</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPackageInfo = <span class="function">(<span class="params">installPackage</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (installPackage.match(<span class="regexp">/^.+\.(tgz|tar\.gz)$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getTemporaryDirectory().then(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> stream</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^http/</span>.test(installPackage)) &#123;</span><br><span class="line">        stream = hyperquest(installPackage)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stream = fsExtra.createReadStream(installPackage)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> extractStream(stream, obj.tmpdir).then(<span class="function"><span class="params">()</span> =&gt;</span> obj)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">name</span>: installPackage &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-根据需要读取修改文件和复制文件"><a href="#6-根据需要读取修改文件和复制文件" class="headerlink" title="6. 根据需要读取修改文件和复制文件"></a>6. 根据需要读取修改文件和复制文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; tmpdir, cleanup &#125; = <span class="keyword">await</span> getPackageInfo(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;host&#125;</span>my-frontend-template/-/my-frontend-template-<span class="subst">$&#123;latest&#125;</span>.tgz`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = path.resolve(projectName)</span><br><span class="line">fsExtra.mkdirSync(root)</span><br><span class="line">process.chdir(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templates = [</span><br><span class="line">   ...,</span><br><span class="line">    <span class="string">'src/common'</span>,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> templates) &#123;</span><br><span class="line">    fsExtra.copy(templatePath(tmpdir, item), item)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-自动下载依赖"><a href="#7-自动下载依赖" class="headerlink" title="7. 自动下载依赖"></a>7. 自动下载依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'pnpm'</span>, [<span class="string">'install'</span>], &#123; <span class="attr">stdio</span>: <span class="string">'inherit'</span> &#125;)</span><br><span class="line">child.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;chalk.cyan(projectName)&#125;</span> is created <span class="subst">$&#123;chalk.green(<span class="string">'successfully'</span>)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Get Started with the following commands:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;chalk.gray(<span class="string">'$'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'cd'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(projectName)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;chalk.gray(<span class="string">'$'</span>)&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'pnpm run serve'</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="8-发布和使用"><a href="#8-发布和使用" class="headerlink" title="8. 发布和使用"></a>8. 发布和使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"bin"</span>: &#123;</span><br><span class="line">        <span class="string">"create-my-app"</span>: <span class="string">"./index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>将脚手架发布到公司私库内，在使用中使用一行命令即可完成生成工作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-my-app &lt;project-directory&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章中贴出来了关键部分的脱敏代码，整体主要参考了<a href="https://github.com/facebook/create-react-app/blob/main/packages/create-react-app/createReactApp.js" target="_blank" rel="noopener">create-react-app</a>的实现，对其代码逻辑之严谨深受启发，其几乎对每一个环节可能出现的问题都做了第二种甚至第三种容错处理，在自己实现过程中，学习到了很多，对日后的开发大有帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rile"
      src="/images/Trevor.jpeg">
  <p class="site-author-name" itemprop="name">rile</p>
  <div class="site-description" itemprop="description">FE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rile14929" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rile14929" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rile14929@163.com" title="E-Mail → mailto:rile14929@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rile</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
